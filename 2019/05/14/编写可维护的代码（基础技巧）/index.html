<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《javascript设计模式》读书笔记一：编写可维护的代码"><meta name="keywords" content="JavaScript"><meta name="author" content="舒小琦"><meta name="copyright" content="舒小琦"><title>《javascript设计模式》读书笔记一：编写可维护的代码 | 舒小琦的Blog</title><link rel="shortcut icon" href="http://p6.qhimg.com/t01f5a5270b7946b505.jpg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E5%B0%BD%E9%87%8F%E5%B0%91%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">一. 尽量少用全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">1.0.1.</span> <span class="toc-text">全局变量的产生</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.2.</span> <span class="toc-text">全局变量的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9C%80%E5%B0%8F%E5%8C%96%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">1.0.3.</span> <span class="toc-text">如何最小化全局变量的数量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87-%E5%87%8C%E6%95%A3%E5%8F%98%E9%87%8F-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">二. 变量声明提升(凌散变量)的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">2.0.1.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.</span> <span class="toc-text">三. for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E5%B8%B8%E7%9A%84for%E5%BE%AA%E7%8E%AF%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">3.0.1.</span> <span class="toc-text">通常的for循环使用：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%94%B9%E8%BF%9B%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">3.0.2.</span> <span class="toc-text">第一种改进的方案：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%94%B9%E8%BF%9B%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">3.0.3.</span> <span class="toc-text">第二种改进的方案：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="toc-number">3.0.4.</span> <span class="toc-text">两种方式的比较：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-for-in%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.</span> <span class="toc-text">四. for-in循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">五.避免使用隐式类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6-gt-lt-gt-lt-%EF%BC%9A%E4%BC%9A%E6%8A%8A%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%88%90number%E4%B9%8B%E5%90%8E%E5%86%8D%E6%AF%94%E8%BE%83%E5%85%B3%E7%B3%BB"><span class="toc-number">5.0.1.</span> <span class="toc-text">2.关系运算符( &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D; &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;)：会把其他数据类型转换成number之后再比较关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="toc-number">5.0.2.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8eval"><span class="toc-number">6.</span> <span class="toc-text">六. 避免使用eval()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8eval-%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.1.</span> <span class="toc-text">不推荐使用使用eval()的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-eval-%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AE%83%E5%A4%96%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">1. eval()可以访问和修改它外部作用域的变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-eval-%E5%8F%AA%E5%9C%A8%E8%A2%AB%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E5%B9%B6%E4%B8%94%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%B0%B1%E6%98%AF-eval-%E6%9C%AC%E8%BA%AB%E6%97%B6%EF%BC%8C%E6%89%8D%E5%9C%A8%E5%BD%93%E5%89%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E6%89%A7%E8%A1%8C%EF%BC%8C-%E5%90%A6%E5%88%99%E5%B0%B1%E6%98%AF%E5%9C%A8%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%89%A7%E8%A1%8C"><span class="toc-number">6.1.2.</span> <span class="toc-text">2.eval() 只在被直接调用并且调用函数就是 eval ()本身时，才在当前作用域中执行， 否则就是在全局作用域执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.3.</span> <span class="toc-text">3.安全问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-2"><span class="toc-number">6.2.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eval-%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">eval() 的替代方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E4%B8%8D%E8%A6%81%E5%A2%9E%E5%8A%A0%E5%86%85%E7%BD%AE%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">七. 不要增加内置的原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-switch%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">八. switch模式：</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://p6.qhimg.com/t01f5a5270b7946b505.jpg"></div><div class="author-info__name text-center">舒小琦</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/webp.webp)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">舒小琦的Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/shuliqi-design">组件</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">《javascript设计模式》读书笔记一：编写可维护的代码</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/">JavaScript</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="一-尽量少用全局变量"><a href="#一-尽量少用全局变量" class="headerlink" title="一. 尽量少用全局变量"></a>一. 尽量少用全局变量</h3><p>Javascript 使用的是函数作用域，在函数内声明的变量，只有在函数内有效，不能在函数外使用。全局变量则是在函数外部声明，在函数内无需声明就可以使用。</p>
 <span id="more"></span>

<p>每一个javascript环境都有一个全局对象，在函数外部使用this进行访问。创建的全局变量都归全局对象所有。</p>
<p>在浏览器中，使用window表示全局变量本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myName = <span class="string">&quot;haha&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(myName)  <span class="comment">//haha</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.myName) <span class="comment">//haha</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>[<span class="string">&quot;myName&quot;</span>]) <span class="comment">//haha</span></span><br></pre></td></tr></table></figure>

<h5 id="全局变量的产生"><a href="#全局变量的产生" class="headerlink" title="全局变量的产生"></a>全局变量的产生</h5><p>javascript的两个特性总让我们在不知不觉中就创建了全局变量</p>
<ol>
<li><p><strong>可直接使用变量。甚至无需声明</strong></p>
</li>
<li><p><strong>javascript有个隐含全局变量。即任何变量，如果未经声明，就为全局对象所有</strong></p>
<p>例1:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	result = x + y;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong>例子中result未经声明， 归全局对象所有，在一般情况下可以正常使用， 但是在相同的全局命名空间使用了另外的result 变量， 就会有问题。</p>
<p>带有var声明的链式赋值有可能导致隐含全局变量</p>
<p>面的例子中你估计想要的结果？</p>
<p>例2:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = b = <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：a是局部变量，b是全局变量</p>
<p><strong>原因</strong>：从右到左的操作符优先级。首先是优先级较高的表达式b=0,此时b未经声明(归全局对象所有)。表达式的返回值是0， 被赋给了var声明的局部变量a。</p>
</li>
</ol>
<h5 id="全局变量的问题"><a href="#全局变量的问题" class="headerlink" title="全局变量的问题"></a>全局变量的问题</h5><ol>
<li><p>全局变量存在于同一个全局命名空间内，很有可能发生命名冲突</p>
</li>
<li><p>变量释放时的副作用</p>
<p>隐含全局变量与明确定义的全局变量有细微的不同。</p>
<ul>
<li><p>使用var创建的全局变量（这类变量在函数外部创建），不可以使用delete操作符撤销变量</p>
</li>
<li><p>不使用var创建的隐含全局变量（即使它是在函数内部创建），也可以使用delete操作符撤销变量</p>
<p>例3:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	c = <span class="number">3</span>;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// 企图删除</span></span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">delete</span> b; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> c; <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 测试删除情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a, <span class="keyword">typeof</span> b, <span class="keyword">typeof</span> c)</span><br><span class="line"><span class="comment">// &quot;number&quot;, &quot;undefined&quot;, &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这说明隐含全局变量不是真正的变量。而是只是全局对象的属性，属性是可以通过delete操作符删除的，但是变量不可以</p>
<h5 id="如何最小化全局变量的数量"><a href="#如何最小化全局变量的数量" class="headerlink" title="如何最小化全局变量的数量"></a>如何最小化全局变量的数量</h5><ol>
<li>命名空间模式</li>
<li>即时函数</li>
<li>使用var声明变量</li>
</ol>
<p>最重要的方式还是使用var声明。上面的例子改造如下：</p>
<p>例1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = x + y; <span class="comment">// result 就不会变成全局变量。</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a, b；</span><br><span class="line">	a = b = <span class="number">0</span>; <span class="comment">//都是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二-变量声明提升-凌散变量-的问题"><a href="#二-变量声明提升-凌散变量-的问题" class="headerlink" title="二. 变量声明提升(凌散变量)的问题"></a>二. 变量声明提升(凌散变量)的问题</h3><p>javascript允许在任何地方声明变量，无论在哪里声明，效果都等同于在函数顶部进行声明。这就是<strong>变量声明提升</strong>。注意：提升的只是声明部分，赋值部分不提升。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;shu&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a) </span><br><span class="line">	<span class="keyword">var</span> a = <span class="string">&quot;liqi&quot;</span></span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong>‘undefined’，’ liqi’</p>
<p><strong>原因：</strong>在函数getName作用域内，a被看做函数作用域内的变量。函数中所有的变量声明都会被提升的函数的最顶成，但是赋值部分位置不变。所以导致log出：’undefined’， liqi。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;shu&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name;</span><br><span class="line">	<span class="built_in">console</span>.log(name) </span><br><span class="line">	name = <span class="string">&quot;liqi&quot;</span></span><br><span class="line">	<span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></figure>

<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>为了避免的这样的混乱， 我们最好在开始就声明要用的变量。</p>
<h3 id="三-for循环"><a href="#三-for循环" class="headerlink" title="三. for循环"></a>三. for循环</h3><p>for循环常用在数组或者类数组对象（伪数组）上面。类对象数组例如：arguments，HTML DOM对象:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByName()</span><br><span class="line">document.getElementsByClassName()</span><br><span class="line">document.getElementsByTagName()</span><br></pre></td></tr></table></figure>

<h5 id="通常的for循环使用："><a href="#通常的for循环使用：" class="headerlink" title="通常的for循环使用："></a>通常的for循环使用：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法在于每次循环都需要访问数组的长度。这样会使代码变慢。特别当arr不是数组，是HTML DOM</p>
<p>对象的时候。更耗时。</p>
<h5 id="第一种改进的方案："><a href="#第一种改进的方案：" class="headerlink" title="第一种改进的方案："></a>第一种改进的方案：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">	 <span class="built_in">console</span>.log(i) <span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式下， 对长度的值只提取一次。但是可以应用的整个循环。</p>
<h5 id="第二种改进的方案："><a href="#第二种改进的方案：" class="headerlink" title="第二种改进的方案："></a>第二种改进的方案：</h5><p>逐步减到0，因为同0比较比同数组的长度比较（同非0数组）比较更有效率</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = arr.length; i--;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="两种方式的比较："><a href="#两种方式的比较：" class="headerlink" title="两种方式的比较："></a>两种方式的比较：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;同长度比较&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">	<span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;同长度比较&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;同0比较&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = arr.length; i--;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">	<span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;同0比较&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>但是也存在一些缺点，就是处理的顺序倒过来了。</p>
<h3 id="四-for-in循环"><a href="#四-for-in循环" class="headerlink" title="四. for-in循环"></a>四. for-in循环</h3><p>for-in是用来循环非数组对象的。当遍历对象属性时遇到原型链的属性时，使用hasOwnProperty()方法来过滤是非常重要的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;shu&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将一个方法clone添加到对象上</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype.clone === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免在枚举的时候出现clone()。 需要调用hasOwnproperty()方法来过滤原型链属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">	<span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(key,<span class="string">&#x27;:&#x27;</span>, obj[key] )</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong> name : shu， age : 12</p>
<h3 id="五-避免使用隐式类型转换"><a href="#五-避免使用隐式类型转换" class="headerlink" title="五.避免使用隐式类型转换"></a>五.避免使用隐式类型转换</h3><p>#####1.字符串连接符与算术运算符（+ - * / %）隐式转换规则</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="string">&#x27;true&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>结果会是什么样的？</p>
<p><strong>转换规则：</strong></p>
<p>​    1.字符串连接符(“+”两边有一边是字符串)：会把其他数据类型调用String()方法然后拼接。</p>
<p>​    2.运算操作符(除了不是字符串连接符的”+”就都是是运算操作符)：会把其他数据类型调用Number()方法转成数字然后做运算。</p>
<p>所以例子的结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;+“ 是字符串连接符：String(1) + &#x27;true&#x27; = &#x27;1true&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="string">&#x27;true&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;+“ 是算术运算符： 1 + Number(true) = 1 + 1 = 2</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">true</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;+“ 是算术运算符： 1 + Number(undefined) = 1 + NaN = NaN</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">undefined</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;+“ 是算数运算符： 1 + Number(null) = 1 + 0 = 1</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span>+ <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>



<h5 id="2-关系运算符-gt-lt-gt-lt-：会把其他数据类型转换成number之后再比较关系"><a href="#2-关系运算符-gt-lt-gt-lt-：会把其他数据类型转换成number之后再比较关系" class="headerlink" title="2.关系运算符( &gt; &lt; &gt;= &lt;= == != === !==)：会把其他数据类型转换成number之后再比较关系"></a>2.关系运算符( &gt; &lt; &gt;= &lt;= == != === !==)：会把其他数据类型转换成number之后再比较关系</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &gt; <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &gt; <span class="string">&#x27;10&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;aad&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> ==  <span class="literal">NaN</span>)</span><br></pre></td></tr></table></figure>

<p>结果会是什么样的呢？</p>
<p><strong>转换规则：</strong></p>
<p>1.关系运算符两边有一边是字符串，会将其使用Number()转成数字，然后比较关系。</p>
<p>2.关系运算符两边都是字符串，两边按照字符串对应的unicode编码（可以使用charCodeAt()查看）转成数字，然后比较。</p>
<p>3.当有多个字符串进行比较，依次从左到右比较。</p>
<p>4.如果数据类型是null，undefined 不是严格比较两者都是相等的。</p>
<p>5.NaN 类型与任何数据类型比较都是NaN</p>
<p>所以例子的结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false  Number(2) &gt; 10 = 2 &gt; 10 = false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true  &#x27;2&#x27;.charCodeAt() &gt; &#x27;10&#x27;.charCodeAt() = 50 &gt; 49 = true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &gt; <span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>.charCodeAt()); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>.charCodeAt()); <span class="comment">// 49</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false 先比较a和b：  &#x27;a&#x27;.charCodeAt() &gt; &#x27;b&#x27;.charCodeAt() = 97 &gt; 98 = false,直接得出结果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>.charCodeAt()); <span class="comment">// 97</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>.charCodeAt()); <span class="comment">// 98</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//true 先比较 a和a, 两者相等。则比较b和a：&#x27;b&#x27;.charCodeAt() &gt; &#x27;a&#x27;.charCodeAt() = 98 &gt; 97 = true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;aad&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true 特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// false 严格比较</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ===  <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true 特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true  特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// false 特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> ==  <span class="literal">NaN</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> ===  <span class="literal">NaN</span>)</span><br></pre></td></tr></table></figure>

<h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>JavaScript在语句比较时会执行隐式类型转换(除了严格比较)。 有时候自己理不清。最好避免使用。使用就最好使用严格比较如：===,   !==。</p>
<h3 id="六-避免使用eval"><a href="#六-避免使用eval" class="headerlink" title="六. 避免使用eval()"></a>六. 避免使用eval()</h3><p><strong>eval函数的作用</strong>:  在当前作用域中执行一段JavaScript代码字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> one = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&#x27;one = 3&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="不推荐使用使用eval-的原因"><a href="#不推荐使用使用eval-的原因" class="headerlink" title="不推荐使用使用eval()的原因"></a>不推荐使用使用eval()的原因</h4><h5 id="1-eval-可以访问和修改它外部作用域的变量"><a href="#1-eval-可以访问和修改它外部作用域的变量" class="headerlink" title="1. eval()可以访问和修改它外部作用域的变量"></a>1. eval()可以访问和修改它外部作用域的变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunOne</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> local = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">eval</span>(<span class="string">&#x27;local = 3; console.log(&quot;eval:&quot;, local)&#x27;</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(local)	 <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line">myFunOne();</span><br></pre></td></tr></table></figure>

<h5 id="2-eval-只在被直接调用并且调用函数就是-eval-本身时，才在当前作用域中执行，-否则就是在全局作用域执行"><a href="#2-eval-只在被直接调用并且调用函数就是-eval-本身时，才在当前作用域中执行，-否则就是在全局作用域执行" class="headerlink" title="2.eval() 只在被直接调用并且调用函数就是 eval ()本身时，才在当前作用域中执行， 否则就是在全局作用域执行"></a>2.eval() 只在被直接调用并且调用函数就是 eval ()本身时，才在当前作用域中执行， 否则就是在全局作用域执行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> one = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">eval</span>; <span class="comment">//这里将a变量指向了eval函数的引用</span></span><br><span class="line">    a(<span class="string">&#x27;one = 3&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>这段代码等价于在全局作用域中调用 eval。</p>
<h5 id="3-安全问题"><a href="#3-安全问题" class="headerlink" title="3.安全问题"></a>3.安全问题</h5><p>eval 也存在安全问题，因为它会执行任意传给它的代码字符串， 在代码字符串未知或者是来自一个不信任的源时就会有安全问题。</p>
<h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><p>​        绝对不要使用 eval，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。 如果一些情况必        须使用到 eval 才能正常工作，首先它的设计会受到质疑，这不应该是首选的解决方案。</p>
<h4 id="eval-的替代方式"><a href="#eval-的替代方式" class="headerlink" title="eval() 的替代方式"></a>eval() 的替代方式</h4><p>new Fuction()构造函数和eval()比较类似。如果一定需要使用eval()，那么可以考虑使用new Fuction()来代替eval()。这样的好处是：<strong>new Function()中的代码将在局部函数空间中运行， 因此代码中的任何采用var定义的变量不会自定成为全局变量</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> one); <span class="comment">// &quot;undefine&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> two); <span class="comment">// &quot;undefine&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var one = 1; console.log(one);&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;var two = 2; console.log(two);&#x27;</span>)() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> one); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> two); <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>setInterval(),setTimeout,function()等构造函数来传递参数。在特殊情况下，会导致类似eval()的隐患。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1111&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 认为 &quot;myFun()&quot; 是可执行的代码  不建议这么写</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;myFun()&quot;</span>, <span class="number">1000</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 认为 &quot;myFun(1,2,3)&quot; 是可执行的代码 不建议这么写</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;myFun(1,2,3)&quot;</span>, <span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐这种方式: 函数的引用</span></span><br><span class="line"><span class="built_in">setInterval</span>(myFun, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	myFun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// myFun是对函数的直接调用，也就是说当setInterval还没有开始函数func就执行了, 果这个函数没有返回值或者返回值不是可执行的函数或者其他的代码的话，就以上代码而言只会打印一次。</span></span><br><span class="line"><span class="built_in">setInterval</span>(myFun(), <span class="number">1000</span> ) </span><br></pre></td></tr></table></figure>



<h3 id="七-不要增加内置的原型"><a href="#七-不要增加内置的原型" class="headerlink" title="七. 不要增加内置的原型"></a>七. 不要增加内置的原型</h3><p>增加内置构造函数（Object(),Array(),Fuction()等）的原型，但是这可能会严重影响可维护性。因为这种做法使得代码更加不可预测。其他开发者在使用你的代码的时候可能期望的内置的Javascript方法，而不是期望有一些你自己添加的方法。</p>
<p>并且，给原型添加属性在没有使用hasOwnproperpty()时可能会在循环中出现。这会导致一些混乱。</p>
<h3 id="八-switch模式："><a href="#八-switch模式：" class="headerlink" title="八. switch模式："></a>八. switch模式：</h3><p>可以使用一下switch模式来提高代码的的可读性和健壮性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		result = <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：每一个case 需要有一个明确的break语句</p>
<p>​        </p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">舒小琦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shuliqi.github.io/2019/05/14/编写可维护的代码（基础技巧）/">https://shuliqi.github.io/2019/05/14/编写可维护的代码（基础技巧）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shuliqi.github.io">舒小琦的Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/05/23/%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1/"><i class="fa fa-chevron-left">  </i><span>《javascript设计模式》读书笔记二：字面量和构造函数</span></a></div><div class="next-post pull-right"><a href="/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/"><span>Vue 的双向绑定原理及手把手实现</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/webp.webp)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By 舒小琦</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>