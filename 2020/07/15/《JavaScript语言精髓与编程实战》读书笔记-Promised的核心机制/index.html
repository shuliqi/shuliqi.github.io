<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《JavaScript语言精髓与编程实战》读书笔记-Promised的核心机制"><meta name="keywords" content><meta name="author" content="舒小琦"><meta name="copyright" content="舒小琦"><title>《JavaScript语言精髓与编程实战》读书笔记-Promised的核心机制 | 舒小琦的Blog</title><link rel="shortcut icon" href="/shuliqi.github.io/melody-favicon.ico"><link rel="stylesheet" href="/shuliqi.github.io/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/shuliqi.github.io/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是Promise"><span class="toc-number">1.</span> <span class="toc-text">什么是Promise?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#promise的状态"><span class="toc-number">2.</span> <span class="toc-text">promise的状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise的特点"><span class="toc-number">3.</span> <span class="toc-text">Promise的特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建Promise"><span class="toc-number">4.</span> <span class="toc-text">创建Promise</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise的构造方法"><span class="toc-number">5.</span> <span class="toc-text">Promise的构造方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构建Promise对象：没有延迟"><span class="toc-number">6.</span> <span class="toc-text">构建Promise对象：没有延迟</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Then-链"><span class="toc-number">7.</span> <span class="toc-text">Then 链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#promise1的置值逻辑"><span class="toc-number">7.1.</span> <span class="toc-text">promise1的置值逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise2的置值逻辑"><span class="toc-number">7.2.</span> <span class="toc-text">promise2的置值逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#then-链中“产生”-reject值的方法"><span class="toc-number">7.3.</span> <span class="toc-text">then 链中“产生” reject值的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Then-链对值的传递"><span class="toc-number">7.4.</span> <span class="toc-text">Then 链对值的传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Then-链-catch-的处理"><span class="toc-number">7.5.</span> <span class="toc-text">Then 链 catch() 的处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise的类方法"><span class="toc-number">8.</span> <span class="toc-text">Promise的类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-resolve"><span class="toc-number">8.1.</span> <span class="toc-text">Promise.resolve()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-reject"><span class="toc-number">8.2.</span> <span class="toc-text">Promise.reject()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-all"><span class="toc-number">8.3.</span> <span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-race"><span class="toc-number">8.4.</span> <span class="toc-text">Promise.race()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise对象的原型方法"><span class="toc-number">9.</span> <span class="toc-text">Promise对象的原型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-Prototype-catch"><span class="toc-number">9.1.</span> <span class="toc-text">Promise.Prototype.catch()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-Prototype-finally"><span class="toc-number">9.2.</span> <span class="toc-text">Promise.Prototype.finally()</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/shuliqi.github.io/img/avatar.png"></div><div class="author-info__name text-center">舒小琦</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/shuliqi.github.io/archives"><span class="pull-left">文章</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/shuliqi.github.io/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/shuliqi.github.io/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/shuliqi.github.io/">舒小琦的Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span></div><div id="post-info"><div id="post-title">《JavaScript语言精髓与编程实战》读书笔记-Promised的核心机制</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/shuliqi.github.io/categories/学习笔记/">学习笔记</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>最近参部门的读书会，读书会会推荐一些书来供我们学习， 这次的读书会推荐读的书是《JavaScript语言精髓与编程实战》。感觉写的很不错，我这次学习的是【Promise的核心机制】, 虽然之前也看过关于<code>Promise</code>  <a href="https://shuliqi.github.io/2018/03/20/ES6学习-Promise/">ES6学习笔记-Promise</a>, 但是在看这本书之后，讲的更多关于<code>Promise</code>的原理。还是有值得很深入的点。</p>
<p>最后感觉跟着大神们学习感觉很不错呀，哈哈嘻😊！</p>
 <a id="more"></a>
<h1 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise?"></a>什么是Promise?</h1><p>Promise对象是一个代理对象（代理一个值）。被代理的值在Promise创建的时候可能是未知的。它允许你为异步操作的成功与失败分别绑定相应的处理方法。这让异步可以像同步方法那样返回值，但并不是立即返回最终的执行结果，而是一个能代表未来的出现的结果的promise对象。</p>
<h1 id="promise的状态"><a href="#promise的状态" class="headerlink" title="promise的状态"></a>promise的状态</h1><p>Promise 一种有三种值的状态： <strong>pending(进行中)</strong>, <strong>fulfiiled(已成功)</strong>，<strong>rejected(已失败)‘</strong></p>
<h1 id="Promise的特点"><a href="#Promise的特点" class="headerlink" title="Promise的特点"></a>Promise的特点</h1><ul>
<li><p><strong>对象的状态不受外界的影响</strong></p>
<p>只有异步的结果可以决定当前是哪一种状态（pending， fulfilled, rejected）。 其他的手段都是无法改变的。</p>
</li>
<li><p><strong>一旦状态改变，就不会再变，任何时候都可以拿到这个状态</strong></p>
<p>Promise的状态只有两种可能：从pending 到 fulfilled， 从peding 到rejected。只要这两种发生了，状态也就凝固了，不会再变了。</p>
<p>如果在对Promise对象添加回调函数，也会立刻拿到这个结果。</p>
</li>
</ul>
<h1 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h1><p>创建Promise对象，主要有三种方式：</p>
<ul>
<li>使用 <code>new Promise()</code>来创建一个<code>promise</code>(即<code>new Promise()</code>构造器)</li>
<li><p>使用类方法Promise.xxx()-——<code>Promise.all()</code>，<code>Promise.race()</code>，<code>Promise.allsettled()</code>，<code>Promise.any()</code>，<code>Promise.resolve()</code>，<code>Promise.reject()</code></p>
</li>
<li><p>使用原型形方法<code>Promise.prototype.xxx()</code>——<code>promise.then()</code>，<code>promise.catch()</code>，<code>promise.fanally()</code>都将返回一个新的promise</p>
<blockquote>
<p>任何方法得到的<code>promise</code>对象都具有<code>.then</code>，<code>.catch</code>等方法，也是<code>Promise.prototype.xxx</code>的原型方法，<code>Javascript</code>调用这些方法将绝对不会抛出异常，所以这就是上面第三种得到一个新的<code>promise</code>对象的方法</p>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong>任何一种方法都是立即得到<code>promise</code>对象的</p>
<h1 id="Promise的构造方法"><a href="#Promise的构造方法" class="headerlink" title="Promise的构造方法"></a>Promise的构造方法</h1><p><code>Promise</code>通常使用一个简单的构造器来让用户方便的创建<code>promise</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建promise对象的构造器</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要用户声明的执行函数</span></span><br><span class="line"><span class="keyword">const</span> executor = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>executor</code> 是用户声明的执行函数，当<code>JavaScript</code>引擎通过new 运算符来创建<code>promise</code>对象时，它事实上在调用<code>executor()</code>之前就创建好一个新的<code>promise</code>对象的实例，并且得到关联给这个实例的两个置值器：<code>resolve()</code>，<code>reject()</code>函数，然后，它会调用<code>executor()</code>，并且把这两个置值器作为入口参数传入，而<code>executor()</code>函数会被执行直到退出。</p>
<p><strong>注意：</strong><code>executor()</code>函数并不通过退出时所返回的值来对系统造成影响——该返回值将会被忽略（无论是显式返回结果，还是默认返回值<code>undefined</code>）。<code>executor()</code>中的用户代码可以利用上述的两个置值器，来向<code>promise</code>对象“代理的那个数据”置值。也就是说，为<code>promise</code>绑定值的过程是由用户代码来触发的。这个过程看起来像”让用户代码回调<code>JavaScript</code>引擎”。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户代码通过resolve(或reject）来回调引擎以置值</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"shuliqi"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意：<code>executor()</code></strong>函数中的<code>resolve</code>·置值器可以接受任何值（除了当前的promise本身之外）,如果使用自身来置值时，<code>JavaScript</code>会抛出一个异常。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂存resolve置值的变量</span></span><br><span class="line"><span class="keyword">let</span> delayResolve;</span><br><span class="line"> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    delayResolve = resolve;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// 尝试使用自身来置值</span></span><br><span class="line"> delayResolve(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="构建Promise对象：没有延迟"><a href="#构建Promise对象：没有延迟" class="headerlink" title="构建Promise对象：没有延迟"></a>构建Promise对象：没有延迟</h1><p>在构建整个<code>Promise</code>对象的过程中， 是没有任何的延迟的。<code>Promise</code>机制中没有延迟， 也没有被延迟的行为，更没有对”时间”这个维度进行控制。因此<code>JavaScript</code>中创建一个<code>promise</code>时，创建过程时立即完成的；使用原型的方法<code>promise.xxx</code>来得到一个新的<code>promise</code>时也是立即完成的。所有<code>promise</code>对象都是在你需要的时候立即就生成的。</p>
<p>只不过重要的是—-&gt;<strong>这些<code>promise</code>所代理的那个值/数据还没有“就绪”。这个就绪的过程要推迟到“未知的将来”才会发生，而一旦数据就绪，promise.then(fun)中的fun就会被触发了</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shuliqi'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'1'</span>), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>只要我们创建了<code>promise</code> 对象，这个过程是立即的，所以立马输出“shuliqi”。然后过3秒，输出 “1”。</p>
<h1 id="Then-链"><a href="#Then-链" class="headerlink" title="Then 链"></a>Then 链</h1><p>两个<code>Promise</code>对象之间顺序执行的关系，在<code>JavaScript</code>中称为“Then 链”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Promise 对象P</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'shuliqi'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过p.then()来得到新的promise对象 p2</span></span><br><span class="line"><span class="keyword">const</span> p2 = p.then(foo() =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过调用<code>p.then(</code>)的方式来约定当前的<code>promise</code>对象与下一个<code>promise</code>对象之间的“链”关系，并且这事实上也也代表了它们之前的顺序执行的关系（<strong>所谓的“顺序执行”是指它们的置值逻辑以及触发的行为之间的关系—-&gt; 因为Promise本身是数据的代理所以并不是执行体</strong>）。</p>
<p>并且then链是Promise机制的基本用法和关键的机制。上面例子中的p.then()代表了对顺序的逻辑的理解， 同时它也隐含的说明：p2 与p1两者所代理的数据之间是有关联的。这个例子的foo()函数是作为p1的成功回调，如下面这个例子的作为onFulfilled参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Promise 对象P</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'shuliqi'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过p.then()来得到新的promise对象 p2</span></span><br><span class="line"><span class="keyword">const</span> p2 = p.then(onFulfilled, onRejected);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(value); <span class="comment">// shuliqi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在当前的promise数据就绪时，JavaScript就将根据就绪状态立即出发有p.then()方法所关联的onFulfilled/ onRejected之一，并且这个函数<strong>退出时返回的值</strong>或者<strong>终止执行时的状态</strong>作为值来调用p2</p>
<p>p.then()实际上是Promise.prototype.then这个原型的方法，它的作用主要是完成三件事：</p>
<ul>
<li>创建新的promise2对象</li>
<li>登记当前promise 与 promise2 之间的关系（顺序执行的关系和代理的数据之间是有关联的）</li>
<li>将onFulfilled ，onRejected关联给promise2 的resolve置值器，并且确保早promise1的数据就绪时调用onFulfilled， onRejected。</li>
</ul>
<h2 id="promise1的置值逻辑"><a href="#promise1的置值逻辑" class="headerlink" title="promise1的置值逻辑"></a>promise1的置值逻辑</h2><p>所以在构建promise的执行器中，可以向resolve/reject 传入任意的JavaScript数据类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    resolve(<span class="string">'我显示使用resolve置值器置值'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(<span class="string">'我显示使用reject 置值器置值'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个例子显式的使用resolve / reject 置值器来置值。</p>
<p>如果执行器在执行的过程中触发异常，javaScript引擎也将调用reject， 并且把异常作为reason。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// 创建异常，并且抛出，相当于reject(new Error())</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>接下来，如果在它的then 链上有promise2,那么如前所诉：onFulfilled/onRejected将被触发，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    resolve(<span class="string">'我显示使用resolve置值器置值'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(<span class="string">'我显示使用reject 置值器置值'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 =p.then(onFulfilled, onRejected);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是resolve置值器置值成功的回调'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是reject置值器置值或者是resolve置值器置值失败的回调"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我是resolve置值器置值成功的回调</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// 创建异常，并且抛出，相当于reject(new Error())</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 =p.then(resolved, rejected);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolved</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是resolve置值器置值成功的回调'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是reject置值器置值或者是resolve置值器置值失败的回调"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我是reject置值器置值或者是resolve置值器置值失败的回调</span></span><br></pre></td></tr></table></figure>
<p>以上的的 resolved， rejected 都只是 p 的状态，他们只是promise2的置值前提而已， 那么promise2的置值逻辑是啥呢？</p>
<h2 id="promise2的置值逻辑"><a href="#promise2的置值逻辑" class="headerlink" title="promise2的置值逻辑"></a>promise2的置值逻辑</h2><p>一个Promise可能被置入两种值之一（并且一旦置值将不可改变，称为“终态”），这两种值时指：</p>
<ul>
<li>如果promise 被 resolve置值器置值成功，则该值称为有效值（value）</li>
<li>如果promise 被 reject置值器置值 或者 resolve置值器置值 失败，则该值用于记录原因（reason）。</li>
</ul>
<p><strong>无论rejected，rejected函数无论返回何值，都将作为resolve值直接绑定给promise2</strong>(即：resolved, rejected函数会关联在promise2的resolve 值值器上)</p>
<p>promise2 的置值逻辑伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断上一个promise的置值状态</span></span><br><span class="line">    <span class="keyword">if</span> (isRejected(p)) &#123;</span><br><span class="line">        x2 = rejected(result);  <span class="comment">// 执行rejected函数，result为reason（result是p代理的数据）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x2 = resolved(result); <span class="comment">// 执行resolved函数</span></span><br><span class="line">    &#125; </span><br><span class="line">    resolve(x2); <span class="comment">// promise2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvedForP1 = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rejectedForP1 = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reason;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> resolvedForP2 = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是p2 resolved状态,'</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rejectedForP2= <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是p2 rejected状态,'</span>, reason);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 顺便调用p1的resolve置值器，还是reject置值器</span></span><br><span class="line">      <span class="comment">// resolve('p1 resolve');</span></span><br><span class="line">      reject(<span class="string">'p1 reject'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(resolvedForP1, rejectedForP1);</span><br><span class="line">p2.then(resolvedForP2, rejectedForP2)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我是p2 resolved状态, p1 reject</span></span><br></pre></td></tr></table></figure>
<p>这个例子： 无论p1 我调用的是 resolve 置值器还是拍，导致无论调用 resolvedForP1还是 rejectedForP1，返回值都是作为resolve值绑定给p2。</p>
<p>调用（p1  reject 置值器 —-&gt; 调用rejectedForP1 —-&gt; rejectedForP1 返回值 —-&gt; 通过p2 的resolve置值器直接绑定给p2）。</p>
<p>注意：<strong>这不是完成的promise2 的置值逻辑</strong>， 完整的请往下看。</p>
<h2 id="then-链中“产生”-reject值的方法"><a href="#then-链中“产生”-reject值的方法" class="headerlink" title="then 链中“产生” reject值的方法"></a>then 链中“产生” reject值的方法</h2><p>在then 链中“产生” reject值的方法只有两种：</p>
<ul>
<li><p>通过抛出异常来使得JavaScript引擎捕获异常对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'我是舒丽琦'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方法1: 通过抛出异常来使得JavaScript引擎捕获异常对象</span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'通过抛出异常来使得JavaScript引擎捕获异常对象'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: Error: 通过抛出异常来使得JavaScript引擎捕获异常对象....</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过显式的调用Promise.reject()。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'我是舒丽琦'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方法2: 显式的调用Promise.reject() </span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">'显式的调用Promise.reject() '</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: 显式的调用Promise.reject() ...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Then-链对值的传递"><a href="#Then-链对值的传递" class="headerlink" title="Then 链对值的传递"></a>Then 链对值的传递</h2><p>如果promise2 的resolve 并没有关联有效的resolved，rejected 呢？ 或者 promise2 根本没有resolved， rejected 函数呢？那么还会生成promise2 吗？ 如果生成， 那么它的值时什么呢？</p>
<p>答案：<strong>如果没有有效的响应函数仍会产生新的promise2, 并且它的resolve 将以then 链中的当前的promise的值为值</strong>，</p>
<p>因此promise2 的完整的伪置值逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断上一个promise的置值状态</span></span><br><span class="line">    <span class="keyword">if</span> (isRejected(p)) &#123;</span><br><span class="line">       <span class="comment">// rejected 是有效的 ? 执行rejected函数，result为reason : result </span></span><br><span class="line">       <span class="comment">// 其中result是p代理的数据</span></span><br><span class="line">        x2 = isValidHandler(rejected) ? rejected(result) :<span class="keyword">throw</span> result;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	  <span class="comment">// resolved函数是有效的 ？ 执行resolved函数 ： result;</span></span><br><span class="line">        x2 = isValidHandler(resolve) : resolved(result) : result; </span><br><span class="line">    &#125; </span><br><span class="line">    resolve(x2); <span class="comment">// promise2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来举例子检测一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'调用p1的reject置值器置值'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then();</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: 调用p1的reject置值器置值...</span></span><br></pre></td></tr></table></figure>
<p>P1代理的值是reject 置值器置值的，在创建p2的时候， rejected 函数不存在(无效), 则抛出异常, 值为当前promise(p1)的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'调用p1的reject置值器置值'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then();</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 调用p1的reject置值器置值</span></span><br></pre></td></tr></table></figure>
<p>P1代理的值是resolve置值器置值的，在创建p2的时候， resolved函数不存在(无效), 则直接返回当前promise(p1)的值。</p>
<h2 id="Then-链-catch-的处理"><a href="#Then-链-catch-的处理" class="headerlink" title="Then 链 catch() 的处理"></a>Then 链 catch() 的处理</h2><p>promise2的置值过程也解释了使用.catch作为then链结尾的原因：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'调用p1的reject置值器置值'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then();</span><br><span class="line"><span class="keyword">const</span> p3 = p2.then();</span><br><span class="line">p3.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: 调用p1的reject置值器置值</span></span><br></pre></td></tr></table></figure>
<p>在任意长的then链中，如果链的前端出现了rejected 值，无论经过多少级.then()响应(只有onFulfilled响应而没有处理)， 最终rejected 值都能够持续向后传递并且被链尾的.catch()响应到。这也就是Promise机制的第一原则：<strong>始于Promise， 终于catch</strong>。</p>
<h1 id="Promise的类方法"><a href="#Promise的类方法" class="headerlink" title="Promise的类方法"></a>Promise的类方法</h1><p>Promise()类方法Promise.xxx主要作用于获得一个promise</p>
<p>promise类方法有四个：</p>
<ul>
<li><p><strong>Promise.resolve()</strong></p>
</li>
<li><p><strong>Promise.reject()</strong></p>
</li>
<li><p><strong>Promise.all()</strong></p>
</li>
<li><p><strong>Promise.race()</strong></p>
</li>
</ul>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>Pomise类方法resolve()是要得到一个resolved 的 promise。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(x)</span><br></pre></td></tr></table></figure>
<p>x是任意值，如果不指定则是undefined</p>
<ul>
<li><p>如果 x 是Promise的一个实例，那么Promise.resolve(x)， 将不会产生新的计算结果，而是直接返回x这个实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(x);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(p)</span><br><span class="line"><span class="comment">// p 与 p2 是相同的promise</span></span><br><span class="line"><span class="built_in">console</span>.log(p === p2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// resolve的值是同一个</span></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span>  <span class="built_in">console</span>.log(value === x)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果x是一个thenable</p>
<p>thenable对象：指任意带有.then()方法的对象。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">   then: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'我是thenable对象'</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'我是thenable对象'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line"><span class="comment">// 我是thenable对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thenable === p); </span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>x.then()是立即执行了， 但是这个thenable对象与最终的p没有关系，所以目前这个执行过程是没有什么意义的。因为这个thenable对象与最终的p对像之间并没有建立关系。为什么没有建立关系呢？这是因为JavaScript是试图将x.then()作为一个“类似new Promise()中的执行器（executor）”来使用的。Promise.resolve(tenable)导致.then() 被执行时，p这个promise对象的resolve与reject两个置值器被作为.then()的参数传入的，因此(与new Promise类似)，用户代码需要在.then(resolve,reject)调用这两个置值器才能真正的建立thenable与p之间的关系。</p>
<p>所以下面这个例子，p对象与thenable才真正建立起了关系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    then: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是thenable对象'</span>);</span><br><span class="line">        resolve(<span class="string">'shuliqi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 我是thenable对象</span></span><br><span class="line"><span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果x是一个rejected的promise对象，那么Project.resolve(x将会是一个rejected状态的promise对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'rejected状态'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(p);</span><br><span class="line">p2.then().catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// rejected状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>x以上情况都不是，那么将会返回一个新的状态直接为resolved的promise对像，并且代理的数据与x的相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">"shuliqi"</span>;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(x);</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'resolved状态的'</span>, value));</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">//resolved状态的, shuliqi</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"resolved状态的"</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  上面这两个例子都是调用了resoled状态的回调。</p>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>Pomise类方法Promise.reject()得到一个rejected 的promise；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(x)； <span class="comment">// x是任意值，如果不指定则为undefined</span></span><br></pre></td></tr></table></figure>
<p>Promise.reject(x)与Promise.resolve(x)不同，Promise.reject(x)是将x作为一个普通的对象。这就意味着仍然会得到一个rejected promise，并且它的值时一个（类型为Promise）的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">'shuliqi'</span>);</span><br><span class="line"><span class="keyword">const</span> p2 =<span class="built_in">Promise</span>.reject(p1);</span><br><span class="line">p2.then().catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'typeof reason:'</span>, <span class="keyword">typeof</span> reason);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'instanceof Promise:'</span>, reason <span class="keyword">instanceof</span> <span class="built_in">Promise</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'reason === p1:'</span>, reason === p1)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// typeof reason: object</span></span><br><span class="line"><span class="comment">// instanceof Promise: true</span></span><br><span class="line"><span class="comment">// reason === p1: true</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>尝试resolve所有元素。当所有的元素都resolved，得到一个将所有结果作为resolved array的promise。当任意一个元素rejected，得到一个该结果 reason 的rejected promise。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(x); <span class="comment">// x 必须是可迭代对象（集合对象，或者是有迭代器的对象）</span></span><br></pre></td></tr></table></figure>
<p><strong>可迭代的对象</strong>：数组， Map/Set集合，字符串可迭代的对象：数组， Map/Set集合，字符串 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all([timeout1, timeout2])</span><br><span class="line">  .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"都执行完成了"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"没有catch"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 都执行完成了</span></span><br></pre></td></tr></table></figure>
<p>Promise.all()会对所有的元素进行预处理（Promise.resolve(x)）所以无论x 是一个普通值还是一个“潜在的promise”， 它都将作为一个resolved promise进入后续的处理，即使x是一个rejected promise， 那么它的状态(Promise.resolve(rejected_promise))依然会影响Promise.all()的最终状态的判断。 一旦发现rejected，则返回rejected的结果。</p>
<p>promise.all(element)只有element完全resolved时，会在then()中得到一个与原始element 存在映射关系的数组。</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>尝试resolve 所有元素。只要其任一元素resolved 或 rejected，都将以该结果作为结果promise</p>
<p>注意：所有的其他的元素的状态都是未确定的，并且他们的执行过程与结果不确定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race(x); <span class="comment">// x 必须是可迭代对象（集合对象，或者是有迭代器的对象）</span></span><br></pre></td></tr></table></figure>
<p>Promise.race()与Promise.all()类似， 都会对所有的元素进行预处理（Promise.resolve(x)）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout 1"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout2"</span>);</span><br><span class="line">    reject();</span><br><span class="line">  &#125;, <span class="number">500</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([timeout1, timeout2])</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第一个time状态发生改变了"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"catch"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// timeout2</span></span><br><span class="line"><span class="comment">//  catch</span></span><br><span class="line"><span class="comment">//  timeout 1</span></span><br></pre></td></tr></table></figure>
<h1 id="Promise对象的原型方法"><a href="#Promise对象的原型方法" class="headerlink" title="Promise对象的原型方法"></a>Promise对象的原型方法</h1><p>Promise对象方法Promise.prototype.xxx(p.xxx)主要用于响应一个promise 状态，并且对象方法的响应结果也必然是返回一个新的promise2。除了.then()之外，promise对象最主要的的原型方法—.catch() 和.finally()都是通过通过.then()来间接实现的。</p>
<h2 id="Promise-Prototype-catch"><a href="#Promise-Prototype-catch" class="headerlink" title="Promise.Prototype.catch()"></a>Promise.Prototype.catch()</h2><p>.catch(onRejected) 与.then(_, onRejected)中的参数一致， 两种用法的效果也近似。</p>
<p>但是使用.catch()的方法， 尤其是在Then链末端的.catch()是非常必要的和安全的， 因为.then(onFulfilled, onRejected)中的onRejected函数并不能捕获到onFulfilled函数里面的异常(以及其中返回的rejected promise)。 如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onFulfilled = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'我抛出异常，产生rejected promise'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'没有能捕获onFulfilled函数返回的rejected promise'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
<p>这个例子中的onRejected 函数并不能响应onFulfilled函数中抛出的异常以及JavaScript为该异常而创建的rejected promise，将会遗漏对rejected Promise的处理，争取的处理应该是遵循“始于promise，终于catch”的原则。如下例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onFulfilled = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'我抛出异常，产生rejected promise'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'没有能捕获onFulfilled函数返回的rejected promise'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p.then(onFulfilled, onRejected).catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我来处理onFulfilled产生的异常:'</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我来处理onFulfilled产生的异常： 我抛出异常，产生rejected promise</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise-Prototype-finally"><a href="#Promise-Prototype-finally" class="headerlink" title="Promise.Prototype.finally()"></a>Promise.Prototype.finally()</h2><p>finally()方法，与try…catch/finally中的finally子句的语法类似；使代码无论.catch()还是.then()调用结束后，总是能得到一次调用.fanally()的机会。</p>
<p><strong>该方法不接受任何的参数，意思就是最后的Promise代理的值是什么， 是没有办法知道的。finally()方法跟最后的promise的状态是无关的。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// finally（）方法的响应函数是无传入参数的</span></span><br><span class="line"><span class="keyword">const</span> onFinally = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"不管promise状态怎么样， 我都会执行, 并且我是无参数参入的哦"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"我抛出错误"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"发生错误"</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(onFinally);</span><br></pre></td></tr></table></figure>
<p>上面例子的结果为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">发生错误 <span class="built_in">Error</span>: 我抛出错误</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">6</span>:<span class="number">15</span></span><br><span class="line">    at <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="xml"><span class="tag">&lt;<span class="name">anonymous</span>&gt;</span>)</span></span><br><span class="line">    at &lt;anonymous&gt;:5:15</span><br><span class="line">VM134:3 不管promise状态怎么样， 我都会执行, 并且我是无参数参入的哦 undefined</span><br></pre></td></tr></table></figure>
<p>这个例子中的onFinally函数中，我们打印value 值，值为undefined。说明.finally()的onFinally函数是不接受任何参数的。</p>
<p><strong>默认.finally()方法不会改变Then 链上前端所产生的值，也包括其状态。</strong></p>
<p>JavaScript 不处理在响应函数onFinally中的任何返回值，.finally()方法的结果—只是简单的“得到了”链上的前一个promise对象所代理的数据。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">"我是舒力气"</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(x);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'我的年龄是21'</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我的值是：'</span>, value)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 我的值是：我是舒力气</span></span><br></pre></td></tr></table></figure>
<p>以上例子中.finally()的onFinally中的返回值自动被忽略。所以p2的值是前一个promise对象所代理的值（p1的值）。</p>
<p>当然，也有例外的时候。如果.finally()的响应函数onFinally()中发生了异常，或者用户代码显式的返回了rejected promise。 那么就会替代了then链上之前的promise对象所代理的值了。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">"我是舒力气"</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(x);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'我在onFinally函数中显式的返回了rejected promise了'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p2.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我的值是：'</span>, reason)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 我的值是： 我在onFinally函数中显式的返回了rejected promise了</span></span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">舒小琦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shuliqi.github.io/2020/07/15/《JavaScript语言精髓与编程实战》读书笔记-Promised的核心机制/">https://shuliqi.github.io/2020/07/15/《JavaScript语言精髓与编程实战》读书笔记-Promised的核心机制/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shuliqi.github.io">舒小琦的Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/"><i class="fa fa-chevron-left">  </i><span>手把手封装axios取消重复请求</span></a></div><div class="next-post pull-right"><a href="/shuliqi.github.io/2020/06/22/文本超出显示省略号的一个完美的方案/"><span>文本超出显示省略号的一个完美的方案</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 舒小琦</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/shuliqi.github.io/js/utils.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/fancybox.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/sidebar.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/copy.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/fireworks.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/transition.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/scroll.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/head.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>