<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="手把手封装axios取消重复请求"><meta name="keywords" content="JavaScript"><meta name="author" content="舒小琦"><meta name="copyright" content="舒小琦"><title>手把手封装axios取消重复请求 | 舒小琦的Blog</title><link rel="shortcut icon" href="/shuliqi.github.io/melody-favicon.ico"><link rel="stylesheet" href="/shuliqi.github.io/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/shuliqi.github.io/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#提出问题"><span class="toc-number">1.</span> <span class="toc-text">提出问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解决思路"><span class="toc-number">2.</span> <span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#axios-如何取消请求"><span class="toc-number">3.</span> <span class="toc-text">axios 如何取消请求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#封装axios"><span class="toc-number">4.</span> <span class="toc-text">封装axios</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-number">4.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开始封装"><span class="toc-number">4.2.</span> <span class="toc-text">开始封装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/shuliqi.github.io/img/avatar.png"></div><div class="author-info__name text-center">舒小琦</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/shuliqi.github.io/archives"><span class="pull-left">文章</span><span class="pull-right">33</span></a><a class="author-info-articles__tags article-meta" href="/shuliqi.github.io/tags"><span class="pull-left">标签</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/shuliqi.github.io/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/shuliqi.github.io/">舒小琦的Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span></div><div id="post-info"><div id="post-title">手把手封装axios取消重复请求</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-31</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>在我们web开发过程中，很多地方需要我们取消重复的请求。但是哪种场合需要我们取消呢？ 我们如何取消呢？带着这些问题我们阅读本文。</p>
<p>阅读完本文，你将了解以下内容：</p>
 <a id="more"></a>
<ul>
<li>需要取消重复请求的场景</li>
<li>我们如何取消重复请求</li>
<li>axios如何取消重复的请求</li>
<li>封装axios</li>
<li>如何给开源的项目提供源码</li>
<li>如何在本地调试npm包</li>
</ul>
<h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><p>最近做的项目中，用的用户经常遇到这样的问题：</p>
<ul>
<li>用户频繁切换筛选条件去请求数据，初次的筛选条件数据量大。用的时间比较多。 后面的筛选条件的数据量小。导致后面请求的数据先返回。内容先显示在页面上。但是等一段时间，初次(或者前面)的请求数据返回了， 会覆盖后面的请求的数据。这就导致了筛选条件和内容不一致的情况。</li>
<li>用户点击了一次提交按钮，接口没有很快响应，导致页面没办法做逻辑语句判断的提示。用户觉得可能没提交上，便会快速又点了按钮几次。如果后端没有去重的判断，就会导致数据中有很多条重复的数据。</li>
</ul>
<p>这些问题给用户的体验是很不友好的。那么取消无用的请求是很有必要的。</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>我们用的请求库是axios。那么我们可以在请求的时候拦截请求判断当前的请求是否重复，如果重复我们就取消当前的请求。大致的实现过程如下：</p>
<p><strong>我们把目前处于pending的请求存储（假如我们放在一个数组）起来。每个请求发送之前我们都要判断当前这个请求是否已经存在于这个数组。如果存在，说明请求重复了，我们就在数组中找到重复的请求并且取消。如果不存在，说明这个请求不是重复的，正常发送并且把这个请求api添加在数据中，等请求结束之后删除数组中的这个api。</strong></p>
<p>我们这个解决思路有了，但是axios如何取消请求的呢？ 我们先来了解下</p>
<h1 id="axios-如何取消请求"><a href="#axios-如何取消请求" class="headerlink" title="axios 如何取消请求"></a>axios 如何取消请求</h1><p>查看axios文档发现axios <a href="http://www.axios-js.com/zh-cn/docs/#%E5%8F%96%E6%B6%88" target="_blank" rel="noopener">提供了两种取消请求的方法</a></p>
<ul>
<li><p>第一种方法</p>
<p>通过<code>axios.CancelToken.source</code>生成取消令牌<code>token</code>和取消方法<code>cancel</code></p>
<p>这是官方给的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  name: <span class="string">'new name'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel the request (the message parameter is optional)</span></span><br><span class="line">source.cancel(<span class="string">'Operation canceled by the user.'</span>);</span><br></pre></td></tr></table></figure>
<p>我们自己写个例子：<a href="http://jsfiddle.net/shuliqi/pfj6nsy9/354/" target="_blank" rel="noopener">axios取消请求第一种方法</a> </p>
<iframe width="100%" height="300" src="//jsfiddle.net/shuliqi/pfj6nsy9/356/embedded/js,result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>在这个例子中可以通过注释：<code>source.cancel(&#39;手动把请求被取消了&#39;);</code>这段代码来看看</p>
</li>
<li><p>第二种方式</p>
<p>通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建 cancel token;</p>
<p>官方的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// executor 函数接收一个 cancel 函数作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel the request</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure>
<p>我们自己来写一个例子看看 <a href="http://jsfiddle.net/shuliqi/ucy6vde1/7/" target="_blank" rel="noopener">axios取消请求第二种方法]</a></p>
<iframe width="100%" height="300" src="//jsfiddle.net/shuliqi/ucy6vde1/7/embedded/js,result/dark/?bodyColor=1c2128" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

</li>
</ul>
<h1 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h1><p>解决取消请求的思路有了，取消请求的办法也有了，那么剩下的就是封装了</p>
<p>由于同事之前已经封装了axios <a href="https://github.com/verymuch/very-axios" target="_blank" rel="noopener">very-axios</a>（基于 axios 进行二次封装，更简单、更统一地使用 axios。）。那么我们就这个基础上提一个pr吧。那么从现在开始我们就一步一步的来实现，这个过程包含了【如何给开源的项目贡献代码】【如何在本地调试npm】如果已经料机的同学可以直接略过。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>由于同事已经封装了axios并且已经开源了。那么我贡献代码的方式主要有两种：</p>
<ul>
<li>代码仓库的管理者给我们添加这个仓库的写入权限，如果这样，我们就可以直接提push。</li>
<li>如果我们没有权限(大多数情况)。我们使用经典的fork &amp; pull request 的方式来提交代码。</li>
</ul>
<p>我们采用的第二种方式。 我们去 <a href="https://github.com/verymuch/very-axios" target="_blank" rel="noopener">very-axios</a>把代码fork到自己的仓库(如果你还没有自己的github,需要自己注册下哦)。</p>
<img src="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/1.png">
<p>那么你回到自己的github仓库下面就会看有一个一摸一样的项目</p>
<img src="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/2.png">
<p>那么我们现在就可以<code>git clone</code>这个仓库的代码到本地，新建branch进行开发,就比如我新建了一个这样的branch：</p>
<img src="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/3.png">
<p>现在已经有本地的代码了，但是我们调试呢？如何确保我们改的是对的呢？那么就需要我们本地调试本地的npm包了。 那就需要<code>npm link</code> 了 </p>
<p>首先在我们要修改的npm 包中<code>npm link</code>,,如：</p>
<img src="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/4.png">
<p>之后我们会得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/shuliqi/.nvm/versions/node/v12.17.0/lib/node_modules/very-axios -&gt; /Users/shuliqi/study/axios/very-axios</span><br></pre></td></tr></table></figure>
<p>这意思就是我们把<code>very-axios</code>链接到全局的<code>node_modules</code></p>
<p> 然后我们进入我们my-project-of-axios 目录下面执行<code>npm link very-axios</code> 如图：</p>
<img src="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/5.png">
<p>这意思就是<code>very-axios</code>被安装在<code>my-project-of-axios</code> 下面了。<code>very-axios</code>的修改都会同步到<code>my-project-of-axios</code>。就实现本地测试了。</p>
<p>我们在<code>my-project-of-axios</code>中的<code>HelloWorld.vue</code>文件中做列子。</p>
<p>如果这里看的不是很懂的同学可以 看看这两篇文章 <a href="https://github.com/allenGKC/Blog/issues/13" target="_blank" rel="noopener">如何在本地调试npm包</a>  <a href="https://juejin.im/post/6844903636863041550" target="_blank" rel="noopener">如何使用 GitHub Flow 给开源项目贡献代码</a></p>
<h2 id="开始封装"><a href="#开始封装" class="headerlink" title="开始封装"></a>开始封装</h2><p>准备工作完成了, 那我们开始封装的事情。根据我们之前的思路。我们采用axios 如何取消请求的第一种方式。</p>
<p>声明一个Map。用来存储每个请求的 标识 和 取消的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stores the identity and cancellation function for each request</span></span><br><span class="line"><span class="keyword">this</span>.pendingAjax = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure>
<p>自定一个字段来让用户自己决定是否需要取消重复的请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// whether to cancel a duplicated request</span></span><br><span class="line">cancelDuplicated = <span class="literal">false</span>,</span><br></pre></td></tr></table></figure>
<p>自定一个字段来让用户是否有全局的统一的设置重复标识的函数。如果没有设置全局的统一的函数，则默认是请求的<code>method</code> 和<code>url</code>作为重复的标识</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// how to generate the duplicated key</span></span><br><span class="line">duplicatedKeyFn,</span><br><span class="line"><span class="keyword">this</span>.duplicatedKeyFn = isFunction(duplicatedKeyFn) ? duplicatedKeyFn : <span class="function">(<span class="params">config</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;config.method&#125;</span><span class="subst">$&#123;config.url&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>添加请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add request to pendingAjax</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; config</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addPendingAjax(config) &#123;</span><br><span class="line">  <span class="comment">// if need cancel duplicated request</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.cancelDuplicated) <span class="keyword">return</span> </span><br><span class="line">  <span class="keyword">const</span> veryConfig = config.veryConfig || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> duplicatedKey = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    duplicatedKey:  veryConfig.duplicatedKey || <span class="keyword">this</span>.duplicatedKeyFn(config), </span><br><span class="line">    type: REQUEST_TYPE.DUPLICATED_REQUEST,</span><br><span class="line">  &#125;);</span><br><span class="line">  config.cancelToken = config.cancelToken || <span class="keyword">new</span> axios.CancelToken(<span class="function">(<span class="params">cancel</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// if the current request does not exist in pendingAjax, add it</span></span><br><span class="line">    <span class="keyword">if</span> (duplicatedKey &amp;&amp; !<span class="keyword">this</span>.pendingAjax.has(duplicatedKey)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.pendingAjax.set(duplicatedKey, cancel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面我们可以使用<code>duplicatedKey</code>字段来让用户对单一请求自定义重复的标识。或者可以使用一个函数<code>duplicatedKeyFn</code>统一的让用户自定义重复的标识</p>
<p>删除请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * remove the request in pendingAjax</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; config</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">removePendingAjax(config) &#123;</span><br><span class="line">  <span class="comment">// if need cancel duplicated request</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.cancelDuplicated) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> veryConfig = config.veryConfig || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> duplicatedKey = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    duplicatedKey:  veryConfig.duplicatedKey || <span class="keyword">this</span>.duplicatedKeyFn(config), </span><br><span class="line">    type: REQUEST_TYPE.DUPLICATED_REQUEST,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// if the current request exists in pendingAjax, cancel the current request and remove it</span></span><br><span class="line">  <span class="keyword">if</span> (duplicatedKey &amp;&amp; <span class="keyword">this</span>.pendingAjax.has(duplicatedKey)) &#123;</span><br><span class="line">    <span class="keyword">const</span> cancel = <span class="keyword">this</span>.pendingAjax.get(duplicatedKey);</span><br><span class="line">    cancel(duplicatedKey);</span><br><span class="line">    <span class="keyword">this</span>.pendingAjax.delete(duplicatedKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装好了， 我们在在哪里使用呢？肯定是在请求开始之前和请求完成之后使用。</p>
<p>在请求之前</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intercept response</span></span><br><span class="line"><span class="keyword">this</span>.axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// check the previous request for cancellation before the request starts</span></span><br><span class="line">  <span class="keyword">this</span>.removePendingAjax(config);</span><br><span class="line">  <span class="comment">// add the current request to pendingAjax</span></span><br><span class="line">  <span class="keyword">this</span>.addPendingAjax(config);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在请求完成之后去掉该请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intercept response</span></span><br><span class="line"><span class="keyword">this</span>.axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  removePending(response) </span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>到现在已经完成了该有的功能， 但是取消请求的错误我们不该返回给用户。所以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(err) =&gt; &#123;</span><br><span class="line"><span class="comment">// whether is the type of duplicated request</span></span><br><span class="line"><span class="keyword">let</span> isDuplicatedType;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> errorType = (<span class="built_in">JSON</span>.parse(error.message) || &#123;&#125;).type</span><br><span class="line">  isDuplicatedType = errorType === REQUEST_TYPE.DUPLICATED_REQUEST;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  isDuplicatedType = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isDuplicatedType) <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在请求完成之后的err里面做一个判断，判断如果当前请求是取消的类型，我们就不返回给用户错误的提示信息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此 完成了我们的封装。<a href="https://github.com/verymuch/very-axios/pull/1" target="_blank" rel="noopener">完成的pr可以点击这里查看</a>   <a href="https://github.com/shuliqi/my-project-of-axios" target="_blank" rel="noopener">本文测试npm包的项目</a></p>
<p>有任何问题可以联系我联系，联系方式：<a href="mailto:shuliqi@outlook.com" target="_blank" rel="noopener">shuliqi@outlook.com</a>  ，<a href="mailto:shuliqi@360.cn" target="_blank" rel="noopener">shuliqi@360.cn</a> </p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">舒小琦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shuliqi.github.io/2020/08/31/封装axios取消重复请求/">https://shuliqi.github.io/2020/08/31/封装axios取消重复请求/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shuliqi.github.io">舒小琦的Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/shuliqi.github.io/tags/JavaScript/">JavaScript</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/shuliqi.github.io/2020/09/30/Docker的必要性及基础使用/"><i class="fa fa-chevron-left">  </i><span>Docker的必要性及基础使用</span></a></div><div class="next-post pull-right"><a href="/shuliqi.github.io/2020/07/15/《JavaScript语言精髓与编程实战》读书笔记-Promised的核心机制/"><span>《JavaScript语言精髓与编程实战》读书笔记-Promised的核心机制</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 舒小琦</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/shuliqi.github.io/js/utils.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/fancybox.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/sidebar.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/copy.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/fireworks.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/transition.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/scroll.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/head.js?version=1.6.1"></script><script src="/shuliqi.github.io/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>