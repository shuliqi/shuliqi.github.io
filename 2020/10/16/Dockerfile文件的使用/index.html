<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Dockerfile文件的使用"><meta name="keywords" content><meta name="author" content="舒小琦"><meta name="copyright" content="舒小琦"><title>Dockerfile文件的使用 | 舒小琦的Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockerfile文件格式"><span class="toc-number">1.</span> <span class="toc-text">Dockerfile文件格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockerfile-的组成部分"><span class="toc-number">2.</span> <span class="toc-text">Dockerfile 的组成部分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockerfile中的指令"><span class="toc-number">3.</span> <span class="toc-text">Dockerfile中的指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FROM"><span class="toc-number">3.1.</span> <span class="toc-text">FROM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RUN"><span class="toc-number">3.2.</span> <span class="toc-text">RUN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shell-执行"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">shell 执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec执行"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">exec执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMD"><span class="toc-number">3.3.</span> <span class="toc-text">CMD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ENTRYPOINT"><span class="toc-number">3.4.</span> <span class="toc-text">ENTRYPOINT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LABEL"><span class="toc-number">3.5.</span> <span class="toc-text">LABEL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXPOSE"><span class="toc-number">3.6.</span> <span class="toc-text">EXPOSE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ENV"><span class="toc-number">3.7.</span> <span class="toc-text">ENV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADD"><span class="toc-number">3.8.</span> <span class="toc-text">ADD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#COPY"><span class="toc-number">3.9.</span> <span class="toc-text">COPY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VOLUME"><span class="toc-number">3.10.</span> <span class="toc-text">VOLUME</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USER"><span class="toc-number">3.11.</span> <span class="toc-text">USER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WORKDIR"><span class="toc-number">3.12.</span> <span class="toc-text">WORKDIR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARG"><span class="toc-number">3.13.</span> <span class="toc-text">ARG</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ONBUILD"><span class="toc-number">3.14.</span> <span class="toc-text">ONBUILD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STOPSIGNAL"><span class="toc-number">3.15.</span> <span class="toc-text">STOPSIGNAL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SHELL"><span class="toc-number">3.16.</span> <span class="toc-text">SHELL</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">舒小琦</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">30</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">舒小琦的Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">Dockerfile文件的使用</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/学习笔记/">学习笔记</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>在上一篇文章 <a href="https://shuliqi.github.io/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/">Docker的必要性及基础使用</a>，我们知道 Dockerfile 是一个文本文件。这个文件里面包含了一系列的指令，每一条指令构建一层，每一条指令的内容及就是描述该层是如何构建的。</p>
 <a id="more"></a>
<p>我们可以上篇文章 <a href="https://shuliqi.github.io/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/">Docker的必要性及基础使用</a>的 <a href="https://github.com/shuliqi/express-for-docker" target="_blank" rel="noopener">Demo</a> 的Dockerfile文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12.17</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">COPY</span> . /shuliqi</span><br><span class="line"><span class="keyword">WORKDIR</span> /shuliqi</span><br><span class="line"><span class="keyword">RUN</span> ["npm", "install"]</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span>/tcp</span><br><span class="line"><span class="keyword">CMD</span> node app.js</span><br></pre></td></tr></table></figure>
<h1 id="Dockerfile文件格式"><a href="#Dockerfile文件格式" class="headerlink" title="Dockerfile文件格式"></a>Dockerfile文件格式</h1><p><code>Dockerfile</code> 文件的格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># comment</span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注释</span><br><span class="line">指令 参数</span><br></pre></td></tr></table></figure>
<p><code>Dockerfile</code>文件中的指令是不区分大小写的，但是为了更容易区分，约定使用 大写形式</p>
<p>Docker会依次执行<code>Dockerfile</code>文件中的指令，文件中第一条指令必须是<code>FROM</code>。</p>
<p>以 <code>#</code>开头的行，Docke会认为是注释，但是 <code>#</code>出现在指令参数中，则不是注释。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Comment</span><br><span class="line">RUN echo &apos;how old are you # my name is shuliqi&apos;</span><br></pre></td></tr></table></figure>
<h1 id="Dockerfile-的组成部分"><a href="#Dockerfile-的组成部分" class="headerlink" title="Dockerfile 的组成部分"></a>Dockerfile 的组成部分</h1><p>Dockerfile 文件主要由 四部分组成，分别是：</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础镜像信息</td>
<td>FROM</td>
</tr>
<tr>
<td>维护者信息</td>
<td>MAINTAINER</td>
</tr>
<tr>
<td>镜像操作指令</td>
<td>RUN，COPY，ADD，EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等</td>
</tr>
<tr>
<td>容器启动时执行指令</td>
<td>CMD、ENTRYPOINT</td>
</tr>
</tbody>
</table>
<h1 id="Dockerfile中的指令"><a href="#Dockerfile中的指令" class="headerlink" title="Dockerfile中的指令"></a>Dockerfile中的指令</h1><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p><code>FROM</code>指令为后面的指令提供镜像基础。<code>FROM</code>指令必须是<code>Dockerfile文件的</code>首条命令，启动构建流程后，<code>Docker</code>将会基于该镜像构建新镜像，<code>FROM</code>后的命令也是基于这个基础镜像。</p>
<p><code>FROM</code>的语法格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;diaest&gt;</span><br></pre></td></tr></table></figure>
<p>通过 <code>FROM</code>指定的镜像，可以是任何有效的基础镜像，<code>FROM</code>有以下的限制：</p>
<ul>
<li><code>FROM</code>必须是 <code>Dockerfile</code>文件的第一条非注释命令</li>
<li>在一个 <code>Dockerfile</code>文件中创建多个镜像时，<code>FROM</code>是可以多次出现。只需要在每个新命令<code>FROM</code>之前，记录提交上次的镜像ID</li>
<li><code>tag</code> 和 <code>digest</code>是可选的，如果不使用这两个值的时候，会使用<code>latest</code>版本的基础镜像</li>
</ul>
<h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p><code>RUN</code>用于在镜像容器中执行命令，有两种命令执行方式：</p>
<h4 id="shell-执行"><a href="#shell-执行" class="headerlink" title="shell 执行"></a><code>shell</code> 执行</h4><p>这种方式会在<code>shell</code>中执行命令，Linux下默认使用<code>/bin/sh -c</code>，Windows下使用<code>cmd /S /C</code>。</p>
<p><code>shell</code>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run &lt;命令行命令&gt;</span><br><span class="line"># &lt;命令行命令&gt; 等同于在终端操作的 shell 的命令</span><br></pre></td></tr></table></figure>
<h4 id="exec执行"><a href="#exec执行" class="headerlink" title="exec执行"></a><code>exec</code>执行</h4><p><code>exec</code>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;可执行的额文件&quot;,“参数1”, &quot;参数2&quot;]</span><br><span class="line">## 例如：</span><br><span class="line"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></pre></td></tr></table></figure>
<p><code>RUN</code>可以执行任何命令，然后再当前镜像上创建一个新层并且提交，提交后的结果镜像将会在 <code>Dockerfile</code>文件的下一步。</p>
<p>通过<code>RUN</code>执行多条命令时，可以通过<code>\</code>换行执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN /bin/bash -c &apos;source $HOME/.bashrc; \</span><br><span class="line">echo $HOME&apos;</span><br></pre></td></tr></table></figure>
<p>也可以在同一行通过分好分隔命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN /bin/bash -c &apos;source $HOME/.bashrc; echo $HOME&apos;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong><code>RUN</code>指令创建的中间镜像会被缓存，并且在下次构建中使用。如果不想使用这些缓存镜像，可以在创建时指定<code>--no-cache</code>参数，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ocker build --no-cache .</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<img src="/2020/10/16/Dockerfile文件的使用/1.png">
<p>这样构建镜像的步骤就没有使用缓存，使得每一层的镜像ID都与之前的不同。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p> <code>CMD</code>用于在指定容器启动时所有执行的命令。<code>CMD</code>有以下三种格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;commond&gt; // shell 格式</span><br><span class="line">CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] // exec格式，推荐格式</span><br><span class="line">CMD [&quot;param1&quot;, &quot;param2&quot;] // 为ENTRYPOINT指令提供参数</span><br></pre></td></tr></table></figure>
<p>与<code>RUM</code>命令不同的是：</p>
<p><code>RUM</code>指令在构建镜像时要执行命令。<code>CMD</code>则是用于在指定的容器启动时所要执行的命令。</p>
<p><code>CMD</code>在 Dockerfile文件中仅可指定一次，指定多次时，会覆盖前面的指令。</p>
<p><strong>需要注意：</strong>docker  run 命令会覆盖<code>CMD</code>命令。 如果 <code>docker run</code>运行容器时，使用了 <code>Dockerfile</code>中的 <code>CMD</code>命令相同的命令。就会覆盖 <code>Dockerfile</code>的<code>CMD</code>命令。</p>
<p>我们来看一个例子：</p>
<p>我们在 <code>Dockfile</code>文件中使用如下的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>
<p>我们构建一个新的镜像，镜像的名字叫：test，构建完成之后， 我们使用这个镜像运行一个容器，运行效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t test:0.0.1</span><br></pre></td></tr></table></figure>
<p>执行完命令之后，将会：</p>
<img src="/2020/10/16/Dockerfile文件的使用/2.png">
<p>我们看到使用了 shell 。说明  <code>Dockfile</code>文件中的<code>CMD</code>起作用了。</p>
<p>但是我们不想使用 <code>Dockfile</code>文件中的<code>CMD</code>指定的命令。我们可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t test:0.0.1 /bin/ps</span><br></pre></td></tr></table></figure>
<p>就会看到：</p>
<img src="/2020/10/16/Dockerfile文件的使用/3.png">
<p>这时，<code>docker run</code>结尾指定的<code>/bin/ps</code>命令覆盖了<code>Dockerfile</code>的<code>CMD</code>中指定的命令。</p>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p><code>ENTRYPOINT</code>与 <code>CMD</code>类似。</p>
<p><code>ENTRYPOINT</code>有两种模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT &lt;command&gt; (shell模式)</span><br><span class="line">ENTRYPOINT [ &quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ] (exec模式)</span><br></pre></td></tr></table></figure>
<p>但是<code>ENTRYPOINT</code>不会被 <code>docker run</code>中执行的命令覆盖，并且<code>docker run</code>命令中指定的任何参数都会被当成参数再次传递给 ENTRYPOINT<code>。如果想要覆盖</code>ENTRYPOINT<code>，则需要在</code>docker run<code>中指定</code>–entrypoint<code>选项。</code>Dockerfile<code>中只允许有一个</code>ENTRYPOINT<code>，多指定时会覆盖前端的设置的</code>ENTRYPOINT`指令。 而只执行最后的 ENTRYPOINT指令。</p>
<p>举个例子：</p>
<p>我们重写我们的<code>Dockerfile</code>文件。添加 <code>ENTRYPOINT</code>指令：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version: 0.0.3</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> 何民三 <span class="string">"cn.liuht@gmail.com"</span></span><br><span class="line"><span class="keyword">RUN</span> apt-get update</span><br><span class="line"><span class="keyword">RUN</span> apt-get install -y nginx</span><br><span class="line"><span class="keyword">RUN</span> echo 'Hello World, 我是个容器' \ </span><br><span class="line">   &gt; /var/www/html/index.html</span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["/usr/sbin/nginx"]</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>docker image build -t test2:0.0.1 .</code>构建我们的镜像、</p>
<p>构建完成之后， 启动一个容器：docker run -i -t  test2:0.0.1 -g “daemon off;”  <code></code></p>
<p>在运行容器时，我们使用了<code>-g &quot;daemon off;&quot;</code>. 这个参数会传递给 <code>ENTRYPOINT</code>。最终在容器中执行的命令为<code>/usr/sbin/nginx -g &quot;daemon off;&quot;</code></p>
<h2 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h2><p><code>LABEL</code>用于为镜像添加元数据，元数据以键值对的形式指定：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>LABEL</code>指定元数据时，一条<code>LABEL</code>指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条<code>LABEL</code>指令指定，以免生成过多的中间镜像。</p>
<p>如，通过<code>LABEL</code>指定一些元数据：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span> name="shuliqi" age="23"</span><br></pre></td></tr></table></figure>
<p>构建容器完后才能之后， 可以使用<code>docker inspect</code>查看</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect test3:<span class="number">0.0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<img src="/2020/10/16/Dockerfile文件的使用/4.png">
<p><strong>注意：</strong><code>Dockerfile</code>中还有个 <code>MAINTAINER</code>用来指定镜像的作者。但是<code></code>MAINTAINER<code>并不推荐使用，更推荐使用</code>LATER`来指定镜像作者。如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span> maintainer="itbilu.com"</span><br></pre></td></tr></table></figure>
<h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p><code>EXPOSE</code>用来指定容器在运行的时监听的端口。</p>
<p>格式如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt; ...]</span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span>/tcp</span><br></pre></td></tr></table></figure>
<p>注意：<code>EXPOSE</code>并不会让容器的端口访问到主机。要使其可以访问， 需要在<code>docker run</code>运行容器时通过 <code>-p</code>来发布这些端口。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -p:8000:3000 express-for-docker:0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p><code>ENV</code>用于设置环境变量，有以下两种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV SHULIQI_PATH=/home/shuliqi/</span><br></pre></td></tr></table></figure>
<p>设置完， 这个环境变量在 <code>ENV</code>命令之后都可以使用。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV SHULIQI_PATH=/home/shuliqi/</span><br><span class="line">WORKDIR $SHULIQI_PATH</span><br></pre></td></tr></table></figure>
<p>这个环境变量不仅可以在构建镜像中使用，使用该镜像创建的容器也可以使用。</p>
<h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p><code>ADD</code>指令用于复制构建环境中的文件/目录到镜像中。</p>
<p>有两种使用格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p>通过<code>ADD</code>复制文件时，需要通过<src>指定源文件位置，并通过<code>&lt;dest&gt;</code>来指定目标位置。<src>可以是一个构建上下文中的文件或目录，也可以是一个<code>URL</code>，但不能访问构建上下文之外的文件或目录。</src></src></p>
<p>如，通过<code>ADD</code>复制一个网络文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD http://wordpress.org/latest.zip $ITBILU_PATH</span><br></pre></td></tr></table></figure>
<p>在上例中，<code>$ITBILU_PATH</code>是我们使用<code>ENV</code>指定的一个环境变量。</p>
<p>另外，如果使用的是本地归档文件（<code>gzip</code>、<code>bzip2</code>、<code>xz</code>）时，Docker会自动进行解包操作，类似使用<code>tar -x</code>。</p>
<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p><code>COPY</code>同样用于复制构建环境中的文件或目录到镜像中。其有以下两种使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p><code>COPY</code>指令非常类似于<code>ADD</code>，不同点在于<code>COPY</code>只会复制构建目录下的文件，不能使用<code>URL</code>也不会进行解压操作。</p>
<h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p><code>VOLUME</code>用于创建挂载点，即向所构建镜像创使的容器添加卷</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure>
<p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p>
<ul>
<li>卷可以容器间共享和重用</li>
<li>容器并不一定要和其它容器共享卷</li>
<li>修改卷后会立即生效</li>
<li>对卷的修改不会对镜像产生影响</li>
<li>卷会一直存在，直到没有任何容器在使用它</li>
</ul>
<p><code>VOLUME</code>让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</p>
<p>如，通过<code>VOLUME</code>创建一个挂载点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM node:12.17.0</span><br><span class="line">COPY . /shuliqi</span><br><span class="line">WORKDIR /shuliqi</span><br><span class="line">RUN [&quot;npm&quot;, &quot;install&quot;]</span><br><span class="line">EXPOSE 3000/tcp</span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br><span class="line"># `VOLUME`创建一个挂载点</span><br><span class="line">ENV SHULIQI_PATH /myblog/</span><br><span class="line">VOLUME [$SHULIQI_PATH]</span><br></pre></td></tr></table></figure>
<p>构建的镜像，并指定镜像名为<code>express-for-docker</code>。构建镜像后，使用新构建的运行一个容器。运行容器时，需<code>-v</code>参将能本地目录绑定到容器的卷（挂载点）上，以使容器可以访问宿主机的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t -v ~/myblog:/myblog/  express-for-docker:0.0.1</span><br><span class="line">root@31b0fac536c4:/# cd /myblog/</span><br><span class="line">root@31b0fac536c4:/myblog# ls</span><br><span class="line">blog</span><br></pre></td></tr></table></figure>
<img src="/2020/10/16/Dockerfile文件的使用/5.png">
<p>如上所示，我们已经可以容器的<code>/home/myblog/</code>目录下访问到宿主机`~/myblog目录下的数据了。</p>
<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p><code>USER</code>用于指定运行镜像所使用的用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure>
<p>使用<code>USER</code>指定用户时，可以使用用户名、<code>UID</code>或<code>GID</code>，或是两者的组合。以下都是合法的指定试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure>
<p>使用<code>USER</code>指定用户后，<code>Dockerfile</code>中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>都将使用该用户。镜像构建完成后，通过<code>docker run</code>运行容器时，可以通过<code>-u</code>参数来覆盖所指定的用户。</p>
<h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p><code>WORKDIR</code>用于在容器内设置一个工作目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure>
<p>通过<code>WORKDIR</code>设置工作目录后，<code>Dockerfile</code>中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>ADD</code>、<code>COPY</code>等命令都会在该目录下执行。</p>
<p>如，使用<code>WORKDIR</code>设置工作目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>pwd</code>最终将会在<code>/a/b/c</code>目录中执行。</p>
<p>在使用<code>docker run</code>运行容器时，可以通过<code>-w</code>参数覆盖构建时所设置的工作目录。</p>
<h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p><code>ARG</code>用于指定传递给构建运行时的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>
<p>如，通过<code>ARG</code>指定两个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG site</span><br><span class="line">ARG build_user=舒丽琦</span><br></pre></td></tr></table></figure>
<p>以上我们指定了<code>site</code>和<code>build_user</code>两个变量，其中<code>build_user</code>指定了默认值。在使用<code>docker build</code>构建镜像时，可以通过<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>参数来指定或重设置这些变量的值。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --build-<span class="keyword">arg</span> site=shuliqi.github.io -t express-for-docker .</span><br></pre></td></tr></table></figure>
<p>这样我们构建了 express-for-docker 镜像，其中<code>site</code>会被设置为 shuliqi.github.io，由于没有指定<code>build_user</code>，其值将是默认值<code>舒丽琦</code>。</p>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><p><code>ONBUILD</code>用于设置镜像触发器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure>
<p>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。</p>
<p>如，当镜像被使用时，可能需要做一些处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<h2 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h2><p><code>STOPSIGNAL</code>用于设置停止容器所要发送的系统调用信号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure>
<p>所使用的信号必须是内核系统调用表中的合法的值，如：<code>9</code>、<code>SIGKILL</code>。</p>
<h2 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h2><p><code>SHELL</code>用于设置执行命令（<code>shell</code>式）所使用的的默认<code>shell</code>类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br></pre></td></tr></table></figure>
<p><code>SHELL</code>在Windows环境下比较有用，Windows下通常会有<code>cmd</code>和<code>powershell</code>两种<code>shell</code>，可能还会有<code>sh</code>。这时就可以通过<code>SHELL</code>来指定所使用的<code>shell</code>类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;/S&quot;&quot;, &quot;/C&quot;]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">舒小琦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shuliqi.github.io/2020/10/16/Dockerfile文件的使用/">https://shuliqi.github.io/2020/10/16/Dockerfile文件的使用/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shuliqi.github.io">舒小琦的Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/09/30/Docker的必要性及基础使用/"><span>Docker的必要性及基础使用</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 舒小琦</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>