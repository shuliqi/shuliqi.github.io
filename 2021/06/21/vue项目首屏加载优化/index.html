<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="vue项目首屏加载优化"><meta name="keywords" content="Vue"><meta name="author" content="舒小琦"><meta name="copyright" content="舒小琦"><title>vue项目首屏加载优化 | 舒小琦的Blog</title><link rel="shortcut icon" href="http://p6.qhimg.com/t01f5a5270b7946b505.jpg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">存在的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.</span> <span class="toc-text">什么是首屏加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">2.1.</span> <span class="toc-text">首屏加载时间的计算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.</span> <span class="toc-text">加载慢的原因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">解决的办法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.1.</span> <span class="toc-text">路由懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">4.1.1.</span> <span class="toc-text">什么是路由懒加载？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%87%92%E5%8A%A0%E8%BD%BD%E5%91%A2%EF%BC%9F"><span class="toc-number">4.1.2.</span> <span class="toc-text">为什么需要懒加载呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.3.</span> <span class="toc-text">路由懒加载的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">4.1.4.</span> <span class="toc-text">如何实现路由懒加载？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87"><span class="toc-number">4.2.</span> <span class="toc-text">压缩图片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gzip-%E5%8E%8B%E7%BC%A9"><span class="toc-number">4.3.</span> <span class="toc-text">gzip 压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">4.3.1.</span> <span class="toc-text">服务器压缩文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF-webpack-%E6%89%93%E5%8C%85%E7%94%9F%E6%88%90-gz-%E6%96%87%E4%BB%B6"><span class="toc-number">4.3.2.</span> <span class="toc-text">前端 webpack 打包生成 gz 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.</span> <span class="toc-text">Webpack打包体积优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#splitChunks"><span class="toc-number">4.4.1.</span> <span class="toc-text">splitChunks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#splitChunks%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.2.</span> <span class="toc-text">splitChunks优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%BD%B4%E5%9B%9E%E6%94%BE"><span class="toc-number">5.</span> <span class="toc-text">时间轴回放</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://p6.qhimg.com/t01f5a5270b7946b505.jpg"></div><div class="author-info__name text-center">舒小琦</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/webp.webp)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">舒小琦的Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/shuliqi-design">UI组件</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">vue项目首屏加载优化</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Vue/">Vue</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>最近这几个月一直在开发一个使用 <code>vue-cli</code>搭建起来的项目。最近打包上线之后。发现首屏打开特别慢，在网络好的情况下大约需要4s 至 5 s。 在网络不好的情况下，还需要7s 8 s。加载的期间一直显示白屏，导致用户的体验非常不好。所以针对这个问题来做一些优化；期望的结果是首屏加载得快一点。白屏缩短。</p>
 <span id="more"></span>

<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>首先我们来看没有优化之前的耗时时间：</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/2.png" class="">

<p>在网络比较好的情况下， 耗时：6.86s。 平均是 7s 左右。</p>
<h1 id="什么是首屏加载"><a href="#什么是首屏加载" class="headerlink" title="什么是首屏加载"></a>什么是首屏加载</h1><p>首屏时间（First Contentfull Paint）: 指的是响应用户在浏览器上输入<code>URL</code>网址， 到首屏内容渲染完后才能的一个时间。此时整个网页不一定要渲染完成，但旭要展示当前视窗需要的内容。</p>
<h2 id="首屏加载时间的计算"><a href="#首屏加载时间的计算" class="headerlink" title="首屏加载时间的计算"></a>首屏加载时间的计算</h2><p>可以通过<code>DOMContentLoad</code> 或者是 <code>performance</code> 来计算首屏时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windown.addEventListner(<span class="string">&quot;DOMContentLoad&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//	....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">performance.getEntriesByName(<span class="string">&quot;first-contentfull-paint&quot;</span>)[<span class="number">0</span>].startTime;</span><br><span class="line"><span class="comment">// performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0]</span></span><br><span class="line"><span class="comment">// 会返回一个 PerformancePaintTiming的实例，结构如下：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;first-contentful-paint&quot;</span>,</span><br><span class="line">  <span class="attr">entryType</span>: <span class="string">&quot;paint&quot;</span>,</span><br><span class="line">  <span class="attr">startTime</span>: <span class="number">507.80000002123415</span>,</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="加载慢的原因"><a href="#加载慢的原因" class="headerlink" title="加载慢的原因"></a>加载慢的原因</h1><p>在页面渲染的过程，导致加载速度慢的因素可能如下：</p>
<ul>
<li><p>网络请求慢</p>
</li>
<li><p>资源体积过大</p>
</li>
<li><p>重复请求资源</p>
</li>
<li><p>加载脚本堵塞了渲染</p>
</li>
</ul>
<h1 id="解决的办法"><a href="#解决的办法" class="headerlink" title="解决的办法"></a>解决的办法</h1><p>我们知道 <code>vue</code>， <code>react</code> 等框架都是<code>js</code> 渲染的<code>html</code>。是典型的单页应用，首次加载耗时多，因此优化<code>Vue</code>项目首屏加载对于提升用户体验非常重要。所以必须要等到这个<code>js</code>文件加载完成后界面才会显示。</p>
<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">[Vue Router路由懒加载]</a></p>
<p><code>vue-router</code>实现路由懒加载的方法有哪些？首先我们先来看<code>vue-router</code>的一些官方解释</p>
<h3 id="什么是路由懒加载？"><a href="#什么是路由懒加载？" class="headerlink" title="什么是路由懒加载？"></a>什么是路由懒加载？</h3><blockquote>
<p>也叫延迟加载，即在需要的时候进行加载，随用随载。</p>
</blockquote>
<h3 id="为什么需要懒加载呢？"><a href="#为什么需要懒加载呢？" class="headerlink" title="为什么需要懒加载呢？"></a>为什么需要懒加载呢？</h3><ul>
<li>首先，我们知道路由中通常会定义很多不同的页面。</li>
<li>这个页面这项目build打包后，一般情况下，会放在一个单独的js文件中</li>
<li>但是，如果很多的页面都放在同一个js文件中，必然会造成这个页面非常大</li>
<li>如果我们一次性的从服务器中请求下来这个页面，可能会花费一定时间，用户体验不好</li>
</ul>
<p>在我们的vue 项目中：</p>
<ul>
<li><p>像vue这种单页面应用，如果没有应用懒加载，运用<code>webpack</code>打包后的文件将会异常的大。</p>
</li>
<li><p>造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了<code>loading</code>也是不利于用户体验。</p>
</li>
<li><p>而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时</p>
</li>
</ul>
<p>总的来说：进入页面不用也不需要一次性加载过多资源造成加载时间过程！</p>
<h3 id="路由懒加载的原理"><a href="#路由懒加载的原理" class="headerlink" title="路由懒加载的原理"></a>路由懒加载的原理</h3><ul>
<li><p>主要作用是将路由对应的组件打包成一个个的js代码块</p>
</li>
<li><p>只有在这个路由被访问到的时候，才加载对应的组件，否则不加载！</p>
</li>
</ul>
<p>总结的来说：只有在这个路由被访问到的时候，才加载对应的组件，否则不加载！</p>
<p>路由懒加载，在访问到当前页面才会加载相关的资源，异步方式分模块加载文件</p>
<h3 id="如何实现路由懒加载？"><a href="#如何实现路由懒加载？" class="headerlink" title="如何实现路由懒加载？"></a>如何实现路由懒加载？</h3><ul>
<li><code>Vue</code>异步组件</li>
<li><code>ES6</code>标准语法<code>import（）</code>———推荐使用</li>
<li><code>webpac</code>k的<code>require</code>，<code>ensure()</code></li>
</ul>
<p>我们使用<code>ES6</code>标准语法<code>import（）</code>来实现懒加载</p>
<p>没有用到路由加载懒加载之前是这么写的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> page404 <span class="keyword">from</span> <span class="string">&quot;@/views/error/page404.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/page404&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;page404&quot;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;404&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">      <span class="attr">slideMenu</span>: slideMenu,</span><br><span class="line">      <span class="attr">topBar</span>: topBar,</span><br><span class="line">      <span class="attr">content</span>: page404</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes;</span><br></pre></td></tr></table></figure>

<p>使用路由懒加载：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page404 = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/error/page404.vue&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h2><p>我们先看打包之后下面的img 的图片的大小：</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/7.png" class="">

<p>总的5.6M。 有点大</p>
<p>我们使用 <code>vue inspect &gt; output.js</code>导出<code> vue-cli</code> 做的的默认<code>webpoack</code>配置：</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/8.png" class="">

<p>发现对于图片， 只用到了 url-loader 。 相对一些比较大的图片。是可以进行压缩的。可以使用 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/image-webpack-loader">image-webpack-loader</a></p>
<p>我们在 <code>vue-config.js</code>配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chainWebpack = <span class="function"><span class="keyword">function</span> <span class="title">chainWebpacks</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config.module</span><br><span class="line">    .rule(<span class="string">&quot;images&quot;</span>)</span><br><span class="line">    .use(<span class="string">&quot;image-webpack-loader&quot;</span>)</span><br><span class="line">    .loader(<span class="string">&quot;image-webpack-loader&quot;</span>)</span><br><span class="line">    .options(&#123;</span><br><span class="line">      <span class="attr">bypassOnDebug</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .end();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后再进行<code>npm run build</code>打包在看看<code>img</code>:</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/9.png" class="">

<p>图片的大小从 5.8M 变到了 1.8M。 感觉效果还是明显的。</p>
<p>经过上面这两步优化，我们再看来首屏加载的时间：</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/18.png" class="">

<p>首页加载的数据的耗时明显减少了大概 1/2 时间， 棒棒哒</p>
<h2 id="gzip-压缩"><a href="#gzip-压缩" class="headerlink" title="gzip 压缩"></a>gzip 压缩</h2><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/11.png" class="">

<p>从上面我们可以看出:<code>vendor-chunks.js</code> 很大。当我们的项部署了之后， 我们的资源文件请求会保持原来的大小。如果文件过大，并且很多的情况下，会导致网络请求耗时。严重点可能会阻塞后面的进程。针对这样的情况， 我们有没有什么比较好的解决方法呢?  有的， 那就进行 <code>gzip</code>压缩。</p>
<p><code>gzip</code>压缩有两种方式：</p>
<ul>
<li>服务器压缩文件</li>
<li>前端 webpack 打包生成 gz 文件</li>
</ul>
<p>那我们先来看看这两种方式：</p>
<h3 id="服务器压缩文件"><a href="#服务器压缩文件" class="headerlink" title="服务器压缩文件"></a>服务器压缩文件</h3><p>这种方式是浏览器请求文件时，服务器对该文件进行压缩后传输给浏览器。前端不用做任何的配置，不需要 <code>webpack</code>生成 <code>.gz</code>文件。而是服务器自己处理。就拿 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Nginx">Nginx</a> 来举例，我么打开 nginx.conf 文件， 会有默认配置，默认的   <code>#gzip  on;</code>即不打开。</p>
<p><strong>nginx 文件结构</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...              <span class="comment"># 全局块</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;         <span class="comment"># events块</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">http</span>      <span class="comment"># http块</span></span><br><span class="line">&#123;</span><br><span class="line">    ...   <span class="comment"># http全局块</span></span><br><span class="line">    <span class="attribute">server</span>        <span class="comment"># server块</span></span><br><span class="line">    &#123; </span><br><span class="line">        ...       <span class="comment"># server全局块</span></span><br><span class="line">        <span class="attribute">location</span> [PATTERN]   <span class="comment"># location块</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span></span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     <span class="comment"># http全局块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 http 块这里开启 <code>gzip</code>和相关的配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">		 <span class="comment"># ... 已省略</span></span><br><span class="line">	   <span class="comment"># 开启gzip</span></span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置缓冲区大小</span></span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#压缩级别官网建议是6</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#压缩的类型</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ... 已省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方案的特点：使用<code>nginx</code>在线<code>gzip</code>，缺点就是耗性能，需要实时压缩，但是<code>vue</code>打包后的文件体积小。</p>
<h3 id="前端-webpack-打包生成-gz-文件"><a href="#前端-webpack-打包生成-gz-文件" class="headerlink" title="前端 webpack 打包生成 gz 文件"></a>前端 webpack 打包生成 gz 文件</h3><p>这次优化主要是采用这种方式。</p>
<p>这种方式是打包的时候通过 <code>webpack</code>配置生成对应的<code>.gz</code>文件，浏览器请求文件时，服务器返回相应的的文件的 <code>.gz </code>文件。</p>
<p>安装 <code>compression-webpack-plugin</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i compression-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>然后再<code>vue.config.js</code>中设置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> productionGzipExtensions = <span class="regexp">/\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i</span>;</span><br><span class="line"><span class="comment">// ... 已省略</span></span><br><span class="line">plugins: [</span><br><span class="line">     <span class="comment">// ... 已省略</span></span><br><span class="line">      <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">        <span class="attr">test</span>: productionGzipExtensions, <span class="comment">// 所有匹配此&#123;RegExp&#125;的资产都会被处理</span></span><br><span class="line">        <span class="attr">threshold</span>: <span class="number">512</span>, <span class="comment">// 只处理大于此大小的资产。以字节为单位</span></span><br><span class="line">        <span class="attr">minRatio</span>: <span class="number">0.8</span>, <span class="comment">// 只有压缩好这个比率的资产才能被处理</span></span><br><span class="line">        <span class="attr">deleteOriginalAssets</span>: <span class="literal">false</span> <span class="comment">// 是否删除未压缩的源文件，谨慎设置，如果希望提供非gzip的资源，可不设置或者设置为false（比如删除打包后的gz后还可以加载到原始资源文件）</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p> 启用gzip压缩打包之后，会变成下面这样，自动生成<code>gz</code>包。目前大部分主流浏览器客户端都是支持gzip的，就算小部分非主流浏览器不支持也不用担心，不支持gzip格式文件的会默认访问源文件的，所以不要配置清除源文件。所以这时候打包的总体积会变大， 是因为我们没有删除源文件。是为了防止有些浏览器不支持的时候能返回源文件。</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/10.png" class="">

<p>上面<code>test</code>匹配的压缩文件类型， 并没有对图片进行压缩，因为图片压缩并不能实际减少文件大小，反而会导致打包后生成很多同大小的gz文件，得不偿失。</p>
<p>这种方式是浏览器在请求资源时，服务器返回相应的 <code>.gz</code> 文件。 所以需要在服务器配置一个属性， 期望它能够正常返回我们需要的<code>.gz</code>文件</p>
<p><code>ginx</code>举例（<code>nginx.conf</code>文件）:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="comment"># ...已省略</span></span><br><span class="line">  <span class="comment"># 静态加载本地的gz文件。</span></span><br><span class="line">  <span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>gzip_static on</code>这个属性是静态加载本地的gz文件</p>
<p>我们先来看采用这种方法前的请求的<code>chunk-vendors.js</code>的大小：</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/11.png" class="">

<p>我们可以看到请求的这个文件大小有 5.4 MB。</p>
<p>我们采用<code>gzip</code>压缩之后，请求该文件的大小：</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/12.png" class="">

<p>可以看出来，请求文件的大小从 5.4MB 变成了 854KB。 而首页的加载时间较少的幅度不是很大， 但也是减少了。</p>
<p>nginx配置了静态gz加载后，浏览器也返回的是gz文件，这样就会请求小文件而不会导致请求卡线程，并且，因为保留了源文件，所以当我们删除gz后，浏览器会自动去请求原始文件，而不会导致界面出现任何问题</p>
<p> 静态加载gz文件主要是依托于下面的请求头：</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/13.png" class="">

<p>这种优化的主要特点：<code> webpack</code>打包，然后直接使用静态的<code>gz</code>，缺点就是打包后文件体积太大，但是不耗服务器性能。</p>
<h2 id="Webpack打包体积优化"><a href="#Webpack打包体积优化" class="headerlink" title="Webpack打包体积优化"></a>Webpack打包体积优化</h2><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/14.png" class="">

<p>从图上我们发现首屏加载过程中总公发起了149次请求。这显然是不友好的。那我们可以考虑考虑减少首屏加载的请求次数。</p>
<p>减少首屏加载请求次数可以从下面这个方面入手：</p>
<ul>
<li>使用<code>splitChunks</code>分离代码并实现相关模块共享，最终的目的就是减少请求资源的大小和请求次数</li>
</ul>
<h3 id="splitChunks"><a href="#splitChunks" class="headerlink" title="splitChunks"></a>splitChunks</h3><p>SplitChunks插件是什么呢，简单的来说就是Webpack中一个提取或分离代码的插件，主要作用是提取公共代码，防止代码被重复打包，拆分过大的js文件，合并零散的js文件。  在Webpack出现前，提取公共代码是人为去处理，而SplitChunks插件的作用就是通过配置让Webpack去帮你提取公共代码</p>
<p>用SplitChunks插件来控制Webpack打包生成的js文件的内容的精髓就在于，防止模块被重复打包，拆分过大的js文件，合并零散的js文件。 最终的目的就是减少请求资源的大小和请求次数</p>
<p>我们先来看<code>splitChunks</code>的一下字段说明吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="comment">// 表示选择哪些 chunks 进行分割，可选值有：async，initial和all, 默认：async</span></span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。</span></span><br><span class="line">      <span class="attr">minSize</span>: <span class="number">3000</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。</span></span><br><span class="line">      <span class="attr">minChunks</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 表示按需加载文件时，并行请求的最大数目。默认为5。</span></span><br><span class="line">      <span class="attr">maxAsyncRequests</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 表示加载入口文件时，并行请求的最大数目。默认为3。</span></span><br><span class="line">      <span class="attr">maxInitialRequests</span>: <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// // 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js</span></span><br><span class="line">      <span class="attr">automaticNameDelimiter</span>: <span class="string">&quot;~&quot;</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// // 设置chunk的文件名。默认为true。当为true时，splitChunks基于chunk和cacheGroups的key自动命名。</span></span><br><span class="line">      <span class="comment">// name: true,</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 缓存组： cacheGroups 的配置项跟 splitChunks是一样的， 但是它自己有几个自己的配置项</span></span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="attr">vender</span>: &#123;</span><br><span class="line">          <span class="comment">// 优先级：数字越大优先级越高，因为默认值为0，所以自定义的一般是负数形式</span></span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">          <span class="comment">// test:可以是一个函数也可以是一个正则，函数的返回值是：boolean RegExp string，通过返回值或者正则来进行匹配。</span></span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="comment">// type: &quot;json&quot;,</span></span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">           <span class="comment">// 这个的作用是当前的chunk如果包含了从main里面分离出来的模块，则重用这个模块，这样的问题是会影响chunk的名称。</span></span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="splitChunks优化"><a href="#splitChunks优化" class="headerlink" title="splitChunks优化"></a>splitChunks优化</h3><p>使用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a> 进行体积分析。该插件可生成依赖包形成可视化分析图谱，帮组开发者分析项目结构</p>
<p>安装：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>

<p>将插件添加到<code>webpack</code>中，因为使用的是vue-cli，所以应在<code>vue.config.js</code>中添加配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DEV = process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chainWebpack = <span class="function"><span class="keyword">function</span> <span class="title">chainWebpacks</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (DEV) &#123;</span><br><span class="line">    <span class="comment">// 开发环境使用</span></span><br><span class="line">    config.plugin(<span class="string">&quot;compressionPlugin&quot;</span>)</span><br><span class="line">      .use(<span class="keyword">new</span> BundleAnalyzerPlugin())</span><br><span class="line">      .end();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行<code>npm run build</code>生成分析页面</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/15.png" class="">

<p>从分析页面可以看出 <code>chunk-vendor</code>很大。因为这个<code>chunk</code>是项目所有的依赖库，从它是打包了<code>node_modules</code>可以看出，所以很影响性能。从图中发现<code>monaco-editor</code> 在线编辑器占了很大体积。 我们可以把它抽离出来。因为用的地方太多了， 导致很难做成按需加载了的了。</p>
<p>在<code>vue.config.js</code>配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">config.optimization.splitChunks(&#123;</span><br><span class="line">  <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">    <span class="attr">common</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;chunk-common&quot;</span>,</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">      <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">maxInitialRequests</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">minSize</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">priority</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">vendors</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;chunk-vendors&quot;</span>,</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">      chunks: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">      <span class="attr">priority</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">enforce</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 增加一个echarts cacheGroup</span></span><br><span class="line">    <span class="attr">echarts</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;chunk-echarts&quot;</span>,</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]echarts[\\/]/</span>,</span><br><span class="line">      priority: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">      <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">enforce</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 增加一个monacoEditor cacheGroup</span></span><br><span class="line">    <span class="attr">monacoEditor</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;chunk-monaco-editor&quot;</span>,</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]monaco-editor[\\/]/</span>,</span><br><span class="line">      chunks: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">      <span class="attr">priority</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">enforce</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们再来看下分析图：</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/16.png" class="">

<p>可以看出<code>monaco-editor</code>和<code>echarts</code>被单独打包了。</p>
<p>现在我们来看最终的结果：</p>
<img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/17.png" class="">

<p>请求次数从 149 减到了  115 次。可观的是首页加载耗时减到了 1.74s。 平均值大概 1.5 s。 表示还是可观的。</p>
<p>注意： <code>SplitChunks</code>插件对代码作更细致的拆分 需要注意的减少请求数必然使得单个文件体积变大,二者是矛盾的,最佳实践是取得一个中庸的值平衡优劣.</p>
<h1 id="时间轴回放"><a href="#时间轴回放" class="headerlink" title="时间轴回放"></a>时间轴回放</h1><table>
<thead>
<tr>
<th>优化方法</th>
<th>请求数量</th>
<th>耗时时间</th>
</tr>
</thead>
<tbody><tr>
<td>未做任何优化</td>
<td>149次</td>
<td>6.86s</td>
</tr>
<tr>
<td>路由懒加载+压缩图片</td>
<td>149次</td>
<td>4.26s</td>
</tr>
<tr>
<td>splitChunks分离代码</td>
<td>115次</td>
<td>1.74s</td>
</tr>
</tbody></table>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">舒小琦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shuliqi.github.io/2021/06/21/vue项目首屏加载优化/">https://shuliqi.github.io/2021/06/21/vue项目首屏加载优化/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shuliqi.github.io">舒小琦的Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/"><i class="fa fa-chevron-left">  </i><span>CSS 实现动画边框的奇思妙想</span></a></div><div class="next-post pull-right"><a href="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/"><span>Vue3.0新特性之Composition API</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/webp.webp)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 舒小琦</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>