<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《javascript设计模式》读书笔记三：函数</title>
    <url>/shuliqi.github.io/2019/06/15/%20%E3%80%8Ajavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="一-函数的特点"><a href="#一-函数的特点" class="headerlink" title="一. 函数的特点"></a>一. 函数的特点</h3><h4 id="函数是第一类对象"><a href="#函数是第一类对象" class="headerlink" title="函数是第一类对象"></a>函数是第一类对象</h4><p>函数就是对象，其表现是：</p>
<ul>
<li><p>函数可以在运行时动态创建，也可以在程序执行过程中创建</p>
</li>
<li><p>函数可以分配给变量，可以将它们的引用复制到其他变量，可以被扩展，此外，除了极少数特殊情况外，函数也可以被删除。</p>
 <a id="more"></a>
</li>
<li><p>可以作为参数传递给他们函数，并且还可以被其他函数返回。</p>
</li>
<li><p>函数可以有自己的属性和方法。</p>
</li>
</ul>
<h4 id="函数提供了作用域"><a href="#函数提供了作用域" class="headerlink" title="函数提供了作用域"></a>函数提供了作用域</h4><p>在JavaScript中没有花括号{}语法以定义局变量，也就是说， 块并不创建作用域。JavaScript仅存在函数作用域。在函数内以var关键词定义的任何变量都是局部变量。对于函数外是不可见的。</p>
<h3 id="二-函数声明和函数表达式"><a href="#二-函数声明和函数表达式" class="headerlink" title="二. 函数声明和函数表达式"></a>二. 函数声明和函数表达式</h3><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>命名函数表达式是函数表达式的一种特殊情况。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数声明与函数表示式的区别"><a href="#函数声明与函数表示式的区别" class="headerlink" title="函数声明与函数表示式的区别"></a>函数声明与函数表示式的区别</h4><ul>
<li><p>函数表达式中需要分号结尾，并且总应该用分号。函数声明不需要分号。</p>
</li>
<li><p>使用函数声明时，不仅仅函数定定义被提升，函数体也被提升了。使用函数表达式时， 只有函数定义提升，函数体不提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'global foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'global bar'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">host</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);  <span class="comment">// "function"</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar); 	<span class="comment">// "undefined"</span></span><br><span class="line">  foo(); <span class="comment">// local foo</span></span><br><span class="line">  bar(); <span class="comment">// bar is not a function</span></span><br><span class="line">  <span class="comment">// 函数声明，函数定义和函数体一起被提升到函数host顶部</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'local foo'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 函数表达式，只有函数定义被提升到函数host顶部</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'local bar'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="三-函数有关的有用的模式"><a href="#三-函数有关的有用的模式" class="headerlink" title="三. 函数有关的有用的模式"></a>三. 函数有关的有用的模式</h3><h4 id="API模式"><a href="#API模式" class="headerlink" title="API模式"></a>API模式</h4><ul>
<li><p>配置对象：有助于保持受到控制的函数的参数数量</p>
<p>如果函数的参数列表很长（超过3个），一个更好的办法是仅使用一个参数对象来替代所有的参数，然后实际的参数在这个对象里面配置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addPerson = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> &#123; age, name &#125; = config;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">	age: <span class="number">12</span>,</span><br><span class="line">	name: <span class="string">"shuliqi"</span>,</span><br><span class="line">&#125;</span><br><span class="line">addPerson(config)</span><br></pre></td></tr></table></figure>
<p>该方法的优点：</p>
<ul>
<li>不需要记住总众多的参数和参数的顺序。</li>
<li>可以安全的忽略可选参数。</li>
<li>更加易于阅读和维护。</li>
<li>更加易于添加参数和删除参数。</li>
</ul>
<p>配置对象的不足：</p>
<ul>
<li>需要记住参数名称</li>
<li>属性名称无法被压缩</li>
</ul>
</li>
</ul>
<h4 id="初始化模式"><a href="#初始化模式" class="headerlink" title="初始化模式"></a>初始化模式</h4><ul>
<li><p>即时函数：是一种支持在定义函数后立即执行该函数的语法</p>
<p><strong>语法：</strong></p>
<ul>
<li>可以使用函数表达式定义一个函数（函数声明则无法达到这个效果）</li>
<li>在末尾添加一组括号，这将导致该函数立即执行</li>
<li>将整个函数包装在括号中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'111'</span>)</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p><strong>好处：</strong>可以包装需要想要执行的任务，且不会在后台留下任何全局变量，定义的所有变量将会是用于自身调用函数的局部变量，并且不会担心全局空间呗临时的变量所污染。</p>
</li>
<li><p>即时对象初始化：跟即时函数类似，可以保护全局作用域不收污染。</p>
<p>这种模式使用带有init()方法的对象。该方法在创建对象之后将会立即执行。init()函数需要负责所有的初始化任务。</p>
<p><strong>语法：</strong></p>
<ul>
<li>使用对象字面量创建一个普通的对象。</li>
<li>将字面量包括到括号中。</li>
<li>在括号结束之后，可以立即调init()方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">	width: <span class="number">600</span>,</span><br><span class="line">	height: <span class="number">300</span>,</span><br><span class="line">	getMax: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.width + <span class="keyword">this</span>.height;</span><br><span class="line">	&#125;,</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.getMax());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).init();</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li>于即时函数的优点相同</li>
<li>如果初始化任务更加复杂，它将会使得整个初始化过程更加有结构化。</li>
</ul>
</li>
<li><p>初始化时分支：也称加载时分支，是一种优化模式。</p>
<p>帮助分支代码在初始化代码执行过程中仅检测一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">var</span> utils = &#123;</span><br><span class="line">	addListenner: <span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.addEventListener === <span class="string">'function'</span>) &#123;</span><br><span class="line">			el.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span>.attachEvent === <span class="string">'function'</span>) &#123;</span><br><span class="line">			el.attachEvent(<span class="string">'on'</span> + type, fn)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			el[<span class="string">'on'</span> + type] = fn;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">  removeListenner: <span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 几乎一样的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式效率比较低下，每次调用utils.addListenner 和utils.addListenner时，都会重复的执行相同的检查。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> utils = &#123;</span><br><span class="line"> 	addListenner: <span class="literal">null</span>,</span><br><span class="line"> 	removeListenner: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.addEventListener === <span class="string">'function'</span>) &#123;</span><br><span class="line">	utils.removeListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">		el.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	utils.removeListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">		el.removeListenner(type, fn, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">document</span>.attachEvent === <span class="string">'function'</span>) &#123;</span><br><span class="line">	utils.addListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">		el.attachEvent(<span class="string">'on'</span> + type, fn)</span><br><span class="line">	&#125;</span><br><span class="line">	utils.removeListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">		el.detachEvent(<span class="string">'on'</span> + type, fn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	utils.addListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">		el[<span class="string">'on'</span> + type] = fn;</span><br><span class="line">	&#125;</span><br><span class="line">	utils.removeListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">		el[<span class="string">'on'</span> + type] = fn;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式就是只会检测一次了。</p>
</li>
</ul>
<h4 id="性能模式"><a href="#性能模式" class="headerlink" title="性能模式"></a>性能模式</h4><ul>
<li><p>备忘录模式：使用函数属性以便使的计算过的值无需在此计算</p>
<p>以为函数是对象，所以有属性和方法。例如：无论以什么方式创建了对象，都会自动获得一个length属性，包含了该函数期望的参数的数量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun.length)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>所以可以在任何时候将自定义属性添加到函数中，其中的一个作用就是缓存函数结果（返回值）。因此在下一次调用的时候就不用重复做潜在的繁重计算功能。缓存函数结果被称：备忘</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFun = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="built_in">arguments</span>.callee;</span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">	<span class="keyword">if</span> (!f.cache) &#123;</span><br><span class="line">		result = <span class="string">"shuliqi"</span>;</span><br><span class="line">		<span class="comment">// ...开销很大的操作</span></span><br><span class="line">		myFun.cache = result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f.cache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存存储</span></span><br><span class="line">myFun.cache = &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义模式（惰性函数定义）： 以新的主体重写本身。使的在第二次或者以后调用时仅需要执行更少的工作</p>
<p>函数可以被动态定义，也可以分配给变量。如果创建了一个新的函数并且把它分配给了另外一个函数的的同一个变量。那么就是以新函数覆盖了就函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'111'</span>);</span><br><span class="line">	myFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'2222'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">myFun(); <span class="comment">// '111'</span></span><br><span class="line">myFun(); <span class="comment">// '2222'</span></span><br><span class="line"><span class="built_in">console</span>.log(myFun.name)</span><br></pre></td></tr></table></figure>
<p>如果函数有一些初始化的准备工作要做。并且只需要执行一次。那么这种模式就很有用。</p>
<p><strong>缺点</strong></p>
<ul>
<li><p>如果改函数使用了不同的名称（比如分配给不同的变量或者以对象的方式来使用）那么重定义就不会发生，并且会执行原始函数体。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'111'</span>);</span><br><span class="line">	myFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'2222'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值给另一个不同名称的变量</span></span><br><span class="line"><span class="keyword">var</span> newMyFun = myFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个方法被调用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> 	fun: newMyFun,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newMyFun() <span class="comment">// '111'</span></span><br><span class="line">newMyFun() <span class="comment">// '111'</span></span><br><span class="line"></span><br><span class="line">obj.fun() <span class="comment">// '111'</span></span><br><span class="line">obj.fun() <span class="comment">// '111'</span></span><br><span class="line"></span><br><span class="line">myFun() <span class="comment">// '2222'</span></span><br><span class="line">myFun() <span class="comment">// '2222'</span></span><br></pre></td></tr></table></figure>
<p>这些调用不断的重写全局myFun()指针。以至于它最终被调用时，它才第一次更新函数主体。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>CSS Grid网格布局</title>
    <url>/shuliqi.github.io/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>最近在参加一个小程序比赛，其中在做瀑布流布局的时候，有人拿Grid网格布局来做的，但是我觉得瀑布流并不是个用Grid网格布局来做，因为它每一个项目占多少网格，都需要人工去指定。虽然我觉得Grid网格布局不是个做瀑布流， 但是我觉得它还是非常强大的，甚至觉得比Flex强大。那么这篇文章就是来记录Grid网格布局的一个使用教程的。当翻阅可看。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们web页面开发过程中，我们可以使用css控制页面中元素的位置，主要的布局样式有以下几种：</p>
<ul>
<li>正常的布局流</li>
<li>display 属性</li>
<li>弹性盒子（<a href="https://shuliqi.github.io/shuliqi.github.io/2018/03/31/Flex%E5%B8%83%E5%B1%80/">FlexBox</a>）</li>
<li>网格（display：table）</li>
<li>浮动（float）</li>
<li>定位（position）</li>
<li>CSS Grid网格布局</li>
<li>多列布局（Multi-column layout）</li>
</ul>
<h1 id="什么是网格布局（Grid）？"><a href="#什么是网格布局（Grid）？" class="headerlink" title="什么是网格布局（Grid）？"></a>什么是网格布局（Grid）？</h1><p>网格布局（Grid）将网页分成一个个网格，可以任意组合不同的网格，设计出各种各样的的布局。</p>
<p>网格布局（Grid）将容器划分成“行” 和 “列”， 然后指定“项目所在”的单元格，可以看做是二维布局。Grid 布局远比 Flex 布局强大。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>学习 Grid 布局之前，需要了解一些基本概念。</p>
<h2 id="容器和项目"><a href="#容器和项目" class="headerlink" title="容器和项目"></a>容器和项目</h2><p>使用网格布局的区域，称为“容器”（container），容器内采用网格定位的子元素，称为“项目”（item）</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我们给 class 为 <code>container</code>的元素设置它为 网格布局（Grid）。那么该元素就是容器， 里面的三个class为<code>tem</code>的元素就是项目。</p>
<p><strong>注意：</strong>项目只能是容器最顶层子元素，不包含项目的子元素。例如上面的<code>span</code>标签就不是项目。Grid布局就对项目生效。</p>
<h2 id="行，列，单元格，网格线"><a href="#行，列，单元格，网格线" class="headerlink" title="行，列，单元格，网格线"></a>行，列，单元格，网格线</h2><img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/3.png">
<p><strong>行和列：</strong></p>
<p>容器里面的水平区域称为”行“（row）；垂直区域称为”列“（column）。 上图中的水平绿色区域就是”行“。垂直的蓝色区域就是”列“。</p>
<p><strong>单元格：</strong></p>
<p>行和列的交叉区域称为”单元格“(cell)。如上图显示”单元格“的区域就是其中的一个单元格</p>
<p><strong>网格线：</strong></p>
<p>划分为网格的线，称为：”网格线“（grid line）。水平网格线划分出行，垂直网格线划分出列。日上图中就有5个水平网格线 和 10 个垂直网格线。</p>
<h1 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h1><p>Grid 布局的属性分为两类。一类是定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这里我们先讲容器属性。</p>
<h2 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h2><p>使用<code>display:grid</code>指定一个容器采用网格布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<iframe height="400" style="width: 100%;" scrolling="no" title="KKgVeKX" src="https://codepen.io/shuliqi/embed/KKgVeKX?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/KKgVeKX" target="_blank" rel="noopener">KKgVeKX</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><br>默认情况下，容器元素都是块级元素，单也可以设置为行内元素。<br><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>如：<br><br><iframe height="400" style="width: 100%;" scrolling="no" title="网格布局inline-grid" src="https://codepen.io/shuliqi/embed/qBabKoB?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/qBabKoB" target="_blank" rel="noopener">网格布局inline-grid</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>上面的这个例子指定了 class 为 <code>grid</code>的 div 为行内元素，该元素内部的项目使用网格布局。</p>
<p><strong>注意：</strong> 设置网格布局之后，容器项目的 <code>float</code>，<code>display: inline-block</code>,<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置将会失效。</p>
<h2 id="grid-template-columns属性"><a href="#grid-template-columns属性" class="headerlink" title="grid-template-columns属性"></a>grid-template-columns属性</h2><h2 id="grid-template-rows-属性"><a href="#grid-template-rows-属性" class="headerlink" title="grid-template-rows 属性"></a>grid-template-rows 属性</h2><p>容器指定了网格布局之后，就需要划分行和列。<code>grid-template-columns</code> 属性用来定义每一列的宽度，<code>grid-template-rows</code>属性用来定义每一行的行高。</p>
<p>例如我们上面两个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上：指定了一个两行两列的网格，列宽和行高都是 <code>100px</code>。</p>
<p>当然<code>grid-template-columns</code> 和<code>grid-template-rows</code>属性除了可以使用绝对值外，也可以使用百分比的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>有时候列宽可能是固定， 到那时我们在指定每一列的列宽时，都需要一一写上。就很麻烦。这时候就可以使用repeat()函数，简化重复的值。</p>
<p><strong>repeat()：</strong>接受两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。例如上面的代码就可以写成：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(2, 50%);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(2, 50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>repeat()：</strong> 也可以重复某种模式。如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(2, 100px 200px);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>:  <span class="built_in">repeat</span>(2,  200px 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<iframe height="600" style="width: 100%;" scrolling="no" title="grid网格布局repeat()" src="https://codepen.io/shuliqi/embed/LYRGgPv?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/LYRGgPv" target="_blank" rel="noopener">grid网格布局repeat()</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>如上这个例子的代码就表示：第一列和第三列的宽为80px，第二列和第四列的宽为100ox。</p>
<h4 id="auto-fill-关键字"><a href="#auto-fill-关键字" class="headerlink" title="auto-fill 关键字"></a>auto-fill 关键字</h4><p>有时候单元格的大小是固定的，但是容器的大小是不固定的。如果我们是希望没一行或者每一列能容纳尽可能多的单元格。就可以使用<code>auto-fill</code>关键字了。这个关键字表示自动填充。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<iframe height="400" style="width: 100%;" scrolling="no" title="auto-fill" src="https://codepen.io/shuliqi/embed/MWjKPwQ?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/MWjKPwQ" target="_blank" rel="noopener">auto-fill</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>例子代码表示：每列列宽为100px，然后自动填充，直到容器不能放置更多的列。</p>
<h4 id="fr关键字"><a href="#fr关键字" class="headerlink" title="fr关键字"></a>fr关键字</h4><p>为了方便的表示比列关系，网格布局提供了<code>fr</code> 关键字。如果两列的了宽度分别是 <code>1fr</code> 和 <code>2fr</code> 表示 后者的列宽是前者的两倍。</p>
<p>如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这表示容器的高度被分为2等份，第一行和第二行的行高都各占了一份。容器的宽被分成2等份，第一列和第二列的列宽都个占了1份。</p>
<iframe height="400" style="width: 100%;" scrolling="no" title="fr" src="https://codepen.io/shuliqi/embed/OJRMBWW?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/OJRMBWW" target="_blank" rel="noopener">fr</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p> 再如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr <span class="number">3</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示容器的宽被分成了5份等份，第一列的列宽占了2份。第二列的列宽占了一份，第三列的列宽占了3份。</p>
<iframe height="400" style="width: 100%;" scrolling="no" title="xxEZydN" src="https://codepen.io/shuliqi/embed/xxEZydN?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/xxEZydN" target="_blank" rel="noopener">xxEZydN</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="minmax"><a href="#minmax" class="headerlink" title="minmax()"></a>minmax()</h4><p><code>minmax()</code>函数产生一个长度范围。它有两个参数，最大值和最小值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: grid;</span><br><span class="line">	<span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="built_in">minmax</span>(100pox, 200px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就表示，该项目的宽度不小于100px，不大于200px</p>
<h4 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h4><p>该关键字表示项目的宽度有浏览器自己决定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.grid &#123;  </span><br><span class="line">  display: grid;  </span><br><span class="line">  grid-template-columns: auto 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示第一个项目的宽度基本是等于该单元格的最大宽度。</p>
<h4 id="网格线的名称"><a href="#网格线的名称" class="headerlink" title="网格线的名称"></a>网格线的名称</h4><p>使用<code>grid-template-columns</code>属性和 <code>grid-template-rows</code>属性时，可以使用方括号，指定每一根网线的名字。方便之后的引用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;  </span><br><span class="line">  <span class="attribute">display</span>: grid;  </span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [a1] auto [a2] <span class="number">100px</span> [a3];</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [b1] <span class="number">100px</span> [b2] <span class="number">100px</span> [b3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上的代码指定的网格布局为两列两行，因此有3根水平网格线和3根垂直网格线。方括号里面依次是这6根网格线的名字。</p>
<iframe height="400" style="width: 100%;" scrolling="no" title="行间距和列间距" src="https://codepen.io/shuliqi/embed/OJRRaOm?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/OJRRaOm" target="_blank" rel="noopener">行间距和列间距</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p><strong>注意：</strong>网格布局允许同一根线可以有多个名字。如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-attr">[a1 m1]</span> <span class="selector-tag">auto</span> <span class="selector-attr">[a2]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[a3]</span>;</span><br></pre></td></tr></table></figure>
<h2 id="grid-row-gap-属性，"><a href="#grid-row-gap-属性，" class="headerlink" title="grid-row-gap 属性，"></a>grid-row-gap 属性，</h2><h2 id="grid-column-gap属性"><a href="#grid-column-gap属性" class="headerlink" title="grid-column-gap属性"></a>grid-column-gap属性</h2><h2 id="grid-gap-属性"><a href="#grid-gap-属性" class="headerlink" title="grid-gap 属性"></a>grid-gap 属性</h2><p><code>grid-row-gap</code>属性设置行与行之间的间隔行间距</p>
<p><code>grid-column-gap</code> 属性设置列与列之间的间隔（列间距）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="comment">/*   行间距 */</span></span><br><span class="line">  <span class="attribute">grid-row-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="comment">/*   列间距 */</span></span><br><span class="line">  <span class="attribute">grid-column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>grid-gap</code> 属性是 <code>grid-column-gap</code>和 <code>grid-row-gap</code>的合并简写。语法:<code>grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;</code></p>
<p><strong>注意：</strong>如果<code>grid-gap</code>省略了第二个值。那么浏览器会默认为第二个值等于第一个值</p>
<p><strong>注意</strong>：根据最新的标准。<code>grid-row-gap</code>，<code>grid-column-gap</code>，<code>grid-gap</code> 这三个属性不用写前缀<code>grid</code>。</p>
<h2 id="grid-template-areas-属性"><a href="#grid-template-areas-属性" class="headerlink" title="grid-template-areas 属性"></a>grid-template-areas 属性</h2><p>网格布局允许执行“区域”（areas），一个区域有多个单元格组成。那么<code>grid-template-areas</code>属性就是用来定义区域的.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-row-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">grid-column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="comment">/*   指定区域 */</span></span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">'a b'</span></span><br><span class="line">                       <span class="string">'c d'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<iframe height="400" style="width: 100%;" scrolling="no" title="指定区域" src="https://codepen.io/shuliqi/embed/oNzzQaj?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/oNzzQaj" target="_blank" rel="noopener">指定区域</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>上面的这个例子我们审查元素来看看。可以看出区域被分成了4部分 a b c d;</p>
<img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/4.png">
<p><strong>多个单元格合并成一个单元格的写法：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-template-areas: 'a a'</span><br><span class="line">                     'b b';</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/5.png">
<p>这样就把把四个单元格分成了 a b  两个区域。</p>
<p>如果某个区域不需要的话，则使用  .  来表示。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">grid-template-areas: 'a .'</span><br><span class="line">                     '. b';</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/6.png">
<p><strong>注意：</strong>区域的命名会影响到网格线，每个区域的起始网格线会自动命名为<code>区域名-start</code>,终止网格线会自动命名为<code>区域名-end</code>.</p>
<h2 id="grid-auto-flow-属性"><a href="#grid-auto-flow-属性" class="headerlink" title="grid-auto-flow 属性"></a>grid-auto-flow 属性</h2><p><code>grid-auto-flow</code>属性用来设置容器项目的放置顺序。主要有四个值：</p>
<h3 id="row"><a href="#row" class="headerlink" title="row:"></a><code>row</code>:</h3><p>默认值。表示放置顺序为”先行后列“。 也就是先填满第一行。再放入第二行。</p>
<blockquote>
<p>我们上面的所有的例子都是这样的（看元素中的数字可以看出），都是先放满第一行，再放如第二行。</p>
</blockquote>
<h3 id="column"><a href="#column" class="headerlink" title="column:"></a><code>column:</code></h3><p>表示”先列后行”。</p>
<p>如：</p>
<iframe height="462" style="width: 100%;" scrolling="no" title="先列后行" src="https://codepen.io/shuliqi/embed/MWjjNZw?height=462&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/MWjjNZw" target="_blank" rel="noopener">先列后行</a> by shuliqi<br>    (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>从例子中可以看出来 1，2  在左边；3，  4 在右边。这是因为我们设置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*   先列后行 */</span></span><br><span class="line"><span class="selector-tag">grid-auto-flow</span>: <span class="selector-tag">column</span>;</span><br></pre></td></tr></table></figure>
<h3 id="row-dense"><a href="#row-dense" class="headerlink" title="row dense:"></a><code>row dense:</code></h3><p>表示”先行后列”，每一行尽可能精密填满，尽量不要有空格；</p>
<p>这个设置的意义在哪里呢？ 我们先来看一个例子：</p>
<iframe height="537" style="width: 100%;" scrolling="no" title="尽量不要有空格" src="https://codepen.io/shuliqi/embed/VwKKoNQ?height=537&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/VwKKoNQ" target="_blank" rel="noopener">尽量不要有空格</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><br>在这个例子中， 我们采用的是”先行后列“的放置顺序；设置第一个项目和第二个项目列宽占两个单元格:<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-column-start: 1;</span><br><span class="line">grid-column-end: 3;</span><br></pre></td></tr></table></figure><br><br>然后就得到如上的结果，从结果可以看出，第一行空出了一个空白的地方。这是为什么呢？ 这是因为第三个项目默认跟着第二个项目，所以会排在第二个项目之后。<br><br> 但是我们把放置顺序改为：<code>row dense</code>。那么结果就是：<br><br>  <iframe height="467" style="width: 100%;" scrolling="no" title="QWKGLGb" src="https://codepen.io/shuliqi/embed/QWKGLGb?height=467&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>    See the Pen <a href="https://codepen.io/shuliqi/pen/QWKGLGb" target="_blank" rel="noopener">QWKGLGb</a> by shuliqi<br>    (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br>  </iframe>

<p>这个例子就可以看出来： 先是填满第一行，再填满第二行，并且每一行尽量不要有空格。所以第三个元素会在第一个元素后面</p>
<h3 id="column-dense"><a href="#column-dense" class="headerlink" title="column dense"></a><code>column dense</code></h3><p>表示 ”先列后行“ 并且每一列尽量不要有空格。</p>
<p>跟上一个的适用场景一样。 我们将放置顺序改为<code>column dense</code>；那么将得到这样的结果：</p>
<iframe height="544" style="width: 100%;" scrolling="no" title="GRjNKQb" src="https://codepen.io/shuliqi/embed/GRjNKQb?height=544&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/GRjNKQb" target="_blank" rel="noopener">GRjNKQb</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>



<h2 id="justify-items-属性"><a href="#justify-items-属性" class="headerlink" title="justify-items 属性"></a>justify-items 属性</h2><h2 id="align-items-属性"><a href="#align-items-属性" class="headerlink" title="align-items 属性"></a>align-items 属性</h2><h2 id="place-items-属性"><a href="#place-items-属性" class="headerlink" title="place-items 属性"></a>place-items 属性</h2><p><code>justify-items</code>属性用来设置<strong>单元格内容</strong>的水平位置。<code>align-items</code> 属性用来设置<strong>单元格内容</strong>的垂直位置。这两个都有如下的值：</p>
<ul>
<li><code>start：</code> 对齐单元格的起始位置</li>
<li><code>end：</code>对齐单元格的结束边缘</li>
<li><code>center:</code>单元格内部居中</li>
<li><code>stretch</code>:项目大小没有指定时，拉伸占据整个网格容器。</li>
</ul>
<p>这里需要注意的是<strong>单元格内容</strong></p>
<p>例：</p>
<iframe height="315" style="width: 100%;" scrolling="no" title="jOMBmZg" src="https://codepen.io/shuliqi/embed/jOMBmZg?height=315&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/jOMBmZg" target="_blank" rel="noopener">jOMBmZg</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>如上的代码， 我们让每个单元格里面的内容水平位置居中，垂直位置居中。我们可以通过审查元素来看：</p>
<img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/7.png">
<p>可以看出来，class为 item的元素在第一个单元格的位置都是单元格内部居中（水平位置居中，垂直位置居中）。</p>
<p>其他值我就不一一举例了。可以直接使用上面的例子，修改 <code>justify-items</code> 和 <code>align-items</code>的值看效果。</p>
<p><code>place-items 属性</code>是 <code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-items</span>: &lt;<span class="selector-tag">align-items</span>&gt; &lt;<span class="selector-tag">justify-items</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<iframe height="330" style="width: 100%;" scrolling="no" title="OJRpgJY" src="https://codepen.io/shuliqi/embed/OJRpgJY?height=330&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/OJRpgJY" target="_blank" rel="noopener">OJRpgJY</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><br>如上的例子： 我们使用<code>place-items</code>设置了 垂直方向是对齐单元格的结束方向。水平方向是居中。我们可以审查元素来看：<br><br><img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/8.png"><br><br>可以看出 来class为 item的元素在第一个单元格的位置是垂直方向是对齐单元格的结束方向。水平方向是居中。<br><br><strong>注意：</strong> <code>place-items</code>属性的第二个参数如果省略的话，则浏览器默认与第一个值相等。<br><br><br><br>## justify-content 属性<br><br>## align-content 属性<br><br>## palce-content 属性<br><br><br><br><code>justify-content</code> 属性是设置整个内容区域在容器里面的水平位置，<code>align-content</code>属性是设置整个内容区域在容器里面的垂直位置。这两个属性都有如下的值：<br><br>- <strong>start</strong>： 对齐容器的起始边框；<br><br>  <img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/9.png"><br><br>- <strong>end</strong>：对齐容器的结束边框;<br><br>  <img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/10.png"><br><br>- <strong>center</strong>：容器内部居中；<br><br>  <img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/11.png"><br><br>- <strong>stretch</strong> - 项目大小没有指定时，拉伸占据整个网格容器。<br><br>  <img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/12.png"><br><br>- <strong>space-around</strong> - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。<br><br>  <img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/13.png"><br><br>- <strong>space-between</strong> - 项目与项目的间隔相等，项目与容器边框之间没有间隔。<br><br>  <img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/14.png"><br><br>- <strong>space-evenly</strong> - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。<br><br>  <img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/15.png"><br><br><code>place-content</code>属性是 <code>justify-content</code>属性和<code>align-content</code>属性的合并缩写形式：<br><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">place-content</span>: &lt;<span class="selector-tag">align-content</span>&gt; &lt;<span class="selector-tag">justify-content</span>&gt;</span><br></pre></td></tr></table></figure><br><br>如果<code>place-content</code>省略第二个值，那么浏览器就会默认第二个值等于第一个值。<br><br><br><br>## grid-auto-columns 属性<br><br>## grid-auto-rows 属性<br><br>有时候我们的项目的指定在网格的外面，那么浏览器就会自动根据单元格的大小生成多余的网格。<br><br><code>grid-auto-cloumns</code>属性 和 <code>grid-auto-rows</code>属性就是用来设置当浏览器自动创就按多余的网格的列宽和行高。这两个属性的法与<code>grid-template-columns</code>,<code>grid-template-rows</code>是一样的;<br><br>如：<br><iframe height="553" style="width: 100%;" scrolling="no" title="grid-auto-columns" src="https://codepen.io/shuliqi/embed/dypvRMq?height=553&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/dypvRMq" target="_blank" rel="noopener">grid-auto-columns</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>这个例子：第7 个项目超出了当前的网格（使用了<code>grid-row-start</code> 和 <code>grid-column-start</code>下面会有介绍），那么浏览器会自动生成多余的网格，我们设置多余的网格列宽和行高都是50px；</p>
<h1 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h1><p>定义在项目上的属性。</p>
<h2 id="grid-column-start-属性"><a href="#grid-column-start-属性" class="headerlink" title="grid-column-start 属性"></a>grid-column-start 属性</h2><h2 id="grid-column-end-属性"><a href="#grid-column-end-属性" class="headerlink" title="grid-column-end 属性"></a>grid-column-end 属性</h2><h2 id="grid-row-start-属性"><a href="#grid-row-start-属性" class="headerlink" title="grid-row-start 属性"></a>grid-row-start 属性</h2><h2 id="grid-row-end-属性"><a href="#grid-row-end-属性" class="headerlink" title="grid-row-end 属性"></a>grid-row-end 属性</h2><p>容器中的项目是可以指定的。使用这四个属性定义项目的边框。这四个属性是定义项目在哪根网格线；</p>
<ul>
<li>grid-column-start 属性：项目左边框所在的垂直网格线；</li>
<li>grid-column-end属性：项目右边框所在的垂直网格线；</li>
<li>grid-row-start 属性：项目上边框所在的水平网格线；</li>
<li>grid-row-end 属性：项目下边框所在的水平线网格线；</li>
</ul>
<p>我们讲解上个属性的时候也用到了这些属性 <code>grid-row-start</code> 和 <code>grid-column-start</code>。我们可以再举个例子：</p>
<iframe height="595" style="width: 100%;" scrolling="no" title="grid-auto-columns" src="https://codepen.io/shuliqi/embed/jOMBZWd?height=595&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/jOMBZWd" target="_blank" rel="noopener">grid-auto-columns</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>我们可以通过审查元素看出来第7个元素占的网格线情况：</p>
<img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/16.png">
<p>第七个项目的上边框在水平网格线的第四根，左边框在垂直网格线的第一根。下边框和右边框没有指定，所以会采用默认位置(下边框滴5根网格线。有边框第二根网格线)。</p>
<p>再看一个例子：</p>
<iframe height="629" style="width: 100%;" scrolling="no" title="grid-auto-columns" src="https://codepen.io/shuliqi/embed/QWKpQpo?height=629&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/QWKpQpo" target="_blank" rel="noopener">grid-auto-columns</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>我们可以通过审查元素看出来第7个元素占的网格线情况：</p>
<img src="/shuliqi.github.io/2020/12/04/CSS-Grid网格布局/17.png">
<p>我们可以看出第一个项目的左边框在垂直网格线的第二个，右边框在垂直网格线的第四个网格线。上下边框没有指定使用默认位置。除了第一个项目之外，其他项目没有指定位置，由浏览器自动布局。这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会”先行后列”进行排列</p>
<p><strong>注意1：</strong>这四个属性的值，也可以指定为网格线的名字。</p>
<iframe height="634" style="width: 100%;" scrolling="no" title="grid-auto-columns" src="https://codepen.io/shuliqi/embed/xxEqYYg?height=634&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/xxEqYYg" target="_blank" rel="noopener">grid-auto-columns</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>第一个项目的左边框指定为a2的网格线，右边框指定为a4的网格线，</p>
<p><strong>注意2：</strong>这四个属性可以使用 <code>span</code>关键字。表示上下边框（左右边框）之间跨越多少网格。</p>
<iframe height="634" style="width: 100%;" scrolling="no" title="grid-auto-columns" src="https://codepen.io/shuliqi/embed/xxEqYYg?height=634&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/xxEqYYg" target="_blank" rel="noopener">grid-auto-columns</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>第一个项目的左右边框，上下边框都跨越2个网格（绿色部分）。</p>
]]></content>
  </entry>
  <entry>
    <title>Dockerfile文件的使用</title>
    <url>/shuliqi.github.io/2020/10/20/Dockerfile%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在上一篇文章 <a href="https://shuliqi.github.io/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/">Docker的必要性及基础使用</a>，我们知道 Dockerfile 是一个文本文件。这个文件里面包含了一系列的指令，每一条指令构建一层，每一条指令的内容及就是描述该层是如何构建的。</p>
 <a id="more"></a>
<h1 id="Dockerfile文件格式"><a href="#Dockerfile文件格式" class="headerlink" title="Dockerfile文件格式"></a>Dockerfile文件格式</h1><p>我们可以上篇文章 <a href="https://shuliqi.github.io/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/">Docker的必要性及基础使用</a>的 <a href="https://github.com/shuliqi/express-for-docker" target="_blank" rel="noopener">Demo</a> 的Dockerfile文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12.17</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">COPY</span> . /shuliqi</span><br><span class="line"><span class="keyword">WORKDIR</span> /shuliqi</span><br><span class="line"><span class="keyword">RUN</span> ["npm", "install"]</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span>/tcp</span><br><span class="line"><span class="keyword">CMD</span> node app.js</span><br></pre></td></tr></table></figure>
<p>因此我们知道<code>Dockerfile</code> 文件的格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># comment</span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 注释</span><br><span class="line">指令 参数</span><br></pre></td></tr></table></figure>
<p><code>Dockerfile</code>文件中的指令是不区分大小写的，但是为了更容易区分，约定使用 大写形式</p>
<p>Docker会依次执行<code>Dockerfile</code>文件中的指令，文件中第一条指令必须是<code>FROM</code>。</p>
<p>以 <code>#</code>开头的行，Docke会认为是注释，但是 <code>#</code>出现在指令参数中，则不是注释。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Comment</span><br><span class="line">RUN echo &apos;how old are you # my name is shuliqi&apos;</span><br></pre></td></tr></table></figure>
<h1 id="Dockerfile-的组成部分"><a href="#Dockerfile-的组成部分" class="headerlink" title="Dockerfile 的组成部分"></a>Dockerfile 的组成部分</h1><p>Dockerfile 文件主要由 四部分组成，分别是：</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础镜像信息</td>
<td>FROM</td>
</tr>
<tr>
<td>维护者信息</td>
<td>MAINTAINER</td>
</tr>
<tr>
<td>镜像操作指令</td>
<td>RUN，COPY，ADD，EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等</td>
</tr>
<tr>
<td>容器启动时执行指令</td>
<td>CMD、ENTRYPOINT</td>
</tr>
</tbody>
</table>
<h1 id="Dockerfile中的指令"><a href="#Dockerfile中的指令" class="headerlink" title="Dockerfile中的指令"></a>Dockerfile中的指令</h1><p>接下来我们讲指令的同时结合例子来讲，首先我们先创建一个可以使用的例子。关于怎么创建可以参考上一篇 博文<a href="https://shuliqi.github.io/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84-Docker-%E5%AE%B9">Docker的必要性及基础使用</a>。我创建了项目 <strong><a href="https://github.com/shuliqi/dockerfile-example" target="_blank" rel="noopener">dockerfile-example</a></strong>。当然项目顺便你怎么弄，直接减一个Dockerfile的文件也算是个。</p>
<h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p><code>FROM</code>指令为后面的指令提供镜像基础。<code>FROM</code>指令必须是<code>Dockerfile文件的</code>首条命令，启动构建流程后，<code>Docker</code>将会基于该镜像构建新镜像，<code>FROM</code>后的命令也是基于这个基础镜像。</p>
<p><code>FROM</code>的语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;diaest&gt;</span><br></pre></td></tr></table></figure>
<p>通过 <code>FROM</code>指定的镜像，可以是任何有效的基础镜像，<code>FROM</code>有以下的限制：</p>
<ul>
<li><code>FROM</code>必须是 <code>Dockerfile</code>文件的第一条非注释命令</li>
<li>在一个 <code>Dockerfile</code>文件中创建多个镜像时，<code>FROM</code>是可以多次出现。只需要在每个新命令<code>FROM</code>之前，记录提交上次的镜像ID</li>
<li><code>tag</code> 和 <code>digest</code>是可选的，如果不使用这两个值的时候，会使用<code>latest</code>版本的基础镜像</li>
</ul>
<p>举个🌰：</p>
<p>在我们当前的项目中， 我们使用node的基础镜像。就可以这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM node:8.4</span><br></pre></td></tr></table></figure>
<p><a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" target="_blank" rel="noopener">Docker Hub</a>有很多高质量的官方镜像。是可以直接拿来使用的。</p>
<p>除了选择现有的镜像为基础镜像外。Dcoker 还有一个比较特殊的镜像叫<code>scratch</code>。这个镜像是虚拟的概念。并不实际存在、表示一个空白的镜像。我们也可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br></pre></td></tr></table></figure>
<p>如果使用了 <code>scratch</code>为基础镜像的话，就说明不以任何的镜像为基础。接下来编写的指令将作为镜像的第一层存在。</p>
<h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p><code>RUN</code>用来在定制镜像（image）时执行命令行命令的，有两种命令执行方式：</p>
<h4 id="shell-执行"><a href="#shell-执行" class="headerlink" title="shell 执行"></a><code>shell</code> 执行</h4><p>这种方式会在<code>shell</code>中执行命令，就像直接在命令行输入命令一样。</p>
<p><code>shell</code>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run &lt;命令行命令&gt;</span><br><span class="line"># &lt;命令行命令&gt; 等同于在终端操作的 shell 的命令</span><br></pre></td></tr></table></figure>
<p>整理了一份 <a href="https://www.jianshu.com/p/3291de46f3ff" target="_blank" rel="noopener">命令行命令</a>。可翻阅</p>
<p>举个🌰：</p>
<p>我们希望在定制镜像（image）是新建一个名字为 shuliqi.js 的文件。我们就可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN touch shuliqi.js</span><br></pre></td></tr></table></figure>
<p>然后我们定制镜像（image）文件<code>docker build -t dockerfile-example .</code>然后以该镜像（image）启动一个容器<code>docker run -t dockerfile-example</code>最后我们进入到这个容器看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">0c3ac932b755        dockerfile-example   &quot;/bin/bash&quot;         59 seconds ago      Up 58 seconds                           compassionate_nobel</span><br><span class="line">$ docker exec -t -i 0c3ac932b755 bash</span><br><span class="line">root@0c3ac932b755:/# ls</span><br><span class="line">bin  boot  dev	etc  home  lib	lib64  media  mnt  opt	proc  root  run  sbin  shuliq.js  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>
<p>进入到容器之后， 我们使用ls 命令行命令，可以看出来，有文件名字为：shuliqi.js</p>
<h4 id="exec执行"><a href="#exec执行" class="headerlink" title="exec执行"></a><code>exec</code>执行</h4><p><code>exec</code>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN [&quot;可执行的额文件&quot;,“参数1”, &quot;参数2&quot;]</span><br><span class="line">## 例如：</span><br><span class="line"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></pre></td></tr></table></figure>
<p><code>RUN</code>可以执行任何命令，然后再当前镜像上创建一个新层并且提交，提交后的结果镜像将会在 <code>Dockerfile</code>文件的下一步。</p>
<p>通过<code>RUN</code>执行多条命令时，可以通过<code>\</code>换行执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN touch shuliqi.js\</span><br><span class="line">touch shuliqi2.js</span><br></pre></td></tr></table></figure>
<p>也可以在同一行通过分好分隔命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN touch shuliqi.js; RUN touch shuliqi.js; \</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong><code>RUN</code>指令创建的中间镜像会被缓存，并且在下次构建中使用。如果不想使用这些缓存镜像，可以在创建时指定<code>--no-cache</code>参数，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ocker build --no-cache .</span><br></pre></td></tr></table></figure>
<p>例如：</p>

<p>这样构建镜像的步骤就没有使用缓存，使得每一层的镜像ID都与之前的不同。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p> <code>CMD</code>用于在指定容器启动时所有执行的命令。<code>CMD</code>有以下三种格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD &lt;commond&gt; // shell 格式</span><br><span class="line">CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] // exec格式，推荐格式</span><br><span class="line">CMD [&quot;param1&quot;, &quot;param2&quot;] // 为ENTRYPOINT指令提供参数</span><br></pre></td></tr></table></figure>
<p>与<code>RUM</code>命令不同的是：</p>
<p><code>RUM</code>指令在构建镜像时要执行命令。<code>CMD</code>则是用于在指定的容器启动时所要执行的命令。</p>
<p><code>CMD</code>在 Dockerfile文件中仅可指定一次，指定多次时，会覆盖前面的指令。</p>
<p><strong>需要注意：</strong>docker  run 命令会覆盖<code>CMD</code>命令。 如果 <code>docker run</code>运行容器时，使用了 <code>Dockerfile</code>中的 <code>CMD</code>命令相同的命令。就会覆盖 <code>Dockerfile</code>的<code>CMD</code>命令。</p>
<p>我们来举个🌰：</p>
<p>还是我们之前的项目，我们在 <code>Dockfile</code>文件中使用如下的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>
<p>我们使用<code>docker build -t dockerfile-example .</code>构建一个新的镜像，镜像的名字叫：dockerfile-example，构建完成之后， 我们使用这个镜像运行一个容器，运行效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -t dockerfile-example</span><br><span class="line">root@cfc0384da571:/#</span><br></pre></td></tr></table></figure>
<p>那么容器终端将会使用 shell 。说明  <code>Dockfile</code>文件中的<code>CMD</code>起作用了。</p>
<p>但是我们不想使用 <code>Dockfile</code>文件中的<code>CMD</code>指定的命令。我们可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -t dockerfile-example /bin/ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure>
<p>这时，<code>docker run</code>结尾指定的<code>/bin/ps</code>命令覆盖了<code>Dockerfile</code>的<code>CMD</code>中指定的命令。</p>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p><code>ENTRYPOINT</code>与 <code>CMD</code>类似。</p>
<p><code>ENTRYPOINT</code>有两种模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT &lt;command&gt; (shell模式)</span><br><span class="line">ENTRYPOINT [ &quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ] (exec模式)</span><br></pre></td></tr></table></figure>
<p>但是<code>ENTRYPOINT</code>不会被 <code>docker run</code>中执行的命令覆盖，并且<code>docker run</code>命令中指定的任何参数都会被当成参数再次传递给 ENTRYPOINT<code>。如果想要覆盖</code>ENTRYPOINT<code>，则需要在</code>docker run<code>中指定</code>–entrypoint<code>选项。</code>Dockerfile<code>中只允许有一个</code>ENTRYPOINT<code>，多指定时会覆盖前端的设置的</code>ENTRYPOINT`指令。 而只执行最后的 ENTRYPOINT指令。</p>
<p>举个例子：</p>
<p>我们重写我们的<code>Dockerfile</code>文件。添加 <code>ENTRYPOINT</code>指令：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Version: 0.0.3</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> 何民三 <span class="string">"cn.liuht@gmail.com"</span></span><br><span class="line"><span class="keyword">RUN</span> apt-get update</span><br><span class="line"><span class="keyword">RUN</span> apt-get install -y nginx</span><br><span class="line"><span class="keyword">RUN</span> echo 'Hello World, 我是个容器' \ </span><br><span class="line">   &gt; /var/www/html/index.html</span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["/usr/sbin/nginx"]</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>docker image build -t test2:0.0.1 .</code>构建我们的镜像、</p>
<p>构建完成之后， 启动一个容器：docker run -i -t  test2:0.0.1 -g “daemon off;”  <code></code></p>
<p>在运行容器时，我们使用了<code>-g &quot;daemon off;&quot;</code>. 这个参数会传递给 <code>ENTRYPOINT</code>。最终在容器中执行的命令为<code>/usr/sbin/nginx -g &quot;daemon off;&quot;</code></p>
<h2 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h2><p><code>LABEL</code>用于为镜像添加元数据，元数据以键值对的形式指定：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>LABEL</code>指定元数据时，一条<code>LABEL</code>指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条<code>LABEL</code>指令指定，以免生成过多的中间镜像。</p>
<p>如，通过<code>LABEL</code>指定一些元数据：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span> name="shuliqi" age="23"</span><br></pre></td></tr></table></figure>
<p>构建容器完后才能之后， 可以使用<code>docker inspect</code>查看</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker inspect test3:<span class="number">0.0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>Dockerfile</code>中还有个 <code>MAINTAINER</code>用来指定镜像的作者。但是<code></code>MAINTAINER<code>并不推荐使用，更推荐使用</code>LATER`来指定镜像作者。如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span> maintainer="itbilu.com"</span><br></pre></td></tr></table></figure>
<h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p><code>EXPOSE</code>用来指定容器在运行的时监听的端口。</p>
<p>格式如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt; ...]</span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span>/tcp</span><br></pre></td></tr></table></figure>
<p>注意：<code>EXPOSE</code>并不会让容器的端口访问到主机。要使其可以访问， 需要在<code>docker run</code>运行容器时通过 <code>-p</code>来发布这些端口。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -t -p:8000:3000 express-for-docker:0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p><code>ENV</code>用于设置环境变量，有以下两种形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV SHULIQI_PATH=/home/shuliqi/</span><br></pre></td></tr></table></figure>
<p>设置完， 这个环境变量在 <code>ENV</code>命令之后都可以使用。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV SHULIQI_PATH=/home/shuliqi/</span><br><span class="line">WORKDIR $SHULIQI_PATH</span><br></pre></td></tr></table></figure>
<p>这个环境变量不仅可以在构建镜像中使用，使用该镜像创建的容器也可以使用。</p>
<h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p><code>ADD</code>指令用于复制构建环境中的文件/目录到镜像中。</p>
<p>有两种使用格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p>通过<code>ADD</code>复制文件时，需要通过<src>指定源文件位置，并通过<code>&lt;dest&gt;</code>来指定目标位置。<src>可以是一个构建上下文中的文件或目录，也可以是一个<code>URL</code>，但不能访问构建上下文之外的文件或目录。</src></src></p>
<p>如，通过<code>ADD</code>复制一个网络文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD http://wordpress.org/latest.zip $ITBILU_PATH</span><br></pre></td></tr></table></figure>
<p>在上例中，<code>$ITBILU_PATH</code>是我们使用<code>ENV</code>指定的一个环境变量。</p>
<p>另外，如果使用的是本地归档文件（<code>gzip</code>、<code>bzip2</code>、<code>xz</code>）时，Docker会自动进行解包操作，类似使用<code>tar -x</code>。</p>
<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p><code>COPY</code>同样用于复制构建环境中的文件或目录到镜像中。其有以下两种使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p><code>COPY</code>指令非常类似于<code>ADD</code>，不同点在于<code>COPY</code>只会复制构建目录下的文件，不能使用<code>URL</code>也不会进行解压操作。</p>
<h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p><code>VOLUME</code>用于创建挂载点，即向所构建镜像创使的容器添加卷</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure>
<p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p>
<ul>
<li>卷可以容器间共享和重用</li>
<li>容器并不一定要和其它容器共享卷</li>
<li>修改卷后会立即生效</li>
<li>对卷的修改不会对镜像产生影响</li>
<li>卷会一直存在，直到没有任何容器在使用它</li>
</ul>
<p><code>VOLUME</code>让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</p>
<p>如，通过<code>VOLUME</code>创建一个挂载点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM node:12.17.0</span><br><span class="line">COPY . /shuliqi</span><br><span class="line">WORKDIR /shuliqi</span><br><span class="line">RUN [&quot;npm&quot;, &quot;install&quot;]</span><br><span class="line">EXPOSE 3000/tcp</span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br><span class="line"># `VOLUME`创建一个挂载点</span><br><span class="line">ENV SHULIQI_PATH /myblog/</span><br><span class="line">VOLUME [$SHULIQI_PATH]</span><br></pre></td></tr></table></figure>
<p>构建的镜像，并指定镜像名为<code>express-for-docker</code>。构建镜像后，使用新构建的运行一个容器。运行容器时，需<code>-v</code>参将能本地目录绑定到容器的卷（挂载点）上，以使容器可以访问宿主机的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -i -t -v ~/myblog:/myblog/  express-for-docker:0.0.1</span><br><span class="line">root@31b0fac536c4:/# cd /myblog/</span><br><span class="line">root@31b0fac536c4:/myblog# ls</span><br><span class="line">blog</span><br></pre></td></tr></table></figure>

<p>如上所示，我们已经可以容器的<code>/home/myblog/</code>目录下访问到宿主机`~/myblog目录下的数据了。</p>
<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p><code>USER</code>用于指定运行镜像所使用的用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure>
<p>使用<code>USER</code>指定用户时，可以使用用户名、<code>UID</code>或<code>GID</code>，或是两者的组合。以下都是合法的指定试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure>
<p>使用<code>USER</code>指定用户后，<code>Dockerfile</code>中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>都将使用该用户。镜像构建完成后，通过<code>docker run</code>运行容器时，可以通过<code>-u</code>参数来覆盖所指定的用户。</p>
<h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p><code>WORKDIR</code>用于在容器内设置一个工作目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure>
<p>通过<code>WORKDIR</code>设置工作目录后，<code>Dockerfile</code>中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>ADD</code>、<code>COPY</code>等命令都会在该目录下执行。</p>
<p>如，使用<code>WORKDIR</code>设置工作目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>pwd</code>最终将会在<code>/a/b/c</code>目录中执行。</p>
<p>在使用<code>docker run</code>运行容器时，可以通过<code>-w</code>参数覆盖构建时所设置的工作目录。</p>
<h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p><code>ARG</code>用于指定传递给构建运行时的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>
<p>如，通过<code>ARG</code>指定两个变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG site</span><br><span class="line">ARG build_user=舒丽琦</span><br></pre></td></tr></table></figure>
<p>以上我们指定了<code>site</code>和<code>build_user</code>两个变量，其中<code>build_user</code>指定了默认值。在使用<code>docker build</code>构建镜像时，可以通过<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>参数来指定或重设置这些变量的值。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker build --build-<span class="keyword">arg</span> site=shuliqi.github.io -t express-for-docker .</span><br></pre></td></tr></table></figure>
<p>这样我们构建了 express-for-docker 镜像，其中<code>site</code>会被设置为 shuliqi.github.io，由于没有指定<code>build_user</code>，其值将是默认值<code>舒丽琦</code>。</p>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><p><code>ONBUILD</code>用于设置镜像触发器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure>
<p>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。</p>
<p>如，当镜像被使用时，可能需要做一些处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<h2 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h2><p><code>STOPSIGNAL</code>用于设置停止容器所要发送的系统调用信号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure>
<p>所使用的信号必须是内核系统调用表中的合法的值，如：<code>9</code>、<code>SIGKILL</code>。</p>
<h2 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h2><p><code>SHELL</code>用于设置执行命令（<code>shell</code>式）所使用的的默认<code>shell</code>类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br></pre></td></tr></table></figure>
<p><code>SHELL</code>在Windows环境下比较有用，Windows下通常会有<code>cmd</code>和<code>powershell</code>两种<code>shell</code>，可能还会有<code>sh</code>。这时就可以通过<code>SHELL</code>来指定所使用的<code>shell</code>类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;/S&quot;&quot;, &quot;/C&quot;]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Debounce和Throttle的原理及实现</title>
    <url>/shuliqi.github.io/2018/04/16/Debounce%E5%92%8CThrottle%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h1><p>在处理诸如<code>resize</code>,<code>scroll</code>,<code>mousemove</code> 和 <code>keydown</code>, <code>keyup</code>,<code>keypress</code>等事件的时候， 我们通常不希望这些事件太过频繁的触发。尤其是监听程序中涉及到大量的计算或者是非常耗资源的操作。</p>
 <a id="more"></a>
<p>有多频繁呢？ 我们以<code>mousemove</code>为例，根据 <a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-type-mousemove" target="_blank" rel="noopener">DOM Level 3</a> 的规定,。</p>
<blockquote>
<p>A <a href="https://www.w3.org/TR/DOM-Level-3-Events/#user-agent" target="_blank" rel="noopener">user agent</a> MUST dispatch this event when a pointing device is moved while it is over an element. The frequency rate of events while the pointing device is moved is implementation-, device-, and platform-specific, but multiple consecutive <a href="https://www.w3.org/TR/DOM-Level-3-Events/#mousemove" target="_blank" rel="noopener"><code>mousemove</code></a> events SHOULD be fired for sustained pointer-device movement, rather than a single event for each instance of mouse movement. Implementations are encouraged to determine the optimal frequency rate to balance responsiveness with performance.</p>
</blockquote>
<p>大概的意思就是：<strong>如果鼠标连续的移动，那么浏览器就应该触发多个连续的<code>mousemove</code>事件。</strong></p>
<p>这就说明了浏览器在其内部计时器允许的情况下，根据用户鼠标的速度来触发<code>mousemove</code>事件。(当然了， 如果移动鼠标足够快，比如“刷”的一下扫过去，浏览器是不会触发的这个事件的），<code>resize</code>,<code>scroll</code> 和<code>key*</code>等事件于此类似。</p>
<p>具体的可以看例子体会下 <a href="https://codepen.io/shuliqi/pen/NWGNXWv?editors=1010" target="_blank" rel="noopener">鼠标滑动 </a></p>
<h1 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h1><p> DOM事件里的<code>debounce</code>概念其实是从机械开关和继电器的“去弹跳(debounce)”衍生出来的，基本的思路就是把多个信号的合并为一个信号。</p>
<p>在Javascript中， <code>debounce</code>函数所做的事情就是：强制某一个函数在某个连续的时间段内只执行一次，哪怕它本来会被调用很多次。即我们希望用户在停止某个操作一段时间之后才执行相应的舰艇函数，而不是在用户操作的过程中，浏览器触发多少次事件，就执行多少次舰艇函数。</p>
<p>比如，在某个5s的时间段内连续移动了鼠标，浏览器就可能会触发几十个（甚至几百个）<code>mousemove</code> 事件， 不使用<code>debounce</code>的话，监听函数就要执行这么多次；如果对监听函数使用1000ms的“去弹跳”。 那么浏览器就只会<strong>执行一次</strong>这个监听函数， 而且是在第6s的时候执行的。</p>
<p>那如何实现一个<code>ddebunce</code> 函数呢？</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们<code>debunce</code>函数接受三个参数， 第一个参数是要“去弹跳”的回调函数<strong>func</strong>, 第二个参数是延迟的时间<strong>wait</strong>，第三个参数<strong>immediate</strong>表示在wait 这个时间区间内做开始执行(<strong>immediate = true</strong>)还是最后执行(<strong>immediate = false</strong>)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* debounce函数， 返回函数连续调用时， 空闲时间必须大于或者等于wait, func 才会执行</span></span><br><span class="line"><span class="comment">* @param &#123;function&#125; func 回调函数</span></span><br><span class="line"><span class="comment">* @param &#123;number&#125; wait 回调函数延迟调用的时间</span></span><br><span class="line"><span class="comment">* param &#123;booleam&#125; 是否为立即调用</span></span><br><span class="line"><span class="comment">* @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate = true</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, args;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 延迟执行函数</span></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 延迟执行函数执行完毕，  需要清除定时器序号</span></span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 首次进入， 没有延迟函数，创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = later();</span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        <span class="comment">// 如果立即执行， 则调用函数</span></span><br><span class="line">        func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存调用函数时的上下文和参数</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果已经存在延迟函数，清除，再重新设定</span></span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>其实原理很简单，<code>debounce</code>返回了一个闭包， 这个闭包依然会被连续的频繁的调用。但是在闭包的内部， 却限制了原始函数<strong>func</strong>的执行， 强制<strong>func</strong>只能在连续操作停止后只执行一次。</p>
<h3 id="调用及例子"><a href="#调用及例子" class="headerlink" title="调用及例子"></a>调用及例子</h3><p>调用方式如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wwindow.addEventListener(<span class="string">'resize'</span>, debounce(handle, <span class="number">1000</span>, <span class="literal">false</span>))</span><br></pre></td></tr></table></figure>
<p><strong><a href="https://codepen.io/shuliqi/pen/vYNGeZR" target="_blank" rel="noopener">一个小小的keydown例子</a></strong></p>
<h1 id="Throttle"><a href="#Throttle" class="headerlink" title="Throttle"></a>Throttle</h1><p><code>throttle</code>理解起来更容易，就是<code>固定函数执行的速率</code> 即所谓的<code>节流</code>。举个例子，正常的情况下，<code>mousemove</code>的监听函数可能会20ms(假设)执行一， 如果设置200ms的”节流“。那么它就会<strong>每200ms</strong>执行一次。 比如在1s的时间段内，正常的监听函数可能会执行50（1000/20）次。”节流”的就会执行5（1000/200）次。</p>
<p>我们来看个例子：<strong><a href="https://codepen.io/shuliqi/pen/WNQGQbV" target="_blank" rel="noopener">例子</a></strong>无论我鼠标移动的有多快， 我的count 都是匀速（每隔1s）增加。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>与<code>debounce</code>类似， 我们<code>throttle</code>    也接收<code>func</code>（一个实际要执行的函数），<code>wait</code>一个执行时间间隔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param func &#123;Function&#125;   实际要执行的函数</span></span><br><span class="line"><span class="comment">* @param wait &#123;Number&#125;  执行间隔，单位是毫秒（ms）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return &#123;Function&#125;     返回一个“节流”函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args;</span><br><span class="line">  <span class="comment">// 设置前一个函数调用的时间戳</span></span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">if</span> (!previous) &#123;</span><br><span class="line">      <span class="comment">// 首次进入</span></span><br><span class="line">      previous = now;</span><br><span class="line">     </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      context = <span class="keyword">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="keyword">let</span> remaining = wait - (now - previous);</span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        previous = now;</span><br><span class="line">        context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用及例子-1"><a href="#调用及例子-1" class="headerlink" title="调用及例子"></a>调用及例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, throttle(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p><code>throttle</code>常用的场景是限制<code>resize</code>和<code>scroll</code>的触发频率。我们以scroll 为例子<strong><a href="https://codepen.io/shuliqi/pen/NWGRGQr" target="_blank" rel="noopener">scroll例子</a> <a href="https://codepen.io/shuliqi/pen/ExVKwEW" target="_blank" rel="noopener">resize例子</a> </strong> </p>
<h1 id="可视化解释"><a href="#可视化解释" class="headerlink" title="可视化解释"></a>可视化解释</h1><p>如果还是不能完全体会<code>debounce</code>和<code>throttle</code>的差异， 可以看这个例子 <strong><a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">可视化例子</a></strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>debounce</code>强制函数在某段时间内只执行一次，<code>throttle</code>强制函数以固定的速率执行，在处理一些高频率触发的DOM 事件的时候， 它们都能极大提高用户体验。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6学习笔记-Class</title>
    <url>/shuliqi.github.io/2018/04/10/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Class/</url>
    <content><![CDATA[<p><code>ES6</code>的<code>Class</code>很多大部分的功能，<code>ES5</code>都是可以实现的， 但是为什么还有出<code>Class</code>呢? 这是因为<code>ES5</code>中生成实例对象的方法是通过构造函数生成的。 这与我们所接触的很多语言（C++）差异很大。于是<code>ES6</code>就提供了跟传统语言的写法。可以说<code>Class</code>是一个语法糖。</p>
<a id="more"></a>
<h1 id="类与ES5"><a href="#类与ES5" class="headerlink" title="类与ES5"></a>类与ES5</h1><p><code>ES6</code>的<code>Class</code>与<code>ES5</code>的构造函数有什么不一样呢？</p>
<p>我们先看<code>ES5</code>如何生成实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 父类实例对象属性：name</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">   <span class="comment">// 父类实例对象属性：age</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型方法</span></span><br><span class="line">People.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型方法</span></span><br><span class="line">People.prototype.getNane = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new 操作符生成实例对象people</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">'shuliqi'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(people)</span><br><span class="line">people.getAge();  <span class="comment">// 18</span></span><br><span class="line">people.getNane(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>上面代码我们有一个构造函数<code>People</code> ；<code>this</code>关键字代表实例对象，实例对象上有两个属性（<code>name</code>, <code>age</code> ） 在原型有两个方法（<code>getName</code>, <code>getAge</code>）。通过<code>new</code>的方式生成实例对象<code>people</code>；</p>
<p>我们把上面的代码改成用<code>class</code>来写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改成class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">     <span class="comment">// 父类实例对象属性：name</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">     <span class="comment">// 父类实例对象属性：age</span></span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法</span></span><br><span class="line">  getNane() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法</span></span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new 操作符生成实例对象people</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">'shuliqi'</span>, <span class="number">18</span>);</span><br><span class="line">people.getAge();  <span class="comment">// 18</span></span><br><span class="line">people.getNane(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>上面代码我们定义来看一个 类叫<code>People</code>；里面的<code>constructor</code>方法就是构造方法、<code>this</code>表示实例对象(也就是<code>new People</code>返回的对象)的本身。<code>People</code>类里有 <code>getName</code>,<code>getAge</code>原型方法。<strong>类里面的方法都是在类的原型上创建的</strong>我们在<strong>类里面写方法的时候是不需要写<code>function</code>关键字</strong>；并且<strong>方法与方法之间是不需要逗号分隔的，加了反而会报错</strong></p>
<p>总归来说， <code>ES6</code>的类就是构造函数的另外一种写法。为什么这么说呢？我们对比一下<code>ES5</code>:</p>
<ul>
<li><p><strong>类的数据类型就是函数。类本身就指向构造函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> People); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(People.prototype.constructor === People); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> People); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(People.prototype.constructor === People); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用类的时候都是直接通过<code>new</code>的命令来使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>ES6</code>的类也有在<code>prototype</code>属性。类中定义的所有方法都是定义在类的<code>prototype</code>属性上面</strong>；</p>
<p>首先我们先来了解<code>ES5</code>的一些概念：</p>
<p><strong>构造函数：</strong></p>
<p>js规定，每个构造函数都有一个<code>prototype</code>属性，指向另外一个对象（我们也叫原型对象或者<code>prototype对象</code>），这个对象的所有属性和方法都会被构造函数所拥有，我们通常把不变的方法方法定义在<code>prototype对象</code>上，这样构造函数生成的实例对象就可以共享这些方法。</p>
<p><strong>实例对象：</strong></p>
<p>构造函数生成的实例对象有一个属性<code>__proto__</code>，指向构造函数的原型对象；所有构造函数生成的实例对象的<code>__proto__</code>与构造函数的<code>prototype</code>是等价的；</p>
<p>实例对象方法和属性的查找规则：先在对象自己身上找，没有再去构造函数的原型对象上查找，还是没有就继续沿着原型链查找。</p>
<p>回到正题：我们<code>ES6</code>的<code>类</code>也是有如<code>ES5</code>这么一套逻辑的(即有自己的prototype属性)。类中定义的方法都是定义在类的<code>prototype对象上</code>的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;&#125;</span><br><span class="line">  getName() &#123;&#125;</span><br><span class="line">  getAge() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line">People.prototype.constructor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">People.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">People.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们类生成的实例上调用的方法其实都是调用<code>prototype</code>对象上的方法。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;&#125;</span><br><span class="line">  getName() &#123;&#125;</span><br><span class="line">  getAge() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line"><span class="built_in">console</span>.log(people.constructor === People.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(people.getName === People.prototype.getName);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(people.getAge === People.prototype.getAge);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是<code>ES6</code>的类与<code>ES5</code>的构造函数还是有不一样的地方的，我们看</p>
<ul>
<li><p><strong>类中定义的方法都是不可枚举的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(People.prototype); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(People.prototype); <span class="comment">// [ 'constructor', 'getName', 'getAge' ]</span></span><br></pre></td></tr></table></figure>
<p>可以看出不可枚举。但是<code>ES5</code>写的构造函数定义的方法是可以枚举的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(People.prototype); <span class="comment">// [ 'getName', 'getAge' ]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(People.prototype); <span class="comment">// [ 'constructor', 'getName', 'getAge' ]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>我们在定义类的时候， 必须有<code>constructor</code>方法，<code>constructor</code>方法是默认方法，如果没有显式的定义，一个空的<code>constructor</code>方法会默认添加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中我们定义了一个空类 <code>People</code>，js引擎会自动给它添加<code>constructor</code>方法。</p>
<p>使用<code>new</code>生成对象的时候， 会自动调用该方法。<code>constructor</code>方法默认返回实例对象(即<code>this</code>)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'使用new命令生成实例的时候， 会被自动调用'</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line"><span class="comment">// 使用new命令生成实例的时候， 会被自动调用</span></span><br></pre></td></tr></table></figure>
<p>我们使用<code>new</code>命令生成实例的时候，<code>constructor</code>方法会被调用。</p>
<p>类使用的时候必须使用<strong>new 调用，否则会报错。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'使用new命令生成实例的时候， 会被自动调用'</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people =  People();</span><br><span class="line"><span class="comment">// TypeError: Class constructor People cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure>
<p>但是普通构造函数式可以不用<code>new</code>的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'调用'</span>)</span><br><span class="line">&#125;</span><br><span class="line">People(); <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>
<h1 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h1><p>生成一个类的实例，也是使用一个<code>new</code>命令。如果不用，将会报错（上一节说过）；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Class constructor People cannot be invoked without 'new'</span></span><br><span class="line"><span class="keyword">const</span> people = People(<span class="string">'shuliqi'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">// 生成类 People 的实例people</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">'shuliqi'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>在一个类中， 属性除非是定义在本身(即定义在this对象上)。否则都是定义在原型上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">'shuliqi'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(  people.getAge()  ); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(  people.hasOwnProperty(<span class="string">'name'</span>)  ) <span class="comment">//  true</span></span><br><span class="line"><span class="built_in">console</span>.log(  people.hasOwnProperty(<span class="string">'age'</span>)  ) <span class="comment">//  true</span></span><br><span class="line"><span class="built_in">console</span>.log(  people.hasOwnProperty(<span class="string">'getName'</span>)  ) <span class="comment">//  false</span></span><br><span class="line"><span class="built_in">console</span>.log(  people.hasOwnProperty(<span class="string">'getAge'</span>)  ) <span class="comment">//  false</span></span><br><span class="line"><span class="built_in">console</span>.log(  people.__proto__.hasOwnProperty(<span class="string">'getAge'</span>)  ) <span class="comment">//  true</span></span><br></pre></td></tr></table></figure>
<p>这代码我们定义了一个类叫<code>People</code>，属性<code>name</code>,<code>age</code>实例对象<code>people</code>的自身属性(因为定义在<code>this</code> 上), 所有<code>hasOwnProperty()</code>方法返回了<code>true</code>。而<code>getName</code>,<code>getAge</code>是原型对象的属性（因为定义在类上）。所以<code>hasOwnProperty()</code>返回<code>false</code>。</p>
<p>跟上面讲过的一样，类的实例共享一个原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> People(<span class="string">'shuliqi'</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> People(<span class="string">'shulina'</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log( p1.__proto__ === p2.__proto__ ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h1><p>类的属性名可以采用表达式，和<code>ES5</code>也是一样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法名变量(表达式)</span></span><br><span class="line"><span class="keyword">const</span> getName = <span class="string">'getName'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  [getName]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">'shuliqi'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(  people.getName()  ); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>People</code>类的方法名<code>getName</code>，是从表达式得到的。</p>
<h2 id="取值函数-getter-和存值函数-setter"><a href="#取值函数-getter-和存值函数-setter" class="headerlink" title="取值函数(getter)和存值函数(setter)"></a>取值函数(getter)和存值函数(setter)</h2><p>在类的内部可以使用<code>get</code>,<code>set</code>关键字。对一个属性进行设置值和取值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> name(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.name = <span class="string">'shuliqi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(people.name); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 我们存取值函数的函数名和里面的变量名不能一致。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> name(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.name = <span class="string">'shuliqi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(people.name); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>这样写是会报错的。这是因为，在构造函数中执行<code>this.name=name</code>的时候，就会去调用<code>set name</code>，在set name方法中，我们又执行<code>this.name = name</code>，进行无限递归，最后导致栈溢出(RangeError)。</p>
<h2 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h2><p>类也可以使用表达式的方式定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> People = <span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="comment">// MyPeople 只能在类的内部使用</span></span><br><span class="line">    MyPeople.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在外部只能使用类的引用名：People</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">'shuliqi'</span>)</span><br></pre></td></tr></table></figure>
<p>如上，我们使用表达式的方式定义了一个类。这个类的名字是<code>MyPeople</code>。但是<code>MyPeople</code>只能在类的内部使用，指向的是当前类。在类的外部只能使用<code>People</code>引用。</p>
<p>当然， 如果内部不用， 可以省略类名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> People = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在外部只能使用类的引用名：People</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">'shuliqi'</span>)</span><br></pre></td></tr></table></figure>
<p>采用表达式定义类， 可以写出立即执行的<code>Class</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'shuliqi'</span>)</span><br><span class="line">people.getName();</span><br><span class="line"><span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<h1 id="Class-注意的点"><a href="#Class-注意的点" class="headerlink" title="Class 注意的点"></a>Class 注意的点</h1><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>类和模块的内部默认就是严格模式，所以我们不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类和模块当中。就只有严格模式可以使用。</p>
<h2 id="不存在提升"><a href="#不存在提升" class="headerlink" title="不存在提升"></a>不存在提升</h2><p>类是不存在提升的（这和<code>ES5</code>完全是不一样的）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不存在声明提升， 在一个类定义好之前使用，直接报错</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// ReferenceError: Cannot access 'People' before initialization</span></span><br></pre></td></tr></table></figure>
<p>上面的代码 <code>People</code>类使用在前，定义在后，这样使用是会报错的。因为<code>ES6</code> 不会把类的声明提升到代码块的顶部的。那为什么有这样的规定呢？ 这是有原因：这和继承有关，必须保证子类在父类之后定义；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> People = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码不会出错，因为<code>Mypeople</code>在继承<code>People</code>的时候，<code>People</code>已经定义了。但是如果存在类的声明提升，上面的代码就会出错了，这是因为<code>class</code> 会被提升到代码块的顶部， 但是<code>let</code>不会提升，就会导致<code>Mypeople</code>在继承<code>People</code>的时候。<code>People</code>没有定义。</p>
<h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">People</span> </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(People.name); <span class="comment">// People</span></span><br></pre></td></tr></table></figure>
<h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p>类的达内部如果有<code>this</code>，它默认指向类的实例，但是单独使用该方法的时候，就可能会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">'shuliqi'</span>);</span><br><span class="line">people.getName();  <span class="comment">// shuliqi</span></span><br><span class="line"><span class="keyword">const</span> &#123; getName &#125; = people;</span><br><span class="line">getName(); <span class="comment">// TypeError: Cannot read property 'name' of undefined</span></span><br></pre></td></tr></table></figure>
<p>类<code>People</code>的方法<code>getName</code>中的<code>this</code>默认指向<code>People</code>的实例。但是这个方法提取出来单独调用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到name属性而报错。</p>
<p>解决的办法可以使用箭头函数。如下这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">'shuliqi'</span>);</span><br><span class="line">people.getName();  <span class="comment">// shuliqi</span></span><br><span class="line"><span class="keyword">const</span> &#123; getName &#125; = people;</span><br><span class="line">getName(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>箭头函数内部的<code>this</code>在定义的时候就确定好了，箭头函数的<code>this</code>总是指向外层第一个普通函数的<code>this</code>。上面代码中，箭头函数构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象。关于this指向的问题可以看这篇文章</p>
<p><a href="https://shuliqi.github.io/shuliqi.github.io/2018/07/02/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/">关于this的指向问题</a></p>
<h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><p>类相当于实例的原型，所有在类中定义的方法，都会被继承，如果我们不想让一个方法被继承，可以在方法名前加<code>static</code>关键字，该方法就就不会被实例继承，只能通过类直接调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态方法 getName</span></span><br><span class="line">  <span class="keyword">static</span> getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shuliqi'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">People.getName(); <span class="comment">// shuliqi</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.getName(); <span class="comment">// people.getName is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面定义了一个类<code>People</code>, 类<code>People</code>里面定义了一个静态方法<code>getName</code>, 该方法只能类<code>People直接调用</code>，实例<code>people</code>调用的话直接报错（该方法不存在）</p>
<p><strong>注意：</strong> 如果在静态方法中有<code>this</code>关键字，这个<code>this</code>指向类，而不是实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">19</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法，只能类调用，实例不能调用</span></span><br><span class="line">  <span class="keyword">static</span> getAge() &#123;</span><br><span class="line">    <span class="comment">// 静态方法中的this 指向 类，而不是实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类属性</span></span><br><span class="line">People.age = <span class="number">900</span>;</span><br><span class="line">People.getAge(); <span class="comment">// 900</span></span><br></pre></td></tr></table></figure>
<p>静态方法可以与非静态方法重名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> getAge() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通方法</span></span><br><span class="line">  getAge() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure>
<p>父类的静态方法是可以被子类继承的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> getAge() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类可以继承父类的静态方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;&#125;</span><br><span class="line">MyPeople.getAge(); <span class="comment">// 子类可以继承父类的静态方法</span></span><br></pre></td></tr></table></figure>
<h1 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h1><p>实例属性除了可以定义在<code>constructor</code>方法中的<code>this</code>上，也可以直接定义在类的最顶层。这样的写法看上去比较整齐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  name = <span class="string">'shuliqi'</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,  <span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.get(); <span class="comment">// shuliqi 10</span></span><br></pre></td></tr></table></figure>
<h1 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h1><p>静态属性是指 <code>Class</code> 本身的属性.即<code>Class.propName</code>，而不是定义在对象（<code>this</code>）的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"> getAge() &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">People.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(People.age); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.getAge(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>这表示给类<code>People</code>添加了静态属性<code>age</code>。只能<code>People.age</code>调用。 在<code>this</code> 是取不到的（<code>people.getAge(); // undefined</code>）</p>
<p>第二种方式，在实例属性前面添加<code>static</code>关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> name = <span class="string">'shuliqi'</span>;</span><br><span class="line"> getName() &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">People.name = <span class="string">'shulina'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(People.name); <span class="comment">// shulina</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.getName(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><p>类可以通过<code>extends</code>关键字实现继承。比ES5 那么多继承方式方便的多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,  <span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">     <span class="keyword">super</span>(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople(<span class="string">'shuliqi'</span>);</span><br><span class="line"><span class="comment">// ReferenceError:: Must call super constructor in derived class before accessing 'this' or returning from derived constructor</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个类 <code>MyPeople</code>, 通过关键字<code>extends</code>继承了 <code>People</code>类的所有属性和方法。我们看到<code></code>MyPeople<code>的构造函数和</code>getName<code>使用了</code>super<code>。那</code>super`这代表什么呢? 我们之后下面有讲到。</p>
<p>需要注意： 在子类的<code>construtor</code>中必须是用<code>super</code>方法。否则在新建实例的时候会报错。为什么呢？这是因为子类的<code>this</code>对象必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法。如果不调用<code>super</code>方法的话，子类就将得不到<code>this</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,  <span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">     <span class="comment">// super(...arguments)</span></span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople(<span class="string">'shuliqi'</span>);</span><br><span class="line"><span class="comment">// ReferenceError:: Must call super constructor in derived class before accessing 'this' or returning from derived constructor</span></span><br></pre></td></tr></table></figure>
<p>这代码中，子类<code>MyPeople</code>继承了父类<code>People</code>, 但是在它的构造函数中没有调用<code>super</code>方法，导致在新建实例的时候报错。</p>
<p><strong>必须先调用super方法的原因：</strong></p>
<p>ES5的继承方式：先创造子类的实例对象的<code>this</code>。然后再把父类的属性和方法加到this上面来。</p>
<p>ES6的继承方式：先将父类实例的属性和方法加到this上面来(所以必须先调用super方法)。然后再用子类的构造函数修改<code>this</code></p>
<p> 跟定义类一样，如果子类没有定义construtor方法，那么这个方法就会被默认加上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类的构造函数中， 只有调用了<code>super</code> 方法之后，才可以使用this关键字，不然就会报错。这是因为子类的实例的创建基于父类实例，只有`super方法才能调用父类实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,  <span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="comment">// 在调用super()之前使用this</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">super</span>(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople(<span class="string">'shuliqi'</span>);</span><br><span class="line"><span class="comment">// ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor</span></span><br></pre></td></tr></table></figure>
<p>上面的代码在子类<code>MyPeople</code>的<code>constructor</code>方法中在使用<code>super()</code>之前是用了<code>this</code>。结果在创建实例的时候报错。</p>
<p>上面有讲过父类的静态方法也会被子类继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父类的静态方法</span></span><br><span class="line">  <span class="keyword">static</span> getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shuliqi'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, sex) &#123;</span><br><span class="line">    <span class="comment">// 调用super方法</span></span><br><span class="line">    <span class="keyword">super</span>(name, age);</span><br><span class="line">    <span class="keyword">this</span>.sex = sex; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类继承了父类的静态方法，所以可以调用父类的静态方法</span></span><br><span class="line">MyPeople.getName(); <span class="comment">//  shuliqi</span></span><br></pre></td></tr></table></figure>
<h1 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h1><p><code>Object.getPrototypeOf()</code>该方法用于从子类获取父类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,  <span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="comment">// 在调用super()之前使用this</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">super</span>(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(MyPeople) === People) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h1 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h1><p>super关键字可以当函数使用，也可以当对象使用。这里可以分成下面这几类来：</p>
<h2 id="super作为函数使用"><a href="#super作为函数使用" class="headerlink" title="super作为函数使用"></a>super作为函数使用</h2><p><code>super</code>作为函数使用时，代表父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的构造函数'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// super作为函数使用时，代表父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line"><span class="comment">// 父类的构造函数</span></span><br></pre></td></tr></table></figure>
<p>这段代码子类<code>MyPeople</code>的<code>constructor</code>函数中，<strong><code>super</code>作为函数调用，代表父类的构造函数</strong>。</p>
<p><strong>注意：</strong>作为函数使用， 只能在子类的构造函数中使用，在其他地方使用的话是会报错的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的构造函数'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// super当函数使用时，代表父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="comment">// super作为函数调用时，只能在constructor中使用</span></span><br><span class="line">    <span class="comment">// 在其他地方使用报错</span></span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// SyntaxError: 'super' keyword unexpected here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br></pre></td></tr></table></figure>
<h2 id="super作为对象在普通方法中使用是指向父类的原型对象"><a href="#super作为对象在普通方法中使用是指向父类的原型对象" class="headerlink" title="super作为对象在普通方法中使用是指向父类的原型对象"></a>super作为对象在普通方法中使用是指向父类的原型对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="comment">// 父类实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'父类实例属性'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类原型方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类原型普通方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="comment">// super在子类作为对象使用，并且在普通方法中，那么super指向父类的原型对象</span></span><br><span class="line">    <span class="keyword">super</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line">people.getName(); <span class="comment">// 父类原型方法</span></span><br></pre></td></tr></table></figure>
<p><code>super</code>作为对象在普通方法中使用是指向父类的原型对象（<code>prototype</code>对象）。</p>
<p><strong>注意：</strong>由于这种情况，<code>super</code>指向父类的原型对象，所以定义在父类实例上的属或者方法是没有办法通过<code>super</code>调用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="comment">// 父类实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'父类实例属性'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类原型方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类原型普通方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="comment">// super在子类作为对象使用，并且在普通方法中，那么super指向父类的原型对象</span></span><br><span class="line">    <span class="comment">// 所以定义在父类实例上的属性或者方法是不能通过super调用的</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line">people.getName(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>调用<code>super.name</code>返回<code>undefined</code>。</p>
<p>如果是定义在父类的原型上就可以取到了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="comment">// 父类实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'父类实例属性'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类原型方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型对象属性</span></span><br><span class="line">People.prototype.name = <span class="string">'父类原型对象属性'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类原型普通方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="comment">// super在子类作为对象使用，并且在普通方法中，那么super指向父类的原型对象</span></span><br><span class="line">    <span class="comment">// 如果name定义在父类原型对象上，那么久可以取到</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line">people.getName(); <span class="comment">// 父类原型对象属性</span></span><br></pre></td></tr></table></figure>
<h2 id="super作为对象在普通方法中调用父类原型的方法，该方法内部的this指向子类的实例-this"><a href="#super作为对象在普通方法中调用父类原型的方法，该方法内部的this指向子类的实例-this" class="headerlink" title="super作为对象在普通方法中调用父类原型的方法，该方法内部的this指向子类的实例(this)"></a>super作为对象在普通方法中调用父类原型的方法，该方法内部的this指向子类的实例(this)</h2><p>这句话看着好大，但是我们可以分析简单理解下。父类的方法都是定义在原型对象上面，而super作为对象在普通方法中使用时指向父类的原型，所以不用说的那么复杂，可以说成<strong>super作为对象在普通函数中调用方法，改方法内部的this指向子类的实例(即this)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="comment">// 父类实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'父类实例属性'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型对象属性</span></span><br><span class="line">People.prototype.name = <span class="string">'父类原型对象属性'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'子类实例属性'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类原型普通方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="comment">// super在子类作为对象使用，并且在普通方法中，调用方法，那么改方法中的this指向子类的实例（this）</span></span><br><span class="line">    <span class="keyword">super</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line">people.getName(); <span class="comment">// 子类实例属性</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>super.getName();</code>虽然调用的是<code>People.prototype.getName()</code>。 但是<code>People.prototype.getName()</code>中的<code>this</code> 指向的是子类<code>MyPeople</code>的实例。 导致输出的是”子类实例属性” 而不是“父类实例属性”</p>
<h2 id="super作为对象在静态方法中是指向父类。"><a href="#super作为对象在静态方法中是指向父类。" class="headerlink" title="super作为对象在静态方法中是指向父类。"></a>super作为对象在静态方法中是指向父类。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; </span><br><span class="line">    <span class="keyword">this</span>.age = <span class="string">'父类实例属性'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类静态方法（只能 People.getName()调用）</span></span><br><span class="line">  <span class="keyword">static</span> getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类静态方法'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.age = <span class="string">'父类原型属性'</span></span><br><span class="line">People.age = <span class="string">'父类属性'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类静态方法（只能MyPeople.getName()调用）</span></span><br><span class="line">  <span class="keyword">static</span> getName() &#123;</span><br><span class="line">    <span class="comment">// 作为对象在子类静态方法中使用，super指向父类(People)，而不是父类的原型(Pepple.prototype)</span></span><br><span class="line">    <span class="keyword">super</span>.getName();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.age);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPeople.getName(); </span><br><span class="line"><span class="comment">// 父类静态方法</span></span><br><span class="line"><span class="comment">// 父类属性</span></span><br></pre></td></tr></table></figure>
<p>super作为对象在子类的静态方法使用，super指向父类(People)，而不是父类的原型(People.prototype)。</p>
<h2 id="super作为对象在静态方法中调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。"><a href="#super作为对象在静态方法中调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。" class="headerlink" title="super作为对象在静态方法中调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。"></a>super作为对象在静态方法中调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; </span><br><span class="line">    <span class="keyword">this</span>.age = <span class="string">'父类实例属性'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类静态方法（只能 People.getName()调用）</span></span><br><span class="line">  <span class="keyword">static</span> getName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="string">'子类实例属性'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类静态方法（只能MyPeople.getName()调用）</span></span><br><span class="line">  <span class="keyword">static</span> getName() &#123;</span><br><span class="line">    <span class="comment">// 作为对象在子类静态方法中使用，super指向父类(People)，而不是父类的原型(Pepple.prototype)</span></span><br><span class="line">    <span class="comment">// 调用父类方法，方法中的this指向子类(MyPeople)，而不是子类的原型(MyPeople.prototype)</span></span><br><span class="line">    <span class="keyword">super</span>.getName();</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPeople.prototype.age = <span class="string">'子类原型属性'</span>;</span><br><span class="line">MyPeople.age = <span class="string">'子类属性'</span>;</span><br><span class="line">MyPeople.getName();  <span class="comment">// 子类属性</span></span><br></pre></td></tr></table></figure>
<p>super作为对象在子类的静态方法调用（<code>super.getName();</code>）这里的<code>super.getName() === People.getName()</code>。虽然调用的是<code>People.getName()</code>但是方法中的this指向的是子类(<code>MyPeople</code>).所以<code>this.age === MyPeople.age</code>  结果为：“子类属性”</p>
<h2 id="使用super设置属性的话，那么super就是当前的this。"><a href="#使用super设置属性的话，那么super就是当前的this。" class="headerlink" title="使用super设置属性的话，那么super就是当前的this。"></a>使用super设置属性的话，那么super就是当前的this。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 父类实例的属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">38</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类的属性</span></span><br><span class="line">People.sex = <span class="number">30</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用super设置属性，就是当前的this，所有给当前的实例的属性age设置值为20</span></span><br><span class="line">    <span class="keyword">super</span>.age = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 普通方法中，super作为对象的话，指向父类的原型；</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.age); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined ---&gt; 父类的原型没有age属性</span></span><br><span class="line"><span class="comment">// 20 ---&gt;使用super设置属性，就是当前的this，所有给当前的实例的属性age设置值为20</span></span><br></pre></td></tr></table></figure>
<p>学习都是来自[<a href="https://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">ECMAScript 6 入门–Class</a>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的必要性及基础使用</title>
    <url>/shuliqi.github.io/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在阅读我们Docker的 <a href="https://www.docker.com/" target="_blank" rel="noopener">官方文档</a>我们知道：</p>
<ul>
<li>Docker  是世界领先的软件容器平台。</li>
<li><p>使用Docker 可以使开发人员消除一起协作开发遇到的一些问题；如”在我的电脑上可正常运行”。</p>
<a id="more"></a>
</li>
<li><p>使用Docker 可以使运维人员在隔离容器中并行运行和管理应用，获得更好的计算密度。</p>
</li>
<li>使用Docker 企业可以构建敏捷的软件交付管道，以更快的速度，更高的安全性和可靠的信誉为 Linux 和 Wiindows Server 应用发布新功能。</li>
</ul>
<p>那么我们为什么需要 Docker 呢？</p>
<h2 id="环境配置的难题"><a href="#环境配置的难题" class="headerlink" title="环境配置的难题"></a>环境配置的难题</h2><p>我们开发一般在写程序，需要好多个环境，主要的可以分为：</p>
<ul>
<li><strong>开发环境：</strong>我们自己本地写代码的环境；</li>
<li><strong>测试环境：</strong> 提供给测试伙伴测试的环境；</li>
<li><p><strong>生产环境：</strong>测试完成可以上线的环境；</p>
<p>我们在开发和学习编辑过程中， 好多时间都浪费在环境上：</p>
</li>
<li><p>如果重装了系统。我之前的项目，就得弄好多的配置，才能跑起来。比如配置MySQL，配置各种的环境变量等；</p>
</li>
<li>假如我们在网上学习跟这老师的步骤去写Demo,不知道你们遇到没，反正有些Demo我总有Bug。</li>
<li>我们在本地开发环境一切安好， 但是在测试环境上就出错了，或者测试环境是好的，一上线也是各种报错(心累~~);</li>
</ul>
<p>所以就有“千万不要和程序员说，你的代码有bug”这样的笑话：</p>
<ul>
<li>程序员的第一反应是你的环境有问题，第二就是你不会使用吧。</li>
<li>你要是跟他说“这个程序运行的怎么跟预期的不一样啊，是不是我操作的问题啊？”。</li>
<li>我们就会第一反应:“这是不是出bug了”</li>
</ul>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另外一种操作系统，比如我在 Windows 系统里面运行 Linnux 系统。应用程序对此是毫无感知的，，因为虚拟机看上去跟真实系统一摸一样，对于底成系统来说，虚拟机就是一个普通的文件，不需要了就删掉，对其他部分毫无影响。</p>
<p>虽然我们可以通过虚拟机还原软件的的原始环境，但是这个方案有几点缺点：</p>
<ul>
<li><p><strong>资源占用多</strong></p>
<p>虚拟机会独自占用一部分内存和硬盘空间，它运行的时候其他程序就无法使用这些资源了，哪怕虚拟机里面的应用程序真正使用的内存只有1MB，虚拟机依然会需要几百MB的内存才能运行。</p>
</li>
<li><p><strong>繁琐的步骤多</strong></p>
<p>虚拟机是完整的操作系统，一些系统级别的步骤是无法跳过的，如用户登陆。</p>
</li>
<li><p><strong>启动慢</strong></p>
<p>启动操作系统需要多久的时间，启动虚拟机就需要多久的时间，可能需要等特别长的时间，应用程序才会运行。</p>
</li>
</ul>
<h2 id="Linux容器"><a href="#Linux容器" class="headerlink" title="Linux容器"></a>Linux容器</h2><p>由于虚拟机存在这些缺点，Linux发明出了另外一种虚拟化技术；linux容器(Linux Container)LXC.。</p>
<p>Linux容器不是模拟一个完整的的操作系统，而是对进程进行隔离。或者说，在正常的进程外面套了一个保护层，对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>由于容器是进程级别的，所以相比虚拟机有很多的优势：</p>
<ul>
<li><p><strong>启动快</strong></p>
<p>容器里面的应用直接就是底层系统的一个进程，，而不是虚拟机内部的进程，所以启动容器就相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多了。</p>
</li>
<li><p><strong>资源占用小</strong></p>
<p>容器只占用需要的资源，不占用那些不需要额资源；虚拟机由于是完整的操作系统，不可避免的要占用所有的资源，另外，多个容器可以共享资源，虚拟机都是独享资源。</p>
</li>
<li><p><strong>体积小</strong></p>
<p>容器只需要打包用到的组件即可，而虚拟机是整个系统的打包，所以容器文件比虚拟机文件要小很多。</p>
</li>
</ul>
<p>最后说明，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销就小很多。</p>
<h2 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a>Docker是什么？</h2><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</p>
<p>它是目前最流行额 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖打包在一个文件里面，运行这个文件，就会生成一个虚容器。程序在这个虚拟容器运行， 就好像在真实的物理机上运行一样。有了 Docker 就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当的简单， 用户可以方便的创建和使用容器，把自己的应用放入容器，容器还可以进行版本管理，复制，分享，修改，就像管理普通的代码一样。</p>
<h2 id="Docker-的用途"><a href="#Docker-的用途" class="headerlink" title="Docker 的用途"></a>Docker 的用途</h2><p>Docker 的主要用途，目前主要有三大类：</p>
<ul>
<li><p><strong>提供一次性的环境</strong></p>
<p>比如：本地测试他人的软件，持续集成的时候提供单元测试和构建环境。</p>
</li>
<li><p><strong>提供弹性的云服务</strong></p>
<p>因为 Docker 容器可以随关随开，，很适合动态扩容和缩容。</p>
</li>
<li><p><strong>组建微服务架构</strong></p>
<p>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构</p>
</li>
</ul>
<h2 id="Docker-的基本概念"><a href="#Docker-的基本概念" class="headerlink" title="Docker 的基本概念"></a>Docker 的基本概念</h2><p>Docker 包含三个基本概念</p>
<ul>
<li><p><strong>镜像（image）</strong></p>
<p>操作系统分为内核和用户空间，就Linux而言，内核启动后，，会挂载<code>root</code>文件系统为其提供用户空间支持。而 Docker镜像，就相当于一个 <code>root</code>文件系统。 Docker镜像就是一个特殊的文件系统，除了提供容器运行时所需的程序，库，资源，配置等文件外，还包含了一些为运行时准备的一些配置参数（如：匿名卷，，环境变量，用户等）。镜像不包含任何的动态数据，，其内容在构建完成之后也不会改变。</p>
</li>
<li><p><strong>容器（container）</strong></p>
<p>镜像（image）和 容器（container）的关系，就像面向对象设计中的 <code>类</code> 和 <code>实例</code> 一样。镜像是静态的定义，，容器是镜像运行时的实体。容器可以被创建，启动通知，删除，暂停等。</p>
<p>容器的实质就是进程，但是与直接宿主执行的进程不同，容器进程运行于属于自己的独立的 <code>命令空间</code>。因此容器有自己<code>root</code>文件系统，自己的网络配置，自己的进程空间，甚至自己的用户ID空间。</p>
</li>
<li><p><strong>仓库（repository）</strong></p>
<p>镜像构建完成之后，可以很容易的在当前宿主机上运行，但是，如果需要在服务器上使用这个镜像，我们就需要一个集中的存储，分发镜像的服务。Docker 官方提供的 Docker <a href="https://hub.docker.com/" target="_blank" rel="noopener">Hub</a>  就是这样的服务，不过这是公共仓库。</p>
</li>
</ul>
<h2 id="Dcoker-的安装"><a href="#Dcoker-的安装" class="headerlink" title="Dcoker 的安装"></a>Dcoker 的安装</h2><p>Docker 有三个更新的频道：<code>stable</code> <code>,</code>test<code>和</code>nightly</p>
<p>官方网站上有各种环境下的 <a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">安装指南</a></p>
<p>安装完成之后，可以使用一下命令检测 Docker 是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p>  如果安装了就会得到关于 docker 的信息</p>
<img src="/shuliqi.github.io/2020/09/30/Docker的必要性及基础使用/1.png">
<h2 id="hello-world-实例"><a href="#hello-world-实例" class="headerlink" title="hello world 实例"></a>hello world 实例</h2><p>现在我们通过简单的 image 文件 <a href="https://hub.docker.com/_/hello-world" target="_blank" rel="noopener">hello world</a> 来感受一下 Docker</p>
<p>运行下面的命令，将image 文件从 仓库拉取到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure>
<p>这个代码中的 <code>docker image pull</code>  是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置。·<code>library</code>是 image 文件所在的组<code>hello-world</code>是image文件的名称。</p>
<p>由于是 Docker 官方提供的image 文件，都放在 <code>library</code>组里面，属于默认组， 所以我们在抓取 Docker 官方 image 文件的时候，可以省略 <code>library</code>·。</p>
<p>所以上面的命令可以写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image pull hello-world</span><br></pre></td></tr></table></figure>
<p>抓取过程：</p>
<img src="/shuliqi.github.io/2020/09/30/Docker的必要性及基础使用/3.png">
<p>抓取成功之后，我们查看本机是否有该 image 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2020/09/30/Docker的必要性及基础使用/4.png">
<p>我们可以看出本机是有该 image 文件了的、</p>
<p>接下来，我们运行这个 image 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure>
<p><code>docker container run</code>命令会从 image 文件 生成一个正在运行的容器。</p>
<p>注意：<code>docker container run</code>命令具有 自动抓取 image 文件的功能，如果发现本地没有指定的 image 文件，就会从仓库自动抓取。</p>
<p>如果运行成功，就会在屏幕上得到以下的输出：</p>

<p>输出这些提示之后就会自动停止运行，容器就会自动终止。</p>
<p>下面会通过Docker 的三个基本概念来介绍。</p>
<h2 id="镜像（image文件）"><a href="#镜像（image文件）" class="headerlink" title="镜像（image文件）"></a>镜像（image文件）</h2><p>Docker 把应用程序及其依赖，打包在 image 文件里面。image 是二进制文件。</p>
<p>只有通过这个文件，才能生成 Docker 容器（container），image文件可以看成是容器的模版。Docker 根据 image 文件生成容器的实例。同一个image文件可以生成多个同时运行的容器实例。</p>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>Docker 运行容器前需要在本地存在对应的镜像（image），如果不存在该镜像，Docker就会从镜像仓库下载该镜像。在<a href="https://hub.docker.com/search?q=&amp;type=image" target="_blank" rel="noopener">Docker Hub</a> 上有大量的镜像可以使用。 </p>
<p>我们可以使用 <code>Docker pull</code>命令获取镜像，命令格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其中具体的<code>选项</code>可以通过<code>Docker pull --help</code>查看。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  Docker pull --help</span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Download all tagged images in the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">      --platform string         Set platform if server is multi-platform capable</span><br><span class="line">  -q, --quiet                   Suppress verbose output</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口]</code>。默认的地址是 <a href="https://hub.docker.com/search?q=&amp;type=image" target="_blank" rel="noopener">Docker Hub</a> </li>
<li>仓库名：仓库名是两段式名称，即：<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对弈仓库是 <a href="https://hub.docker.com/search?q=&amp;type=image" target="_blank" rel="noopener">Docker Hub</a> 如果不给出用户名，那么默认为<code>library</code>(官方镜像)。</li>
</ul>
<p>举个🌰：</p>
<p>我们从 <a href="https://hub.docker.com/search?q=&amp;type=image" target="_blank" rel="noopener">Docker Hub</a> 仓库上拉取一个 <code>hello-world</code>镜像（image）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ Docker pull hello-world</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">0e03bdcc26d7: Pull complete</span><br><span class="line">Digest: sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line">docker.io/library/hello-world:latest</span><br></pre></td></tr></table></figure>
<p>这命令明没有给出 Docker 镜像（image）仓库地址，那么将会从<a href="https://hub.docker.com/search?q=&amp;type=image" target="_blank" rel="noopener">Docker Hub</a> 获取镜像（image）。镜像的名字叫做<code>hello-world</code>，因此会获取官方镜像<code>library/hello-world</code>仓库中的最新的版本的镜像(我们没有执行用哪个标签的版本，所以是最新的)。</p>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>可以使用命令`docker image ls 列出已经下载下来的镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                                 TAG                       IMAGE ID            CREATED             SIZE</span><br><span class="line">express-for-docker                         0.0.1                     75b97434d52d        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    b2d9a05ebb31        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    1083c90adc0f        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    914f52bcbe8b        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    7032438fb234        2 days ago          920MB</span><br><span class="line">shuliqi/express-for-docker                 0.0.1                     e46126aa45a5        6 days ago          920MB</span><br><span class="line">r.addops.soft.360.cn/qixiao/backend-test   20200529163234-5ed720bd   a5e1f04e8d6a        4 months ago        2.71GB</span><br><span class="line">node                                       12.17.0                   a37df1a0b8f0        4 months ago        918MB</span><br><span class="line">hello-world                                latest                    bf756fb1ae65        9 months ago        13.3kB</span><br></pre></td></tr></table></figure>
<p>我们可以看出来，列表包含了 <code>仓库名</code>，<code>标签</code>，<code>镜像ID</code>，<code>创建时间</code>，<code>所占用的空间</code>。其中镜像ID 是镜像的唯一标识、</p>
<p> image 文件是通用的，一台机器的 image 文件拷贝到另外一台机器，依然是可以使用的。所以一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作，即使自己制作，也应该基于别人 image 文件进行加工，而不是从零制作。</p>
<p>为了方便共享，inage 文件制作完成之后可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker hub</a> 应该是最常用的。</p>
<h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>在上面的镜像中， 有一些比较特殊镜像，这些镜像没有仓库名。也没有标签，均为：<code>&lt;none&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;none&gt;                                     &lt;none&gt;                    b2d9a05ebb31        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    1083c90adc0f        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    914f52bcbe8b        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    7032438fb234        2 days ago          920MB</span><br></pre></td></tr></table></figure>
<p>原因是这样的，这些镜像原先是有镜像和标签的，但是随着这些镜像的官网维护，发布了新版本之后， 重新 <code>Docker     pull</code> 的时候。旧的镜像名被转移到新下载的镜像身上了。而这个旧的镜像上的名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了docker pull<code>可能导致这种情况。</code>docker build`也同样可以导致这种现象。</p>
<p>由于新旧镜像同名，旧镜像名称被取消。从而出现仓库名，标签均为<code>&lt;none&gt;</code>的镜像。这类镜像就被称为<strong>虚悬镜像（dangling image）</strong></p>
<p>一般使用<code>docker image ls-f dangling=true</code>来显示这类镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image ls -f dangling=<span class="literal">true</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              b2d9a05ebb31        2 days ago          920MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              1083c90adc0f        2 days ago          920MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              914f52bcbe8b        2 days ago          920MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              7032438fb234        3 days ago          920MB</span><br></pre></td></tr></table></figure>
<p>一般来说，虚悬惊险已经失去了存在的价值，是可以随意删除，可以使用下面的命令删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br><span class="line">WARNING! This will remove all dangling images.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line">Deleted Images:</span><br><span class="line">deleted: sha256:914f52bcbe8b3931a0f28de7f0fdac94718eb679af0eee6056a4339896a2986b</span><br><span class="line">deleted: sha256:8b34628d630ae6f1313ed41ce1539acaa66a2adcc20c5f888475008da5f8f8af</span><br><span class="line">deleted: sha256:107e046f0614e4beb0296e38933989724b232bef66013a83beb5e4a507b15875</span><br><span class="line">deleted: sha256:7adb718c36f311154759d7659bb3a56edc0eef972fe808960a1890a260a344d5</span><br><span class="line">deleted: sha256:49e7e6fadd8e6517ee862d5281a849faa45adf6e097ce280927e5861936731ba</span><br><span class="line">deleted: sha256:b8cfe3d0a0f3c1b19554f9e4cb39978810793399d4c20eb819b7b67205ad58f0</span><br><span class="line">Total reclaimed space: 5.13MB</span><br></pre></td></tr></table></figure>
<h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加快镜像的构建，重复利用资源，Docker 会利用<strong>中间镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的命令<code>docker image ls</code>只会列出顶层镜像。如果希望现实包含中间层镜像在内的所有镜像的话，需要加<code>-a</code>参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker image ls -a</span><br></pre></td></tr></table></figure>
<p>这样就会看到很多无标签的镜像，与之前的虚悬镜像 不同，这些无标签的镜像很多都是中间层镜像，是其他镜像所依赖的镜像，这些无标签的镜像就不应该删除。否则会导致上层镜像会因为失去依赖而出错。</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>如果想要删除本地的镜像，可以使用<code>Docker image rm</code>命令，其格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt;...]</span><br></pre></td></tr></table></figure>
<p>其中<code>镜像</code> 可以是 <code>镜像短ID</code>，<code>镜像长ID</code>,<code>镜像名</code> 或者 <code>镜像摘要</code>.</p>
<p>举个🌰：</p>
<p>我们先列出本地的镜像（image）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                                 TAG                       IMAGE ID            CREATED             SIZE</span><br><span class="line">express-for-docker                         0.0.1                     75b97434d52d        3 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    b2d9a05ebb31        3 days ago          920MB</span><br><span class="line">r.addops.soft.360.cn/qixiao/backend-test   20200529163234-5ed720bd   a5e1f04e8d6a        4 months ago        2.71GB</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>镜像长ID</code>来删除镜像。使用脚本的时候可能会用长ID。但是人工输入的话就会太累了。所以更多的时候是使用<code>短ID</code>来删除镜像、·docker image ls·列出的就是镜像的短ID。</p>
<p>假如我们要删<code>express-for-docker</code>·镜像，就可以使用短ID执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image rm 75b97434d52d</span><br><span class="line">Untagged: express-for-docker:0.0.1</span><br><span class="line">Deleted: sha256:75b97434d52d019ad7ee9c1e1d2c903bc6d5e7261a429cb0f97c0302a0323279</span><br><span class="line">Deleted: sha256:4605991534be3e41e1dd0dc142be83617424b94f68feab431ee4cdf88be944f2</span><br><span class="line">Deleted: sha256:b77592ec1b655839244fdaa2bf94f7ebe606e20ae617154aedaed5e6bd04b9dd</span><br><span class="line">Deleted: sha256:15c1b2c7cd44394daa5b22ddae5e66a5a8804bef4a70ef172738f3b8cbf4a8dd</span><br><span class="line">Deleted: sha256:ffa48c079ea207b279b6fffaa41b893e5c66c9c5908fe616e07978e32ed4b341</span><br><span class="line">Deleted: sha256:ffcf86b030c4b1ecba89778455e52e9ce61ecf22fb2ee7fe8e642d52b0f7f82d</span><br><span class="line">Deleted: sha256:e24e7952278d2bde9a56a78ef1887ca732e786a3735f8e3c1cbc315b88edb0b6</span><br><span class="line">Deleted: sha256:60d46f3b1697a276dff10b74fb8199f523c171ece03bd1e372a0b6ce3c6ada23</span><br><span class="line">Deleted: sha256:4e891fdf8b241174de56b22682015358baf52302f4a7a2ddbd0ff417a71d0e2d</span><br></pre></td></tr></table></figure>
<p>也可以使用镜像名字，即：<code>&lt;仓库名&gt;：&lt;标签&gt;</code>，来删除镜像.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                                 TAG                       IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    b2d9a05ebb31        3 days ago          920MB</span><br><span class="line">r.addops.soft.360.cn/qixiao/backend-test   20200529163234-5ed720bd   a5e1f04e8d6a        4 months ago        2.71GB</span><br><span class="line">hello-world                                latest                    bf756fb1ae65        9 months ago        13.3kB</span><br><span class="line">$ docker image rm  hello-world:latest</span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0</span><br><span class="line">Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b</span><br><span class="line">Deleted: sha256:9c27e219663c25e0f28493790cc0b88bc973ba3b1686355f221c38a36978ac63</span><br><span class="line"> shuliqi@shuliqideMacBook-Pro  ~ </span><br></pre></td></tr></table></figure>
<p>当然也可以使用 <code>镜像摘要</code>来删除镜像。</p>
<p>首先我们使用命令<code>docker image ls --digests</code>先列出镜像的摘要</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image ls --digests</span><br><span class="line">REPOSITORY                                 TAG                       DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    &lt;none&gt;                                                                    b2d9a05ebb31        3 days ago          920MB</span><br><span class="line">r.addops.soft.360.cn/qixiao/backend-test   20200529163234-5ed720bd   sha256:d88b37ff35301dc149c346345cb0609600201b720b14d29f52f7ef232a098e39   a5e1f04e8d6a        4 months ago        2.71GB</span><br><span class="line">hello-world                                latest                    sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0   bf756fb1ae65        9 months ago        13.3kB</span><br></pre></td></tr></table></figure>
<p>然后使用<code>镜像摘要</code>删除:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image rm sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0</span><br></pre></td></tr></table></figure>
<h3 id="使用Dockerfile-定制镜像"><a href="#使用Dockerfile-定制镜像" class="headerlink" title="使用Dockerfile 定制镜像"></a>使用Dockerfile 定制镜像</h3><p>这一部分也是很重要的一个知识点， 我们放在下面的内容 <strong>实例：制作自己的 Docker 容器</strong>来一起讲。</p>
<h2 id="容器（container-文件）"><a href="#容器（container-文件）" class="headerlink" title="容器（container 文件）"></a>容器（container 文件）</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</p>
<p>一般来说，一旦容器生成，就会同时存在两个文件： image 文件 和 容器文件，而且关闭容器不会删除容器文件。只是容器停止运行而已。</p>
<h3 id="列出容器："><a href="#列出容器：" class="headerlink" title="列出容器："></a>列出容器：</h3><p>列出本机容器 可以使用命令 <code>docker container ls</code>。其命令格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container ls [OPTIONS]</span><br></pre></td></tr></table></figure>
<p>OPTIONS 的选项很多。具体可以看看 <a href="https://docs.docker.com/engine/reference/commandline/container_ls/" target="_blank" rel="noopener">docker container ls</a>的文档。</p>
<p>列出本机正在运行的容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container ls</span><br></pre></td></tr></table></figure>
<p>列出本机所有的容器，包括终止运行的容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                              COMMAND                  CREATED             STATUS                        PORTS               NAMES</span><br><span class="line">d211b923866c        ubuntu                             &quot;/bin/bash&quot;              40 minutes ago      Exited (0) 40 minutes ago                         goofy_feistel</span><br><span class="line">a80be7a20f56        ubuntu                             &quot;/bin/bash&quot;              40 minutes ago      Exited (0) 40 minutes ago                         inspiring_clarke</span><br><span class="line">8d91eaa8f2e1        ubuntu                             &quot;/bin/bash&quot;              3 hours ago         Exited (0) 3 hours ago                            bold_mendel</span><br><span class="line">995f498d0371        ubuntu                             &quot;/bin/bash&quot;              3 hours ago         Exited (0) 3 hours ago                            thirsty_mestorf</span><br><span class="line">33b16714d2b8        shuliqi/express-for-docker:0.0.1   &quot;docker-entrypoint.s…&quot;   3 hours ago         Up 3 hours                    3000/tcp            great_lewin</span><br><span class="line">251d68312383        ubuntu                             &quot;/bin/bash&quot;              3 hours ago         Exited (130) 3 hours ago                          vibrant_banach</span><br><span class="line">1f50021cd2b8        ubuntu                             &quot;/bin/bash&quot;              3 hours ago         Exited (0) 3 hours ago                            gifted_keldysh</span><br></pre></td></tr></table></figure>
<p>得到的结果之中有容器的ID。这个ID的使用场景就很多，比如终止容器的时候需要提供。</p>
<h3 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h3><p>启动容器有两个方式：</p>
<ul>
<li>一种是基于镜像新建一个容器并启动；</li>
<li>一种是将终止状态的容器重新启动；</li>
</ul>
<h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>即第一种启动容器的得方式。启动所需的命令：<code>docker run</code>。其格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>
<p>OPTION 选项 具体可以看官方 <a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank" rel="noopener">docker run</a></p>
<p>下面的内容会是我们比较常用的参数的例子。</p>
<p>我们继续以官方的事镜像<code>Hello world</code>来演示。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们拉取我自己上传的一个镜像（image）<code>express-for-docker</code>，再举个特别的🌰：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull shuliqi/express-for-docker:0.0.1</span><br></pre></td></tr></table></figure>
<p>如果提示没有权限获取，可能没有登录  <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker hub</a> 。需要注册登录一下，下面的内容有讲，可以移步往下面内容看看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -t -i shuliqi/express-for-docker:0.0.1 /bin/bash</span><br><span class="line">root@f6cf67490ae4:/shuliqi<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>上面这个命令启动了一个bash 终端，允许用户进行交互。</p>
<ul>
<li><strong>-t：</strong>表示容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器</li>
<li><strong>-i:</strong>   表示让容器的标准输入保持开启</li>
<li><strong>/bin/bash:</strong>  容器启动后，内部第一个执行的命令。这里是起订 Bash.保证用户使用 Shell</li>
</ul>
<p>我们再试一个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run  -t -i -p 8000:3000 shuliqi/express-for-docker:0.0.1 /bin/bash</span><br><span class="line">root@e400118aabd7:/shuliqi<span class="comment"># node app.js</span></span><br><span class="line">111</span><br><span class="line">Example app listening at http://localhost:3000</span><br></pre></td></tr></table></figure>
<p>然后打开我们浏览器，访问<a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> 就会看到如下界面：</p>

<p>其中:</p>
<ul>
<li><strong>-p:</strong> 是指将容器的某个端口映射到本机的某个端口。这个例子就是讲 容器的 3000 端口 映射到本机的 8000 端口</li>
</ul>
<h4 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h4><p>可以使用<code>docker container start</code>命令来启动一个已终止的容器。其格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<p>OPTION 的选项具体可以看官方文档：<a href="https://docs.docker.com/engine/reference/commandline/container_start/" target="_blank" rel="noopener">docker container start</a></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container start e400118aabd7</span><br></pre></td></tr></table></figure>
<p>更多的时候我们是需要Docker 在后台进行而不是直接把执行命令输出的结果输出到当前目录下。那么久可以是用<code>-d</code>来参数来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d -t -i -p 8000:300</span><br><span class="line">597e02ae84f497a8ff6ce03b87ecc40cd2c2a44b3eba41ed927e7aa7beded980</span><br></pre></td></tr></table></figure>
<p>使用·-d· 参数启动后会返回一个唯一的id。</p>
<p>这时候继续访问 ：<a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> 还是会看到和之前一样的界面。</p>
<p>如果我们想看容器的输出结果。可以使用<code>docker container logs [containerID or NAMES]:</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container logs 597e02ae84f497a8ff6ce03b87ecc40cd2c2a44b3eba41ed927e7aa7beded980</span><br><span class="line">111</span><br><span class="line">Example app listening at http://localhost:3000</span><br></pre></td></tr></table></figure>
<h3 id="终止容器运行"><a href="#终止容器运行" class="headerlink" title="终止容器运行"></a>终止容器运行</h3><p>终止容器可以使用：<code>docker container stop [containerID]</code>命令来终止。其格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container stop 597e02ae84f4</span><br><span class="line">597e02ae84f4</span><br></pre></td></tr></table></figure>
<p>上面的命令会导致 containerID 为 597e02ae84f4 的容器停止运行。</p>
<p>可以通过 <code>docker container ls -a</code>来查看终止状态的容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                              COMMAND                  CREATED             STATUS                        PORTS                                      NAMES</span><br><span class="line">597e02ae84f4        shuliqi/express-for-docker:0.0.1   &quot;docker-entrypoint.s…&quot;   8 minutes ago       Exited (137) 7 seconds ago                                               optimistic_antonelli</span><br></pre></td></tr></table></figure>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在前面我们说过 使用 <code>-d</code>参数时，容器启动后悔进入后台。</p>
<p>但是有些时候需要进入容器进行一些操作。那么可以使用<code>docker attach</code>或 <code>docker exec</code>来进入容器。但是推荐使用<code>docker exec</code>进入容器。因为使用<code>docker attach</code>进入容器。如果在stdin中exit(退出),是会导致容器停止的。而<code>docker exex</code>则不会。其格式分别为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure>
<p>使用<code>docker exec</code>的话， 后面可以跟多个参数，可以使用<code>docker exec --help</code>来查看参数。这里主要说名<code>-t</code>，·-i·</p>
<p>参数。</p>
<p>如果只使用<code>-i</code>参数的话，由于没有分配伪终端。界面没有我们熟悉的Linux命令符提示器。但是命令执行结果依然可以返回。</p>
<p>当<code>-i</code>,<code>-t</code>参数一起使用时，则可以看到我们熟悉的Linux命令提示符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker exec -i 33b16714d2b8 bash</span><br><span class="line">ls</span><br><span class="line">Dockerfile</span><br><span class="line">README.md</span><br><span class="line">app.js</span><br><span class="line">node_modules</span><br><span class="line">package-lock.json</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker exec -i -t 33b16714d2b8 bash</span><br><span class="line">root@33b16714d2b8:/shuliqi# ls</span><br><span class="line">Dockerfile  README.md  app.js  node_modules  package-lock.json	package.json</span><br></pre></td></tr></table></figure>
<h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><p>使用<code>docker export</code>来导出本地的某个容器。其格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
<p>OPTIONS 只有一个选项:</p>
<ul>
<li><strong>–output , -o:</strong>将输入内容写到文件</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                              COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">33b16714d2b8        shuliqi/express-for-docker:0.0.1   &quot;docker-entrypoint.s…&quot;   3 hours ago         Up 3 hours          3000/tcp            great_lewin</span><br><span class="line">$ docker export 33b16714d2b8 &gt; express-docker.tar</span><br><span class="line">$ ls</span><br><span class="line">express-docker.tar</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker export -o=&quot;shuliqi.tar&quot; 33b16714d2b8</span><br><span class="line">$ ls</span><br><span class="line">express-docker.tar shuliqi.tar</span><br></pre></td></tr></table></figure>
<p>可以使用<code>docker import</code>从容器快照文件中再导入为镜像。其格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>
<p>OPTION选项可以查看官方文档  <a href="https://docs.docker.com/engine/reference/commandline/import/" target="_blank" rel="noopener">docker import</a></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat express-docker.tar  | docker import - express-docker.tar</span><br><span class="line"></span><br><span class="line">sha256:d16ef3cbe87943de5c4a7c91f11de88b6b1854f7b8898f64060c7580c2840dda</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                                 TAG                       IMAGE ID            REPOSITORY                                 TAG                       IMAGE ID            CREATED             SIZE</span><br><span class="line">express-docker.tar                         latest                    d16ef3cbe879        45 seconds ago      913MB</span><br></pre></td></tr></table></figure>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<code>docker container rm</code>命令来删除。其格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker container rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<p>如果删除一个 运行中的容器，可以添加 <code>-f</code> 参数。</p>
<p>使用<code>docker container ls --a</code>命令，可以查看所有已创建的包括终止状态的容器。如果数量太多的话一个一个删除会很麻烦。<strong>清理所有处于终止状态的容器</strong>可以使用命令 <code>docker container prune</code></p>
<h2 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h2><p>以上的内容我们学会了如何使用 image 和容器文件，但是如何生成 image 文件呢？</p>
<p>这就需要 DockerFile 文件，它是一个文本文件，用来配置 image，Docker 根据该文件生成二进制的 image 文件。</p>
<p>那么我们就通过一个实例，来演示如何编写 DcokerFile 文件吧。</p>
<h2 id="实例：制作自己的-Docker-容器"><a href="#实例：制作自己的-Docker-容器" class="headerlink" title="实例：制作自己的 Docker 容器"></a>实例：制作自己的 Docker 容器</h2><p>我们先创建一个 express 搭建的项目传到自己的 github。我已经创建完了 <a href="https://github.com/shuliqi/express-for-docker" target="_blank" rel="noopener">express-for-docker</a>。怎么创建 express 实例，可以看<a href="https://expressjs.com/zh-cn/starter/hello-world.html" target="_blank" rel="noopener">express的官网</a>。</p>
<p>当然我们上面使用的好多例子也用到了我们上传的 image 文件 <a href="https://hub.docker.com/r/shuliqi/express-for-docker" target="_blank" rel="noopener">express-for-docker</a></p>
<p>接下来我们开始制作自己的 Docker 容器</p>
<h3 id="编写-Dockerfile-文件"><a href="#编写-Dockerfile-文件" class="headerlink" title="编写 Dockerfile 文件"></a>编写 Dockerfile 文件</h3><p>首先， 我们在项目的根目录下新建一个文本文件 <code>.dockerignore</code>,并写下下面的内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">node-modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>
<p>上面的代码表示，这三个路径需要排除，不要打包进 image 文件。如果没有路径需要排除，则这个文件不需要新建。</p>
<p>然后我们在项目的根目录下新建一个文本文件 <code>Dockerfile</code>,写入下面的内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /shuliqi</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /shuliqi</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"npm"</span>, <span class="string">"install"</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span>/tcp</span><br></pre></td></tr></table></figure>
<p>上面的五行代码分别代表什么意思呢？</p>
<ul>
<li><p><strong>FROM node:8.4</strong></p>
<p>这个 image 文件继承官方的得 node image，冒号表示标签，这里的标签是12.17.0。即12.17.0 版本的node</p>
</li>
<li><p><strong>COPY . /app</strong></p>
<p>将当前目录下的所有文件（除了.dockerignore排除的路径）都拷贝到 image 文件的/app目录下面。</p>
</li>
<li><p><strong>WORKDIR /app</strong></p>
<p>指定接下来的工作路径为/app</p>
</li>
<li><p><strong>RUN [“npm”, “install”]</strong></p>
<p>在/app目录下面，运行 npm install 安装依赖。注意：安装后的所有依赖，都将打包进入  image 文件</p>
</li>
<li><p><strong>EXPOSE 3000</strong></p>
<p>将容器的 3000 端口暴露出来，允许外部连接这个端口。</p>
</li>
</ul>
<p>关于完整的一个 Dockerfile各种命令的使用，我们在下一节讲， 请继续关注哦(<em> ￣3)(ε￣ </em>)！！</p>
<h3 id="创建-image-文件"><a href="#创建-image-文件" class="headerlink" title="创建 image 文件"></a>创建 image 文件</h3><p>有了 .Dockerfile 文件之后， 就可以使用 <code>docker  build</code>命令创建 image 文件。<code>docker build</code> 的具体格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>
<p>当然 OPTION 选项也是很多的。具体也可以翻阅官方文档 <a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">docker build </a>。</p>
<p>这里我们讲一个常用到的OPTION 选项：</p>
<ul>
<li><strong>–tag, -t:</strong>镜像的名字以及标签通常 name:tag 格式 或是是 name 格式。</li>
</ul>
<p>name继续我们的是咧。我们来构建 image 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker  build -t express=for-docker .</span><br><span class="line">//或者</span><br><span class="line">docker  build -t express=for-docker:0.0.1 .</span><br></pre></td></tr></table></figure>
<p>这个命令中的 <code>-t</code>参数用来指定 image 文件的名字。后面还可以使用冒号来指定标签。如果不指定的话，默认的标签就是 latest。最后那个表示表示 Dockerfile文件所在的路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build -t express-for-docker .</span><br><span class="line">Sending build context to Docker daemon  2.011MB</span><br><span class="line">Step 1/6 : FROM node:8.4</span><br><span class="line"> ---&gt; 386940f92d24</span><br><span class="line">Step 2/6 : COPY . /shuliqi</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 04a303d12b5f</span><br><span class="line">Step 3/6 : WORKDIR /shuliqi</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; fe2455b89e40</span><br><span class="line">Step 4/6 : RUN [&quot;npm&quot;, &quot;install&quot;]</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 4b9c8652ccc9</span><br><span class="line">Step 5/6 : EXPOSE 3000/tcp</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 11fbd94359f4</span><br><span class="line">Step 6/6 : CMD node app.js</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 1c4d4712b8c0</span><br><span class="line">Successfully built 1c4d4712b8c0</span><br><span class="line">Successfully tagged express-for-docker:latest</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                                 TAG                       IMAGE ID            CREATED              SIZE</span><br><span class="line">express-for-docker                         latest                    1c4d4712b8c0        About a minute ago   674MB</span><br></pre></td></tr></table></figure>
<p>打包完成后，我们在使用 <code>docker image ls</code>查看所有的image文件，是可以看到我们刚刚打包的image文件（express-for-docker）</p>
<h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p>使用<code>docker run</code>命令就会从image 文件生成容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -t -p 8000:3000  express-for-docker:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure>
<p>上面命令的参数含义如下：</p>
<ul>
<li><strong>-p参数：</strong> 容器的 3000 端口 映射到 本机的 8000 端口</li>
<li><strong>-t 参数：</strong> 容器额 Shell  映射到当前的 Shell，然后在本机窗口输入命令，就会传入容易</li>
<li><strong>express-for-docker:0.0.1</strong>： image文件的文件名和tag</li>
<li><strong>/bin/bash：</strong>容器启动后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li>
</ul>
<p>执行上面的命令，如果一切正常，那么就会返回命令行提示符号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@622773f4bec9:/app#</span><br></pre></td></tr></table></figure>
<p>这个提示就说明你已经在容器里面了，返回的提示符就是容器里面的 Shell 提示符。</p>
<p>接下来我们执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@622773f4bec9:/app# node app.js</span><br></pre></td></tr></table></figure>
<p>这命令就是启动我们这个项目的， 这时打开 <a href="http://127.0.0.1:8000" target="_blank" rel="noopener">http://127.0.0.1:8000</a> 网页显示 “Hello World!”</p>
<h3 id="CMD-命令"><a href="#CMD-命令" class="headerlink" title="CMD 命令"></a>CMD 命令</h3><p>上面的例子， 容器启动后，我们需要手动的 输入 <code>node app.js</code>来启动项目。其实我们可以吧这个命令写在 Dockerfile 文件里面，这样容器启动后，这个命令就会执行了，不需要我们手动输入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM node:12.17.0</span><br><span class="line">COPY . /shuliqi</span><br><span class="line">WORKDIR /shuliqi</span><br><span class="line">RUN [&quot;npm&quot;, &quot;install&quot;]</span><br><span class="line">EXPOSE 3000/tcp</span><br><span class="line">CMD node app.js</span><br></pre></td></tr></table></figure>
<p>多出来的这与 一个命令<code>CMD node app.js</code> 它表示容器启动后自动执行  <code>node app.js</code>.。</p>
<p><strong>CMD 和 RUN 命令的区别：</strong></p>
<p><code>RUN</code>命令在 image 文件构建阶段执行，执行结果都会打包进入 image 文件</p>
<p><code>CMD</code>命令则是在容器启动后执行</p>
<p>一个Dockerfile文件可以包含多个 <code>RUN</code>命令，但是只能有一个<code>CMD</code> 命令</p>
<h3 id="发布-image-文件"><a href="#发布-image-文件" class="headerlink" title="发布 image 文件"></a>发布 image 文件</h3><p>容器运行成功了之后，就说明 image 文件是有效的。那么我们可以考虑把 image 文件分享到网上， 让其他人也可以使用。</p>
<p>首先，我们需要去 <a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a>注册账号，然后使用如下的命令登录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>
<p>然后输入注册的用户名和密码。如果成功登录的话，会显示</p>
<img src="/shuliqi.github.io/2020/09/30/Docker的必要性及基础使用/8.png">
<p>那么接下来继续我们的发布，我们给本地的 image 标注用户名和版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker tag [imageName] [userNane]/[repository]:[tag]</span><br></pre></td></tr></table></figure>
<p>我们给自己的 <code>express-for-docker</code>标注用户名和版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker tag express-for-docker:0.0.1 shuliqi/express-for-docker:0.0.1</span><br></pre></td></tr></table></figure>
<p>标注完之后，我们就可以往 <a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a>发布我们的image包了。使用如下的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker push express-for-docker:0.0.1</span><br></pre></td></tr></table></figure>
<p>如发布成功，则会显示：</p>
<img src="/shuliqi.github.io/2020/09/30/Docker的必要性及基础使用/9.png">
<p>我们到 <a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a> 上就会看到已经上传的 image 文件</p>
<img src="/shuliqi.github.io/2020/09/30/Docker的必要性及基础使用/10.png">
<p>这样我们就成功发布了一个 image 文件</p>
<p>文章使用的例子 <a href="https://github.com/shuliqi/express-for-docker" target="_blank" rel="noopener">express-for-docker</a></p>
<p>下一节详细讲 <a href="https://shuliqi.github.io/2020/10/20/Dockerfile%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/">Dockerfile 文件</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://yeasy.gitbook.io/docker_practice/image/list" target="_blank" rel="noopener">Docker —— 从入门到实践</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程</a></li>
<li><a href="https://docs.docker.com/reference/" target="_blank" rel="noopener">docker docs</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>ES6学习笔记-Symbol的使用</title>
    <url>/shuliqi.github.io/2020/02/23/ES6%E4%B8%ADSymbol%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>ES6中引入了一种新的基础数据类型：<code>Symbol</code>，不过很多开发者可能都不怎么了解它，或者觉得在实际的开发工作中并没有什么场景应用到它，那么今天我们来讲讲这个数据类型，并看看我们怎么来利用它来改进一下我们的代码。</p>
<a id="more"></a>
<h3 id="ES6中的Symbol"><a href="#ES6中的Symbol" class="headerlink" title="ES6中的Symbol"></a>ES6中的Symbol</h3><p><code>Symbol</code>是由ES6规范引入的一项新特性，它的功能类似于一种标识唯一性的ID。通常情况下，我们可以通过调用<code>Symbol()</code>函数来创建一个Symbol实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> q1 = <span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure>
<p>或者，你也可以在调用<code>Symbol()</code>函数时传入一个可选的字符串参数，相当于给你创建的Symbol实例一个描述信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> q2 = <span class="built_in">Symbol</span>(<span class="string">'another symbol'</span>)</span><br></pre></td></tr></table></figure>
<p>如果用当下比较流行的TypeScript的方式来描述这个<code>Symbol()</code>函数的话，可以表示成：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;any&#125; description 描述信息。可以是任何可以被转型成字符串的值，如：字符串、数字、对象、数组等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Symbol</span><span class="params">(description?: any)</span>: <span class="title">symbol</span></span></span><br></pre></td></tr></table></figure>
<p>由于<code>Symbol</code>是一种基础数据类型，所以当我们使用<code>typeof</code>去检查它的类型的时候，它会返回一个属于自己的类型<code>symbol</code>，而不是什么<code>string</code>、<code>object</code>之类的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> q1  <span class="comment">// 'symbol'</span></span><br></pre></td></tr></table></figure>
<p>另外，我们需要重点记住的一点是：每个Symbol实例都是唯一的。因此，当你比较两个Symbol实例的时候，将总会返回<code>false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> q1 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> q2 = <span class="built_in">Symbol</span>(<span class="string">'another symbol'</span>)</span><br><span class="line"><span class="keyword">let</span> q3 = <span class="built_in">Symbol</span>(<span class="string">'another symbol'</span>)</span><br><span class="line"></span><br><span class="line">q1 === q2 <span class="comment">// false</span></span><br><span class="line">q2 === q3 <span class="comment">// fals</span></span><br></pre></td></tr></table></figure>
<h3 id="Symbol的应用场景"><a href="#Symbol的应用场景" class="headerlink" title="Symbol的应用场景"></a>Symbol的应用场景</h3><ul>
<li><h4 id="使用Symbol来作为对象属性名-key"><a href="#使用Symbol来作为对象属性名-key" class="headerlink" title="使用Symbol来作为对象属性名(key)"></a>使用Symbol来作为对象属性名(key)</h4><p>在这之前，我们通常定义或访问对象的属性时都是使用字符串，比如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  age: <span class="number">123</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"shuliqi"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">"age"</span>] <span class="comment">// 123</span></span><br><span class="line">obj[<span class="string">"name"</span>] <span class="comment">// 'shuliqi'</span></span><br></pre></td></tr></table></figure>
<p>而现在，<code>Symbol</code>可同样用于对象属性的定义和访问：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PROP_NAME = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> PROP_AGE = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [PROP_NAME]: <span class="string">"我的代码呀"</span></span><br><span class="line">&#125;</span><br><span class="line">obj[PROP_AGE] = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">obj[PROP_NAME] <span class="comment">// '我的代码呀'</span></span><br><span class="line">obj[PROP_AGE] <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p>随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用<code>Object.keys()</code>或者<code>for...in</code>来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">   [<span class="built_in">Symbol</span>(<span class="string">'name'</span>)]: <span class="string">'一斤代码'</span>,</span><br><span class="line">   age: <span class="number">18</span>,</span><br><span class="line">   title: <span class="string">'Engineer'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)   <span class="comment">// ['age', 'title']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(p)   <span class="comment">// 分别会输出：'age' 和 'title'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)   <span class="comment">// ['age', 'title']</span></span><br></pre></td></tr></table></figure>
<p>被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。</p>
<p>也正因为这样一个特性，当使用<code>JSON.stringify()</code>将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(obj)  <span class="comment">// &#123;"age":18,"title":"Engineer"&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以利用这一特点来更好的设计我们的数据对象，让“对内操作”和“对外选择性输出”变得更加优雅。</p>
<p>然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Object的API</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(name)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新增的反射API</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj) <span class="comment">// [Symbol(name), 'age', 'title']</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="使用Symbol来替代常量"><a href="#使用Symbol来替代常量" class="headerlink" title="使用Symbol来替代常量"></a>使用Symbol来替代常量</h4><p>先来看一下下面的代码，是不是在你的代码里经常会出现？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="string">'AUDIO'</span></span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="string">'VIDEO'</span></span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="string">'IMAGE'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFileResource</span>(<span class="params">resource</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(resource.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> TYPE_AUDIO:</span><br><span class="line">      playAudio(resource)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> TYPE_VIDEO:</span><br><span class="line">      playVideo(resource)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> TYPE_IMAGE:</span><br><span class="line">      previewImage(resource)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unknown type of resource'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的代码中那样，我们经常定义一组常量来代表一种业务逻辑下的几个不同类型，我们通常希望这几个常量之间是唯一的关系，为了保证这一点，我们需要为常量赋一个唯一的值（比如这里的’AUDIO’、’VIDEO’、 ‘IMAGE’），常量少的时候还算好，但是常量一多，你可能还得花点脑子好好为他们取个好点的名字。</p>
<p>现在有了<code>Symbol</code>，我们大可不必这么麻烦了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure>
<p>这样定义，直接就保证了三个常量的值是唯一的了！是不是挺方便的呢。</p>
</li>
<li><h4 id="使用Symbol定义类的私有属性-方法"><a href="#使用Symbol定义类的私有属性-方法" class="headerlink" title="使用Symbol定义类的私有属性/方法"></a>使用Symbol定义类的私有属性/方法</h4><p>我们知道在JavaScript中，是没有如Java等面向对象语言的访问控制关键字<code>private</code>的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。</p>
<p>而有了<code>Symbol</code>以及<code>模块化机制</code>，类的私有属性和方法才变成可能。例如：</p>
<p><strong>在文件 1.js中</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PASSWORD = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(username, password) &#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">    <span class="keyword">this</span>[PASSWORD] = password</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkPassword(pwd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>[PASSWORD] === pwd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Login</span><br></pre></td></tr></table></figure>
<p><strong>2.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="keyword">new</span> Login(<span class="string">'admin'</span>, <span class="string">'123456'</span>)</span><br><span class="line"></span><br><span class="line">login.checkPassword(<span class="string">'123456'</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">login.PASSWORD  <span class="comment">// oh!no!</span></span><br><span class="line">login[PASSWORD] <span class="comment">// oh!no!</span></span><br><span class="line">login[<span class="string">"PASSWORD"</span>] <span class="comment">// oh!no!</span></span><br></pre></td></tr></table></figure>
<p>由于Symbol常量<code>PASSWORD</code>被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），因此这个<code>PASSWORD</code>的Symbol只能被限制在a.js内部使用，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。</p>
</li>
<li><h4 id="注册和获取全局Symbol"><a href="#注册和获取全局Symbol" class="headerlink" title="注册和获取全局Symbol"></a>注册和获取全局Symbol</h4><p>通常情况下，我们在一个浏览器窗口中（window），使用<code>Symbol()</code>函数来定义和Symbol实例就足够了。但是，如果你的应用涉及到多个window（最典型的就是页面中使用了<code></code>），并需要这些window中使用的某些Symbol是同一个，那就不能使用<code>Symbol()</code>函数了，因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol。这种情况下，我们就需要使用另一个API来创建或获取Symbol，那就是<code>Symbol.for()</code>，它可以注册或获取一个window间全局的Symbol实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gs1 = <span class="built_in">Symbol</span>.for(<span class="string">'global_symbol_1'</span>)  <span class="comment">//注册一个全局Symbol</span></span><br><span class="line"><span class="keyword">let</span> gs2 = <span class="built_in">Symbol</span>.for(<span class="string">'global_symbol_1'</span>)  <span class="comment">//获取全局Symbol</span></span><br><span class="line"></span><br><span class="line">gs1 === gs2  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。</p>
<p>好了，通过以上这些例子，你现在是不是开始对ES6的这个Symbol功能有点了解了呢？Symbol在JS内部也有很多应用，比如迭代器(Iterator)等，大家可以以此为出发点，发掘出更多相关知识点，深入的理解Symbol的用法和使用场景。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6学习笔记-Promise</title>
    <url>/shuliqi.github.io/2018/03/20/ES6%E5%AD%A6%E4%B9%A0-Promise/</url>
    <content><![CDATA[<blockquote>
<p><strong>我们知道在Javascript中，所有的代码都是单线程的。也就是说是同步执行的。而Promise就为异步编程提供了一种解决方案</strong></p>
</blockquote>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Promise 是一个对象，从它那里可以取得异步操作的消息。Promise 提供统一的API，各种异步操作都可以用同样的方法进行处理。</p>
<ul>
<li><p>状态：</p>
<p>一共有三种状态：<strong>pending（进行中</strong>)， <strong>fulfilled（已成功)</strong>， <strong>rejected（已失败)</strong></p>
</li>
<li><p>特点：</p>
<ol>
<li><p><strong>对象的状态不受外界的影响。</strong></p>
<p>只有异步的结果可以决定当前是哪一种状态（pending， fulfilled, rejected）。 其他的手段都是无法改变的。</p>
</li>
<li><p><strong>一旦状态改变，就不会再变，任何时候都可以拿到这个状态。</strong></p>
<p>Promise的状态只有两种可能：从pending 到 fulfilled， 从peding 到rejected。只要这两种涨停发生了，状态也就凝固了，不会再变了。</p>
<p>如果在对Promise对象添加回调函数，也会立刻拿到这个结果。</p>
</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li><strong>无法取消Promise,一旦新建就会立即执行，中途无法取消</strong></li>
<li><strong>如果没有设置回掉函数，Promise内部抛出错误，不会反应到外部</strong></li>
<li><strong>当处于pending状态的时候，无法知道目前进展到哪一个阶段（刚刚开始还是即将完成）</strong></li>
</ol>
</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><strong>Promise 对象是有关键字new 和Promise 构造函数创建的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="comment">/** 异步操作成功 */</span> ) &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise构造函数的参数是一个函数， 这个函数有两个参数<code>resolve</code>, <code>reject</code>，这两个参数也是函数，由Javacript引擎提供， 不用自己部署。</p>
<p><strong>resolve函数：</strong>将Promise对象的状态“未完成” 变成”完成“ （pending —-&gt; fulfilled）. 在异步操作成功的时候调用， 并且会异步操作的结果作参数传递出去；</p>
<p><strong>reject函数: </strong>将Promise对象的状态“未完成” 变成”失败“ （pending —-&gt; rejected）. 在异步操作失败的时候调用， 并且会异步操作的结果作参数传递出去；</p>
<p><strong>Promise实例生成之后， 可以使用then方法分别指定 resolve 和 rejected 状态的回调。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 异步操作成功的回调</span></span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 异步操作失败的回调</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>then方法可以有两个回调函数作为参数，。 第一个回调函数是Promise对象变为resolve时调用， 第二个回调函数是Promise对象状态变为rejected时调用。其中第二个参数是可选的，不一定要提供。这两个函数都接受promise对象传出的值作为参数。</p>
<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">timeout(<span class="number">1000</span>).then(</span><br><span class="line">  (value) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步操作成功"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"异步操作失败了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>Promise 新建之后就会立即执行。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"11111"</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"2222"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"33333"</span>);</span><br><span class="line"><span class="comment">// 11111</span></span><br><span class="line"><span class="comment">// 33333</span></span><br><span class="line"><span class="comment">// 2222</span></span><br></pre></td></tr></table></figure>
<p>Promise执行之后是立即执行的， 先输出了 <code>11111</code> 然后then方法指定回调函数，将当前的同步操作的任务执行完毕之后(输出 <code>33333</code>)。 最后才输出 <code>222</code></p>
<p>一个Promise封装的ajax</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax = <span class="function">(<span class="params">method, url, <span class="keyword">async</span>, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.onreadychange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.resayState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">          resolve(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.status));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(method, url, <span class="keyword">async</span>);</span><br><span class="line">    xhr.send(data || <span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(<span class="string">"get"</span>, <span class="string">"api/get/shu"</span>, <span class="literal">true</span>, &#123; <span class="attr">name</span>: <span class="string">"sgykiuqu"</span> &#125;).then(</span><br><span class="line">  (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"请求成功"</span>, data);</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"请求抛出错误："</span> + error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果调用resolve函数和rejecte函数时都带有参数，那么它们的参数就会被传递给回调函数。reject函数的参数通常是Error实例， 表示抛出错误，。 resolve函数的参数除了正常的值以外，还可能是另外一个Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p1 = new Promise((resolve, rejecte) =&gt; &#123;&#125;);</span><br><span class="line">const p2 = new Promise((resolve, rejecte) =&gt; &#123;</span><br><span class="line">	resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个例子， p1和p2都是Pro mi se实例， 但是p2的resolve方法将p1作为参数，也就是说以后个异步操作返回了另外一个异步操作。</p>
<p><strong>注意：</strong>这里的p1的状态会传递给p2，也就是说， p1 的状态决定了p2 的状态。如果p1的状态是pendin·g，那么p2的回调函数就会等待p1状态的改变；如果p1的状态是fulfilled 或者 rejected， 那么回调函数就会立即执行；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(</span><br><span class="line">  (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这个例子p2就会等p1 的状态改变回调函数才会调用（等了1 秒才调用）</p>
<p><strong>调用resolve或者rejecte并不会终止Promise的执行</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"111111"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"22222"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 22222</span></span><br><span class="line"><span class="comment">// 111111</span></span><br></pre></td></tr></table></figure>
<p>这个例子： 调用了 resolve(“111111”); 之后， 后面的 console.log(“22222”); 还是会执行， 并且首先打印出来。这是因为resolve 是在本轮时间循环的末尾执行， 总是晚于本轮的同步任务。</p>
<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="string">"111111"</span>);  <span class="comment">//加上return </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"22222"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 111111</span></span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p><strong>作用：</strong>Promise 状态改变时的回调函数。</p>
<p>有两个函数参数：第一个是fulfilled状态的回调函数，一个是rejected状态的回调函数。 的哥参数是可选的。</p>
<p>then方法返回的是一个新的Pro mi se实例（不是原来的Promise实例）。 因此可以采用链式写法：then方法后面再调用另一个then方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1111"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"22222"</span>);</span><br><span class="line">    <span class="keyword">return</span> timeout(<span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"44444"</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>这个例子可以看出，前一个回调函数，有可能返回一个promise对象(也就是有异步操作)， 这时后一个回调函数，就会等待该Promise对象状态发生改变(等待timeout)才会被调用。</p>
<h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><strong>作用：</strong>用于指定发生错误的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax = <span class="function">(<span class="params">method, url, <span class="keyword">async</span>, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.onreadychange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.resayState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">          resolve(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.status));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(method, url, <span class="keyword">async</span>);</span><br><span class="line">    xhr.send(data || <span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(<span class="string">"get"</span>, <span class="string">"/api/getname"</span>, <span class="literal">true</span>).then(() -&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"成功"</span>)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"发生错误"</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发生错误 ReferenceError: XMLHttpRequest is not defined</span></span><br></pre></td></tr></table></figure>
<p>这个例子： 如果对象的promise异步操作成功就会调用t hen方法， 如果一步操作抛出错误，状态变味rejected,就会调用catch()方法指定的回调函数处理这个错误，另外，then()方法指定的回调函数运行中抛出错误，也会被catch()方法捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(shu);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"发生错误"</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 发生错误 ReferenceError: shu is not defined</span></span><br></pre></td></tr></table></figure>
<p>在then方法中没有 shu 这个变量， catch捕获到了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以发现<code>reject()</code>方法的作用，等同于抛出错误;</p>
<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"asd"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(shu);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"发生错误"</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>如果Promise的状态已经变成fulfilled。 再抛出错误是没用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"asd"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"发生错误"</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 成功</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>
<p>一般来说， 不要再then方法里面定义rejecte状态的回调函数（即then的第二个参数）。总是使用catch方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><strong>作用：</strong>不管promise的最后状态如何，都会执行的操作。</p>
<p>该方法不接受任何参数，意思就是Promise状态到底是什么，是没有办法知道的。这表明finally方法里面的操作时跟状态无关的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"asd"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"发生错误"</span>, error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"不管promise状态怎么样， 我都会执行"</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><strong>作用:</strong> 将多个Promise实例， 包装成一个新的Promise实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1,p2,p3])</span><br></pre></td></tr></table></figure>
<p>Promise.all()方法接受一个数组作为参数， 也可以不是数组， 但是必须是具有iterator 接口， 且返回的每个成员都是pro mise对象。</p>
<p>如果传入的参数不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>p的状态是有p1,p2,p3决定，分成两种情况。</p>
<ol>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>状态都变成<code>fulfilled</code>，p的状态才会变成<code>fulfilled</code>。此p1,p2,p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.all([timeout1, timeout2])</span><br><span class="line">    .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"都执行完成了"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"没有catch"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 都执行完成了</span></span><br></pre></td></tr></table></figure>
<p>所有的Promise实例的状态都是fulfilled。 所有会调成功的回调， 打印：”都执行完成了”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(reject, <span class="number">2000</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.all([timeout1, timeout2])</span><br><span class="line">    .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"都执行完成了"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"至少有一个状态是rejected"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 至少有一个状态是rejected</span></span><br></pre></td></tr></table></figure>
<p>timeout2d的状态是rejected， 所以all的最终状态是rejected。</p>
<p>如果作为参数的promise实例， 自己定义了catch方法， 那么它一旦rejected。并且不会触发Pro mi se.all()的catch方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(reject, <span class="number">2000</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeou2 的catch"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.all([timeout1, timeout2])</span><br><span class="line">    .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"都执行完成了"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"不会到打这个catch了"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  timeou2 的catch</span></span><br><span class="line"><span class="comment">//  都执行完成了</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>这个例子的timeout1会resolve, timeout2首先会rejected, 但是timeout2由自己的catch方法，该方法会返回一个Promise实例。timeout2指向这个实例，该实例执行catch后，也会变成resolved。 导致两个实例都resolved.因此会调用then方法。而不会调用catch方法</p>
<p>如果timeout2没有自己的catch方法， 就会调用Promise.all()的catch方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(reject, <span class="number">2000</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.all([timeout1, timeout2])</span><br><span class="line">    .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"都执行完成了"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"参数实例没有自己的catch,所以有错误都会到这里"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 参数实例没有自己的catch,所以有错误都会到这里</span></span><br></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><strong>作用：</strong>作用也是将多个promise实例，包装成一个新的Promise实例。但是只要其中的一个实例状态发生改变，就会触发回调。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="built_in">Promise</span>.race([timeout1, timeout2])</span><br></pre></td></tr></table></figure>
<p>只要timeout1, timeout2其中有一个实例状态发生改变。time的状态就会发生改变。那个先改变的实例的返回值，就传递给time的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"timeout 1"</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"timeout2"</span>);</span><br><span class="line">      reject();</span><br><span class="line">    &#125;, <span class="number">500</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.race([timeout1, timeout2])</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"第一个time状态发生改变了"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"catch"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timeout2</span></span><br><span class="line"><span class="comment">//  catch</span></span><br><span class="line"><span class="comment">//  timeout 1</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，timeout2 在500ms 之后状态变成rejected了。比timeout1块， 所有就会立即调用time的then方法。然后timeout1 才会调用。</p>
<h3 id="Promise-allsettled"><a href="#Promise-allsettled" class="headerlink" title="Promise.allsettled()"></a>Promise.allsettled()</h3><p><strong>作用：</strong>作用也是将多个promise实例，包装成一个新的Promise实例.。但是只要这些参数的实例都返回结果，不管是fulfilled还是rejected,包装实例才会结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"timeout 1"</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"timeout2"</span>);</span><br><span class="line">      reject();</span><br><span class="line">    &#125;, <span class="number">500</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.allSettled([timeout1, timeout2]).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout1 和 timeou2 都结束了"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// timeout2</span></span><br><span class="line"><span class="comment">// timeout 1</span></span><br><span class="line"><span class="comment">// timeout1 和 timeou2 都结束了</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//     &#123;status: "fulfilled", value: undefined&#125;</span></span><br><span class="line"><span class="comment">//     &#123;status: "rejected", reason: undefined&#125;</span></span><br><span class="line"><span class="comment">//  ]</span></span><br></pre></td></tr></table></figure>
<p>Timeout1 和timeout2 都返回了结果， 才会调用then方法.then方法接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的两个 Promise 实例。每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。<code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</p>
<p>这个点方法的好处在哪里呢？ 好处就在有时候我们不关系一步操作的结果，只关心异步操作有没有结束。这个方法就很有用。</p>
<h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h3><p><strong>作用：</strong>作用也是将多个promise实例，包装成一个新的Promise实例。 但是是是要参数实例有任何一个状态变成fulfilled。 包装实例对象就会变成fulfilled状态。如果所有的Promise状态都变成rejected, 包装实例对象才会变成rejecte的状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout 1"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout2"</span>);</span><br><span class="line">    reject();</span><br><span class="line">  &#125;, <span class="number">500</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.any([timeout1, timeout2]).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"timeout1 状态变成了 fulfilled"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>Promise.any()目前还在草案阶段。</p>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p><strong>作用</strong>: 将现有的对象转成Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(name))</span><br></pre></td></tr></table></figure>
<p>Promise.resolve()方法的参数有四种情况：</p>
<ol>
<li><p>参数是一个promise实例， 那么promise.resolve将不做任何的修改， 直接原封不动的返回这个实例</p>
</li>
<li><p>参数是一个thenable对象。Promise.resolve()会将这个对象转成Promise对象， 然后立即执行thenable对象的then方法。</p>
<p>thenable对象就是指具有then方法的对象。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then: <span class="function">(<span class="params">resolve, rejecte</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"ashds"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    then: <span class="function">(<span class="params">resolve, rejecte</span>) =&gt;</span> &#123;</span><br><span class="line">      rejecte(<span class="string">"ashds"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(thenable)</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"thenable 的then方法返回的状态是fulfilled"</span>, data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"thenable的then方法返回的状态是rejected"</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// thenable的then方法返回的状态是rejected ashds</span></span><br></pre></td></tr></table></figure>
<p>   这个例子 Promise.resolve将thenable转成Promise对象之后，立即调用thenble对象的then方法。thenable对象的then方法返回的状态是 rejected; 所以执行到catch里面</p>
<ol start="3">
<li><p>参数不是thenable对象， 或者根本不是对象。Promise.resolve()会返回一个新的Promise实例，状态直接为resolved。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">"shuliqi"</span>).then(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="built_in">console</span>.log(name));</span><br><span class="line"><span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>这个例子的shuliqi不属于异步操作(字符串对象没有then方法)。返回的Promise从一开始就是resolved/所以会调函数就会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p>
</li>
<li><p>不带任何参数。直接返回一个<code>resolved</code>状态的 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"hahahah"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// hahahah</span></span><br></pre></td></tr></table></figure>
<p>Promise.resolved是没有参数的， 直接返回一个状态为resolved的Promise对象。 所以会调函数立即就调用了。</p>
</li>
</ol>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p><strong>作用:</strong>返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">"shuliqi"</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejecte</span>) =&gt;</span> reject(<span class="string">"shuliqi"</span>))</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">   then: <span class="function">(<span class="params">resolve, rejecte</span>) =&gt;</span> &#123;</span><br><span class="line">     rejecte(<span class="string">"ashds"</span>);</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="built_in">Promise</span>.reject(thenable).catch(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data === thenable);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>Promise.reject</code>方法的参数是一个<code>thenable</code>对象，执行以后，后面<code>catch</code>方法的参数不是<code>reject</code>抛出的“出错了”这个字符串，而是<code>thenable</code>对象。</p>
<p><a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">学习的链接</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript运行机制</title>
    <url>/shuliqi.github.io/2019/08/10/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="JavaScript运行机制"><a href="#JavaScript运行机制" class="headerlink" title="JavaScript运行机制"></a>JavaScript运行机制</h3><p>我们知道JavaScript执行的时候是单线程的。但是Javascript为什么是单线程的呢， JavaScript为什么需要异步呢，JavaScript又如何靠单线程实现异步的呢？我们又为什么要掌握JavaScript的单线程。</p>
<a id="more"></a>
<p>为了回答上面的问题， 我们先看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'我执行了'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码是真的会在1秒后执行吗？答案是不一定的。这就需要我们了解JavaScript的运行机制了。</p>
<h4 id="Javascript为什么是单线程？"><a href="#Javascript为什么是单线程？" class="headerlink" title="Javascript为什么是单线程？"></a>Javascript为什么是单线程？</h4><p>JavaScript是用在web浏览中。如果JavaScript是多线程的话。那么有两个线程是必然的，如果process1和procees2都操作在同一个DOM。process1要删除这个DOM， process2要编辑这个DOM。这样就会产生矛盾。所以JavaScript还是设计成单线程的。</p>
<h4 id="JavaScript为什么需要异步？"><a href="#JavaScript为什么需要异步？" class="headerlink" title="JavaScript为什么需要异步？"></a>JavaScript为什么需要异步？</h4><p>如果JavaScript不存在异步， 代码都是自上而下执行，如果上一行代码解析时间过长等原因，那么下面的代码就会被阻塞。这种现象对于用户来说就是“卡死”。用户体验很不好。</p>
<h4 id="JavaScript单线程如何实现异步呢？"><a href="#JavaScript单线程如何实现异步呢？" class="headerlink" title="JavaScript单线程如何实现异步呢？"></a>JavaScript单线程如何实现异步呢？</h4><p>JavaScript是通过事件循环（event loop）来实现的，事件循环机制也就是今天要说的JavaScript运行机制。</p>
<h4 id="同步和异步任务"><a href="#同步和异步任务" class="headerlink" title="同步和异步任务"></a>同步和异步任务</h4><p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果：1 3  2</p>
<p>setTimeout需要延迟一段时间爱能去执行。这类代码就是一异步代码。</p>
<p>根据这个结果。通常我们都这么理解JS的执行原理：</p>
<ol>
<li>判断JavaScript是同步的还是异步的。同步的直接进入主线程。异步的则进入Eevent table</li>
<li>异步任务在Eevent table注册函数，当满足出发条件后，进入event queue（事件队列）。</li>
<li>同步任务进入主线程后一直执行，直到主线程空闲。才会去event queue中查看是否有可执行的异步任务，如果有就推入主线程。</li>
</ol>
<h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><p>但是。按照同步和异步任务来理解JavaScript运行机制并不准确。</p>
<p>例如看这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"d"</span>);</span><br></pre></td></tr></table></figure>
<p>上述的代码按照异步和同步的理解，结果应该是：b  d a c 。按顺序在主线程自上而下的执行。而 a c 是异步。按顺序在主线程有空后自先而后执行</p>
<p>可是结果并不是这样的， 结果是这样的：b  d  c  a。</p>
<p>这是为什么呢？ 这就需要了解宏任务和微任务。</p>
<ol>
<li><strong>宏任务：</strong> script全部代码，setTimeout，setInterval， I/O， UI Rendering等。</li>
<li><strong>微任务：</strong>Process.nextTick（Node独有），Promise等。</li>
</ol>
<p><img src="/Users/shuliqi/mage/20180924120852420.png" alt></p>
<p>根据这个例子我们理解的Javascript是这样的。</p>
<ol>
<li>执行宏任务(主线程的同步script代码),如果遇到微任务。就把任务发到微任务的时间队列中。</li>
<li>当前的宏任务执行完（调用栈是是空的），会去查找微任务的任务队列。将全部的微任务依次执行完毕之后。再去依次执行宏任务事件队列。</li>
</ol>
<p>以上的例子promise的then是一微任务，因此它的执行在setTimeout之前。</p>
<h4 id="JavaScript运行机制-1"><a href="#JavaScript运行机制-1" class="headerlink" title="JavaScript运行机制"></a>JavaScript运行机制</h4><p>通过以上的结论证明， JavaScript运行机制应该是这样的</p>
<p><strong>同步宏任务→微任务promise→微任务process.nextTick→异步宏任务</strong></p>
<p>注意的点： 在node环境下，process.nextTick的优先级高于promise。也就是可以简单理解为，在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的promise部分。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后总结开头的例子，我们可以理解为：</p>
<p>1秒后，setTimeout里的函数会被推入event queue，而event queue（事件队列）里的任务，只有在主线程空闲时才会执行。也就是需要同时满足两个条件（1）1秒后。（2）主线程必须空闲，这样1秒后才会执行该函数。</p>
<p>下面有几个例子可以看看</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>
<p>同步宏任务：script start， script end</p>
<p>异步宏任务：setTimeout</p>
<p>微任务：promise1， promise2</p>
<p>根据JavaScript运行机制我们可以得出结果是：script start， script end， promise1， promise2，setTimeout</p>
<p> 有兴趣的话， 可以再研究研究这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>) </span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>
<p>文章参考出处：<a href="https://blog.csdn.net/qq_41635167/article/details/82827970，" target="_blank" rel="noopener">https://blog.csdn.net/qq_41635167/article/details/82827970，</a> <a href="https://juejin.im/post/5c3d8956e51d4511dc72c200#heading-12" target="_blank" rel="noopener">https://juejin.im/post/5c3d8956e51d4511dc72c200#heading-12</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex布局教程</title>
    <url>/shuliqi.github.io/2018/03/31/Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="Flex-布局的概念"><a href="#Flex-布局的概念" class="headerlink" title="Flex 布局的概念"></a>Flex 布局的概念</h2><p>Flex 是 Flexible Box 的缩写，意思就是“弹性布局”。它的作用就是为盒状模型提供最大的灵活性。</p>
<p>任何容器都可以指定为Flex 布局.</p>
<a id="more"></a>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>行内元素也可以使用flex 布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	<span class="attribute">dispaly</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 设置为Flex布局之后， 子元素的·<code>float</code>，<code>claer</code>，<code>vertical-align</code> 将会失效。</p>
<h2 id="Flex的基本概念"><a href="#Flex的基本概念" class="headerlink" title="Flex的基本概念"></a>Flex的基本概念</h2><p>使用了Flex布局的元素， 称为：Flex容器， 简称：“容器”。 容器内的所有元素自动成为容器成员。称为：Flex项目， 简称“项目“。</p>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/1.png">
<p>容器默认存在两根轴，水平的主轴（main axis）和垂直的交叉轴（cross axis），主轴的开始位置（与边框的交叉点）叫<code>main start</code>, 结束位置叫<code>main end</code>交叉轴的开始位置叫<code>cross start</code>, 结束位置叫<code>cross start</code>。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫<code>main size</code>, 占据的交叉轴空间叫<code>cross size</code>。</p>
<h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>一共有6 个属性是可以设置在容器上。</p>
<ol>
<li><strong>flex-direction</strong></li>
<li><strong>flex-wrap</strong></li>
<li><strong>flex-flow</strong></li>
<li><strong>justify-content</strong></li>
<li><strong>align-items</strong></li>
<li><strong>align-content</strong></li>
</ol>
<h3 id="flex-direction-属性"><a href="#flex-direction-属性" class="headerlink" title="flex-direction 属性"></a>flex-direction 属性</h3><p>flex-direction 决定主轴的方向（项目的排列方向）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">	flex-direction: row | row-reverse | column | column-reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex-direction的4个值的含义：</p>
<ol>
<li><p>row：默认值，主轴为水平方向，起点在左端。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  flex-direction: row; // 默认值，主轴为水平方向，起点在左端 </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/direction1.jpg">
<p>完整 <a href="https://jsbin.com/cuvokizabu/1/edit?html,css,output" target="_blank" rel="noopener">Demo</a></p>
</li>
<li><p>row-reverse：主轴是水平方向，起点在右端</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  flex-direction: row-reverse; // 主轴是水平方向，起点在右端</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/direction2.jpg">
<p>完整 <a href="https://jsbin.com/rihinemulu/edit?html,css,output" target="_blank" rel="noopener">Demo</a></p>
</li>
<li><p>column：主轴为垂直方向， 起点在上沿</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  flex-direction: column; // 主轴为垂直方向， 起点在上沿</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/direction3.jpg">
<p>完整 <a href="https://jsbin.com/tasofavuro/edit?html,css,js,output" target="_blank" rel="noopener">Demo</a></p>
</li>
<li><p>column-reverse：主轴是垂直方向，起点在下沿</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  flex-direction: column-reverse; //主轴是垂直方向，起点在下沿</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/direction4.jpg">
<p>完整 <a href="https://jsbin.com/kerinetanu/1/edit?html,css,js,output" target="_blank" rel="noopener">Demo</a></p>
</li>
</ol>
<h3 id="flex-wrap-属性"><a href="#flex-wrap-属性" class="headerlink" title="flex-wrap 属性"></a>flex-wrap 属性</h3><p>默认情况下，所有的项目都排列在一条线上（又称为“轴线“）. flex-wrap属性定义， 如果在一条轴线上排不下， 如何换行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">	flex-wrap: nowrap | wrap | wrap-column</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex-wrap的3个值的含义：</p>
<ol>
<li><p><strong>nowrap</strong>： 默认值，不换行</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap: // 默认值，不换行</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/wrap1.jpg">
<p>完整 <a href="https://jsbin.com/wutepopode/edit?html,css,js,output" target="_blank" rel="noopener">Demo</a></p>
</li>
<li><p>wrap：换行， 第一行在上方</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  flex-wrap: wrap; // 换行， 第一行在上方</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/wrap2.jpg">
<p>完整 <a href="https://jsbin.com/tuzihaqaza/1/edit?html,css,js,output" target="_blank" rel="noopener">Demo</a></p>
</li>
<li><p>wrap-reverse：换行， 第一行在下方</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  flex-wrap: wrap-reverse; // 换行， 第一行在下方</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/wrap3.jpg">
<p><a href="https://jsbin.com/pugusasura/edit?html,css,output" target="_blank" rel="noopener">Demo</a></p>
</li>
</ol>
<h3 id="flex-flow-属性"><a href="#flex-flow-属性" class="headerlink" title="flex-flow 属性"></a>flex-flow 属性</h3><p><code>flex-flow</code> 属性是<code>flex-direction</code>属性  和 <code>flex-wrap</code>属性的简写形式。默认值：<code>row nowrap</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">	flex-flow: &lt;flex-direction&gt; | &lt;flex-wrap&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="justify-content-属性"><a href="#justify-content-属性" class="headerlink" title="justify-content 属性"></a>justify-content 属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">	justify-content: flex-start | flex-end | center| space-between | space-around</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>justify-content属性有5个值：</p>
<ol>
<li><strong>flex start:</strong>      默认值，主轴的起点对齐</li>
<li><strong>flex-end：</strong> 主轴的终点对齐</li>
<li><strong>center：</strong>居中</li>
<li><strong>space-between：</strong>两端对齐，项目之间的间隔是相等的</li>
<li><strong>space-around：</strong> 每个项目两侧的距离相等，所以项目之间的间距与项目与边框的间距要大</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container1</span> &#123;</span><br><span class="line">  <span class="comment">/* 默认值，主轴的起点对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container2</span> &#123;</span><br><span class="line"> <span class="comment">/*  主轴的终点对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container3</span> &#123;</span><br><span class="line">  <span class="comment">/* 居中 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container4</span> &#123;</span><br><span class="line">  <span class="comment">/* 两端对齐，项目之间的间隔是相等的 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container5</span> &#123;</span><br><span class="line">  <span class="comment">/* 每个项目两侧的距离相等，所以项目之间的间距与项目与边框的间距要大 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/7.jpg">
<p>完整<a href="https://jsbin.com/xoqikozalu/1/edit?html,css,output" target="_blank" rel="noopener">Demo</a></p>
<h3 id="align-items-属性"><a href="#align-items-属性" class="headerlink" title="align-items 属性"></a>align-items 属性</h3><p><code>align items</code> 属性定义项目在交叉轴的对齐方式，</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">   <span class="attribute">align-items</span>: flex-start |flex-end | center | baseline| stretch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一共有5个值：</p>
<ol>
<li><p><strong>flex start:</strong>: 交叉轴的起点对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  align-items: flex-start; // 交叉轴的起点对齐</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/flex1.jpg">
<p>完整 <a href="https://jsbin.com/nihavapeve/1/edit?html,css,js,output" target="_blank" rel="noopener">Demo</a></p>
</li>
<li><p><strong>flex end:</strong> 交叉轴的终对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  align-items: flex-end; // 交叉轴的终点对齐 </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/flex2.jpg">
<p>完整 <a href="https://jsbin.com/nuxeqobude/1/edit?html,css,output" target="_blank" rel="noopener">Demo</a></p>
</li>
<li><p><strong>center：</strong>居中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  align-items: center; // 居中 </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/flex3.jpg">
<p>完整 <a href="https://jsbin.com/sikuxofozu/edit?html,css,output" target="_blank" rel="noopener">Demo</a></p>
</li>
<li><p><strong>baseline</strong>： 项目的第一行文字基线对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: baseline </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/flex4.jpg">
<p>完整  <a href="https://jsbin.com/xinosalodo/1/edit?html,css,output" target="_blank" rel="noopener">Demo</a></p>
</li>
<li><p><strong>stretch：</strong> 默认值， 如果项目未设置高度或者设置高度为auto，将铺满整个容器的高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: #54b4c557;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: strecth; //  默认值， 如果项目未设置高度或者设置高度为auto，将铺满整个容器的高度</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">.item1 &#123;</span><br><span class="line">  background: #f19f9e;</span><br><span class="line">  width: 30px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 50px;</span><br><span class="line">   margin: 0 20px;</span><br><span class="line">&#125;</span><br><span class="line">.item2 &#123;</span><br><span class="line">  width: 30px;</span><br><span class="line">  font-size: 50px;</span><br><span class="line">  background: #f19f9e;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 50px;</span><br><span class="line">  margin: 0 20px;</span><br><span class="line">&#125;</span><br><span class="line">.item3 &#123;</span><br><span class="line">  width: 30px;</span><br><span class="line">  background: #f19f9e;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">  margin: 0 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/flex5.jpg">
</li>
</ol>
<p>​       完整  <a href="https://jsbin.com/vuqetirola/1/edit?html,css" target="_blank" rel="noopener">Demo</a></p>
<h3 id="align-content-属性"><a href="#align-content-属性" class="headerlink" title="align-content 属性"></a>align-content 属性</h3><p><code>align-content</code>属性设置了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性是不生效的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">	align-content: flex-start | flex-end | center | space-between | space-around | stretch </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该属性一共有6 个属性值：</p>
<ol>
<li><strong>flex start:</strong>: 交叉轴的起点对齐</li>
<li><strong>flex end:</strong> 交叉轴的终对齐</li>
<li><strong>center：</strong>居中</li>
<li><strong>stretch：</strong> 默认值， 如果项目未设置高度或者设置高度为auto，将铺满整个容器的高度</li>
<li><strong>space-between</strong>:与交叉轴两端对齐，轴线之间的间隔平均分布</li>
<li><strong>space-around</strong>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li>
<li><strong>stretch：</strong>默认值，占满整个容器</li>
</ol>
<p><strong>注意：</strong> <code>align-items</code> 属性和<code>align-content</code>属性的区别：<code>align-items</code>属性是设置多根轴线和单根轴线的， <code>align-content</code>属性是设置多根轴线的。这里的多根轴线和单根轴线是指<code>flex-wrap：nowrap</code>是单根轴线，align-items 和align-content同时存在的话， align-items 生效，align-content 不生效。<code>flex-wrap：wrap| wrap-reverse</code> 且项目换行了，align-items 和align-content同时存在的话， align-items 不生效，align-content 生效。</p>
<p>例子如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-end; </span><br><span class="line">  <span class="attribute">align-content</span>: flex-start;</span><br><span class="line">  // align-content单根轴线是不生效的，当 flex-wrap: nowrap, 生效的是align-items</span><br><span class="line">  // 多轴情况下， align-items 和 align-content 同时存在， align-content会覆盖align-items </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的 <a href="https://jsbin.com/sixesiquve/1/edit?html,css,output" target="_blank" rel="noopener">Demo</a></p>
<h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><p>以下6个属性设置在项目上。</p>
<ol>
<li><p><strong><code>order</code></strong></p>
</li>
<li><p><strong><code>flex-grow</code></strong></p>
</li>
<li><p><strong><code>flex-shrink</code></strong></p>
</li>
<li><p><strong><code>flex-basis</code></strong></p>
</li>
<li><p><strong><code>flex</code></strong></p>
</li>
<li><p><strong><code>align-self</code></strong></p>
</li>
</ol>
<h3 id="order-属性"><a href="#order-属性" class="headerlink" title="order 属性"></a>order 属性</h3><p><code>order</code> 属性定义项目的排列顺序，数值越小，排列越靠前， 默认值为0。</p>
<p><strong>使用语法：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例子：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="comment">/* order 属性定义项目的排列顺序，数值越小，排列越靠前 */</span></span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/order.jpg">
<p> <a href="https://jsbin.com/sazuwamure/1/edit?html,css,output" target="_blank" rel="noopener">例子完整代码</a></p>
<h3 id="flex-grow-属性"><a href="#flex-grow-属性" class="headerlink" title="flex-grow 属性"></a>flex-grow 属性</h3><p><code>flex-grow</code>属性定义项目的放大比列。默认为0，即 即使存在剩余空间， 也不放大。 </p>
<p><strong>使用语法：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例子：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/grow.jpg">
<p> <a href="https://jsbin.com/zafuhamuwo/1/edit?html,css,output" target="_blank" rel="noopener">例子完整代码</a></p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为4，其他项目都为1，则前者占据的剩余空间将比其他多4倍。</p>
<h3 id="flex-shrink-属性"><a href="#flex-shrink-属性" class="headerlink" title="flex-shrink 属性"></a>flex-shrink 属性</h3><p><code>flex-shrink</code>属性定义项目的缩小比例，默认值为1， 如果剩余空间不足，项目将缩小。</p>
<p><strong>使用语法：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123; </span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例：子</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/shrink.jpg">
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。</p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，其他的<code>flex-shrink</code> 为10，那么后者的缩小比例是前者的10倍</p>
<p>如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<p> <a href="https://jsbin.com/gihubasolo/2/edit?html,css,output" target="_blank" rel="noopener">例子完整代码</a></p>
<h3 id="flex-basis-属性"><a href="#flex-basis-属性" class="headerlink" title="flex-basis 属性"></a>flex-basis 属性</h3><p><code>flex-basis</code>属性定义在分配剩余空间之前， 项目占主轴的空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小</p>
<p><strong>使用语法：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例子：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">700px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/basis.jpg">
<p> <a href="https://jsbin.com/bepehogude/1/edit?html,css,output" target="_blank" rel="noopener">例子完整代码</a></p>
<h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code> <code>flex-shrink</code> <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<p><strong>使用语法：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h3 id="align-self-属性"><a href="#align-self-属性" class="headerlink" title="align-self 属性"></a>align-self 属性</h3><p><code>align-self</code>属性允许单个项目与其他项目不一样的对齐方式，可覆盖<code>align-items</code>，默认值为auto，表示继承父级的<code>align-items</code>。如果没有父元素，则等同于<code>stretch</code>。</p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<p><strong>使用语法：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例子:</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c557</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2018/03/31/Flex布局/self.jpg">
<p> <a href="https://jsbin.com/luzusoceci/edit?html,css,output" target="_blank" rel="noopener">例子完整代码</a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6学习笔记- Proxy</title>
    <url>/shuliqi.github.io/2018/03/05/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Proxy/</url>
    <content><![CDATA[<p>之前深入了解了<strong><a href="http://localhost:4000/2018/02/19/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Object-defineProperty/" target="_blank" rel="noopener">Object.defineProperty</a></strong>。 发现ES6有一个新的对象（Proxy）也能实现属性拦截器的作用，但是功能更加强大。所以这里也学习学习，总结总结。</p>
<p>学习都是来自<a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰老师</a>。</p>
<a id="more"></a>
<h3 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h3><p><strong>Proxy</strong>对象在目标对象的外层设置一层拦截器，外界对目标的某些操作，必须通过这层拦截</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>
<p><strong>new proxy</strong>表示生成一个proxy实例；</p>
<p><strong>target：</strong>表示拦截的目标对象；<br><strong>handler：</strong> 表示拦截的行为， 也是一个对象；</p>
<p><strong>注意：</strong>要使得<strong>Proxy </strong>起作用， 就必须针对<strong>Proxy </strong>实例（上面的例子就是<strong>proxyObj</strong>对象）进行操作，而不是针对目标对象（上面的例子就是(<strong>obj对象</strong>)进行操作。</p>
<h3 id="proxy拦截操作–handler"><a href="#proxy拦截操作–handler" class="headerlink" title="proxy拦截操作–handler"></a>proxy拦截操作–handler</h3><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h5><p>拦截对象属性的读取。 比如 <strong>proxyObj.name</strong> 和 <strong>proxyObj[name]</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>(target, propKey, recevier)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>get()方法接受三个参数</p>
<ol>
<li><strong>target:</strong> 目标对象</li>
<li><strong>propKey:</strong> 读取的属性名</li>
<li><strong>recevier：</strong>Proxy实例本身</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"shuliqi"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, propKey, recevier) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target[propKey]) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"找不到该属性的值"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxyObj.name); <span class="comment">// shuliqi</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyObj.age);  <span class="comment">// 找不到该属性的值</span></span><br></pre></td></tr></table></figure>
<p>这个例子代码表示， 如果访对象不存在的属性， 会打印“找不到该属性的值”。 如过没有这个拦截， 访问不存在的属性，， 只会返回undefined。</p>
<h5 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h5><p>拦截某个属性的赋值操作。比如： 比如 <strong>proxyObj.name = “shuliqi”</strong> 和 <strong>proxyObj[name] =. “shuliqi”</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(target, propKey，value, recevier)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p> set()方法有三个参数：</p>
<ol>
<li><strong>target:</strong> 目标对象</li>
<li><strong>propKey:</strong> 读取的属性名</li>
<li><strong>value：</strong> 属性值</li>
<li><strong>recevier：</strong>Proxy实例本身</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"shuliqi"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, propKey, value, recevier) &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey === <span class="string">"age"</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">        <span class="comment">// 如果不是整数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"age需要是一个整数"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"符合赋值"</span>);</span><br><span class="line">        target[propKey] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyObj.age = <span class="number">12.1</span>; <span class="comment">// age需要是一个整数</span></span><br><span class="line">proxyObj.age = <span class="number">25</span>; <span class="comment">// 符合赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>这个例子如果age赋值的不是整数，会拦截到并且log“age需要是一个整数”。如果符合的话log“符合赋值” . 并且成功赋值。</p>
<h5 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply()方法"></a>apply()方法</h5><p>拦截函数的调用，<strong>call</strong> 和 <strong>apply</strong>的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">apply(target, context, args)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>apply()方法有三个参数：</p>
<ol>
<li><strong>target：</strong> 目标函数对象</li>
<li><strong>context:</strong> 目标函数对象的上下文对象(this)</li>
<li><strong>args：</strong>目标函数对象的参数数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> targetFn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"我是目标函数对象"</span>;</span><br><span class="line"><span class="keyword">const</span> proxyFn = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetFn, &#123;</span><br><span class="line">  apply(_proxyFntarghet, context, args) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我目标函数代理对象"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyFn.call(); <span class="comment">// 我目标函数代理对象</span></span><br><span class="line">proxyFn.apply();<span class="comment">// 我目标函数代理对象</span></span><br><span class="line">proxyFn(); <span class="comment">// 我目标函数代理对象</span></span><br></pre></td></tr></table></figure>
<p>例子里面proxyFn 是 targetFn的实例，当被调用的时候，就会被apply方法拦截到。返回“我目标函数代理对象”</p>
<h5 id="has-方法"><a href="#has-方法" class="headerlink" title="has() 方法"></a>has() 方法</h5><p>拦截判断某个对象是否具有某个属性时(hasProperty)， 这个方法会生效。 典型的操作比如 in 操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">has(targe, propKey)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>has() 方法 有两个参数：</p>
<ol>
<li><strong>target：</strong> 目标对象‘</li>
<li><strong>propKey:</strong> 需要查询的属性名；</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">name</span>: <span class="string">"shuliqi"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  has(target, key) &#123;</span><br><span class="line">    <span class="comment">// 拦截的时候， 我们都给判断未false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> target; <span class="comment">// true</span></span><br><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> proxyObj; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>例子里面， 我们代理对象用has()方法拦截判断对象是否具有某个属性时， 拦我们拦截到的时候都个片段未false， 所以使用代理对象判断时返回的都是false( “name” in target)。如果我们没有使用代理对象的话，那么是对象target 是具有name属性的。</p>
<p><strong>注意：</strong>has()方法只能拦截hasProperty， 而不是hasOwnProperty. 所以是不能判断一个属性是否是一个对象的自身属性。</p>
<p> 还有注意的就是：has 对 for…in… 是不管用的的</p>
<p>未完， 待学习….</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>MutationObserver 追踪DOM的变化</title>
    <url>/shuliqi.github.io/2020/04/21/MutationObserver-%E7%9B%91%E5%90%ACDOM%E6%A0%91%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<p><code>Mutation observer</code>（变动观察器）是监听DOM变动的接口。当DOM对象树发生任何变动时，Mutation observer会得到通知。</p>
<p>其实<code>Mutation observer</code>代替了<code>Mutation events</code>作为观察DOM树结构发生变化时，作出相应处理的API。为什么要使用<code>Mutation observer</code>去替代 <code>Mutation events</code>呢？ 我们可以先了解一下<code>Mutation events</code></p>
<a id="more"></a>
<h1 id="Mutation-events"><a href="#Mutation-events" class="headerlink" title="Mutation events"></a>Mutation events</h1><p><code>Mutation events</code>是在 <a href="https://link.jianshu.com/?t=https://www.w3.org/TR/DOM-Level-3-Events/#events-mutationevents" target="_blank" rel="noopener">DOM3中定义</a>，用于监听DOM树结构变化的事件</p>
<p><code>Mutation events</code>的一个简单的例子<strong><a href="https://codepen.io/shuliqi/pen/dyYObbo" target="_blank" rel="noopener">Demo</a></strong></p>
<p>可知它的简单用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"container"</span>).addEventListener(<span class="string">"DOMSubtreeModified"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我检测到子元素被修改'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Mutation events</strong> 支持的事件列表如下：</p>
<ol>
<li><p><strong>DOMAttributeNameChanged</strong>：</p>
</li>
<li><p><strong>DOMCharacterDataModified</strong>：在文本节点的值发生变化时触发</p>
</li>
<li><p><strong>DOMElementNameChanged</strong></p>
</li>
<li><p><strong>DOMNodeInserted</strong>：监听元素子项的增加</p>
</li>
<li><p><strong>DOMNodeRemoved</strong>： 监听元素子项的删除</p>
</li>
<li><p><strong>DOMNodeInsertedIntoDocument</strong>：在一个节点被直接插入文档或通过子树间接插入到文档之后触发。这个事件在DOMNodeInserted之后触发</p>
</li>
<li><p><strong>DOMSubtreeModified</strong>： 监听元素子项的修改(包括删除和新增)</p>
</li>
<li><p><strong>DOMAttrModified</strong>： 是监听元素属性的修改，并且能够提供具体的修改动作</p>
</li>
</ol>
<h1 id="Mutation-events-遇到的问题"><a href="#Mutation-events-遇到的问题" class="headerlink" title="Mutation events 遇到的问题"></a>Mutation events 遇到的问题</h1><ol>
<li><p><strong>浏览器兼容问题</strong></p>
<ul>
<li>IE9不支持<code>Mutation events</code></li>
<li>webkit内核不支持DOMAttrModified特性</li>
<li>DOMElementNameChanged 和 DOMAttributeNameChanged 在Firefox上不被支持</li>
</ul>
</li>
<li><p><strong>性能问题</strong></p>
<ul>
<li><code>Mutation events</code> 是同步执行的，他每次调用，都需要从队列中取出事件，执行，然后从队列中移除，期间需要移动队列元素。如果事件触发的较为频繁的话， 每一次都需要执行上面的步骤，那么浏览器就会被拖慢。</li>
<li><code>Mutation events</code> 本身是事件， 所以捕获是采用事件冒泡的形式，如果冒泡期间又出发了其他的 <code>Mutation events</code>的话，很有可能会导致阻塞javascript线程，甚至导致浏览器崩溃。</li>
</ul>
</li>
</ol>
<h1 id="Mutation-Observer"><a href="#Mutation-Observer" class="headerlink" title="Mutation Observer"></a>Mutation Observer</h1><p><code>Mutation Observer</code> 是在DOM4中定义的， 用于替代<code>Mutation events</code>的新的API，它的不同events 的是，<code>Mutation Observer</code> 所有监听操作以及相应处理都是在其他脚本执行完毕之后异步执行的，并且是所有的变动触发之后，将变的记录在数组中，统一进行回调，也就是说，当你使用observer监听多个DOM 变化时， 并且这若干DOM发生变化，那么observer会将变化记录到变化中， 等到一起都结束了，然后一次性的冲变化数组中执行相应饿回调函数。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>只有在全部DOM操作完成之后才会调用callback, 可以看下面的<strong>验证的例子</strong>的<code>callback的回调次数</code>,</li>
<li>DOM 变动纪录封装成一个数组举行处置惩罚，而不是一条条地一般处置 DOM 变动。</li>
<li>能够视察发作在 DOM 节点的一切变动，也能够视察某一类变动</li>
</ol>
<p>如今，Firefox(14+)、Chrome(26+)、Opera(15+)、IE(11+) 和 Safari(6.1+) 支撑这个 API。 Safari 6.0 和 Chrome 18-25 运用这个 API 的时刻，须要加上 WebKit 前缀（WebKitMutationObserver）。能够运用下面的表达式搜检浏览器是不是支撑这个 API。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MutationObserver =</span><br><span class="line">  <span class="built_in">window</span>.MutationObserver ||</span><br><span class="line">  <span class="built_in">window</span>.WebKitMutationObserver ||</span><br><span class="line">  <span class="built_in">window</span>.MozMutationObserver</span><br><span class="line"><span class="comment">// 监测浏览器是不是支撑</span></span><br><span class="line"><span class="keyword">const</span> observeMutationSupport = !!MutationObserver</span><br></pre></td></tr></table></figure>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>Mutation Observer 的API 调用非常简单， 是一个构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line">  mutations.forEach(<span class="function"><span class="params">mutation</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mutation)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>MutationObserver 构造函数实例化一个观察者对象，其中的一个参数是一个回调函数，它会在指定的DOM节点发生变化之后执行的函数，回调函数会被传入两个参数， 一个是变化记录数组, 另外一个是观察者对象本身。</p>
<p>实例对象具有三个方法：</p>
<ol>
<li><code>observe</code></li>
<li><code>disconnect</code></li>
<li><code>takeRecords</code></li>
</ol>
<h2 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h2><p>在观察者对象上，注册需要 观察的DOM节点，以及相应的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> observe(Node target, optional MutationObserverInit options)</span><br></pre></td></tr></table></figure>
<p>其中可选参数 MutationObserverInit的属性如下：</p>
<ol>
<li><strong>childLIst</strong>： 观察目标节点的子节点的新增和删除 。</li>
<li><strong>attributes</strong>： 观察目标节点的属性节点(新增或删除了某个属性,以及某个属性的属性值发生了变化)。</li>
<li><strong>characterData</strong>： 如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化</li>
<li><strong>subtree</strong>：观察目标节点的所有后代节点(观察目标节点所包含的整棵DOM树上的上述三种节点变化)</li>
<li><strong>attributeOldValue</strong>： 已经设为true的前提下,将发生变化characterData节点之前的文本内容记录下来(记录到下面MutationRecord对象的oldValue属性中)</li>
<li><strong>attributeFilter</strong>： 一个属性名数组(不需要指定命名空间),只有该数组中包含的属性名发生变化时才会被观察到,其他名称的属性发生变化后会被忽略想要设置那些筛选参数的话，</li>
</ol>
<p>如果想要使用哪个参数的话， 就将其值设定为true。</p>
<h2 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h2><p>暂停在观察者对象上设置的节点的变化的监听， 直到重新调用observe 方法。</p>
<h2 id="takeRecords"><a href="#takeRecords" class="headerlink" title="takeRecords"></a>takeRecords</h2><p>在观察者对象上调用takeRecords 会返回其观察节点上的变化的记录(MutationRecords)数组。</p>
<p>其中MutationRecords数组也会作为观察者初始化时的回调函数的第一个参数。其中的属性如下：</p>
<ol>
<li><strong>type</strong>： 如果是属性发生变化，则返回attribuutes。如果是一个CharacterData节点发生变化，则返回characterData, 如果目标节点的某个字节点发生了变化，则返回childList.</li>
<li><strong>target</strong>：返回此次变化影响到的节点，具体返回哪种节点类型是根据type值的不同而不同的。如果type为attributes，则返回发生变化的属性节点所在的元素节点。如果type值是characterData，则返回发生变化的这个characterData节点。如果type值是childLiist,则返回发生变化的的子节点的父节点。</li>
<li><strong>addedNodes</strong>:返回被添加的节点。</li>
<li><strong>removeNodes</strong>：返回被删除的节点</li>
<li><strong>previousSibling</strong>: 返回被添加或者删除的节点的前一个兄弟节点。</li>
<li><strong>nextSibling</strong>: 返回被添加或者删除的节点的后一个兄弟节点。</li>
<li><strong>attributeName</strong>： 返回变更属性的本地名称。</li>
<li><strong>oldValue</strong>: 根据type 值的不同， 返回的值也会不同。如果type为attributes,则返回该属性变化之前的属性值.如果type为characterData,则返回该节点变化之前的文本数据.如果type为childList,则返回null</li>
</ol>
<h1 id="验证的的例子"><a href="#验证的的例子" class="headerlink" title="验证的的例子"></a>验证的的例子</h1><h2 id="callback的回调次数"><a href="#callback的回调次数" class="headerlink" title="callback的回调次数"></a>callback的回调次数</h2><p><strong>html结构：</strong></p>
   <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>打开控制台看看log<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'target'</span> <span class="attr">class</span>=<span class="string">'block'</span> <span class="attr">name</span>=<span class="string">'target'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是target的第一个子节点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是target的后代<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>javascri 代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>);</span><br><span class="line"><span class="keyword">const</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> observe=<span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations,observe</span>) </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我在全部DOM操作完成之后才会调用， 不信你看i的值:"</span>, i) <span class="comment">// </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//设置true，表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</span></span><br><span class="line">  childList: <span class="literal">true</span>, </span><br><span class="line">&#125;</span><br><span class="line">observe.observe(target, config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加几个TextNode节点</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'我新加的textNode1'</span>));</span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'我是新加的textNode2'</span>));</span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'我是新加的textNode3'</span>));</span><br></pre></td></tr></table></figure>
<p><strong>控制台打印的结果：</strong></p>
<p>控制只会打印一条：“ 我在全部DOM操作完成之后才会调用， 不信你看i的值: 1”</p>
<p><strong>说明</strong></p>
<p>MutationObserver的callback回调是异步的，只有在所有的DOM操作完成之后才会调用callback。</p>
<p><strong><a href="https://codepen.io/shuliqi/pen/zYvobdB" target="_blank" rel="noopener">可以移步看看Demo</a> </strong></p>
<h2 id="childList属性"><a href="#childList属性" class="headerlink" title="childList属性"></a>childList属性</h2><p><strong>html结构</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>打开控制台看看log<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'target'</span> <span class="attr">class</span>=<span class="string">'block'</span> <span class="attr">name</span>=<span class="string">'target'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是target的第一个子节点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是target的后代<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>javascript代码</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>);</span><br><span class="line"><span class="keyword">const</span> observe=<span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations,observe</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(mutations);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//设置true，表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</span></span><br><span class="line">  childList: <span class="literal">true</span>, </span><br><span class="line">&#125;</span><br><span class="line">observe.observe(target, config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加几个TextNode节点</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'新增Text节点'</span>));   <span class="comment">//增加节点，观察到变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点，可以观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].remove();    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于只设置 childList： true, 所以修改字节点以及自子节点后代， 不会被观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].textContent=<span class="string">'改变子节点的后代'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>控制台打印的结果：</strong></p>
<img src="/shuliqi.github.io/2020/04/21/MutationObserver-监听DOM树变化/mo1.jpg">
<p><strong>说明</strong>：</p>
<p>从打印的结果得出结论，设置{ <strong>childList: true</strong>}时,表示观察目标子节点的变化,，如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</p>
<p><strong><a href="https://codepen.io/shuliqi/pen/wvKoZWB" target="_blank" rel="noopener">可以移步看看例子</a></strong></p>
<p>如果想要观察到子节点以及后台的变化需要设置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;childList: true, subtree: true&#125;</span><br></pre></td></tr></table></figure>
<p><strong><a href="https://codepen.io/shuliqi/pen/gOaLyeb" target="_blank" rel="noopener">修改后代也能观察到的具体例子可以看看</a></strong></p>
<h2 id="CharacterData属性"><a href="#CharacterData属性" class="headerlink" title="CharacterData属性"></a>CharacterData属性</h2><p><strong>html结构</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>打开控制台看看log<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'target'</span> <span class="attr">class</span>=<span class="string">'block'</span> <span class="attr">name</span>=<span class="string">'target'</span>&gt;</span></span><br><span class="line">    我是target的text节点</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是target的后代<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>javascript:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>);</span><br><span class="line"><span class="keyword">const</span> observe=<span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations,observe</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(mutations);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// 观察目标节点的子节点的新增和删除。</span></span><br><span class="line">  subtree: <span class="literal">true</span>, </span><br><span class="line">  <span class="comment">// 如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化</span></span><br><span class="line">  characterData: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">observe.observe(target, config);</span><br><span class="line"><span class="comment">// target.childNodes[0]：“我是target的第一个子节点”， 是characterData类型节点 所以可以观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].textContent=<span class="string">'改变Text节点'</span>;      </span><br><span class="line"></span><br><span class="line"><span class="comment">// arget.childNodes[1]： &lt;p&gt;&lt;span&gt;我是target的后代&lt;/span&gt;&lt;/p&gt;  不是是characterData类型节点， 所以不会观察到</span></span><br><span class="line">target.childNodes[<span class="number">1</span>].textContent=<span class="string">'改变p元素内容'</span>; </span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加text节点不会观察到</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'新增Text节点'</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除TEXT节点也不会观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].remove();  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：我们只需要记住只有对CharacterData类型的节点的数据改变才会被characterData为true的选项所观察到。</span></span><br></pre></td></tr></table></figure>
<p><strong>控制台结果</strong></p>
<img src="/shuliqi.github.io/2020/04/21/MutationObserver-监听DOM树变化/mo2.jpg">
<p><strong>说明：</strong></p>
<p>characterData这个选项，它是用来观察CharacterData类型的节点的，只有在改变节点数据时才会观察到，如果你删除或者增加节点都不会进行观察，还有如果对不是CharacterData类型的节点的改变不会观察到。</p>
<p><strong><a href="https://codepen.io/shuliqi/pen/KKdNYGq?editors=1010" target="_blank" rel="noopener">可以移步看看Demo</a></strong></p>
<h2 id="attributeFilter属性"><a href="#attributeFilter属性" class="headerlink" title="attributeFilter属性"></a>attributeFilter属性</h2><p><strong>html结构</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>打开控制台看看log<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'target'</span> <span class="attr">class</span>=<span class="string">'block'</span> <span class="attr">name</span>=<span class="string">'target'</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    我是target的text节点</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是target的后代<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>javascript代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>);</span><br><span class="line"><span class="keyword">const</span> observe=<span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations,observe</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(mutations); <span class="comment">// 我们可以看到打印的mutations有两个改变的状态</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// 观察目标节点的子节点的新增和删除。</span></span><br><span class="line">  subtree: <span class="literal">true</span>, </span><br><span class="line">  <span class="comment">// 一个属性名数组(不需要指定命名空间),只有该数组中包含的属性名发生变化时才会被观察到,其他名称的属性发生变化后会被忽略想要设置那些删选参数的话</span></span><br><span class="line">  attributeFilter: [<span class="string">"style"</span>],</span><br><span class="line">&#125;</span><br><span class="line">observe.observe(target, config);</span><br><span class="line"></span><br><span class="line">target.style=<span class="string">'color:red'</span>; <span class="comment">//可以观察到</span></span><br><span class="line"></span><br><span class="line">target.removeAttribute(<span class="string">'name'</span>); <span class="comment">//删除name属性，无法观察到</span></span><br></pre></td></tr></table></figure>
<p><strong>控制台打印的结果：</strong></p>
<img src="/shuliqi.github.io/2020/04/21/MutationObserver-监听DOM树变化/mo3.jpg">
<p><strong>说明：</strong></p>
<p>attributeFilte属性我们只设置了r: [“style”],没有设置name， 说明观察者只会观察style 属性的变化。</p>
<p>attributeFilte 选项主要是用来筛选要观察的属性</p>
<p><strong><a href="https://codepen.io/shuliqi/pen/yLYVWNK?editors=1010" target="_blank" rel="noopener">可以移步看看例子</a></strong></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 入门教程</title>
    <url>/shuliqi.github.io/2019/10/16/TypeScript%E5%85%A5%E9%97%A8-%E4%B8%80/</url>
    <content><![CDATA[<p>最近一直在看阮一峰老师的 <a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript入门教程</a>。教程写的非常好，清晰明了。学习完了自己也试着写一些总结吧。</p>
<p>其次：TypeScript <a href="http://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">官方文档</a>, <a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook" target="_blank" rel="noopener">非官方中文文档</a></p>
<a id="more"></a>
<h2 id="TypeScript-是什么"><a href="#TypeScript-是什么" class="headerlink" title="TypeScript 是什么"></a>TypeScript 是什么</h2><p>TypeScript官网是这么解释的：</p>
<blockquote>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>TypeScript 是 JavaScript 的类型的一个超集，它可以编译成纯JavaScript。编译出来的JavaScript可以运行在任何的浏览器上。TypeScript编译的工具可以运行在任何服务器和任何系统上。TypeScript是开源 的。</p>
</blockquote>
<p>而我自己的理解是：</p>
<p>TypeScript是 JavaScript的一个超集。主要提供了<strong>类型系统</strong>和对<strong>es6</strong>的支持。</p>
<h2 id="TypeScript的优点"><a href="#TypeScript的优点" class="headerlink" title="TypeScript的优点"></a>TypeScript的优点</h2><p><a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript 官网</a>列举了TypeScript的很多优点。 自己总结的话， 我觉得有以下优点：</p>
<h5 id="TypeScript增加代码的可读性和可维护性"><a href="#TypeScript增加代码的可读性和可维护性" class="headerlink" title="TypeScript增加代码的可读性和可维护性"></a>TypeScript增加代码的可读性和可维护性</h5><ul>
<li>在编译的过程中发现大部分的bug的错误。</li>
<li>增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。</li>
<li>类型系统非常好。大部分看类型的定义就知道函数该如何使用了。</li>
</ul>
<h5 id="TypeScript-非常包容"><a href="#TypeScript-非常包容" class="headerlink" title="TypeScript 非常包容"></a>TypeScript 非常包容</h5><ul>
<li>TypeScript是JavaScript的一个超集。所以后缀<code>.js</code>可以直接改名为<code>.ts</code>。</li>
<li>TypeScript编译报错， 也可以生成JavaScript文件。</li>
</ul>
<h2 id="TypeScript的缺点"><a href="#TypeScript的缺点" class="headerlink" title="TypeScript的缺点"></a>TypeScript的缺点</h2><ul>
<li><p>有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念。</p>
</li>
<li><p>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本。</p>
</li>
<li><p>集成到构建流程需要一些工作量。</p>
</li>
<li><p>可能和一些库结合的不是很完美。</p>
</li>
</ul>
<h2 id="TypeScript的安装"><a href="#TypeScript的安装" class="headerlink" title="TypeScript的安装"></a>TypeScript的安装</h2><p>TypeScript 的命令行工具安装方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-的例子"><a href="#TypeScript-的例子" class="headerlink" title="TypeScript 的例子"></a>TypeScript 的例子</h2><p>我们创建一个文件：hello.ts</p>
<p>在该文件中写入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">person: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">'shuliqi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(helloWorld(user));</span><br></pre></td></tr></table></figure>
<p>然后我们进行编辑，可以执行以下命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure>
<p>执行完，会生成一个编译好的文件：hello.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">'shuliqi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(helloWorld(user));</span><br></pre></td></tr></table></figure>
<p>注：TypeScript中使用 <strong>：</strong>指定变量的类型。 <strong>：</strong>前后有没有空格都无所谓。</p>
<p>上面的例子中，我们的变量 person 的类型是 string。 但是在编译之后的js 中， 并没有检查变量类型的代码插入进来。</p>
<p><strong>TypeScript只会静态检查，如果有错误。在编译的时候会抛出错误</strong></p>
<p>例如：我们在hello.ts中的user变量赋值一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">person: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(helloWorld(user));</span><br></pre></td></tr></table></figure>
<p>编译的时候就会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hello.ts:<span class="number">6</span>:<span class="number">24</span> - error TS2345: Argument <span class="keyword">of</span> type <span class="string">'number[]'</span> is not assignable to parameter <span class="keyword">of</span> type <span class="string">'string'</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="built_in">console</span>.log(helloWorld(user));</span><br><span class="line">                         ~~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> error.</span><br></pre></td></tr></table></figure>
<p><strong>TypeScript在编译的时候检查出错误，抛出错误，但还是会生成js文件</strong>。</p>
<p>如上的例子，还是会生成<strong>.js</strong>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(helloWorld(user));</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript基础"><a href="#TypeScript基础" class="headerlink" title="TypeScript基础"></a>TypeScript基础</h2><h4 id="一-原始数据类型"><a href="#一-原始数据类型" class="headerlink" title="一.原始数据类型"></a>一.原始数据类型</h4><blockquote>
<p>TypeScript支持与Javascript几乎相同的数据类型。</p>
<p>Javascript分为原始数据类型（布尔值，数值，字符串，null, undefined）和对象类型。</p>
</blockquote>
<h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><p>在typeScript中使用<code>boolean</code>定义布尔值类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isOk:boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span></span><br></pre></td></tr></table></figure>
<p>注意：只有构造函数 <code>Boolean</code>创建的对象不是布尔值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isOk:boolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>编译的时候报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hello.ts:<span class="number">10</span>:<span class="number">5</span> - error TS2322: Type <span class="string">'Boolean'</span> is not assignable to type <span class="string">'boolean'</span>.</span><br><span class="line">  <span class="string">'boolean'</span> is a primitive, but <span class="string">'Boolean'</span> is a wrapper object. Prefer using <span class="string">'boolean'</span> when possible.</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="keyword">let</span> isOk : boolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>原因：new Boolean()返回的是一个 <code>Boolean</code> 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isOk:<span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>编译不回报错</p>
<p>其次直接调用 <code>Boolean</code>也是返回布尔值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isOk:boolean = <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h5 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h5><p>在TypeScript中使用<code>number</code>定义数值类型。</p>
<p>TypeScript和Javascript一样，所有的数字都是浮点数。类型都<code>number</code>。TypeScript除了支持十进制和十六进制字面量外，还支持<a href="http://es6.ruanyifeng.com/#docs/number" target="_blank" rel="noopener">ES6的八进制和二进制的字面量</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: number = <span class="number">0b1010</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: number = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> notANumber: number = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> infinityNumber: number = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure>
<p>编辑的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> decLiteral = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> hexLiteral = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">var</span> binaryLiteral = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">var</span> octalLiteral = <span class="number">484</span>;</span><br><span class="line"><span class="keyword">var</span> notANumber = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> infinityNumber = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>0b1010</code> 和 <code>0o744</code> 是 <a href="http://es6.ruanyifeng.com/#docs/number#二进制和八进制表示法" target="_blank" rel="noopener">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>用<code>string</code>表示文本数据类型。 和JavaScript一样，可以使用双引号（<code>&quot;</code>），单引号（<code>’</code>）或 <code>模版字符串</code> 表示字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双引号</span></span><br><span class="line"><span class="keyword">let</span> firstName:string = <span class="string">"shu"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单引号</span></span><br><span class="line"><span class="keyword">let</span> lastName:string = <span class="string">"liqi"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版字符串</span></span><br><span class="line"><span class="keyword">let</span> name:string = <span class="string">`my name is <span class="subst">$&#123;firstName&#125;</span><span class="subst">$&#123;lastName&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// my name is shu liqi</span></span><br></pre></td></tr></table></figure>
<h5 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h5><p>JavaScript中时没有空值的概念。但在TypeScript 中可以使用<code>void</code> 表示没有任何返回值的函数。</p>
<p>注意：定义一个空值的变量是没有用的。因为只能赋值 null 或者 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'my name is shuliqi'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name:<span class="keyword">void</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h5 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h5><p>可以使用 Null 和 Undefined 来定义这两个原始类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName:<span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> age:<span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<p>注意：null 和 undefined 是所有类型的子集。也就是说 null ，undefined 可以赋值给其他类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: string = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> age: number = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myName: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> myLastName: number = myName;</span><br><span class="line"><span class="keyword">let</span> myAge = age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都不会报错</span></span><br></pre></td></tr></table></figure>
<p>但是 <code>void</code> 类型的变量不能赋值给 其他 类型的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myAge:<span class="keyword">void</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> myGender:<span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age: number = myAge;</span><br><span class="line"><span class="keyword">let</span> gender: string = myGender;</span><br></pre></td></tr></table></figure>
<p>编译报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hello.ts:<span class="number">52</span>:<span class="number">5</span> - error TS2322: Type <span class="string">'void'</span> is not assignable to type <span class="string">'number'</span>.</span><br><span class="line"><span class="number">52</span> <span class="keyword">let</span> age: number = myAge;</span><br><span class="line">hello.ts:<span class="number">53</span>:<span class="number">5</span> - error TS2322: Type <span class="string">'void'</span> is not assignable to type <span class="string">'string'</span>.</span><br><span class="line"><span class="number">53</span> <span class="keyword">let</span> gender: string = myGender;</span><br></pre></td></tr></table></figure>
<h4 id="二-任意值"><a href="#二-任意值" class="headerlink" title="二. 任意值"></a>二. 任意值</h4><p>任意值（Any）用来表示允许赋值为任何类型。</p>
<h5 id="什么是任意值类型"><a href="#什么是任意值类型" class="headerlink" title="什么是任意值类型"></a>什么是任意值类型</h5><p>在TypeScript中普通的类型，如果在赋值的过程中改变类型是不允许的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age: string = <span class="string">'12'</span>;</span><br><span class="line">age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>编译时报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hello.ts:<span class="number">62</span>:<span class="number">1</span> - error TS2322: Type <span class="string">'5'</span> is not assignable to type <span class="string">'string'</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">62</span> age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>但是类型是任意值类型的话。就允许在赋值的过程中改变类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let age: any = &apos;12&apos;;</span><br><span class="line">age = 5</span><br></pre></td></tr></table></figure>
<h5 id="任意值的属性和方法"><a href="#任意值的属性和方法" class="headerlink" title="任意值的属性和方法"></a>任意值的属性和方法</h5><p>访问任意值的属性和方法都是允许的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anyName: any = <span class="string">"shuliqi"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anyName.firstName);</span><br><span class="line">anyName.setName(<span class="string">'shulina'</span>);</span><br></pre></td></tr></table></figure>
<p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p>
<h5 id="未声明的类型的变量"><a href="#未声明的类型的变量" class="headerlink" title="未声明的类型的变量"></a>未声明的类型的变量</h5><p>如果在声明变量的时候，没有制指定类型。那么会被识别为任意值类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName;</span><br><span class="line">myName = <span class="string">'shuliqi'</span>;</span><br><span class="line">myName = <span class="number">12</span>;</span><br><span class="line">myName = <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line">myName = <span class="literal">null</span>; </span><br><span class="line">myName = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<h4 id="三-类型推论"><a href="#三-类型推论" class="headerlink" title="三. 类型推论"></a>三. 类型推论</h4><p>如果在定义一个变量的时候。没有明确的指定类型。那么在TypeScript就会按照<strong>类型推论</strong>规则来推断出一个类型。</p>
<h5 id="什么是类型推论"><a href="#什么是类型推论" class="headerlink" title="什么是类型推论"></a>什么是类型推论</h5><p>如以下的代码虽然没有指定类型，但是在编译时会出错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">34</span>;</span><br><span class="line">age = <span class="string">"shuliqi"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错：</span></span><br><span class="line">Type <span class="string">'"shuliqi"'</span> is not assignable to type <span class="string">'number'</span>.</span><br></pre></td></tr></table></figure>
<p>其实上面的代码等价于这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age: number = <span class="number">34</span>;</span><br><span class="line">age = <span class="string">"shuliqi"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错：</span></span><br><span class="line">Type <span class="string">'"shuliqi"'</span> is not assignable to type <span class="string">'number'</span>.</span><br></pre></td></tr></table></figure>
<p>原因：TypeScript会在没有明确定义变量的类型的时候推测出一个类型。这就是<strong>类型推论</strong></p>
<p>注意：在定义的时候没有赋值。不管之后有没有赋值，都会被推断为<code>any</code>类型。而不做类型检查。sss</p>
<h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>联合类型表示取值可以为多种类型中的一种。</p>
<p>联合类型 用 <code>|</code>分隔每个类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> haha: string | number;</span><br><span class="line">haha = <span class="string">'shuliqi'</span>;</span><br><span class="line">haha = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>以上例子表示：haha这个变量类型可以是<code>string</code> , <code>number</code>     但是不能是其他的类型。</p>
<h4 id="对象的类型—接口"><a href="#对象的类型—接口" class="headerlink" title="对象的类型—接口"></a>对象的类型—接口</h4><p>在TypeScript中，我们使用接口来定义对象的类型。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  name: <span class="string">'shuliqi'</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中我们定义了一个接口 Person， 然后我们定义了一个变量 shu，它的类型是 Person。这就约束了shu的形状必须和Person一致。</p>
<p>注意：接口的首字母一般大写。</p>
<p>如果我们定义的变量比接口少一些属性是不允许的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  name: <span class="string">'shuliqi'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时会报错的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'age'</span> is declared here.</span><br></pre></td></tr></table></figure>
<p>如果我们定义的变量比接口多一些属性也是不允许的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  name: <span class="string">'shuliqi'</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  parent: <span class="string">'shulina'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">error TS2322: Type <span class="string">'&#123; name: string; age: number; parent: string; &#125;'</span> is not assignable to type <span class="string">'Person'</span>.</span><br><span class="line">  <span class="built_in">Object</span> literal may only specify known properties, and <span class="string">'parent'</span> does not exist <span class="keyword">in</span> type <span class="string">'Person'</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>  parent: <span class="string">'shulina'</span></span><br></pre></td></tr></table></figure>
<h5 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h5><p>有的时候我们不需要完全匹配一个形状。我们可以使用可选属性：在属性后端加 ？ 符号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  name: <span class="string">'shuliqi'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可选属性的含义可以不存在。注意： 这时候仍然不可以添加未定义的属性。</p>
<h5 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h5><p>有时候我们希望一个接口允许有任意的属性，可以使用如下的方式 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  [propName: string]: any;s</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  name: <span class="string">'shuliqi'</span>,</span><br><span class="line">  age: <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[propName: string ] 表示属性的类型是string</p>
<p>注意：<strong>如果我们的定义了任意属性，那么确定属性和可选属性都必须是它值类型的子集：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number</span><br><span class="line">  [propName: string]: string</span><br><span class="line">&#125;</span><br><span class="line">let shu: Person = &#123;</span><br><span class="line">  name: &apos;shuliqi&apos;,</span><br><span class="line">  age: 12,</span><br><span class="line">  parent: &apos;123&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译额时候会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Type <span class="string">'&#123; name: string; age: number; parent: string; &#125;'</span> is not assignable to type <span class="string">'Person'</span>.</span><br><span class="line">  Property <span class="string">'age'</span> is incompatible <span class="keyword">with</span> index signature.</span><br><span class="line">    Type <span class="string">'number'</span> is not assignable to type <span class="string">'string'</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">      ~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found <span class="number">2</span> errors.</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong>：可选属性age的值的类型是number， 任意属性的值的类型 是string。number 不是stringl类型。所以会报错.</p>
<p>未整理完….待继续整理</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作整理</title>
    <url>/shuliqi.github.io/2019/09/17/git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p><strong>获得Git项目的仓库有两种方式：</strong></p>
<ol>
<li><p>在现有的目录下面通过导入所有的文件夹来创建Git仓库</p>
</li>
<li><p>从已有的仓库克隆一个新新的镜像仓库来使用</p>
</li>
</ol>
</blockquote>
<a id="more"></a>
<h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>在现有的工作目录中初始化新仓库：</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_init.png">
<p>初始化完成后，在当前的目录下面会出现一个名为.git的目录。</p>
<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>从现有的仓库克隆。</p>
<p>克隆的命令：<code>git clone [url]</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:shuliqi/echarts-vue.git</span><br></pre></td></tr></table></figure>
<h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>检查当前文件的状态。</p>
<blockquote>
<p>git的工作目录下的所有文件都不外呼两种状态：已跟踪，未跟踪</p>
<p><code>已跟踪：</code> 指被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间之后，它们的状态可能是<code>未更新</code>，<code>已修改</code>，<code>已放入暂存入</code></p>
<p><code>未跟踪：</code>没有上次的更新时的快照，也不在当前的暂存区域（即不是已跟踪文件就是未更新文件）。</p>
<p>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>
</blockquote>
<img src="/shuliqi.github.io/2019/09/17/git命令/no_status.png">
<p>说明当前的工作目录很干净。所有的跟踪文件在上次提交之后没有更新过。</p>
<p>我们新建一个文件，1.js。 通过 <code>git status</code> 可看出我们新建的文件在未跟踪的文件列表里面.</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/add-status.png">
<h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>跟踪一个新文件。</p>
<p>例如，要跟踪一个新文件1.js, 则可以:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git add <span class="number">1.</span>js</span><br></pre></td></tr></table></figure>
<p>添加跟踪完之后，我们再根据<code>git status</code> 查看状态，可看出该文件已经添加到已追踪列表.</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_new_status.png">
<p>只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中</p>
<p> 当我们在修改1.js 文件。再<code>git status</code>：</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/edit_status.png">
<p>文件 1.js  出现在 “Changes not staged for commit”  这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 <code>git add</code> 命令。</p>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>有一些文件我们不需要纳入git版本控制。但是我们也不希望它出现在未跟踪的文件列表中。我们可以创建一个名为：.gitignore的文件。里面列出需要忽略的文件的模式。</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/gitignore.png">
<p>文件<code>.gitignore</code>的格式如下：</p>
<ul>
<li>所有的以<code>#</code>符号开头，所有的空行都会被省略。</li>
<li>可以使用标准的 glob 模式匹配（指 shell 所使用的简化了的正则表达式）。</li>
<li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .js 结尾的文件</span><br><span class="line">*.js</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!shuliqi.js</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br><span class="line">doc<span class="comment">/**/</span>*.txt</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc<span class="comment">/*.txt</span></span><br></pre></td></tr></table></figure>
<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p><code>git status</code> 显示比较简单，仅仅是列出了修改过的文件。如果要看文件具体修改了哪些地方，可以使用<code>git diff</code></p>
<p>如果我们修改了文件。再使用<code>git diff</code> 查看：</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_diff_1.png">
<p>比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>
<p><strong>注意</strong></p>
<ul>
<li><p><code>git diff ：</code> 对比工作区(未 git add)和暂存区(git add 之后)</p>
</li>
<li><p><code>git diff —cached:</code> 对比暂存区(git add 之后)和版本库(git commit 之后)</p>
</li>
<li><p><code>git diff HEAD:</code> 对比工作区(未 git add)和版本库(git commit 之后)</p>
</li>
</ul>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>提交更新。</p>
<p>使用<code>git commit</code> 提交暂存区代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p>这种方式会启动文本编辑器以便输入本次提交的说明。</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_commit.png">
<p>还有一种提交的方式，不需要启动文本编辑器来提交本次的说明。</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_commit_m.png">
<p>提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添改和删改过。</p>
<p>虽然使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。</p>
<p>那么使用 <code>git commit -a -m&quot;跳过暂存区提交&quot;</code></p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_commit_a.png">
<p>提交之前不再需要 <code>git add</code> 文件了。</p>
<p><strong><code>git commit --amend</code> </strong> 此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。</p>
<p>我们使用<code>git log  -1</code> 查看上一次commit的简要信息</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_commit_amend1.png">
<p>撤销上次的commit, 重新编辑提交说明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<p>提交说明改成: “提交新东西(git commit —amend)”</p>

<p>再<code>git log</code> 查看当前的提交历史</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_commit_amend3.png">
<p>从图中看看出，我们的提交说明已经改变了。并且提交历史也没有我们第一次的commit(我们已经改变了)</p>
<p>如果上次的提交我们有些文件改动没有暂存，我们可以补上暂存操作，然后再<code>git commit --ammend</code>提交。</p>
<p>例如： 我们提交了一次commit</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_commit_amend3.png">
<p>当前的更新历史为：</p>

<p>补上一个暂存操作，再<code>git commit --ammend</code>，可更改上次的提交了.</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git-commit-amend6.png">
<img src="/shuliqi.github.io/2019/09/17/git命令/git-commit-amend7.png">
<p>总结：以下的操作只会产生一个commit</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'提交'</span></span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>移除文件。</p>
<p>如果想在git 删除某个文件，就必须得从已跟踪（暂存区）的文件清单中移除。然后再提交。使用<code>git rm</code> 移除文件。那么移除的文件就不会出现在未跟踪的清单中了。</p>
<p>如果手动删除了一个文件，再使用<code>git status</code>查看：</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_rm.png">
<p>显示在“Changes not staged for commit”。也就是文件还在跟踪中。</p>
<p>如果使用<code>git rm</code></p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_rm_2.png">
<p>那么最后提交的时候，该文件就不再纳入版本管理了。</p>
<p>如果我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。则可以使用git rm –cached 文件</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_rm_cached.png">
<h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>移除文件（更改文件名）。</p>
<p>git 无法跟踪文件的移除操作。如果我们改了一个文件名。 Git 并不会体现出这一操作。如果想给一个文件改名，则可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git mv old_name new_name</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_mv.png">
<p><code>git mv</code>命令相当于以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ mv old.txt new.txt</span><br><span class="line">➜ git rm old.txt</span><br><span class="line">➜ git add new.txt</span><br></pre></td></tr></table></figure>
<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>查看提交历史。</p>
<p>使用<code>git log</code> 查看提交历史.</p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_log.png">
<p>如果默认没有参数， 会按提交的时间显示所有的更新。最近的更新排在最上面。每一次的提交都有SHA-1 校验，作者的名字和邮箱，提交的时间， 提交声明。</p>
<p><code>git log</code>     一些常用的选项:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log -p <span class="comment">// 展开显示每次提交的内容的差异</span></span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_log_p.png">
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git log -<span class="xml"><span class="tag">&lt;<span class="name">n</span>&gt;</span> // 加上n &gt; 0 的数字， 显示最近几次的提交</span></span><br></pre></td></tr></table></figure>
<p>例如：<code>git log -1</code></p>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_log_1.png">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log -p --word-diff. // 单词层面的比较</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_log_word.png">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --stat //显示简要的增改行数统计</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_log_stat.png">
<p><strong>整理的常用的选项：</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-p</code></td>
<td>按补丁格式显示每个更新之间的差异。</td>
</tr>
<tr>
<td><code>--word-diff</code></td>
<td>按 word diff 格式显示差异。</td>
</tr>
<tr>
<td><code>--stat</code></td>
<td>显示每次更新的文件修改统计信息。</td>
</tr>
<tr>
<td><code>--shortstat</code></td>
<td>只显示 –stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr>
<td><code>--name-only</code></td>
<td>仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr>
<td><code>--name-status</code></td>
<td>显示新增、修改、删除的文件清单。</td>
</tr>
<tr>
<td><code>--abbrev-commit</code></td>
<td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td>
</tr>
<tr>
<td><code>--relative-date</code></td>
<td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td>
</tr>
<tr>
<td><code>--graph</code></td>
<td>显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr>
<td><code>--pretty</code></td>
<td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
<tr>
<td><code>--oneline</code></td>
<td><code>--pretty=oneline --abbrev-commit</code> 的简化用法。</td>
</tr>
</tbody>
</table>
<p>其他的：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-(n)</code></td>
<td>仅显示最近的 n 条提交</td>
</tr>
<tr>
<td><code>--since, --after</code></td>
<td>仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td><code>--until, --before</code></td>
<td>仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td><code>--author</code></td>
<td>仅显示指定作者相关的提交。</td>
</tr>
<tr>
<td><code>--committer</code></td>
<td>仅显示指定提交者相关的提交。</td>
</tr>
</tbody>
</table>
<h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>取消已经暂存的文件。</p>
<p>假如我们不小心<code>git add</code> 了一个文件加到暂存区。但是我们想撤消该文件加到暂存区。则可以使用<code>git reset</code>进行撤销。</p>
<blockquote>
<p>命令不需要我们强制记住，<code>git add</code> 之后我们使用<code>git status</code> 可以看到git 提示我们如何撤消。</p>
</blockquote>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_reset.png">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt; // 如何在暂存区撤销一个文件</span><br></pre></td></tr></table></figure>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_reset1.png">
<p>即可撤消。</p>
<h2 id="git-checkout-–-file"><a href="#git-checkout-–-file" class="headerlink" title="git checkout – file"></a>git checkout – file</h2><p>取消对文件的修改。</p>
<p>如果我们觉得对一个文件的修改没有必要。想要取消修改。则可以使用<code>git checkout -- &lt;file&gt;</code></p>
<blockquote>
<p>命令不需要我们强制记住，<code>git add</code> 之后我们使用<code>git status</code> 可以看到git 提示我们如何取消对一个文件的修改。</p>
</blockquote>
<img src="/shuliqi.github.io/2019/09/17/git命令/git_checkout-file.png">
<img src="/shuliqi.github.io/2019/09/17/git命令/git_checkout_file1.png">
<p>撤消之后，再<code>git status</code>该文件则已经回到没有修改过的状态了。</p>
<h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p>查看远程仓库。</p>
<p> <code>git remote</code>: 会显示每个远程仓库的简短的名字.如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜ git remoete</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p><code>git remote -v</code>: 显示远程仓库的名字和对应的clone 地址。如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜ git remote -v</span><br><span class="line">origin	git@github.com:shuliqi/rzfx.git (fetch)</span><br><span class="line">origin	git@github.com:shuliqi/rzfx.git (push)</span><br></pre></td></tr></table></figure>
<p><code>git remote add [name] [url]</code> 添加远程仓库。如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜ git remote add shuliqi git@github.com:shuliqi/rzfx.git</span><br><span class="line">➜ git:(master) git remote -v</span><br><span class="line">origin	git@github.com:shuliqi/rzfx.git (fetch)</span><br><span class="line">origin	git@github.com:shuliqi/rzfx.git (push)</span><br><span class="line">shuliqi	git@github.com:shuliqi/rzfx.git (fetch)</span><br><span class="line">shuliqi	git@github.com:shuliqi/rzfx.git (push)</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>git fetch shuliqi</code> 来抓取shuliqi仓库有的但是本地没有的信息。</p>
<p><code>git remote show [remote-name]</code>: 查看某个远程仓库的相信信息。</p>
<p>例如：查看克隆的origin的仓库的分支。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com:shuliqi/rzfx.git</span><br><span class="line">  Push  URL: git@github.com:shuliqi/rzfx.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master     tracked</span><br><span class="line">    shu        tracked</span><br><span class="line">    shu-branch tracked</span><br><span class="line">  Local branch configured for 'git pull':</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local refs configured for 'git push':</span><br><span class="line">    master pushes to master (fast-forwardable)</span><br><span class="line">    shu    pushes to shu    (up to date)</span><br></pre></td></tr></table></figure>
<p>给出了很多的信息：</p>
<ul>
<li><p>仓库的克隆地址</p>
</li>
<li><p>提醒你要是在master 可以使用<code>git pull</code>抓取数据。</p>
</li>
<li><p>列出了所有的处于跟踪的分支（master, shu, shu-branch ）</p>
</li>
</ul>
<p><code>git remote rename [old-remote-name] [new-remote-name]</code> 命令修改某个远程仓库在本地的简称。</p>
<p>例如：把本地仓库<code>origin</code>改成成<code>shu</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜ git remote</span><br><span class="line">origin</span><br><span class="line">shuliqi</span><br><span class="line">➜  git remote rename shuliqi shu</span><br><span class="line">➜  git remote</span><br><span class="line">origin</span><br><span class="line">shu</span><br></pre></td></tr></table></figure>
<p>git remote rm [remote-name]` 删除远端仓库。</p>
<p>例如：删除远程仓库<code>shu</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜ git remote</span><br><span class="line">origin</span><br><span class="line">shu</span><br><span class="line">➜  git remote rm shu</span><br><span class="line">➜  git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p><code>git fetach &lt;remote-name&gt;</code>会到远程仓库中拉取所有你本地仓库中还没有的数据。</p>
<p>fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜ git fetch origin</span><br></pre></td></tr></table></figure>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>将本地仓库中的数据推送到远程仓库 <code>git push [remote-name] [branch-name]</code> </p>
<p>例如： 我们新建一个分支<code>shu</code>。对代码做了一些改动。并且推送到远程跟踪的相应的分支。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜  git checkout -b shu</span><br><span class="line">Switched to a new branch 'shu'</span><br><span class="line">➜  git commit -a -m"将本地数据推送到远程"</span><br><span class="line">[shu be180a1] 将本地数据推送到远程</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">➜  git push origin shu</span><br><span class="line">Counting objects: 15, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (15/15), 1.41 KiB | 1.41 MiB/s, done.</span><br><span class="line">Total 15 (delta 9), reused 0 (delta 0)</span><br><span class="line"><span class="comment">remote: Resolving deltas: 100% (9/9), completed with 4 local objects.</span></span><br><span class="line"><span class="comment">remote:</span></span><br><span class="line"><span class="comment">remote: Create a pull request for 'shu' on GitHub by visiting:</span></span><br><span class="line"><span class="comment">remote:      https://github.com/shuliqi/rzfx/pull/new/shu</span></span><br><span class="line"><span class="comment">remote:</span></span><br><span class="line"><span class="comment">remote:</span></span><br><span class="line"><span class="comment">remote:</span></span><br><span class="line"><span class="comment">remote: GitHub found 2 vulnerabilities on shuliqi/rzfx's default branch (1 high, 1 moderate). To find out more, visit:</span></span><br><span class="line"><span class="comment">remote:      https://github.com/shuliqi/rzfx/network/alerts</span></span><br><span class="line"><span class="comment">remote:</span></span><br><span class="line">To github.com:shuliqi/rzfx.git</span><br><span class="line"> * [new branch]      shu -&gt; shu</span><br></pre></td></tr></table></figure>
<p>这条命令如期执行的条件：</p>
<ul>
<li>在该克隆的服务器上有读写权限。</li>
<li>在同一时刻，没有其他人提交更新</li>
</ul>
<p>如果在推送前，有人已经做了若干更新。 那么你的更新会被驳回。你只能把他们的更新抓到本地。 并且和冰岛自己的项目中。然后进行再次推送才会成功。</p>
<h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><h4 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h4><p>使用<code>git tag</code>    列出所有的标签</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜  git tag</span><br><span class="line">v0.0.1</span><br><span class="line">v0.0.2</span><br><span class="line">v0.0.3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Git 使用的标签有两种类型：</p>
<ul>
<li>轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</li>
<li>含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</li>
</ul>
</blockquote>
<h4 id="新建含附注标签"><a href="#新建含附注标签" class="headerlink" title="新建含附注标签"></a>新建含附注标签</h4><p>如命令：<code>git tag -a v0.0.1 -m&quot;新建一个标签，标记0.0.1版本&quot;</code> 可以新建一个含附注标签。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜  git tag -a v0.0.1 -m"新建一个标签，标记0.0.1版本"</span><br><span class="line">➜  git tag</span><br><span class="line">v0.0.1</span><br></pre></td></tr></table></figure>
<p><code>-m</code> 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p>
<p><code>git show [tag-name]</code>：查看一个标签的的信息。    </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">tag v0.0.1</span><br><span class="line">Tagger: shuliqi &lt;1169046371@qq.com&gt;</span><br><span class="line">Date:   Fri Sep 27 19:52:56 2019 +0800</span><br><span class="line"></span><br><span class="line">新建一个标签，标记0.0.1版本</span><br></pre></td></tr></table></figure>
<p>可看出：标签名字，标签说明等。</p>
<h4 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h4><p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 <code>-a</code>，<code>-s</code> 或 <code>-m</code> 选项都不用，直接给出标签名字即可。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜  git tag v1.1.6</span><br><span class="line">➜  git show v1.1.6</span><br><span class="line">commit be180a1be40d9ce2ca8fe3a8c9bb2e9e7322275f (HEAD -&gt; shu, tag: v1.1.6, tag: v0.0.3, tag: v0.0.2, tag: v0.0.1, tag: show, origin/shu)</span><br><span class="line">Author: shuliqi &lt;1169046371@qq.com&gt;</span><br><span class="line">Date:   Fri Sep 27 19:02:15 2019 +0800</span><br></pre></td></tr></table></figure>
<p>可看出轻量级标签就只有相应的提交对象摘要。</p>
<h4 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h4><p>可以使用<code>git push [remote-name] [tag-name]</code> 命令将某一个tag 推送到远端。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜  git push origin v0.0.1</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 200 bytes | 200.00 KiB/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:shuliqi/rzfx.git</span><br><span class="line"> * [new tag]         v0.0.1 -&gt; v0.0.1</span><br></pre></td></tr></table></figure>
<p>可以使用<code>git push origin --tags</code> 命令推送所有的tag 到远端。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜  git push origin --tags</span><br><span class="line">Counting objects: 2, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (2/2), 194 bytes | 194.00 KiB/s, done.</span><br><span class="line">Total 2 (delta 1), reused 0 (delta 0)</span><br><span class="line"><span class="comment">remote: Resolving deltas: 100% (1/1), done.</span></span><br><span class="line">To github.com:shuliqi/rzfx.git</span><br><span class="line"> * [new tag]         show -&gt; show</span><br><span class="line"> * [new tag]         v0.0.2 -&gt; v0.0.2</span><br><span class="line"> * [new tag]         v0.0.3 -&gt; v0.0.3</span><br><span class="line"> * [new tag]         v1.1.6 -&gt; v1.1.6</span><br></pre></td></tr></table></figure>
<p>​    </p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化与Webpack属性 library,libraryTarget的关联</title>
    <url>/shuliqi.github.io/2021/02/03/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Alibrary%EF%BC%8ClibraryTarget%EF%BC%8CauxiliaryComment/</url>
    <content><![CDATA[<p><code>webpack</code> 是前端目前很热门的打包工具，相信大家应该在项目中都使用过。它有很复杂的配置项。其中 <code>library</code>，<code>libraryTarget</code> 属性大家可能就更陌生了，因为在一般的项目中使用 <code>wabpacK</code> 是不需要关注 这两个属性的，但是如果我们是开发类库，如果使用webpack 来打包的话，那么<code>library</code>，<code>libraryTarget</code> 这两个属性是一定要了解的</p>
<blockquote>
<p>ps： 也不一定非要使用 <code>webpack</code> 来打包， 打包的工具很多，<code>rollup</code> 之类的都是可以打包的。当然也是可以不打包的，只要你写的模块(类库)符合规范就可以。</p>
</blockquote>
<p>这篇文章将从下面这几个问题来进行解答的</p>
<ul>
<li>模块一般是怎么引入（有多少种方式）;</li>
<li>为什么有那么多种引入的方式呢？</li>
<li><code>webpack</code> 的<code>library</code> 和 <code>libraryTarget</code> 属性具体是用来干什么的？</li>
<li><code>webpack</code> 的 <code>library</code> 和<code>libraryTarget</code>属性 能将我们写的模块暴露成什么样的？</li>
</ul>
<a id="more"></a>
<h1 id="模块的引入方式"><a href="#模块的引入方式" class="headerlink" title="模块的引入方式"></a>模块的引入方式</h1><p>当我们引用别人开发的模块时有几种引入放入的方式？，假如我们有一个开发好的模块<code>demo</code>。那么如何使用它呢？</p>
<h2 id="传统方式：script-标签"><a href="#传统方式：script-标签" class="headerlink" title="传统方式：script 标签"></a>传统方式：script 标签</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"demo.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  demo();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="AMD-方式"><a href="#AMD-方式" class="headerlink" title="AMD 方式"></a>AMD 方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'demo'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">demo</span>) </span>&#123;  </span><br><span class="line">  demo();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="commonJs-方式"><a href="#commonJs-方式" class="headerlink" title="commonJs 方式"></a>commonJs 方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="built_in">require</span>(<span class="string">'demo'</span>);</span><br><span class="line">  </span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>
<h2 id="ES6-module-方式"><a href="#ES6-module-方式" class="headerlink" title="ES6 module 方式"></a>ES6 module 方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> demo <span class="keyword">from</span> <span class="string">'demo'</span>;</span><br><span class="line"></span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>
<p>为什么这些模块能支持不用的方式引用呢？ 是怎么实现的呢？</p>
<hr>
<h1 id="引入方式取决于模块如何导出-暴露"><a href="#引入方式取决于模块如何导出-暴露" class="headerlink" title="引入方式取决于模块如何导出(暴露)"></a>引入方式取决于模块如何导出(暴露)</h1><p>上面如何引入也提出了问题，为什么模块支持不同的引入？其实这取决于模块之前的是如何导出的。</p>
<p>我们举个列子：</p>
<p>我们开发一个 模块 demo。这个模块抛出一个 <code>getName</code> 函数，函数里面打印 ”shuliqi“字符串。</p>
<p>基本的项目结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">  |--index.js</span><br><span class="line">  |--index.html</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>本地安装 <code>webpack</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev  webpack@5.19.0</span><br></pre></td></tr></table></figure>
<p>安装 <code>webpack-cli</code>(目的是为了在命令行中是用 <code>webpack</code> 命令)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -D webpack-cli</span><br></pre></td></tr></table></figure>
<p>package.json 文件的<code>scripts</code>字段改成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"> <span class="string">"build"</span>: <span class="string">"webpack --config webpack.config.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'shuliqi'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 打包文件名字</span></span><br><span class="line">    filename: <span class="string">'default.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'../dist/default.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    demo 示例</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">   getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到目前为止我们的结构目录变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">  |--index.js</span><br><span class="line">  |--index.html</span><br><span class="line">|--webpack.config.js</span><br><span class="line">|--package.json</span><br><span class="line">|--package-lock.json</span><br><span class="line">|-node_modules</span><br></pre></td></tr></table></figure>
<p>然后我们在根目录执行 <code>webpack</code> 打包命令(package.json 文件 script 字段我们定义好的)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<p>打包完之后会出现 <code>dist</code> 文件夹，里面有 <code>default.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">  |--default.js</span><br><span class="line">|--src</span><br><span class="line">  |--index.js</span><br><span class="line">  |--index.html</span><br><span class="line">|--webpack.config.js</span><br><span class="line">|--package.json</span><br><span class="line">|--package-lock.json</span><br><span class="line">|-node_modules</span><br></pre></td></tr></table></figure>
<p>我们在浏览器打 <code>index.html</code></p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/1.png">
<p>发现报错：index.html:12 Uncaught ReferenceError: getName is not defined</p>
<p>为什么会报错呢？</p>
<p>显然页面在调用 <code>getName</code>的时候，在 window 上寻找 <code>getName</code>方法，但是模块化的开发呢，是拒绝一切的全局变量的，所以在全局找不到该对象。所以使用 <code>script</code> 标签引入该模块是访问不到 <code>getName</code>方法的。</p>
<p>那如何根据不用的引入需要来决定如何导出模块呢？ 如果是使用<code>webpack</code> 对类库进行打包的话，那么<code>library</code>，<code>libraryTarget</code> 这两个属性是可以决定如何导出类库的。</p>
<blockquote>
<p>PS: 当然不是只有webpack 可以打包，想 rollup 之类的都是可以打包的</p>
</blockquote>
<hr>
<h1 id="webpack-的-library-libraryTarget"><a href="#webpack-的-library-libraryTarget" class="headerlink" title="webpack 的 library, libraryTarget"></a>webpack 的 library, libraryTarget</h1><p><code>webpac</code>k的<code>output</code>的配置项<code>library</code> 和<code>libraryTarget</code>可以决定如何导出模块。</p>
<h2 id="output-library"><a href="#output-library" class="headerlink" title="output.library"></a>output.library</h2><p>这个字段支持 <code>string</code> 和 <code>object</code>类型的值</p>
<blockquote>
<p>注意：webpack 3.1.0 才支持 object 类型的，并且这个仅限与 libraryTarget: “umd” 时使用</p>
</blockquote>
<p><code>output.library</code> 的值被如何使用是根据 <code>output.libraryTarget</code> 的取值不同而不用.。</p>
<h2 id="output-libraryTarget"><a href="#output-libraryTarget" class="headerlink" title="output.libraryTarget"></a>output.libraryTarget</h2><p>这个字段支持<code>string</code> 类型的值，。默认值: <code>var</code></p>
<p>这个配置的作用是控制 <code>webpack</code> 打包的内容是如何暴露的（即上面说的如何导出的）</p>
<hr>
<h1 id="模块的导出方式"><a href="#模块的导出方式" class="headerlink" title="模块的导出方式"></a>模块的导出方式</h1><p>根据以上我们知道 <code>webpack</code> 的 <code>library</code>,<code>libraryTarget</code> 可以决定如何导出模块，那么可以导出（暴露）什么样的类库呢？ </p>
<h2 id="暴露为一个变量"><a href="#暴露为一个变量" class="headerlink" title="暴露为一个变量"></a>暴露为一个变量</h2><p>如果将<code>libraryTarget</code> 设置为 <code>var</code>/ <code>assign</code>, webpack 会把模块返回的值（无论暴露的是什么）绑定到一个由 <code>output.library</code>指定的变量上。这两种导出方式使用<strong>传统方式：script 标签方式</strong> 来引入的。</p>
<h3 id="libraryTarget-“var”"><a href="#libraryTarget-“var”" class="headerlink" title="libraryTarget: “var”"></a>libraryTarget: “var”</h3><p>这是<code>libraryTarget</code> 的默认值。当模块加载完成时候，模块的的返回值（入口起点的任何导出值）将分配到一个使用 var 声明的变量上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _entry_return_: 模块的返回值</span></span><br><span class="line"><span class="comment">// 变量 demo 使用 var 声明 </span></span><br><span class="line"><span class="keyword">var</span> demo = _entry_return_;</span><br></pre></td></tr></table></figure>
<p><strong>举个例子🌰</strong></p>
<p>还是基于以上例子，目录中添加一个新的配置文件  <code>webpack-config-var.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 打包的文件名</span></span><br><span class="line">    filename: <span class="string">'webpack-var.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块的返回值分配到一个使用var 声明的变量上， 该变量由  library 决定</span></span><br><span class="line">    library: <span class="string">'demo'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'var'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 的 <code>script</code> 添加一条心的打包命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-var"</span>:  <span class="string">"webpack --config webpack-config-var.js"</span></span><br></pre></td></tr></table></figure>
<p>在根目录执行新的打包命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run  build-var</span><br></pre></td></tr></table></figure>
<p>打包之后的文件 <code>webpack-var.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo;</span><br><span class="line">demo = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,o</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            o.r(r),</span><br><span class="line">            o.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[t])</span><br><span class="line">            <span class="keyword">return</span> r[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, o),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r)</span><br><span class="line">            o.o(r, t) &amp;&amp; !o.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    o.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>
<p>打包结果：模块的返回值分配到了 使用 <code>var</code> 声明的变量 <code>demo</code> 上。</p>
<p><strong>引用模块</strong></p>
<p>可以通过 传统的引入方式（script标签）来加载使用</p>
<p>在原来的目录结构上<code>src</code> 目录下添加 <code>index-var.html</code></p>
<p>index-var.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 传统引入方式：`script` 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'../dist/webpack-var.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    demo 示例</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(demo);</span></span><br><span class="line"><span class="undefined">    demo.getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们打开 <code>index.html</code>:</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/2.png">
<p>从截图中可以看出来， 我们是能访问到暴露出的<code>demo</code> 模块 及其它 <code>getName</code>方法的。</p>
<p>注意： 如果没有设置 library，那么打包将会直接报错</p>
<hr>
<h3 id="libraryTarget-“assign”"><a href="#libraryTarget-“assign”" class="headerlink" title="libraryTarget: “assign”"></a>libraryTarget: “assign”</h3><p>使用这个设置， <code>webpack</code>把模块返回值分配给一个没有使用 var 声明的变量，如果这个变量在没有引入作用域提前申请过，那么将会挂载在全局作用域中，<strong>这个设置可能会重新分配全局中已经存在的值</strong> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _entry_return_: 模块的返回值</span></span><br><span class="line"><span class="comment">// 变量 demo 没有使用 var 声明 </span></span><br><span class="line">demo = _entry_return_;</span><br></pre></td></tr></table></figure>
<p><strong>举个例子🌰</strong></p>
<p>还是基于以上例子，目录中添加一个新的配置文件  <code>webpack-config-assign.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 打包文件名字</span></span><br><span class="line">    filename: <span class="string">'webpack-assign.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块的返回值将分配到一个没有使用var声明的变量上，变量由 library 控制</span></span><br><span class="line">    library: <span class="string">'demo'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'assign'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 的 <code>script</code> 字段添加一条心的打包命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-assgin"</span>: <span class="string">"webpack --config webpack-config-assigin.js"</span></span><br></pre></td></tr></table></figure>
<p>在根目录执行新的打包命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build-assign</span><br></pre></td></tr></table></figure>
<p>打包之后的文件 <code>webpack-assign.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">demo = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,o</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            o.r(r),</span><br><span class="line">            o.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[t])</span><br><span class="line">            <span class="keyword">return</span> r[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, o),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r)</span><br><span class="line">            o.o(r, t) &amp;&amp; !o.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    o.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>
<p>打包结果：模块的返回值分配到了没有使用<code>var</code> 声明的变量 <code>demo</code> 上。</p>
<p><strong>引用</strong></p>
<p>如果使用的话， 可以通过 传统的引入方式（script标签）来引用。</p>
<p>在原来的目录结构上<code>src</code> 目录下添加 <code>index-assign.html</code></p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 传统引入方式：`script` 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'../dist/webpack-assign.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    assign 配置</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(demo);</span></span><br><span class="line"><span class="undefined">    demo.getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开我们的 html 文件，结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/3.png">
<p>我们能打印出模块<code>demo</code>，及可以使用它的<code>getName</code>方法</p>
<p><strong>注意：</strong>但是如果在加载模块之前已经存在变量， 那么加载模块之后，  会覆盖已存在的变量</p>
<p>在 <code>src</code> 目录中添加 <code>index.cover-assign.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 全局已经存在的变量 demo</span></span></span><br><span class="line"><span class="javascript">      demo = <span class="string">"我是demo"</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(demo);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 传统引入方式：`script` 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'../dist/webpack-assign.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    assign 配置:</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    但是如果在加载模块之前已经存在变量， 那么加载模块之后，  会覆盖已存在的变量</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 加载完我们的模块之后， 会覆盖全局中已经存在的变量 demo</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(demo)</span></span><br><span class="line"><span class="undefined">    demo.getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开HTML文件结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/4.png">
<p>结果说明：我们加载模块之后的 重新赋值了之前的变量 <code>demo</code></p>
<hr>
<h2 id="通过对象上赋值暴露"><a href="#通过对象上赋值暴露" class="headerlink" title="通过对象上赋值暴露"></a>通过对象上赋值暴露</h2><p>以下 的四个设置选项 <code>webpack</code> 会将模块的返回值（入口起点的任何导出值）赋值给一个特定对象的属性上; 这个对象<code>output.libraryTarget</code> 指定，这个属性由 <code>output.library</code>指定。如果<code>output.library</code>没有指定，那么默认行为是将模块返回值的所有属性都分配到对象中。</p>
<blockquote>
<p>注意： <code>output.library</code>没有指定的时候， webpack并不会检查对象中是否已经存在某些属性设置，即会发生覆盖行为</p>
</blockquote>
<h3 id="libraryTarget-“this”"><a href="#libraryTarget-“this”" class="headerlink" title="libraryTarget: “this”"></a>libraryTarget: “this”</h3><p>这个配置项表示 模块的返回值将分配给<code>this</code> 对象 的一个属性，这个属性是由<code>output.library</code>指定；如果没有指定，则模块返回值的所有属性将直接分配到 <code>this</code> 对象上（并且<code>webpack</code>并不会检查对象中是否已经存在某些属性设置，即会发生覆盖行为）</p>
<p>使用这个配置，当模块被加载时，那么模块的返回值会被分配到 this 对象的 属性（library决定属性）上 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _entry_return_:模块的返回值</span></span><br><span class="line"><span class="keyword">this</span>[<span class="string">'demo'</span>] = _entry_return_;</span><br></pre></td></tr></table></figure>
<p><strong>举个例子🌰</strong></p>
<p>在上面例子的基础上， 我们在根目录添加一个新的配置文件 <code>webpack-config-this.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 打包后的文件名字</span></span><br><span class="line">    filename: <span class="string">'webpack-this.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块的返回值分配在 this 对象的 demo 属性上</span></span><br><span class="line">    library: <span class="string">'demo'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'this'</span>,</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 文件的<code>script</code>字段添加新一条新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-this"</span>: <span class="string">"webpack --config webpack-config-this.js"</span></span><br></pre></td></tr></table></figure>
<p>在根目录执行 新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build-<span class="keyword">this</span></span><br></pre></td></tr></table></figure>
<p>打包的文件 <code>webpack-this.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.demo = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,t</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.r(r),</span><br><span class="line">            t.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>o</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[o])</span><br><span class="line">            <span class="keyword">return</span> r[o].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[o] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[o](n, n.exports, t),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> o <span class="keyword">in</span> r)</span><br><span class="line">            t.o(r, o) &amp;&amp; !t.o(e, o) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, o, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[o]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    t.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    t.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    t(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>
<p>打包结果：模块的返回值分配给了<code>this</code>对象的 <code>demo</code>属性</p>
<p><strong>引用模块：</strong></p>
<p>可以通过传统的引入方式（script标签）来引用我们的模块。</p>
<p><code>src</code>目录下添加 <code>index-this.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'../dist/webpack-this.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   this 配置</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> demo = <span class="keyword">this</span>.demo;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(demo)</span></span><br><span class="line"><span class="undefined">    demo.getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 在浏览器打开HTML， 结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/5.png">
<p>从截图可以看出 我们在<code>this</code>对象能找到 <code>demo</code> 模块</p>
<p><strong>举个例子🌰</strong></p>
<p>如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 <code>this</code>对象中。</p>
<p>添加新的配置文件 <code>webpack-config-this-cover.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ModuleFilenameHelpers &#125; = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename:<span class="string">'webpack-this-cover.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 `this`对象中。</span></span><br><span class="line">    libraryTarget: <span class="string">'this'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>packge.json 文件的 <code>script</code> 字段添加新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-this-cover"</span>: <span class="string">"webpack --config webpack-config-this-cover.js"</span></span><br></pre></td></tr></table></figure>
<p>执行我们新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build-<span class="keyword">this</span>-cover</span><br></pre></td></tr></table></figure>
<p>打包之后的文件 <code>webpack-this-cover.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> o <span class="keyword">in</span> r)</span><br><span class="line">        e[o] = r[o];</span><br><span class="line">    r.__esModule &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">        value: !<span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;(<span class="keyword">this</span>, (<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,o</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            o.r(r),</span><br><span class="line">            o.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[t])</span><br><span class="line">            <span class="keyword">return</span> r[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, o),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r)</span><br><span class="line">            o.o(r, t) &amp;&amp; !o.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    o.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)());</span><br></pre></td></tr></table></figure>
<p><strong>引用模块</strong></p>
<p>添加新的文件 <code>index-this-cover.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'../dist/webpack-this-cover.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   this 配置:</span><br><span class="line">   <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 `this`对象中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开 HTML 结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/6.png">
<p>结果： 没有设置 library 的值，那么将模块返回值的所有属性都分配到 <code>this</code>对象中。所有可以直接执行<code>getName</code>方法</p>
<hr>
<h3 id="libraryTarget-“window”"><a href="#libraryTarget-“window”" class="headerlink" title="libraryTarget: “window”"></a>libraryTarget: “window”</h3><p>这个配置项表示模块的返回值将分配给 <code>window</code> 对象的一个属性，这个属性是由<code>output.library</code>指定；如果没有指定，则模块返回值的所有属性将直接分配到 <code>window</code> 对象上（并且<code>webpack</code>并不会检查对象中是否已经存在某些属性设置，即会发生覆盖行为）</p>
<p>使用这个配置，当模块被加载时，那么模块的返回值会被分配到 <code>window</code> 对象的 属性（library决定属性）上 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _entry_return_:模块的返回值</span></span><br><span class="line"><span class="built_in">window</span>[<span class="string">'demo'</span>] = _entry_return_;</span><br></pre></td></tr></table></figure>
<p><strong>举个例子🌰</strong></p>
<p>添加新的配置文件 <code>webpack-config-var.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'/src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename:<span class="string">'webpack-window.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块的返回值分配到 window 对象的 demo 属性上</span></span><br><span class="line">    library: <span class="string">'demo'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'window'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 文件的<code>script</code>字段添加新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-window"</span>: <span class="string">"webpack --config webpack-config-window.js"</span></span><br></pre></td></tr></table></figure>
<p>执行新的打包命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build-window</span><br></pre></td></tr></table></figure>
<p>打包之后的文件  <code>webpack-window.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.demo = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,o,r</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            r.r(o),</span><br><span class="line">            r.d(o, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , o = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o[t])</span><br><span class="line">            <span class="keyword">return</span> o[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = o[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, r),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.d = <span class="function">(<span class="params">e,o</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> o)</span><br><span class="line">            r.o(o, t) &amp;&amp; !r.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: o[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    r.o = (e,o)=&gt;Object.prototype.hasOwnProperty.call(e, o),</span><br><span class="line">    r.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    r(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>
<p>打包结果：模块的返回值 分配到了<code>window</code> 的 <code>demo</code> 属性上。</p>
<p><strong>引用模块：</strong></p>
<p>可以通过传统的引入方式（script标签）来引用我们的类库。</p>
<p>index-window.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传统引入方式：`script` 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./dist/main.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    demo 示例</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    demo.getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开index.html</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/7.png">
<p>结果：我们可以直接在<code>window</code> 上获取<code>demo</code>; 说明模块模块的返回值将分配给 window 的 demo 属性上。</p>
<hr>
<p><strong>举个例子🌰</strong></p>
<p>如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 <code>window</code> 对象中。</p>
<p>添加一个新的配置文件：webpack-config-window-cover.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename:<span class="string">'webpack-window-cover.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 `window`对象中。</span></span><br><span class="line">    libraryTarget: <span class="string">'window'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 文件<code>script</code>添加新的打包命令:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-window-cover"</span>: <span class="string">"webpack --config webpack-config-window-cover.js"</span></span><br></pre></td></tr></table></figure>
<p>执行我们新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build-<span class="built_in">window</span>-cover</span><br></pre></td></tr></table></figure>
<p>打包之后的文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e, o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> r <span class="keyword">in</span> o)</span><br><span class="line">        e[r] = o[r];</span><br><span class="line">    o.__esModule &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">        value: !<span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;(<span class="built_in">window</span>, (<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,o,r</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            r.r(o),</span><br><span class="line">            r.d(o, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , o = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o[t])</span><br><span class="line">            <span class="keyword">return</span> o[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = o[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, r),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.d = <span class="function">(<span class="params">e,o</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> o)</span><br><span class="line">            r.o(o, t) &amp;&amp; !r.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: o[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    r.o = (e,o)=&gt;Object.prototype.hasOwnProperty.call(e, o),</span><br><span class="line">    r.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    r(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)());</span><br></pre></td></tr></table></figure>
<p><strong>引用模块</strong></p>
<p>可以通过传统的引入方式（script标签）来引用我们的类库。</p>
<p>index-window-cover.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'../dist/webpack-window-cover.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   window 配置</span><br><span class="line">   <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 window 对象中。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开HTML 文件，结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/8.png">
<p>结果说明：没有设置 library。demo 模块返回值的所有属性（例如: <code>getName</code>）都会被分配到 <code>window</code>对象中（即 我们可以直接调用 <code>getName</code>方法的原因）</p>
<h3 id="libraryTarget-“global”"><a href="#libraryTarget-“global”" class="headerlink" title="libraryTarget: “global”"></a>libraryTarget: “global”</h3><p>这个配置项表示模块的的返回值将分配给·<code>global</code> 对象 的一个属性，这个属性是由<code>output.library</code>指定；如果没有指定，则模块返回值的所有属性将直接分配到 <code>global</code> 对象上（并且<code>webpack</code>并不会检查对象中是否已经存在某些属性设置，即会发生覆盖行为）</p>
<p>使用这个配置，当模块被加载时，那么模块的返回值会被分配到 <code>global</code> 对象的 属性（library决定属性）上 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _entry_return_:模块的返回值</span></span><br><span class="line">global[<span class="string">"demo"</span>] = _entry_return_;</span><br></pre></td></tr></table></figure>
<p><strong>举个例子🌰</strong></p>
<p>添加新的配置文件 <code>webpack-config-global.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'webpack-global.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块的的返回值将分配给 global对象 demo 属性上</span></span><br><span class="line">    library: <span class="string">'demo'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'global'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 文件 <code>script</code> 添加新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-global"</span>: <span class="string">"webpack --config webpack-config-global.js"</span></span><br></pre></td></tr></table></figure>
<p>执行新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build-global</span><br></pre></td></tr></table></figure>
<p>打包之后的文件 <code>webpack-global.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.demo = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,o</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            o.r(r),</span><br><span class="line">            o.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[t])</span><br><span class="line">            <span class="keyword">return</span> r[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, o),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r)</span><br><span class="line">            o.o(r, t) &amp;&amp; !o.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    o.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>
<p>打包结果：我们的模块绑定在了 <code>self</code> 上。 有的同学可能会问， 不是该绑定在 <code>global</code> 上吗？</p>
<p>其实：</p>
<blockquote>
<p>通常讨论全局对象时，很少会区分全局对象是 global 对象，还是 global 对象上的属性。由于作用域链的原因，global 对象上的属性都可以直接在全局访问。不同的 JavaScript 环境存在不同的全局对象，例如浏览器中的 <code>window</code>、<code>self</code>、<code>location</code>、<code>navigator</code>、<code>event</code>，Node.js 中的 <code>global</code>、<code>module</code>、<code>exports</code>、<code>process</code> 等。访问宿主环境中不存在的全局变量会产生 <code>ReferenceError</code> 错误（即访问未声明变量）。</p>
</blockquote>
<p><strong>引用模块</strong></p>
<p>可以通过传统的引入方式（script标签）来引用我们的类库。</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传统引入方式：`script` 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./dist/main.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    demo 示例</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    demo.getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开HTML 结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/9.png">
<p>结果：我们可以直接访问全局对象的 <code>demo</code> 属性。</p>
<blockquote>
<p>通常讨论全局对象时，很少会区分全局对象是 global 对象，还是 global 对象上的属性。由于作用域链的原因，global 对象上的属性都可以直接在全局访问。不同的 JavaScript 环境存在不同的全局对象，例如浏览器中的 <code>window</code>、<code>self</code>、<code>location</code>、<code>navigator</code>、<code>event</code>，Node.js 中的 <code>global</code>、<code>module</code>、<code>exports</code>、<code>process</code> 等。访问宿主环境中不存在的全局变量会产生 <code>ReferenceError</code> 错误（即访问未声明变量）。</p>
</blockquote>
<p><strong>举例子🌰</strong></p>
<p>如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 <code>global</code> 对象中。</p>
<p>webpack-config-global-cover.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'webpack-global-cover.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 `global` 对象中</span></span><br><span class="line">    libraryTarget: <span class="string">'global'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>packge.js 文件 <code>script</code> 字段添加 新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-global-cover"</span>: <span class="string">"webpack --config webpack-config-global-cover.js"</span></span><br></pre></td></tr></table></figure>
<p>执行打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build-global-cover</span><br></pre></td></tr></table></figure>
<p>打包后的文件 <code>webpack-global-cover.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> o <span class="keyword">in</span> r)</span><br><span class="line">        e[o] = r[o];</span><br><span class="line">    r.__esModule &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">        value: !<span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;(self, (<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,o</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            o.r(r),</span><br><span class="line">            o.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[t])</span><br><span class="line">            <span class="keyword">return</span> r[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, o),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r)</span><br><span class="line">            o.o(r, t) &amp;&amp; !o.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    o.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)());</span><br></pre></td></tr></table></figure>
<p><strong>引用模块</strong></p>
<p>index-global-cover.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'../dist/webpack-global-cover.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    global 配置</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 `global` 对象中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器打开HTML, 结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/9.png">
<p>由截图克制： 模块返回值的 <code>getName</code>属性直接分配到了全局对象上，所有我们才能直接执行 <code>getName()</code></p>
<h3 id="libraryTarget-”commonjs”"><a href="#libraryTarget-”commonjs”" class="headerlink" title="libraryTarget: ”commonjs”"></a>libraryTarget: ”commonjs”</h3><p>将模块的返回值分配给 <code>exports</code> 对象的属性上， 这个属性由 <code>output.library</code> 指定；如果没有指定，则模块返回值的所有属性将直接分配到 <code>exports</code> 对象上（并且<code>webpack</code>并不会检查对象中是否已经存在某些属性设置，即会发生覆盖行为）</p>
<p>使用这个配置，当模块被加载时，那么模块的返回值会被分配到 <code>window</code> 对象的 属性（library决定属性）上 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _entry_return_:模块的返回值</span></span><br><span class="line">exports[<span class="string">"demo"</span>] = _entry_return_;</span><br></pre></td></tr></table></figure>
<p><strong>举个例子🌰</strong></p>
<p>添加新的配置文件 <code>webpack-config-global.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename:<span class="string">'webpack-commonjs.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块的返回值分配给 `exports` 对象的属性上， 这个属性由 `output.library` 指定</span></span><br><span class="line">    library: <span class="string">'demo'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'commonjs'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>packge.js 文件 <code>script</code> 字段添加 新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-commonjs"</span>: <span class="string">"webpack --config webpack-config-commonjs.js"</span></span><br></pre></td></tr></table></figure>
<p>执行新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build-commonjs</span><br></pre></td></tr></table></figure>
<p>打包之后的文件 <code>webpack-commonjs.js</code>；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.demo = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,o</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            o.r(r),</span><br><span class="line">            o.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[t])</span><br><span class="line">            <span class="keyword">return</span> r[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, o),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r)</span><br><span class="line">            o.o(r, t) &amp;&amp; !o.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    o.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>
<p>从打包结果可以看出，我们的 模块 <code>demo</code> 挂载在了 <code>exports</code> 对象上</p>
<p><strong>引用模块</strong></p>
<p>引用的话，需要在 CommonJS 环境中</p>
<p>在 <code>src</code> 目录中添加 <code>test-commonjs.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> my_export = <span class="built_in">require</span>(<span class="string">'./dist/main.js'</span>);</span><br><span class="line"><span class="keyword">const</span> demo = my_export.demo;</span><br><span class="line"><span class="built_in">console</span>.log(demo)</span><br><span class="line">demo.getName();</span><br></pre></td></tr></table></figure>
<p> 然后我们在 CommonJS 环境下执行这个代码（可以在 vscode 编辑器中执行，安装run-code 插件就可以执行); </p>
<p>执行的结果为：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/11.png">
<p><strong>举个例子🌰</strong></p>
<p>如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 <code>exports</code> 对象中。</p>
<p>webpack-config-commonjs-cover.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'webpack-commonjs-cover.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有设置 library 的值，那么将模块返回值的所有属性都分配到 `exports` 对象中。</span></span><br><span class="line">    libraryTarget: <span class="string">'commonjs'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>packge.js 文件 <code>script</code> 字段添加 新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-commonjs-cover"</span>: <span class="string">"webpack --config webpack-config-commonjs-cover.js"</span></span><br></pre></td></tr></table></figure>
<p>执行新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build-commonjs-cover</span><br></pre></td></tr></table></figure>
<p>打包之后的文件（dist/webpack-commonjs-cover.js）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> o <span class="keyword">in</span> r)</span><br><span class="line">        e[o] = r[o];</span><br><span class="line">    r.__esModule &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">        value: !<span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;(exports, (<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,o</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            o.r(r),</span><br><span class="line">            o.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[t])</span><br><span class="line">            <span class="keyword">return</span> r[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, o),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r)</span><br><span class="line">            o.o(r, t) &amp;&amp; !o.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    o.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)());</span><br></pre></td></tr></table></figure>
<p>结果说明：没有设置 library 的值，那么将模块返回值的所有属性都分配到对象 <code>export</code> 中</p>
<p><strong>引用模块</strong></p>
<p>src/test-commonjs-cover.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="built_in">require</span>(<span class="string">'../dist/webpack-commonjs-cover.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(demo)</span><br><span class="line">demo.getName()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/12.png">
<p>可以看出来:<code>require</code> 的结果就是 <code>demo</code>模块本身，可知没有设置 library 的值，那么将模块返回值的所有属性都分配到对象 <code>export</code> 中</p>
<hr>
<h2 id="模块定义系统"><a href="#模块定义系统" class="headerlink" title="模块定义系统"></a>模块定义系统</h2><p>这些选项将产生一个包含更完整兼容代码的包，以确保各个模块系统的兼容性。这时候 <code>output.library</code> 选项在不同的 <code>output.libraryTarget</code>选项中具有不同的含义。</p>
<h3 id="libraryTarget-“commonjs2”"><a href="#libraryTarget-“commonjs2”" class="headerlink" title="libraryTarget: “commonjs2”"></a>libraryTarget: “commonjs2”</h3><p>这个选项配置是指将模块的返回值（入口的返回值）分配给 <code>module.exports</code>对象上的属性， 这个属性由<code>library</code>指定; 如果没有指定，模块的返回值直接分配给 <code>module.exports</code>对象。</p>
<p>正如名字所指可以在使用在 <code>CommonJS</code> 环境。</p>
<blockquote>
<p>有没有发现commonjs 和 commonjs2 长的很像？ 其实他们确实很相似， 但是也有一些很微妙的区别的，可以点击这个 <a href="https://github.com/webpack/webpack/issues/1114" target="_blank" rel="noopener">issue</a> 了解了解</p>
</blockquote>
<p>使用这个配置，当模块被加载时，那么模块的返回值会被分配给 <code>module.exports</code>对象，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _entry_return_: 模块的返回值</span></span><br><span class="line"><span class="comment">// 打包方式结果</span></span><br><span class="line"><span class="built_in">module</span>.exports = _entry_return_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式: 使用加载器来使用</span></span><br><span class="line"><span class="comment">// 如：在commonJS 环境中使用 require 来加载模块</span></span><br><span class="line"><span class="keyword">const</span> demo = <span class="built_in">require</span>(<span class="string">"demo"</span>);</span><br><span class="line">demo.getName();</span><br></pre></td></tr></table></figure>
<p>注意，这种情况下<code>output.library</code> 不能与 <code>output.libraryTarget</code> 一起使用。即使使用也会被忽略掉。具体原因请参照<a href="https://github.com/webpack/webpack/issues/11800" target="_blank" rel="noopener">此 issue</a>。</p>
<p><strong>举个例子🌰</strong></p>
<ul>
<li>模块的返回值（入口的返回值）分配给 <code>module.exports</code>对象上的属性, 这个属性由<code>library</code>指定</li>
</ul>
<p>新加配置文件 <code>webpack-config-commonjs2.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    library:<span class="string">'demo'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'commonjs2'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 添加新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-commonjs2"</span>: <span class="string">"webpack --config webpack-config-commonjs2.js"</span></span><br></pre></td></tr></table></figure>
<p>执行我们新打包的命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build-commonjs2</span><br></pre></td></tr></table></figure>
<p>打包之后的文件 <code>dist/webpack-commonjs2.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.demo = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,o,r</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            r.r(o),</span><br><span class="line">            r.d(o, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , o = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o[t])</span><br><span class="line">            <span class="keyword">return</span> o[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = o[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, r),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.d = <span class="function">(<span class="params">e,o</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> o)</span><br><span class="line">            r.o(o, t) &amp;&amp; !r.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: o[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    r.o = (e,o)=&gt;Object.prototype.hasOwnProperty.call(e, o),</span><br><span class="line">    r.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    r(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>
<p>打包结果可以看出来：我们的模块 <code>demo</code>挂载在我们的<code>nodule.exports</code> 对象上。</p>
<p><strong>引用模块</strong></p>
<p>可以使用加载器来加载模块使用；如 requireJS等</p>
<p><code>src/test-commonjs2.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> my_module_exports = <span class="built_in">require</span>(<span class="string">'../dist/webpack-commonjs2.js'</span>);</span><br><span class="line"><span class="keyword">const</span> demo = my_module_exports.demo;</span><br><span class="line"><span class="built_in">console</span>.log(my_module_exports);</span><br><span class="line"><span class="built_in">console</span>.log(demo);</span><br><span class="line">demo.getName()</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/13.png">
<p>结果说明：我们的 <code>demo</code>模块 挂载在了 <code>nodule.exports</code>对象上</p>
<p><strong>举个例子🌰</strong></p>
<p>如果没有指定 <code>library</code>， 那么模块的返回值将直接分配到 <code>module.exports</code>上。</p>
<p><code>webpack-config-commonjs2-cover.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'webpack-commonjs2-cover.js'</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有指定 `library`， 那么模块的返回值将直接分配到 `module.exports`上。</span></span><br><span class="line">    libraryTarget: <span class="string">'commonjs2'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 添加新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-commonjs2-cover"</span>: <span class="string">"webpack --config webpack-config-commonjs2-cover.js"</span></span><br></pre></td></tr></table></figure>
<p>执行我们新打包的命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build-commonjs2-cover</span><br></pre></td></tr></table></figure>
<p>打包之后的文件 <code>dist/webpack-commonjs2-cover.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,o</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            o.r(r),</span><br><span class="line">            o.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[t])</span><br><span class="line">            <span class="keyword">return</span> r[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, o),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r)</span><br><span class="line">            o.o(r, t) &amp;&amp; !o.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    o.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>
<p>打包结果： 可以看出来， 我们模块的返回值直接分配给了 <code>module.exports</code>。</p>
<p><strong>使用模块</strong></p>
<p><code>src/test-commonjs2-cover.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="built_in">require</span>(<span class="string">'../dist/webpack-commonjs2-cover.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(demo);</span><br><span class="line">demo.getName()</span><br></pre></td></tr></table></figure>
<p>在 commonJS环境中执行，结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/14.png">
<p>结果说明： 我们<code>require</code>d的结果就是 <code>demo</code>模块本身。</p>
<hr>
<h3 id="libraryTarget-“amd”"><a href="#libraryTarget-“amd”" class="headerlink" title="libraryTarget: “amd”"></a>libraryTarget: “amd”</h3><p>这个选项将模块的返回值作为 <code>AMD</code>模块导出。<code>AMD</code>模块要求输入脚本被定义为具有特定属性，通常通过 RequireJS 或者任何的加载器（例如almond）提供的 <code>reuqire</code> 和 <code>define</code>属性。否则直接加载生成的AMD 模块捆绑包将会导致 <code>define is not defined</code>的错误。</p>
<p><strong>注意：</strong>这一小节的内容和网上的文章会有所不同，那是因为 <code>webpack</code> 版本的原因。 网上的教程的 webpack4 以下版本， 我们这个是 webpack5.19.1 版本的， 是有一些不一样的。</p>
<p>如果定义了<code>output.library</code>，打包定义成的代码将会是如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _entry_return_： 模块的返回值</span></span><br><span class="line"><span class="comment">// 打包方式的结果</span></span><br><span class="line">define(<span class="string">'demo'</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _entry_return_;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果<code>output.library</code>没有定义有效值，那么生成的代码将如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _entry_return_;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议是使用不定义 <code>output.library</code>值</p>
</blockquote>
<p>使用可以通过 模块加载器来加载使用（具体使用方式看下面的例子）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'demo'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myDemo</span>) </span>&#123;</span><br><span class="line"> <span class="comment">//... dosomething</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>举个例子🌰</strong></p>
<ul>
<li><code>output.library</code>没有定义有效值</li>
</ul>
<p><code>webpack-config-amd-cover.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'webpack-amd-cover.js'</span>,</span><br><span class="line">    <span class="comment">// 没有定义 library </span></span><br><span class="line">    libraryTarget: <span class="string">'amd'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 添加新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-amd-cover"</span>: <span class="string">"webpack --config webpack-config-amd-cover.js"</span></span><br></pre></td></tr></table></figure>
<p>执行新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build-amd-cover</span><br></pre></td></tr></table></figure>
<p>打包之后的文件 <code>dist/webpack-amd-cover.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function">(<span class="params">(</span>)=&gt;</span><span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,t</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            t.r(r),</span><br><span class="line">            t.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>o</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[o])</span><br><span class="line">            <span class="keyword">return</span> r[o].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[o] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[o](n, n.exports, t),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> o <span class="keyword">in</span> r)</span><br><span class="line">            t.o(r, o) &amp;&amp; !t.o(e, o) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, o, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[o]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    t.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    t.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    t(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)()));</span><br></pre></td></tr></table></figure>
<p><strong>引用模块</strong></p>
<p>我们知道 AMD 模块 是为了能在客户端使用的，所以可以通过 加载器来加载使用（requireJS等加载器）</p>
<p><code>src/index-amd-cover.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>AMD 模块的引用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 引入require.js并指定js主文件的入口 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://requirejs.org/docs/release/2.3.6/minified/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">require</span>([<span class="string">'../dist/webpack-amd-cover.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">demo</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(demo,<span class="string">'加载完成了'</span>)</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    amd 配置:</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    没有定义了 output.library 的值</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开HTML文件， 结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/15.png">
<blockquote>
<p>注意： 没有定义 library 的情况下，我们加载完 模块之后， 是可以得到模块（html 的 demo 参数是有值的），所以我们是可以使用模块的， 但是定义了 library 就取不到了，</p>
</blockquote>
<p><strong>举个例子🌰</strong></p>
<ul>
<li><code>output.library</code>定义有效值</li>
</ul>
<p><code>webpack-config-amd.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'webpack-amd.js'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// library 定义有效值</span></span><br><span class="line">    library: <span class="string">'demo'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'amd'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 添加新的打包命令:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-amd"</span>: <span class="string">"webpack --config webpack-config-amd.js"</span></span><br></pre></td></tr></table></figure>
<p>执行我们新的打包命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build-amd</span><br></pre></td></tr></table></figure>
<p>打包之后的文件<code>dist/webpack-amd.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="string">"demo"</span>, [], (<span class="function"><span class="params">()</span>=&gt;</span><span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> e = &#123;</span><br><span class="line">        <span class="number">138</span>: <span class="function">(<span class="params">e,r,o</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            o.r(r),</span><br><span class="line">            o.d(r, &#123;</span><br><span class="line">                getName: <span class="function"><span class="params">()</span>=&gt;</span>t</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      , r = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r[t])</span><br><span class="line">            <span class="keyword">return</span> r[t].exports;</span><br><span class="line">        <span class="keyword">var</span> n = r[t] = &#123;</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> e[t](n, n.exports, o),</span><br><span class="line">        n.exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o.d = <span class="function">(<span class="params">e,r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r)</span><br><span class="line">            o.o(r, t) &amp;&amp; !o.o(e, t) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, t, &#123;</span><br><span class="line">                enumerable: !<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">get</span>: r[t]</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o.o = (e,r)=&gt;Object.prototype.hasOwnProperty.call(e, r),</span><br><span class="line">    o.r = e=&gt;&#123;</span><br><span class="line">        <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">            value: <span class="string">"Module"</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">            value: !<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    o(<span class="number">138</span>)</span><br><span class="line">&#125;</span><br><span class="line">)()));</span><br></pre></td></tr></table></figure>
<p>打包结果说明：模块的返回值作为 AMD 模块导出。</p>
<p><strong>引用模块</strong></p>
<p>我们知道 AMD 模块 是为了能在客户端使用的，所以可以通过 加载器来加载使用（requireJS等加载器）</p>
<p><code>src/index-amd.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>AMD 模块的引用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 引入require.js并指定js主文件的入口 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://requirejs.org/docs/release/2.3.6/minified/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">require</span>([<span class="string">'../dist/webpack-amd.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">demo</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(demo,<span class="string">'加载完成了'</span>)</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    amd 配置:</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    定义了 output.library 的值</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行我们的 HTML 文件， 结果是打印出： undefined “加载完成了”</p>
<blockquote>
<p>注意： 使用定义了 library 值的模块， 我们在模块加载之后是回调参数是 undefined。没法使用模块。使用这种方式，看自己的场景来使用吧。</p>
</blockquote>
<p><strong>举个例子🌰</strong></p>
<h3 id="libraryTarget-“umd”"><a href="#libraryTarget-“umd”" class="headerlink" title="libraryTarget: “umd”"></a>libraryTarget: “umd”</h3><p>这个选项表示将模块的返回值导出为<code>AMD模式</code> 和 导出到<code>global 对象</code>上，所以它能在 AMD 环境中运行、在浏览器充当全局对象的属性。</p>
<p>注意： 这时候的library 是必须的。</p>
<p><strong>举个例子🌰</strong></p>
<p><code>webpack-config-umd.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'webpack-umd.js'</span>,</span><br><span class="line">    <span class="comment">// 模块的返回值导出为` AMD模式` 和 导出到`global 对象`上，所以它能在 AMD 环境中运行、在浏览器充当全局对象的属性</span></span><br><span class="line">    library: <span class="string">'demo'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json 添加新的打包命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"build-umd"</span>: <span class="string">"webpack --config webpack-config-umd.js"</span></span><br></pre></td></tr></table></figure>
<p>执行新的打包方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npon run build-umd</span><br></pre></td></tr></table></figure>
<p>打包之后的文件 <code>dist/webpack-umd.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e, o</span>) </span>&#123;</span><br><span class="line">    <span class="string">"object"</span> == <span class="keyword">typeof</span> exports &amp;&amp; <span class="string">"object"</span> == <span class="keyword">typeof</span> <span class="built_in">module</span> ? <span class="built_in">module</span>.exports = o() : <span class="string">"function"</span> == <span class="keyword">typeof</span> define &amp;&amp; define.amd ? define([], o) : <span class="string">"object"</span> == <span class="keyword">typeof</span> exports ? exports.demo = o() : e.demo = o()</span><br><span class="line">&#125;(self, (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="meta">        "use strict"</span>;</span><br><span class="line">        <span class="keyword">var</span> e = &#123;</span><br><span class="line">            <span class="number">138</span>: <span class="function">(<span class="params">e,o,t</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"shuliqi"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                t.r(o),</span><br><span class="line">                t.d(o, &#123;</span><br><span class="line">                    getName: <span class="function"><span class="params">()</span>=&gt;</span>r</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          , o = &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o[r])</span><br><span class="line">                <span class="keyword">return</span> o[r].exports;</span><br><span class="line">            <span class="keyword">var</span> n = o[r] = &#123;</span><br><span class="line">                exports: &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> e[r](n, n.exports, t),</span><br><span class="line">            n.exports</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t.d = <span class="function">(<span class="params">e,o</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> r <span class="keyword">in</span> o)</span><br><span class="line">                t.o(o, r) &amp;&amp; !t.o(e, r) &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, r, &#123;</span><br><span class="line">                    enumerable: !<span class="number">0</span>,</span><br><span class="line">                    <span class="keyword">get</span>: o[r]</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        ,</span><br><span class="line">        t.o = (e,o)=&gt;Object.prototype.hasOwnProperty.call(e, o),</span><br><span class="line">        t.r = e=&gt;&#123;</span><br><span class="line">            <span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">                value: <span class="string">"Module"</span></span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">                value: !<span class="number">0</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        ,</span><br><span class="line">        t(<span class="number">138</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    )()</span><br><span class="line">&#125;</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<p>打包结果：封装了两种模式（amd 和 global）这两种方式</p>
<p><strong>引用模块</strong></p>
<ul>
<li>加载器加载使用(requireJS)</li>
</ul>
<p><code>src/index-umd.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>umd 使用 requireJs 加载器加载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 引入require.js并指定js主文件的入口 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://requirejs.org/docs/release/2.3.6/minified/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">require</span>([<span class="string">'../dist/webpack-umd.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">demo</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(demo);</span></span><br><span class="line"><span class="undefined">        demo.getName()</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    umd 配置:</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    使用 requireJs 加载器加载</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器打开 html 文件， 结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/16.png">
<p>结果说明：加载我们的模块之后， 可以使用我们的模块（<code>demo.getName()</code>）</p>
<ul>
<li>script标签 方式引入</li>
</ul>
<p><code>index-umd-cover.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>umd配置: script 标签引入方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传统银土方式：script 标签引入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'../dist/webpack-umd.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    umd配置: </span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    script 标签引入方式</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  demo.getName();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开html，结果如下：</p>
<img src="/shuliqi.github.io/2021/02/03/webpack学习笔记：library，libraryTarget，auxiliaryComment/17.png">
<p>说明：<code>demo</code> 模块是挂载在全局变量上面了， 我们才可以直接使用 <code>demo.getName()</code></p>
<hr>
<p>剩下还有两中暴露方式（暴露<code>jsonp</code>，暴露为<code>system</code>）， 我自己没怎么看懂如何使用，等我懂的时候再补充上来吧！！</p>
<p>上面的例子 的所有代码都是 上传到 <code>github</code> 上<a href="https://github.com/shuliqi/webpack-libraryTarget" target="_blank" rel="noopener">webpack-libraryTarget</a>，如果有需要， 可以下载。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.xlaoyu.info/2018/01/05/webpack-output-librarytarget/" target="_blank" rel="noopener">详解webpack的out.libraryTarget属性</a></p>
<p><a href="https://webpack.docschina.org/configuration/output/#outputlibrarytarget" target="_blank" rel="noopener">output.libraryTarget </a></p>
<p><a href="https://juejin.cn/post/6844903618081095688" target="_blank" rel="noopener">【深入理解webpack】library,libraryTarget,externals的区别及作用</a></p>
]]></content>
      <tags>
        <tag>webpack学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack学习--概念以及配置项</title>
    <url>/shuliqi.github.io/2020/05/15/webpack%E5%AD%A6%E4%B9%A0-%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E9%A1%B9/</url>
    <content><![CDATA[<p>在平常的工作中，经常使用到<code>webpack</code>，大多数是脚手架直接帮我们配置好。一直想好好从零开始学习<code>webpack</code>。减少对脚手架的依赖。</p>
<p>这篇博客将先学习基础的概念， 然后看<code>webpack</code>的配置项，由于有些配置项很长， 所以会分开写，但是总体的配置项还是会在这里显示。</p>
<p>所以会导致这篇文章持续待续的状态</p>
 <a id="more"></a>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><code>webpack</code> 是一个用于现在<code>JavaScript</code> 应用程序的静态模块打包工具，当<code>webpack</code>处理应用程序时，会在内部构建一个依赖图，该依赖图对应映射到项目所需的每个模块，最后生成一个或者多个 bundle。</p>
<p>webpack 有一些核心的概念需要理解：</p>
<ul>
<li>入口（<code>entry</code>）</li>
<li>输出（<code>output</code>）</li>
<li><code>loader</code></li>
<li>插件（<code>plugin</code>）</li>
<li>模式（<code>mode</code>）</li>
<li>浏览器兼容（<code>browser compatibility</code>）</li>
</ul>
<ul>
<li>环境（<code>environment</code>）</li>
</ul>
<p>下面我们就分别来学习这些模块</p>
<h2 id="入口（entry）"><a href="#入口（entry）" class="headerlink" title="入口（entry）"></a>入口（entry）</h2><p>入口（<code>entry</code>）指示webpack应该使用哪个模块来作为构建其内部依赖图的开始。进入入口起点后，<code>webpack</code>会找出有哪些模块和库是入口起点依赖的。</p>
<p>默认值：    <code>src/index.js</code>. 但是可以在配置文件中配置entry的属性。</p>
<p><code>webpack</code>配置中有多种方式定义 entry 属性。</p>
<h3 id="单个入口"><a href="#单个入口" class="headerlink" title="单个入口"></a>单个入口</h3><p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: string | [string]</span><br></pre></td></tr></table></figure>
<p><code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: <span class="string">'./path/myproject/src/index.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以简写如下：</p>
<p><code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">'./path/myproject/src/index.js'</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将一个文件路径数组传递给<code>entry</code>属性，这将会创建一个所谓的 <code>multi-main entry</code>。如果想一次性注入多个依赖的文件，并且想它们依赖关系绘制在一个<code>chunk</code>中时， 就可以使用这种方式</p>
<p><code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: [</span><br><span class="line">		<span class="string">'src/1.js'</span>,</span><br><span class="line">		<span class="string">'src/2.js'</span>,</span><br><span class="line">		<span class="string">'src/3.js'</span>,</span><br><span class="line">	],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你希望通过一个入口为应用程序快速设置<code>webpac</code>k配置时候，单一入口的方式就是一个很合适的选择，但是使用这种语法方式来扩展或调整配置的灵活性不大。</p>
<h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: &#123; &lt;entryChunkName&gt; string | [string]&#125; | &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">'src/main.js'</span>,</span><br><span class="line">		admin: <span class="string">'src/admin.js'</span>,</span><br><span class="line">    index: <span class="string">'src/index.js'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象语法会比较繁琐，但是，这是应用程序中定义入口最可扩展的方式。</p>
<blockquote>
<p>这里的最可扩展是指这些配置可以重复使用，并且与其他配置组合使用。</p>
</blockquote>
<h2 id="输出（output）"><a href="#输出（output）" class="headerlink" title="输出（output）"></a>输出（output）</h2><p><code>output</code>属性告诉wbpack 在哪里输出它创建的 bundle，以及如何命名这些文件。</p>
<p>主要输出文件的默认值是<code>./dist/main.js</code>, 其他生成的文件默认放置在<code>./dist</code>文件夹中。</p>
<p><strong>注意：</strong> 即使存在多个<code>entry</code> 起点，但也只能指定一个 <code>output</code>配置。</p>
<p>用法：  在<code>webpack</code>配置中， output属性的最低要求是将它配置成一个对象，然后为输出的文件配置名字(<strong>output.filnename</strong>)</p>
<p><code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">'bundle.js'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置将一个单独的<code>bundle.js</code> 文件输出到 dist 目录中。</p>
<p>如果是多个入口起点， 则应该使用 <strong>占位符</strong> 来确保每一个文件具有唯一的名称。</p>
<ul>
<li><code>name</code> 如果设置，则为<code>chunk</code>的名称，否则使用<code>chunk</code>的<code>ID</code></li>
</ul>
<ul>
<li><p>[ id ]:   chunk的ID</p>
</li>
<li><p>[ contenthash ]: 此chunk的hash值只包括该内容类型的元素（受optimization.realContentHash影响</p>
</li>
<li><p>[  chunkhash  ]: 此chunk的hash值，包含该chunk的所有元素</p>
</li>
</ul>
<p><code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: &#123;</span><br><span class="line">		main: <span class="string">'./src/main.js'</span>，</span><br><span class="line">		admin: <span class="string">'./src/admin.js'</span>，</span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: [name].js,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这配置最终dist目录：main.js, admin.js</p>
<p>其次<code>output</code> 属性可配置的字段常用的还有<strong>output.path</strong>字段</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: [name].js</span><br><span class="line">		path: path.resolve(__dirname, <span class="string">'/dist'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p><code>webpack</code>只能理解<code>javaScript</code>和 <code>JSON</code> 文件。这是<code>webpack</code> 开箱可用的能力。<code>loader让webpack</code> 能够去处理其他类型的文件，并将它们转换成有效的模块，已供应用使用， 以及被添加到依赖图中，即loader用于对模块的源代码进行转换。loader可以使你在import 或者l ”load加载“模块时预处理文件。</p>
<p>在<code>webpac</code>k配置中，<code>loader</code>有两个属性：</p>
<ul>
<li><code>test</code>属性， 识别出哪些文件会被转换</li>
<li><code>use</code>属性，定义在进行转换时，应该使用哪个<code>loader</code></li>
</ul>
<p><code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exportas = &#123;</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: [name].js</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [</span><br><span class="line">			&#123;</span><br><span class="line">				test: <span class="regexp">/\.css$/</span>, </span><br><span class="line">				use: <span class="string">'css-laoder'</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置中， 对一个单独的<code>module</code>对象定义了 rules 属性、里面的每个配置都包含了两个必须的属性：<code>test</code>。<code>use</code> 。</p>
<p>这个配置的意思就是：</p>
<blockquote>
<p>当遇到<code>import/ require</code>语句中解析有<code>.css</code>的路径时，在对它进行打包之前，先使用<code>css-loader</code> 转换一下。</p>
</blockquote>
<p><strong>注意1：</strong>在<code>webpack</code>配置中定义<code>rules</code>时， 要定义在<code>module.rules</code> 中而不是<code>rules</code>中。 </p>
<p><strong>注意2：</strong>在<code>webpack</code> 中使用正则表达式时， 不给它添加引号。也就是说：<code>/\.css$/</code>和 <code>/\.css$/</code> 或者 <code>/\.css$/</code> 是不一样的。前者的意思是匹配任何以<code>.css</code> 结尾的文件。而后者指示<code>webpack</code>匹配具有绝对路径<code>.css</code>的对单个文件。</p>
<h3 id="使用loader"><a href="#使用loader" class="headerlink" title="使用loader"></a>使用loader</h3><p>在应用程序中使用<code>loader</code> 有三种方式：</p>
<ul>
<li>配置方式（推荐使用）: 在配置文件中指定<code>loader</code></li>
<li>内联方式 ：在每个import 文语句显示的指定<code>loader</code></li>
<li><code>CLI</code>方式：在<code>shell</code>命令中指定它们</li>
</ul>
<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>这种方式是在配置文件中的<code>module.rules</code>中配置。允许webpack配置中配置多个<code>loader</code>。<code>loader</code>从右到左的取值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		rules: [</span><br><span class="line">			&#123; </span><br><span class="line">				test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">				use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置表示：匹配所有的<code>.css</code>结尾的文件，先后分别使用<code>sass-loader</code>, <code>css-loader</code>,<code>style-loader</code>进行转换。</p>
<h2 id="插件（plugin）"><a href="#插件（plugin）" class="headerlink" title="插件（plugin）"></a>插件（plugin）</h2><p><code>loader</code> 是用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量等。</p>
<p>使用一个插件，需要<code>require（）</code>它，然后添加在<code>webpac</code>k配置中的 <code>plugins</code> 数组中。多数的插件是可以通过选项来自定义的。</p>
<p>由于插件可以携带参数/选项，所以在<code>webpac</code>k配置中，向 <code>plugins</code> 属性传入一个 new 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置我们使用了一个插件<code>html-webpack-plugin</code> 这个插件为应用程序生成一个<code>HTML</code> 文件，并且自动注入所有生成的<code>bundle</code>。</p>
<p>插件的用法有两种：</p>
<ul>
<li><p>配置方式</p>
<p>就如上的示例</p>
</li>
<li><p>Node API 方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">// 访问 webpack 运行时(runtime)</span></span><br><span class="line"><span class="keyword">const</span> configuration = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compiler = webpack(configuration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> webpack.ProgressPlugin().apply(compiler);</span><br><span class="line"></span><br><span class="line">compiler.run(<span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>想要看看 webpack 插件有哪些，可以看看 <a href="https://webpack.docschina.org/plugins/" target="_blank" rel="noopener">插件列表</a>。当然插件列表也不是全的， 有很多插件都是用户自己上传的，可以的话， 也可以到npm 上面搜 webpack等字样。</p>
<h2 id="模式（Mode）"><a href="#模式（Mode）" class="headerlink" title="模式（Mode）"></a>模式（Mode）</h2><p>通过选择 development, production，none 之中的一个来设置 mode 参数，来启用webpack 内置在相应环境下的优化， 默认值： production。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	mode: &apos;production&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者也可以在CLI 参数中传递：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack --mode=&apos;development&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>development : 会将DefinePlugin中的 process.env.NODE_ENV 的值设置为 development，为模块和 chunk启用有效的名</li>
<li>production： 会将 <code>DefinePlugin</code> 中 <code>process.env.NODE_ENV</code> 的值设置为 <code>production</code>。为模块和 chunk 启用确定性的混淆名称等</li>
<li>none: 不使用任何的默认优化选项</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>一些需要了解的概念已经了解的差不多了， 那么接下来就是具体的配置项了。</p>
<p>webpack 是开箱即用的， 也就是说无需任何的配置文件，这种情况下webpack会假定项目的入口起点是 <code>src/index.js</code>，然后会在 <code>dist/main.js</code>中输出结果。并且在生产环境开启压缩和优化。</p>
<p>举个例子：</p>
<p>假如我们有这样的目录结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">	 |--index.js</span><br></pre></td></tr></table></figure>
<p>我们在根目录命令行输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack</span><br></pre></td></tr></table></figure>
<p>这时候我们发现跟目录多了一个文件夹<code>dist</code>，该文件夹里面有main.js。即目前的文件文件目录为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	 |--main.js</span><br><span class="line">|--src</span><br><span class="line">	 |--index.js</span><br></pre></td></tr></table></figure>
<p>所有可以看出不用做任何的配置就可以直接使用webpack。</p>
<p>虽然我们可以直接使用webpack来打包， 但是通常的情况下， 我们的项目都需要继续扩展能力，因此可以在根目录下创建 webpack.config.js 文件。 然后webpack 会自动使用它。</p>
<p>我们在根目录新建一个文件<code>webpack.config.js</code>。内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口起点</span></span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 输出的文件的名字</span></span><br><span class="line">    filename: <span class="string">'shuliqi.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这配置文件，我们修改了入口起点。输出的文件名我们也改成<code>shuliqi.js</code>。然后我们在根目录执行命令：<code>webpack</code>. 最后我们会看到我们的文件目录是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	 |--shuliqi.js</span><br><span class="line">|--src</span><br><span class="line">	 |--main.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>由此可知，在根目录有webpack.config.js配置文件的话，输入<code>webpack</code>命令的时候会使用这个配置文件。</p>
<p>当然在某些特定的额情况下，需要根据实际情况使用不用的配置文件。webpack也可以使用不用的配置文件， 只需要在命令行中使用<code>--congig flag</code>修改配置文件名称。</p>
<p>我们新建一个文件<code>webpack.dev.js</code>,内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack.dev.js配置的入口</span></span><br><span class="line">  entry: <span class="string">'./src/dev.js'</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// webpack.dev.js配置的输出的文件的名字</span></span><br><span class="line">    filename: <span class="string">'output-dev.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在命令行执行：<code>webpack --config webpack.dev.js</code>。然后我们可以到打包之后的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	 |--output-dev.js</span><br><span class="line">|--src</span><br><span class="line">	 |--dev.js</span><br><span class="line">|--webpack.dev.js</span><br></pre></td></tr></table></figure>
<p>可以看到打包结果跟我们配置文件写的一样(打包之后输出的名字，打包的入口)。</p>
<h1 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h1><h2 id="上下文（context）"><a href="#上下文（context）" class="headerlink" title="上下文（context）"></a>上下文（context）</h2><p><strong>用法:</strong> <code>context: string</code></p>
<p><strong>概念：</strong> 基础路径，绝对路径，用于从配置文件中解析入口起点(entry)</p>
<p>入口对象是用于webpack查找看是构建bundle的地方。 上下文是入口文件所处的目录的绝对路径的字符串。</p>
<p>webpack 默认的上下文是当前的目录。 我们可以使用context修改上下文。</p>
<p>我们建一个文件夹，目录结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--app</span><br><span class="line">	 |--index.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>我们的配置文件webpack.config.js的内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 将上下文修改为 当前绝对路径的app目录下面,我们的额入口起点将是在这个目录下面</span></span><br><span class="line">  <span class="comment">// ps:可以先注释注释点这个配置，如果这样打包是会报错的</span></span><br><span class="line">  context: path.resolve(__dirname, <span class="string">'app'</span>),</span><br><span class="line">  entry: <span class="string">'./index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'shuliqi.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们注释掉：<code>context: path.resolve(__dirname, &#39;app&#39;)。然后根目录命令:</code>webpack`。 这时候会报错：</p>
   
<p>我们不注释 ` context: path.resolve(__dirname, ‘app’)的话， 是能正常打包的，正常打包的结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	 |-- shuliqi.js</span><br><span class="line">|--src</span><br><span class="line">	 |--index.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看出 context 的作用了，如果没有设置 context  我们的 entry 应该这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: <span class="string">'./app/index.js'</span>,</span><br></pre></td></tr></table></figure>
<p>不禁想问， context 的好处是什么呢？ 我们不用设置 context 也可以进行打包的呀。嗯哈？</p>
<p>假如我们要打包 app 下面的很多js 文件，我们不设置的 context 修改的当前入口目录的话，那么我们是不是每个都需要写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry:[<span class="string">'./app/1.js'</span>, <span class="string">'./app/2.js'</span>, <span class="string">'./app/3.js'</span>, <span class="string">'./app/4.js'</span>, ...],</span><br></pre></td></tr></table></figure>
<p>这样每个文件都要写 ‘./app/XXX’， 是不是有点繁琐了？ 那这时候使用 contetxt 就很方便了。</p>
<h2 id="入口（entry）-1"><a href="#入口（entry）-1" class="headerlink" title="入口（entry）"></a>入口（entry）</h2><p>配置文件中的 entry 接受三种形式的值：String（字符串），Array（数组）， Object（对象）。</p>
<p>我们先来介绍对象形式，因为这是最完整的 entry 配置，其他的形式只是它的简化形式而已。</p>
<h3 id="对象-entry"><a href="#对象-entry" class="headerlink" title="对象 entry"></a>对象 entry</h3><p>对象的形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">	&lt;key&gt;: <span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p><strong>key 值可以使简单的字符串， 比如： main，index等等。并且对应着 output.filename 配置中的  [name]变量。</strong></p>
<p>假如我们有这样的文件路径：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>webpack.config.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的配置，我们在根目录执行 <code>webpack</code> 命令之后可以生成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	|--app.js</span><br><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p><strong>key 还可以是路径字符串， webpack 会自动生成路径目录，并将路径的最后最为[name]</strong>。这个特性在多页面配置下是很有用的。</p>
<p>假如我们还是一样的目录：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>webpack.config.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'public/static/app'</span>: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的配置，我们在根目录执行 <code>webpack</code> 命令之后可以生成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	|--public</span><br><span class="line">		|--<span class="keyword">static</span></span><br><span class="line">			|--app.js</span><br><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><h5 id="如果value是字符串"><a href="#如果value是字符串" class="headerlink" title="如果value是字符串"></a>如果value是字符串</h5><p>如果value 是字符串，那么必须是合理的 node reqiur  函数参数字符串，比如文件径：’./app.js’（require(‘./app.js’)）；比如是安装的npm 模块路径：’lodash’（require(‘lodash’))</p>
<p>假如有这样的路径：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">|--webpack.config.js</span><br><span class="line">|--package.json</span><br></pre></td></tr></table></figure>
<p>package.json：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"webpack.config.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"lodash"</span>: <span class="string">"^4.17.20"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>webpack.config.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'my-lodash'</span>: <span class="string">'lodash'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的配置打包生成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	|--my-lodash.js</span><br><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">|--webpack.config.js</span><br><span class="line">|--package.json</span><br></pre></td></tr></table></figure>
<h5 id="如果value是数组"><a href="#如果value是数组" class="headerlink" title="如果value是数组"></a>如果value是数组</h5><p>则数组中的元素要符合上面描述的合理字符串值，数组中的文件一般是没有互相依赖关联关系的。但是又处于某种原因要将它们打包在一起的。</p>
<p>假如这样的目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">	|--main.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>webpack.config.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'all'</span>: [<span class="string">'./src/index.js'</span>, <span class="string">'./src/main.js'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的配置打生成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	|-all.js</span><br><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">	|--main.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<h5 id="如果value是对象"><a href="#如果value是对象" class="headerlink" title="如果value是对象"></a>如果value是对象</h5><h6 id="Import字段"><a href="#Import字段" class="headerlink" title="Import字段"></a>Import字段</h6><p>Import字段表示引入入口 chunk</p>
<p>如这样的目录：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">	|--main.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">   <span class="string">'app'</span>: &#123;  <span class="attr">import</span>: <span class="string">'./src/index.js'</span>&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的配置打包生成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	|--app.js</span><br><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">	|--main.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>当然imprt 也可以是数组:</p>
<p>webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">   <span class="string">'app'</span>: &#123;  <span class="attr">import</span>: [<span class="string">'./src/index.js'</span>, <span class="string">'./src/main.js'</span>]&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包生成和上面的例子相同。</p>
<h6 id="filename字段"><a href="#filename字段" class="headerlink" title="filename字段"></a>filename字段</h6><p>filename字段为特定的入口指定一个自定义的输出文件名</p>
<p>同样的目录：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">	|--main.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">   <span class="comment">//  给当前的入口 chunk 自定义输出文件名 shuliqi.js</span></span><br><span class="line">   <span class="string">'app'</span>: &#123;  <span class="attr">import</span>: <span class="string">'./src/index.js'</span>, <span class="attr">filename</span>:<span class="string">'shuliqi.js'</span>&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的配置打包生成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	|--shuliqi.js</span><br><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">	|--main.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<h6 id="dependOn"><a href="#dependOn" class="headerlink" title="dependOn"></a>dependOn</h6><p>dependOn字段可以设置与另一个入口chunk 共享哪些模块</p>
<p>假如我们有这样的目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--src</span><br><span class="line">	|--common.js</span><br><span class="line">	|--index.js</span><br><span class="line">	|--main.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>common.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'common.js'</span>)</span><br></pre></td></tr></table></figure>
<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./common.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'index.js'</span>)</span><br></pre></td></tr></table></figure>
<p>main.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./common.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'main.js'</span>)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'common'</span>: <span class="string">'./src/ common.js'</span>,</span><br><span class="line">    <span class="string">'index'</span>: &#123; <span class="attr">import</span>: <span class="string">'./src/index.js'</span>&#125;,</span><br><span class="line">    <span class="string">'main'</span>: &#123; <span class="attr">import</span>: <span class="string">'./src/main.js'</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们是这样配置生成的是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|--dist</span><br><span class="line">	|--main.js</span><br><span class="line">	|--index.js</span><br><span class="line">	|--common.js</span><br><span class="line">|--src</span><br><span class="line">	|--index.js</span><br><span class="line">	|--main.js</span><br><span class="line">	|--common.js</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure>
<p>其中生成的 index.js  main.js 是包含 common 模块的。</p>
<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="keyword">var</span> e=&#123;<span class="number">62</span>:<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">"common.js"</span>)&#125;&#125;,o=&#123;&#125;;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params">t</span>)</span>&#123;<span class="keyword">if</span>(o[t])<span class="keyword">return</span> o[t].exports;<span class="keyword">var</span> n=o[t]=&#123;<span class="attr">exports</span>:&#123;&#125;&#125;;<span class="keyword">return</span> e[t](n,n.exports,r),n.exports&#125;r.n=<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="keyword">var</span> o=e&amp;&amp;e.__esModule?<span class="function"><span class="params">()</span>=&gt;</span>e.default:<span class="function"><span class="params">()</span>=&gt;</span>e;<span class="keyword">return</span> r.d(o,&#123;<span class="attr">a</span>:o&#125;),o&#125;,r.d=<span class="function">(<span class="params">e,o</span>)=&gt;</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t <span class="keyword">in</span> o)r.o(o,t)&amp;&amp;!r.o(e,t)&amp;&amp;<span class="built_in">Object</span>.defineProperty(e,t,&#123;<span class="attr">enumerable</span>:!<span class="number">0</span>,<span class="attr">get</span>:o[t]&#125;)&#125;,r.o=<span class="function">(<span class="params">e,o</span>)=&gt;</span><span class="built_in">Object</span>.prototype.hasOwnProperty.call(e,o),(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="string">"use strict"</span>;r(<span class="number">62</span>),<span class="built_in">console</span>.log(<span class="string">"index.js"</span>)&#125;)()&#125;)();</span><br></pre></td></tr></table></figure>
<p>main.js</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(()=&gt;&#123;<span class="keyword">var</span> e=&#123;<span class="number">62</span>:()=&gt;&#123;console.log(<span class="string">"common.js"</span>)&#125;&#125;,o=&#123;&#125;;<span class="function">function <span class="title">r</span><span class="params">(t)</span></span>&#123;<span class="keyword">if</span>(o[t])<span class="keyword">return</span> o[t].<span class="keyword">exports</span>;<span class="keyword">var</span> n=o[t]=&#123;<span class="keyword">exports</span>:&#123;&#125;&#125;;<span class="keyword">return</span> e[t](n,n.<span class="keyword">exports</span>,r),n.<span class="keyword">exports</span>&#125;r.n=e=&gt;&#123;<span class="keyword">var</span> o=e&amp;&amp;e.__esModule?()=&gt;e.<span class="keyword">default</span>:()=&gt;e;<span class="keyword">return</span> r.d(o,&#123;a:o&#125;),o&#125;,r.d=(e,o)=&gt;&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t in o)r.o(o,t)&amp;&amp;!r.o(e,t)&amp;&amp;Object.defineProperty(e,t,&#123;enumerable:!<span class="number">0</span>,get:o[t]&#125;)&#125;,r.o=(e,o)=&gt;Object.prototype.hasOwnProperty.call(e,o),(()=&gt;&#123;<span class="string">"use strict"</span>;r(<span class="number">62</span>),console.log(<span class="string">"main.js"</span>)&#125;)()&#125;)();</span><br></pre></td></tr></table></figure>
<p>但是这样造成就是资源重复很多，这时候如果使用：dependOn就可以共享资源了</p>
<p>webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'common'</span>: <span class="string">'./src/ common.js'</span>,</span><br><span class="line">    <span class="string">'index'</span>: &#123; <span class="attr">import</span>: <span class="string">'./src/index.js'</span>, <span class="attr">dependOn</span>: <span class="string">'common'</span>&#125;,</span><br><span class="line">    <span class="string">'main'</span>: &#123; <span class="attr">import</span>: <span class="string">'./src/main.js'</span>,  <span class="attr">dependOn</span>: <span class="string">'common'</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中生成的 main 和 index chunk 就不会包含 common 模块了。</p>
<p>最后 <code>dependOn</code> 选项的也可以为字符串数组：</p>
<blockquote>
<p>ps： 不是很懂这个设置有什么用，等我之后再来研究研究  尴尬</p>
</blockquote>
<h3 id="字符串entry："><a href="#字符串entry：" class="headerlink" title="字符串entry："></a>字符串entry：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">  	main: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组-entry"><a href="#数组-entry" class="headerlink" title="数组 entry"></a>数组 entry</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [<span class="string">'./src/index.js'</span>, <span class="string">'./src/main.js'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">  	main: [<span class="string">'./src/index.js'</span>, <span class="string">'./src/main.js'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模式（mode）"><a href="#模式（mode）" class="headerlink" title="模式（mode）"></a>模式（mode）</h2><p>webpack 配置文件中 mode 配置选项是一个 string， 可能的值有：<strong>production</strong>，<strong>development</strong>，<strong>none</strong>。默认值是：<strong>production</strong>。</p>
<p>这个配置选项的主要作用是告诉 webpack 使用相应的内置的优化配置。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>可以直接在配置文件中配置该选项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过 cli 来传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">webpack --mode=development</span><br></pre></td></tr></table></figure>
<h3 id="选项描述"><a href="#选项描述" class="headerlink" title="选项描述"></a>选项描述</h3><table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>development</code></td>
<td style="text-align:left">会将 <code>DefinePlugin</code> 中 <code>process.env.NODE_ENV</code> 的值设置为 <code>development</code>。启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code></td>
</tr>
<tr>
<td style="text-align:left"><code>production</code></td>
<td style="text-align:left">会将 <code>DefinePlugin</code> 中 <code>process.env.NODE_ENV</code> 的值设置为 <code>production</code>。启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>TerserPlugin</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>none</code></td>
<td style="text-align:left">没有任何默认优化选项</td>
</tr>
</tbody>
</table>
<p>如果没有设置， webpack 会将 mode 设置为  production</p>
<blockquote>
<p>注意：设置 mode 可以改变 process.env,NODE_ENV。但是反过来，设置 NODE_ENV 并不会自动设置webpack 的 mode 选项。这里的  process.env,NODE_ENV 不是 node 的环境变量，而是webpack.DefinePlugin中定义的全局变量，允许根据不同的环境执行不用的代码</p>
</blockquote>
<h4 id="development"><a href="#development" class="headerlink" title="development"></a>development</h4><p>设置 mode 为 development</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就相当于如下的配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'eval'</span>,</span><br><span class="line">  cache: <span class="literal">true</span>,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    pathinfo: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    namedModules: <span class="literal">true</span>,</span><br><span class="line">    namedChunks: <span class="literal">true</span>,</span><br><span class="line">    nodeEnv: <span class="string">'development'</span>,</span><br><span class="line">    flagIncludedChunks: <span class="literal">false</span>,</span><br><span class="line">    occurrenceOrder: <span class="literal">false</span>,</span><br><span class="line">    sideEffects: <span class="literal">false</span>,</span><br><span class="line">    usedExports: <span class="literal">false</span>,</span><br><span class="line">    concatenateModules: <span class="literal">false</span>,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      hidePathInfo: <span class="literal">false</span>,</span><br><span class="line">      minSize: <span class="number">10000</span>,</span><br><span class="line">      maxAsyncRequests: <span class="literal">Infinity</span>,</span><br><span class="line">      maxInitialRequests: <span class="literal">Infinity</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    noEmitOnErrors: <span class="literal">false</span>,</span><br><span class="line">    checkWasmTypes: <span class="literal">false</span>,</span><br><span class="line">    minimize: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.NamedChunksPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="production"><a href="#production" class="headerlink" title="production"></a>production</h4><p>设置 mode 为 production</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode:<span class="string">"production"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其相当于设置如下配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: <span class="string">'warning'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    pathinfo: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    namedModules: <span class="literal">false</span>,</span><br><span class="line">    namedChunks: <span class="literal">false</span>,</span><br><span class="line">    nodeEnv: <span class="string">'production'</span>,</span><br><span class="line">    flagIncludedChunks: <span class="literal">true</span>,</span><br><span class="line">    occurrenceOrder: <span class="literal">true</span>,</span><br><span class="line">    sideEffects: <span class="literal">true</span>,</span><br><span class="line">    usedExports: <span class="literal">true</span>,</span><br><span class="line">    concatenateModules: <span class="literal">true</span>,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      hidePathInfo: <span class="literal">true</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    noEmitOnErrors: <span class="literal">true</span>,</span><br><span class="line">    checkWasmTypes: <span class="literal">true</span>,</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> TerserPlugin(<span class="comment">/* ... */</span>),</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"production"</span>) &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><p>设置 mode 为 none</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode:<span class="string">"none"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其相当于设置如下配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  performance: &#123;</span><br><span class="line">   hints: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    flagIncludedChunks: <span class="literal">false</span>,</span><br><span class="line">    occurrenceOrder: <span class="literal">false</span>,</span><br><span class="line">    sideEffects: <span class="literal">false</span>,</span><br><span class="line">    usedExports: <span class="literal">false</span>,</span><br><span class="line">    concatenateModules: <span class="literal">false</span>,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      hidePathInfo: <span class="literal">false</span>,</span><br><span class="line">      minSize: <span class="number">10000</span>,</span><br><span class="line">      maxAsyncRequests: <span class="literal">Infinity</span>,</span><br><span class="line">      maxInitialRequests: <span class="literal">Infinity</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    noEmitOnErrors: <span class="literal">false</span>,</span><br><span class="line">    checkWasmTypes: <span class="literal">false</span>,</span><br><span class="line">    minimize: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出（output）-1"><a href="#输出（output）-1" class="headerlink" title="输出（output）"></a>输出（output）</h3><p>output 是最顶级的键，包括了一组选项，目的是提示webpack 如何去输出，以及在哪里输出。它的配置项很多， 我们跟着教程一个一个的来看看这些配置到底是什么怎么使用的。</p>
<h4 id="library"><a href="#library" class="headerlink" title="library"></a>library</h4><h4 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h4><p>这两个配置项具体可以直接看这边文章 <a href="https://shuliqi.github.io/shuliqi.github.io/2021/02/03/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Alibrary%EF%BC%8ClibraryTarget%EF%BC%8CauxiliaryComment/">模块化与Webpack属性 library,libraryTarget的关联</a></p>
<h4 id="auxiliaryComment"><a href="#auxiliaryComment" class="headerlink" title="auxiliaryComment"></a>auxiliaryComment</h4><p>注意：这个配置项在webpack4版本以下生效， 以上版本不生效。</p>
<p>如果是webpack 3 的 可以具体看看 <a href="https://webpack.docschina.org/configuration/output/#outputauxiliarycomment" target="_blank" rel="noopener">output.auxiliaryComment</a></p>
<h4 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h4><h4 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h4><p>这两个配置项的使用 具体移步 <a href="https://shuliqi.github.io/shuliqi.github.io/2021/02/22/webpack%E4%B8%AD%E7%9A%84filename%E5%92%8CchunkFilename%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/">webpack中的filename和chunkFilename及其区别</a></p>
<h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p><code>output.path</code>配置输出文件存放在本地的目录，必须是<code>string</code>类型的绝对路径。通常通过<code>Node.js</code>的<code>path</code>模块去获取绝对的路径。<a href="http://nodejs.cn/api/path.html#path_path_relative_from_to" target="_blank" rel="noopener">Node.js  path</a></p>
<p><code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入Node的path模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>path.resolve(path1, path2, ...)</code>方法的作用是：按照顺序依次拼接，获取绝对路径，路径末尾不会带有路径分隔符号， 若合并后的路径没有构成一绝对路径，则会默认使用当前工作目录的绝对路径。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 Node 模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>); </span><br><span class="line"><span class="comment">// 拼接路径中没有带有绝对路径</span></span><br><span class="line"><span class="keyword">var</span> _path = path.resolve(<span class="string">'path3'</span>, <span class="string">'path4'</span>, <span class="string">'a/b/cc/'</span>); <span class="comment">// 没有末尾的路径分隔符\</span></span><br><span class="line"><span class="built_in">console</span>.log(_path)</span><br><span class="line"><span class="comment">// 结果为：/Users/shuliqi/study/webpack-demo/path3/path4/a/b/cc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接路径中带有绝对路径</span></span><br><span class="line"><span class="keyword">var</span> _path2 = path.resolve(<span class="string">'/Users/shuliqi/study/webpack-demo/'</span>, <span class="string">'path3'</span>, <span class="string">'path4'</span>, <span class="string">'a/b/cc/'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(_path2)</span><br><span class="line"><span class="comment">// 结果为：/Users/shuliqi/study/webpack-demo/path3/path4/a/b/cc</span></span><br></pre></td></tr></table></figure>
<p>而 <code>__dirname</code>在 <code>Node.js</code>中总是指向被执行的<code>js</code>文件的绝对路径。如： 当你在<code>：/Users/shuliqi/study/webpack-demo/src/index.js</code>文件中写了<code>__dirname</code>，那么它的值就是<code>/Users/shuliqi/study/webpack-demo/src/</code></p>
<h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><ul>
<li>默认值： 空字符串</li>
</ul>
<p>在复杂的项目中可能会有一些构建出的资源需要异步加载，加载这些异步资源需要对应的<code>url</code>地址。<code>output。publicPath</code>配置就是发布到线上资源的<code>url</code>前缀，是<code>string</code>类型，默认是空字符串，即相对路径。</p>
<p>举个例子🌰：</p>
<p>我们需要把构建出的资源上传到<code>CDN</code>服务上，以便于加快页面的打开速度，配置的代码假设如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入Node的path模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    publicPath: <span class="string">'https://shuliqi.github.io/public/js/'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时发布到线上的<code>HTML</code>在引入<code>Javascript</code>文件时就需要：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'https://shuliqi.github.io/public/js/jkashdjashd.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>webpack学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>window.open被浏览器拦截的解决方案</title>
    <url>/shuliqi.github.io/2019/09/04/window-open%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8B%A6%E6%88%AA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="存在的现象"><a href="#存在的现象" class="headerlink" title="存在的现象"></a>存在的现象</h3><p>最近在做一个需求，遇到了使用window.open()跳转到一个新的页面会被浏览器拦截的情况。虽然在开发环境。我们会手动放行。但是对于客户来说，不能要求用户都来通过拦截。而且在出现拦截的时候。很多小白客户根本不知道发生了啥，以为系统出来安全性问题。</p>
<p>此外，还发现：<strong>当window.open为用户触发事件内部或者加载时，不会被拦截，一旦将弹出代码移动到ajax或者一段异步代码内部，马上就出现被拦截的表现了</strong>。</p>
<a id="more"></a>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>当浏览器检测到非用户操作产生的新弹出窗口，则会对其进行阻止。因为浏览器认为这不是一个用户希望看到的页面。</p>
<p><strong>例1：</strong>直接打开一个页面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">'https://app.mokahr.com'</span>, <span class="string">'_blank'</span>);</span><br></pre></td></tr></table></figure>
<p>在各个浏览器的表现：</p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>ie8</th>
<th><strong>chrome 40</strong></th>
<th><strong>firefox 34</strong></th>
<th><strong>opera 27</strong></th>
<th><strong>safari 5.1.7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>是否拦截</strong></td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
<td><strong>YES</strong></td>
<td><strong>YES</strong></td>
<td><strong>YES</strong></td>
</tr>
</tbody>
</table>
<p><strong>例2：</strong>ajax中的使用window.open</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type:<span class="string">"post"</span>,</span><br><span class="line">    url:<span class="string">"Webservices/WS_BBS_Login.asmx/GetUserInfo"</span>,</span><br><span class="line">    data:<span class="string">"&#123;&#125;"</span>,</span><br><span class="line">    dataType:<span class="string">"json"</span>,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.open(result.url, <span class="string">'_blank'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>也会出现浏览器拦截的情况。</p>
<p><strong>例3：</strong>但是对于这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">window</span>.open(<span class="string">'https://app.mokahr.com'</span>, <span class="string">'_blank'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>所有的浏览器都不会被拦截</p>
<p><strong>结论：各浏览器对拦截时机的判断不一致，而对于放在ajax回调中的代码，也会被拦截。但是，被浏览器拦截我们代码中要弹出的窗口并不是程序员所希望的。</strong></p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol>
<li><p><strong>用a标签代替，这样用户点击这个超链接，浏览器会认为它是打开一个新的链接，所以就不会拦截</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;url&quot; target=&quot;_blank&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>也可以自己创建一个<code>a</code>标签。</p>
<p>给出如下函数，将此函数绑定到click的事件回调中，就可以避免大部分浏览器对窗口弹出的拦截。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function newWin(url, id) &#123;</span><br><span class="line">  var a = document.createElement(&apos;a&apos;);</span><br><span class="line">  a.setAttribute(&apos;href&apos;, url);</span><br><span class="line">  a.setAttribute(&apos;target&apos;, &apos;_blank&apos;);</span><br><span class="line">  a.setAttribute(&apos;id&apos;, id);</span><br><span class="line">  // 防止反复添加</span><br><span class="line">  if(!document.getElementById(id)) document.body.appendChild(a);</span><br><span class="line">  a.click();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用form的submit方法打开一个页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">     &lt;form id=&quot;shu&quot; action=&quot;form_action.asp&quot; method=&quot;get&quot;&gt;&lt;/form&gt; </span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      $(&quot;#shu&quot;).attr(&apos;target&apos;, &apos;_blank&apos;);</span><br><span class="line">      $(&quot;#shu&quot;).submit();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过定时器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var newOpenWindow=window.open();</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">　　newOpenWindow.location=locationurl;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
</li>
<li><p>终极解决方案–先弹出窗口，然后重定向</p>
<p><strong>注意：大家注意，以上方法不适合放在ajax的回调函数中，如果放在回调函数中，依然会被浏览器拦截。</strong></p>
<p>这种方法的核心思想就是：先通过用户点击打开页面，然后再对页面进行重定向。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xx.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 打开页面，此处最好使用提示页面</span></span><br><span class="line">    <span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">'loading page'</span>);</span><br><span class="line"></span><br><span class="line">    ajax().done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 重定向到目标页面</span></span><br><span class="line">        newWin.location.href = <span class="string">'target url'</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此篇文章是参考： <a href="http://zakwu.me/2015/03/03/dan-chu-chuang-kou-bei-liu-lan-qi-lan-jie-de-jie-jue-fang-an/" target="_blank" rel="noopener">window.open被浏览器拦截的解决方案</a>， <a href="https://www.cnblogs.com/hss-blog/p/10194830.html" target="_blank" rel="noopener">ajax回调中window.open弹出的窗口会被浏览器拦截的解决方法</a>，</p>
]]></content>
      <tags>
        <tag>工作中遇到的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是函数柯里化</title>
    <url>/shuliqi.github.io/2018/10/05/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h2 id="什么是“函数柯里化”"><a href="#什么是“函数柯里化”" class="headerlink" title="什么是“函数柯里化”"></a>什么是“函数柯里化”</h2><blockquote>
<p>curry的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
</blockquote>
 <a id="more"></a>
<p>先看一个简单的例子,add函数接受两个参数，addcurry函数接受一个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCurry</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(addCurry(<span class="number">1</span>)(<span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>由例子可以看出，所谓的“<strong>柯里化</strong>“就是<strong>将一个多参数的函数，转化成单参数的函数</strong>。</p>
<h2 id="函数柯里化的优点"><a href="#函数柯里化的优点" class="headerlink" title="函数柯里化的优点"></a>函数柯里化的优点</h2><ul>
<li><p>参数复用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt);</span><br><span class="line">&#125;</span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">'test'</span>)       <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">'test'</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCurry</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> hasNumber = checkCurry(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="keyword">const</span> hasLetter = checkCurry(<span class="regexp">/[a-z]+/g</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hasNumber(<span class="string">'shuliqi11'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(hasNumber(<span class="string">'shuliqi'</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(hasLetter(<span class="string">'1231231'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便</p>
</li>
<li><p>延迟运行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像我们js中经常使用的bind，实现的机制就是Curry</p>
</li>
</ul>
<h2 id="如何实现柯里化"><a href="#如何实现柯里化" class="headerlink" title="如何实现柯里化"></a>如何实现柯里化</h2><p>我们先看一个例子：这里使用了(ramda， 自行安装)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">"ramda"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a, b, c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curry_add = _.curry(add);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(curry_add(<span class="number">1</span>)); <span class="comment">// 输出函数</span></span><br><span class="line"><span class="built_in">console</span>.log(curry_add(<span class="number">1</span>)(<span class="number">2</span>)); <span class="comment">// 输出函数</span></span><br><span class="line"><span class="built_in">console</span>.log(curry_add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出结果</span></span><br></pre></td></tr></table></figure>
<p>栗子中我们对 add 进行了柯里化，从结果上可以看到当参数为 1 个时返回的是个函数，当参数为 2 个的时候返回函数，当参数为 3 个的时候返回<code>函数执行结果</code>。</p>
<p>根据上述的小栗子，可以得到，<code>柯里化后的函数</code>如果接受到全部参数则返回<code>函数执行结果</code>，否则返回<code>一个柯里化函数</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 假如我们柯里化的函数叫 curry_fn</span></span><br><span class="line">		<span class="comment">// if curry_fn接收到的参数等于fn接受</span></span><br><span class="line">		<span class="comment">// else return "一个柯里化函数"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述伪代码是不是很像递归？</p>
<ul>
<li>递归出口：curry_fn接受到的参数数量等于fn接受参数的数量</li>
<li>重复逻辑：return “一个柯里化函数”</li>
</ul>
<p>于是有了以下简单实现柯里化的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> rest = [...args, ...arguments];</span><br><span class="line">        <span class="keyword">if</span> (rest.length &lt; fn.length) &#123;</span><br><span class="line">            <span class="comment">// 如果传入的参数的个数没有等于 fn 函数的参数的个数，则递归返回</span></span><br><span class="line">            <span class="keyword">return</span> curry.call(<span class="keyword">this</span>, fn,  rest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行fn</span></span><br><span class="line">            <span class="keyword">return</span> fn.apply(fn, rest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curryAdd = curry(add);</span><br><span class="line"><span class="built_in">console</span>.log(curryAdd(<span class="number">1</span>)(<span class="number">1</span>)(<span class="number">1</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript语言精髓与编程实战》读书笔记-Promised的核心机制</title>
    <url>/shuliqi.github.io/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>最近参部门的读书会，读书会会推荐一些书来供我们学习， 这次的读书会推荐读的书是《JavaScript语言精髓与编程实战》。感觉写的很不错，我这次学习的是【Promise的核心机制】, 虽然之前也看过关于<code>Promise</code>  <a href="https://shuliqi.github.io/2018/03/20/ES6学习-Promise/">ES6学习笔记-Promise</a>, 但是在看这本书之后，讲的更多关于<code>Promise</code>的原理。还是有值得很深入的点。</p>
<p>最后感觉跟着大神们学习感觉很不错呀，哈哈嘻😊！</p>
 <a id="more"></a>
<h1 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise?"></a>什么是Promise?</h1><p>Promise对象是一个代理对象（代理一个值）。被代理的值在Promise创建的时候可能是未知的。它允许你为异步操作的成功与失败分别绑定相应的处理方法。这让异步可以像同步方法那样返回值，但并不是立即返回最终的执行结果，而是一个能代表未来的出现的结果的promise对象。</p>
<h1 id="promise的状态"><a href="#promise的状态" class="headerlink" title="promise的状态"></a>promise的状态</h1><p>Promise 一种有三种值的状态： <strong>pending(进行中)</strong>, <strong>fulfiiled(已成功)</strong>，<strong>rejected(已失败)‘</strong></p>
<h1 id="Promise的特点"><a href="#Promise的特点" class="headerlink" title="Promise的特点"></a>Promise的特点</h1><ul>
<li><p><strong>对象的状态不受外界的影响</strong></p>
<p>只有异步的结果可以决定当前是哪一种状态（pending， fulfilled, rejected）。 其他的手段都是无法改变的。</p>
</li>
<li><p><strong>一旦状态改变，就不会再变，任何时候都可以拿到这个状态</strong></p>
<p>Promise的状态只有两种可能：从pending 到 fulfilled， 从peding 到rejected。只要这两种发生了，状态也就凝固了，不会再变了。</p>
<p>如果在对Promise对象添加回调函数，也会立刻拿到这个结果。</p>
</li>
</ul>
<h1 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h1><p>创建Promise对象，主要有三种方式：</p>
<ul>
<li>使用 <code>new Promise()</code>来创建一个<code>promise</code>(即<code>new Promise()</code>构造器)</li>
<li><p>使用类方法Promise.xxx()-——<code>Promise.all()</code>，<code>Promise.race()</code>，<code>Promise.allsettled()</code>，<code>Promise.any()</code>，<code>Promise.resolve()</code>，<code>Promise.reject()</code></p>
</li>
<li><p>使用原型形方法<code>Promise.prototype.xxx()</code>——<code>promise.then()</code>，<code>promise.catch()</code>，<code>promise.fanally()</code>都将返回一个新的promise</p>
<blockquote>
<p>任何方法得到的<code>promise</code>对象都具有<code>.then</code>，<code>.catch</code>等方法，也是<code>Promise.prototype.xxx</code>的原型方法，<code>Javascript</code>调用这些方法将绝对不会抛出异常，所以这就是上面第三种得到一个新的<code>promise</code>对象的方法</p>
</blockquote>
</li>
</ul>
<p><strong>注意：</strong>任何一种方法都是立即得到<code>promise</code>对象的</p>
<h1 id="Promise的构造方法"><a href="#Promise的构造方法" class="headerlink" title="Promise的构造方法"></a>Promise的构造方法</h1><p><code>Promise</code>通常使用一个简单的构造器来让用户方便的创建<code>promise</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建promise对象的构造器</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要用户声明的执行函数</span></span><br><span class="line"><span class="keyword">const</span> executor = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>executor</code> 是用户声明的执行函数，当<code>JavaScript</code>引擎通过new 运算符来创建<code>promise</code>对象时，它事实上在调用<code>executor()</code>之前就创建好一个新的<code>promise</code>对象的实例，并且得到关联给这个实例的两个置值器：<code>resolve()</code>，<code>reject()</code>函数，然后，它会调用<code>executor()</code>，并且把这两个置值器作为入口参数传入，而<code>executor()</code>函数会被执行直到退出。</p>
<p><strong>注意：</strong><code>executor()</code>函数并不通过退出时所返回的值来对系统造成影响——该返回值将会被忽略（无论是显式返回结果，还是默认返回值<code>undefined</code>）。<code>executor()</code>中的用户代码可以利用上述的两个置值器，来向<code>promise</code>对象“代理的那个数据”置值。也就是说，为<code>promise</code>绑定值的过程是由用户代码来触发的。这个过程看起来像”让用户代码回调<code>JavaScript</code>引擎”。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户代码通过resolve(或reject）来回调引擎以置值</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"shuliqi"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意：<code>executor()</code></strong>函数中的<code>resolve</code>·置值器可以接受任何值（除了当前的promise本身之外）,如果使用自身来置值时，<code>JavaScript</code>会抛出一个异常。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂存resolve置值的变量</span></span><br><span class="line"><span class="keyword">let</span> delayResolve;</span><br><span class="line"> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    delayResolve = resolve;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// 尝试使用自身来置值</span></span><br><span class="line"> delayResolve(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="构建Promise对象：没有延迟"><a href="#构建Promise对象：没有延迟" class="headerlink" title="构建Promise对象：没有延迟"></a>构建Promise对象：没有延迟</h1><p>在构建整个<code>Promise</code>对象的过程中， 是没有任何的延迟的。<code>Promise</code>机制中没有延迟， 也没有被延迟的行为，更没有对”时间”这个维度进行控制。因此<code>JavaScript</code>中创建一个<code>promise</code>时，创建过程时立即完成的；使用原型的方法<code>promise.xxx</code>来得到一个新的<code>promise</code>时也是立即完成的。所有<code>promise</code>对象都是在你需要的时候立即就生成的。</p>
<p>只不过重要的是—-&gt;<strong>这些<code>promise</code>所代理的那个值/数据还没有“就绪”。这个就绪的过程要推迟到“未知的将来”才会发生，而一旦数据就绪，promise.then(fun)中的fun就会被触发了</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'shuliqi'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'1'</span>), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>只要我们创建了<code>promise</code> 对象，这个过程是立即的，所以立马输出“shuliqi”。然后过3秒，输出 “1”。</p>
<h1 id="Then-链"><a href="#Then-链" class="headerlink" title="Then 链"></a>Then 链</h1><p>两个<code>Promise</code>对象之间顺序执行的关系，在<code>JavaScript</code>中称为“Then 链”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个Promise 对象P</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'shuliqi'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过p.then()来得到新的promise对象 p2</span></span><br><span class="line"><span class="keyword">const</span> p2 = p.then(foo() =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过调用<code>p.then(</code>)的方式来约定当前的<code>promise</code>对象与下一个<code>promise</code>对象之间的“链”关系，并且这事实上也也代表了它们之前的顺序执行的关系（<strong>所谓的“顺序执行”是指它们的置值逻辑以及触发的行为之间的关系—-&gt; 因为Promise本身是数据的代理所以并不是执行体</strong>）。</p>
<p>并且then链是Promise机制的基本用法和关键的机制。上面例子中的p.then()代表了对顺序的逻辑的理解， 同时它也隐含的说明：p2 与p1两者所代理的数据之间是有关联的。这个例子的foo()函数是作为p1的成功回调，如下面这个例子的作为onFulfilled参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个Promise 对象P</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'shuliqi'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过p.then()来得到新的promise对象 p2</span></span><br><span class="line"><span class="keyword">const</span> p2 = p.then(onFulfilled, onRejected);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(value); <span class="comment">// shuliqi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在当前的promise数据就绪时，JavaScript就将根据就绪状态立即出发有p.then()方法所关联的onFulfilled/ onRejected之一，并且这个函数<strong>退出时返回的值</strong>或者<strong>终止执行时的状态</strong>作为值来调用p2</p>
<p>p.then()实际上是Promise.prototype.then这个原型的方法，它的作用主要是完成三件事：</p>
<ul>
<li>创建新的promise2对象</li>
<li>登记当前promise 与 promise2 之间的关系（顺序执行的关系和代理的数据之间是有关联的）</li>
<li>将onFulfilled ，onRejected关联给promise2 的resolve置值器，并且确保早promise1的数据就绪时调用onFulfilled， onRejected。</li>
</ul>
<h2 id="promise1的置值逻辑"><a href="#promise1的置值逻辑" class="headerlink" title="promise1的置值逻辑"></a>promise1的置值逻辑</h2><p>所以在构建promise的执行器中，可以向resolve/reject 传入任意的JavaScript数据类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    resolve(<span class="string">'我显示使用resolve置值器置值'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(<span class="string">'我显示使用reject 置值器置值'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个例子显式的使用resolve / reject 置值器来置值。</p>
<p>如果执行器在执行的过程中触发异常，javaScript引擎也将调用reject， 并且把异常作为reason。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// 创建异常，并且抛出，相当于reject(new Error())</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>接下来，如果在它的then 链上有promise2,那么如前所诉：onFulfilled/onRejected将被触发，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    resolve(<span class="string">'我显示使用resolve置值器置值'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(<span class="string">'我显示使用reject 置值器置值'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 =p.then(onFulfilled, onRejected);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是resolve置值器置值成功的回调'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是reject置值器置值或者是resolve置值器置值失败的回调"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我是resolve置值器置值成功的回调</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// 创建异常，并且抛出，相当于reject(new Error())</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 =p.then(resolved, rejected);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolved</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是resolve置值器置值成功的回调'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是reject置值器置值或者是resolve置值器置值失败的回调"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我是reject置值器置值或者是resolve置值器置值失败的回调</span></span><br></pre></td></tr></table></figure>
<p>以上的的 resolved， rejected 都只是 p 的状态，他们只是promise2的置值前提而已， 那么promise2的置值逻辑是啥呢？</p>
<h2 id="promise2的置值逻辑"><a href="#promise2的置值逻辑" class="headerlink" title="promise2的置值逻辑"></a>promise2的置值逻辑</h2><p>一个Promise可能被置入两种值之一（并且一旦置值将不可改变，称为“终态”），这两种值时指：</p>
<ul>
<li>如果promise 被 resolve置值器置值成功，则该值称为有效值（value）</li>
<li>如果promise 被 reject置值器置值 或者 resolve置值器置值 失败，则该值用于记录原因（reason）。</li>
</ul>
<p><strong>无论rejected，rejected函数无论返回何值，都将作为resolve值直接绑定给promise2</strong>(即：resolved, rejected函数会关联在promise2的resolve 值值器上)</p>
<p>promise2 的置值逻辑伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断上一个promise的置值状态</span></span><br><span class="line">    <span class="keyword">if</span> (isRejected(p)) &#123;</span><br><span class="line">        x2 = rejected(result);  <span class="comment">// 执行rejected函数，result为reason（result是p代理的数据）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x2 = resolved(result); <span class="comment">// 执行resolved函数</span></span><br><span class="line">    &#125; </span><br><span class="line">    resolve(x2); <span class="comment">// promise2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvedForP1 = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rejectedForP1 = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reason;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> resolvedForP2 = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是p2 resolved状态,'</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rejectedForP2= <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是p2 rejected状态,'</span>, reason);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 顺便调用p1的resolve置值器，还是reject置值器</span></span><br><span class="line">      <span class="comment">// resolve('p1 resolve');</span></span><br><span class="line">      reject(<span class="string">'p1 reject'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(resolvedForP1, rejectedForP1);</span><br><span class="line">p2.then(resolvedForP2, rejectedForP2)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我是p2 resolved状态, p1 reject</span></span><br></pre></td></tr></table></figure>
<p>这个例子： 无论p1 我调用的是 resolve 置值器还是拍，导致无论调用 resolvedForP1还是 rejectedForP1，返回值都是作为resolve值绑定给p2。</p>
<p>调用（p1  reject 置值器 —-&gt; 调用rejectedForP1 —-&gt; rejectedForP1 返回值 —-&gt; 通过p2 的resolve置值器直接绑定给p2）。</p>
<p>注意：<strong>这不是完成的promise2 的置值逻辑</strong>， 完整的请往下看。</p>
<h2 id="then-链中“产生”-reject值的方法"><a href="#then-链中“产生”-reject值的方法" class="headerlink" title="then 链中“产生” reject值的方法"></a>then 链中“产生” reject值的方法</h2><p>在then 链中“产生” reject值的方法只有两种：</p>
<ul>
<li><p>通过抛出异常来使得JavaScript引擎捕获异常对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'我是舒丽琦'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方法1: 通过抛出异常来使得JavaScript引擎捕获异常对象</span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'通过抛出异常来使得JavaScript引擎捕获异常对象'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: Error: 通过抛出异常来使得JavaScript引擎捕获异常对象....</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过显式的调用Promise.reject()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'我是舒丽琦'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方法2: 显式的调用Promise.reject() </span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">'显式的调用Promise.reject() '</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: 显式的调用Promise.reject() ...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Then-链对值的传递"><a href="#Then-链对值的传递" class="headerlink" title="Then 链对值的传递"></a>Then 链对值的传递</h2><p>如果promise2 的resolve 并没有关联有效的resolved，rejected 呢？ 或者 promise2 根本没有resolved， rejected 函数呢？那么还会生成promise2 吗？ 如果生成， 那么它的值时什么呢？</p>
<p>答案：<strong>如果没有有效的响应函数仍会产生新的promise2, 并且它的resolve 将以then 链中的当前的promise的值为值</strong>，</p>
<p>因此promise2 的完整的伪置值逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断上一个promise的置值状态</span></span><br><span class="line">    <span class="keyword">if</span> (isRejected(p)) &#123;</span><br><span class="line">       <span class="comment">// rejected 是有效的 ? 执行rejected函数，result为reason : result </span></span><br><span class="line">       <span class="comment">// 其中result是p代理的数据</span></span><br><span class="line">        x2 = isValidHandler(rejected) ? rejected(result) :<span class="keyword">throw</span> result;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	  <span class="comment">// resolved函数是有效的 ？ 执行resolved函数 ： result;</span></span><br><span class="line">        x2 = isValidHandler(resolve) : resolved(result) : result; </span><br><span class="line">    &#125; </span><br><span class="line">    resolve(x2); <span class="comment">// promise2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来举例子检测一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'调用p1的reject置值器置值'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then();</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: 调用p1的reject置值器置值...</span></span><br></pre></td></tr></table></figure>
<p>P1代理的值是reject 置值器置值的，在创建p2的时候， rejected 函数不存在(无效), 则抛出异常, 值为当前promise(p1)的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'调用p1的reject置值器置值'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then();</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 调用p1的reject置值器置值</span></span><br></pre></td></tr></table></figure>
<p>P1代理的值是resolve置值器置值的，在创建p2的时候， resolved函数不存在(无效), 则直接返回当前promise(p1)的值。</p>
<h2 id="Then-链-catch-的处理"><a href="#Then-链-catch-的处理" class="headerlink" title="Then 链 catch() 的处理"></a>Then 链 catch() 的处理</h2><p>promise2的置值过程也解释了使用.catch作为then链结尾的原因：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'调用p1的reject置值器置值'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then();</span><br><span class="line"><span class="keyword">const</span> p3 = p2.then();</span><br><span class="line">p3.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: 调用p1的reject置值器置值</span></span><br></pre></td></tr></table></figure>
<p>在任意长的then链中，如果链的前端出现了rejected 值，无论经过多少级.then()响应(只有onFulfilled响应而没有处理)， 最终rejected 值都能够持续向后传递并且被链尾的.catch()响应到。这也就是Promise机制的第一原则：<strong>始于Promise， 终于catch</strong>。</p>
<h1 id="Promise的类方法"><a href="#Promise的类方法" class="headerlink" title="Promise的类方法"></a>Promise的类方法</h1><p>Promise()类方法Promise.xxx主要作用于获得一个promise</p>
<p>promise类方法有四个：</p>
<ul>
<li><p><strong>Promise.resolve()</strong></p>
</li>
<li><p><strong>Promise.reject()</strong></p>
</li>
<li><p><strong>Promise.all()</strong></p>
</li>
<li><p><strong>Promise.race()</strong></p>
</li>
</ul>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>Pomise类方法resolve()是要得到一个resolved 的 promise。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(x)</span><br></pre></td></tr></table></figure>
<p>x是任意值，如果不指定则是undefined</p>
<ul>
<li><p>如果 x 是Promise的一个实例，那么Promise.resolve(x)， 将不会产生新的计算结果，而是直接返回x这个实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(x);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(p)</span><br><span class="line"><span class="comment">// p 与 p2 是相同的promise</span></span><br><span class="line"><span class="built_in">console</span>.log(p === p2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// resolve的值是同一个</span></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span>  <span class="built_in">console</span>.log(value === x)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果x是一个thenable</p>
<p>thenable对象：指任意带有.then()方法的对象。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">   then: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'我是thenable对象'</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'我是thenable对象'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line"><span class="comment">// 我是thenable对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thenable === p); </span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>x.then()是立即执行了， 但是这个thenable对象与最终的p没有关系，所以目前这个执行过程是没有什么意义的。因为这个thenable对象与最终的p对像之间并没有建立关系。为什么没有建立关系呢？这是因为JavaScript是试图将x.then()作为一个“类似new Promise()中的执行器（executor）”来使用的。Promise.resolve(tenable)导致.then() 被执行时，p这个promise对象的resolve与reject两个置值器被作为.then()的参数传入的，因此(与new Promise类似)，用户代码需要在.then(resolve,reject)调用这两个置值器才能真正的建立thenable与p之间的关系。</p>
<p>所以下面这个例子，p对象与thenable才真正建立起了关系：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    then: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我是thenable对象'</span>);</span><br><span class="line">        resolve(<span class="string">'shuliqi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 我是thenable对象</span></span><br><span class="line"><span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果x是一个rejected的promise对象，那么Project.resolve(x将会是一个rejected状态的promise对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'rejected状态'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(p);</span><br><span class="line">p2.then().catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// rejected状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>x以上情况都不是，那么将会返回一个新的状态直接为resolved的promise对像，并且代理的数据与x的相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">"shuliqi"</span>;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(x);</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'resolved状态的'</span>, value));</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">//resolved状态的, shuliqi</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"resolved状态的"</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  上面这两个例子都是调用了resoled状态的回调。</p>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>Pomise类方法Promise.reject()得到一个rejected 的promise；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(x)； <span class="comment">// x是任意值，如果不指定则为undefined</span></span><br></pre></td></tr></table></figure>
<p>Promise.reject(x)与Promise.resolve(x)不同，Promise.reject(x)是将x作为一个普通的对象。这就意味着仍然会得到一个rejected promise，并且它的值时一个（类型为Promise）的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">'shuliqi'</span>);</span><br><span class="line"><span class="keyword">const</span> p2 =<span class="built_in">Promise</span>.reject(p1);</span><br><span class="line">p2.then().catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'typeof reason:'</span>, <span class="keyword">typeof</span> reason);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'instanceof Promise:'</span>, reason <span class="keyword">instanceof</span> <span class="built_in">Promise</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'reason === p1:'</span>, reason === p1)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// typeof reason: object</span></span><br><span class="line"><span class="comment">// instanceof Promise: true</span></span><br><span class="line"><span class="comment">// reason === p1: true</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>尝试resolve所有元素。当所有的元素都resolved，得到一个将所有结果作为resolved array的promise。当任意一个元素rejected，得到一个该结果 reason 的rejected promise。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(x); <span class="comment">// x 必须是可迭代对象（集合对象，或者是有迭代器的对象）</span></span><br></pre></td></tr></table></figure>
<p><strong>可迭代的对象</strong>：数组， Map/Set集合，字符串可迭代的对象：数组， Map/Set集合，字符串 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all([timeout1, timeout2])</span><br><span class="line">  .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"都执行完成了"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"没有catch"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 都执行完成了</span></span><br></pre></td></tr></table></figure>
<p>Promise.all()会对所有的元素进行预处理（Promise.resolve(x)）所以无论x 是一个普通值还是一个“潜在的promise”， 它都将作为一个resolved promise进入后续的处理，即使x是一个rejected promise， 那么它的状态(Promise.resolve(rejected_promise))依然会影响Promise.all()的最终状态的判断。 一旦发现rejected，则返回rejected的结果。</p>
<p>promise.all(element)只有element完全resolved时，会在then()中得到一个与原始element 存在映射关系的数组。</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>尝试resolve 所有元素。只要其任一元素resolved 或 rejected，都将以该结果作为结果promise</p>
<p>注意：所有的其他的元素的状态都是未确定的，并且他们的执行过程与结果不确定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race(x); <span class="comment">// x 必须是可迭代对象（集合对象，或者是有迭代器的对象）</span></span><br></pre></td></tr></table></figure>
<p>Promise.race()与Promise.all()类似， 都会对所有的元素进行预处理（Promise.resolve(x)）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout 1"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout2"</span>);</span><br><span class="line">    reject();</span><br><span class="line">  &#125;, <span class="number">500</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([timeout1, timeout2])</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第一个time状态发生改变了"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"catch"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// timeout2</span></span><br><span class="line"><span class="comment">//  catch</span></span><br><span class="line"><span class="comment">//  timeout 1</span></span><br></pre></td></tr></table></figure>
<h1 id="Promise对象的原型方法"><a href="#Promise对象的原型方法" class="headerlink" title="Promise对象的原型方法"></a>Promise对象的原型方法</h1><p>Promise对象方法Promise.prototype.xxx(p.xxx)主要用于响应一个promise 状态，并且对象方法的响应结果也必然是返回一个新的promise2。除了.then()之外，promise对象最主要的的原型方法—.catch() 和.finally()都是通过通过.then()来间接实现的。</p>
<h2 id="Promise-Prototype-catch"><a href="#Promise-Prototype-catch" class="headerlink" title="Promise.Prototype.catch()"></a>Promise.Prototype.catch()</h2><p>.catch(onRejected) 与.then(_, onRejected)中的参数一致， 两种用法的效果也近似。</p>
<p>但是使用.catch()的方法， 尤其是在Then链末端的.catch()是非常必要的和安全的， 因为.then(onFulfilled, onRejected)中的onRejected函数并不能捕获到onFulfilled函数里面的异常(以及其中返回的rejected promise)。 如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> onFulfilled = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'我抛出异常，产生rejected promise'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'没有能捕获onFulfilled函数返回的rejected promise'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
<p>这个例子中的onRejected 函数并不能响应onFulfilled函数中抛出的异常以及JavaScript为该异常而创建的rejected promise，将会遗漏对rejected Promise的处理，争取的处理应该是遵循“始于promise，终于catch”的原则。如下例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> onFulfilled = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'我抛出异常，产生rejected promise'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'没有能捕获onFulfilled函数返回的rejected promise'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p.then(onFulfilled, onRejected).catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我来处理onFulfilled产生的异常:'</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我来处理onFulfilled产生的异常： 我抛出异常，产生rejected promise</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise-Prototype-finally"><a href="#Promise-Prototype-finally" class="headerlink" title="Promise.Prototype.finally()"></a>Promise.Prototype.finally()</h2><p>finally()方法，与try…catch/finally中的finally子句的语法类似；使代码无论.catch()还是.then()调用结束后，总是能得到一次调用.fanally()的机会。</p>
<p><strong>该方法不接受任何的参数，意思就是最后的Promise代理的值是什么， 是没有办法知道的。finally()方法跟最后的promise的状态是无关的。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finally（）方法的响应函数是无传入参数的</span></span><br><span class="line"><span class="keyword">const</span> onFinally = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"不管promise状态怎么样， 我都会执行, 并且我是无参数参入的哦"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"我抛出错误"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"发生错误"</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(onFinally);</span><br></pre></td></tr></table></figure>
<p>上面例子的结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">发生错误 <span class="built_in">Error</span>: 我抛出错误</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">6</span>:<span class="number">15</span></span><br><span class="line">    at <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="xml"><span class="tag">&lt;<span class="name">anonymous</span>&gt;</span>)</span></span><br><span class="line">    at &lt;anonymous&gt;:5:15</span><br><span class="line">VM134:3 不管promise状态怎么样， 我都会执行, 并且我是无参数参入的哦 undefined</span><br></pre></td></tr></table></figure>
<p>这个例子中的onFinally函数中，我们打印value 值，值为undefined。说明.finally()的onFinally函数是不接受任何参数的。</p>
<p><strong>默认.finally()方法不会改变Then 链上前端所产生的值，也包括其状态。</strong></p>
<p>JavaScript 不处理在响应函数onFinally中的任何返回值，.finally()方法的结果—只是简单的“得到了”链上的前一个promise对象所代理的数据。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">"我是舒力气"</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(x);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'我的年龄是21'</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我的值是：'</span>, value)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 我的值是：我是舒力气</span></span><br></pre></td></tr></table></figure>
<p>以上例子中.finally()的onFinally中的返回值自动被忽略。所以p2的值是前一个promise对象所代理的值（p1的值）。</p>
<p>当然，也有例外的时候。如果.finally()的响应函数onFinally()中发生了异常，或者用户代码显式的返回了rejected promise。 那么就会替代了then链上之前的promise对象所代理的值了。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">"我是舒力气"</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(x);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'我在onFinally函数中显式的返回了rejected promise了'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p2.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我的值是：'</span>, reason)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 我的值是： 我在onFinally函数中显式的返回了rejected promise了</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>你不知道的css技巧</title>
    <url>/shuliqi.github.io/2019/08/27/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84css%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h4 id="1-用-Of-Type-选择元素"><a href="#1-用-Of-Type-选择元素" class="headerlink" title="1.用 :*-Of-Type 选择元素"></a><strong>1.用 :*-Of-Type 选择元素</strong></h4><blockquote>
<p>不兼容IE8</p>
</blockquote>
<p>假如我们有这样的htm结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>11111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>22222<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>33333<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>44444<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>55555<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <a id="more"></a>
<p>给第一个 p 段落文本变红：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p:first-of-type &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给最后一个 p 加边框:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让偶数列的 p 段落背景设置黑色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type(even)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外， 还可以设置其他类型的参数</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* only 第三个 */</span></span><br><span class="line"><span class="selector-pseudo">:nth-of-type(3)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每第三个 */</span></span><br><span class="line"><span class="selector-pseudo">:nth-of-type(3n)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每第四加三个，即 3, 7, 11, ... */</span></span><br><span class="line"><span class="selector-pseudo">:nth-of-type(4n+3)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成的代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 给第一个 p 段落文本变红： */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span><span class="selector-pseudo">:first-of-type</span> &#123;</span></span><br><span class="line"><span class="undefined">      color: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 给最后一个 p 加边框 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span> &#123;</span></span><br><span class="line"><span class="undefined">      border: 1px solid green;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 让偶数列的 p 段落背景设置黑色： */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type(even)</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* only 第三个 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-pseudo">:nth-of-type(3)</span> &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 每第三个 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-pseudo">:nth-of-type(3n)</span> &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 每第四加三个，即 3, 7, 11, ... */</span></span></span><br><span class="line"><span class="css">    <span class="selector-pseudo">:nth-of-type(4n+3)</span> &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>11111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>22222<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>33333<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>44444<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>55555<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-用-unset-做-CSS-Reset"><a href="#2-用-unset-做-CSS-Reset" class="headerlink" title="2.用 unset 做 CSS Reset"></a><strong>2.用 unset 做 CSS Reset</strong></h4><blockquote>
<p>不兼容IE8</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    button &#123;</span></span><br><span class="line"><span class="undefined">      color: red;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 取消 item 中 button 的 color 设置 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> <span class="selector-tag">button</span> &#123;</span></span><br><span class="line"><span class="undefined">      color: unset;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮111<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮222<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-使用-empty-区分空元素"><a href="#3-使用-empty-区分空元素" class="headerlink" title="3.使用 :empty 区分空元素"></a>3.使用 :empty 区分空元素</h4><blockquote>
<p>不兼容IE8</p>
</blockquote>
<p>假如我们有以下的HTML结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我们希望对空元素和非空元素区别处理。那么有这两种方案。</p>
<p>使用 <strong>:empty</strong> 选择空元素:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:empty</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用<strong>:not(:empty)</strong> 选择非空元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:empty)</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: red</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>完成的代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="undefined">      width: 100%;</span></span><br><span class="line"><span class="undefined">      height: 50px;</span></span><br><span class="line"><span class="undefined">      margin: 10px 0;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 使用 :empty 选择空元素: */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span><span class="selector-pseudo">:empty</span> &#123;</span></span><br><span class="line"><span class="undefined">      display: none;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/*使用:not(:empty) 选择非空元素 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-pseudo">:not(</span><span class="selector-pseudo">:empty)</span> &#123;</span></span><br><span class="line"><span class="undefined">      color: red</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-每个单词的首字母大写-text-transform"><a href="#4-每个单词的首字母大写-text-transform" class="headerlink" title="4.每个单词的首字母大写 text-transform"></a>4.每个单词的首字母大写 text-transform</h3><blockquote>
<p> CSS2 中的属性，参数有 capitalize | uppercase | lowercase | none</p>
</blockquote>
<p>参数介绍：</p>
<ol>
<li>none：默认。定义带有小写字母和大写字母的标准的文本。</li>
<li>capitalize：文本中的每个单词以大写字母开头。</li>
<li>uppercase：定义仅有大写字母。</li>
<li>lowercase：定义无大写字母，仅有小写字母。</li>
</ol>
<p>从这个属性我们可以知道全部大写（小写）的需求这个属性也能轻易实现。</p>
<p>例子：每个单词的首字母大写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>shuliqi is boy<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">   <span class="attribute">text-transform</span>:capitalize;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>例子链接： <a href="http://jsrun.pro/IYWKp/edit" target="_blank" rel="noopener">http://jsrun.pro/IYWKp/edit</a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IntersectionObserver提升性能</title>
    <url>/shuliqi.github.io/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h2 id="问题引出？"><a href="#问题引出？" class="headerlink" title="问题引出？"></a>问题引出？</h2><p>之前， 我们要做<strong>懒加载</strong>  或者 <strong>无限加载</strong>的时候。通常是这么做的：</p>
<ol>
<li><p><strong>懒加载</strong></p>
 <a id="more"></a>
<p>图示：</p>
<img src="/shuliqi.github.io/2020/03/26/使用IntersectionObserver提高性能/lazyLoad.jpg">
<p>主要代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>);</span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 浏览器滚动过的高度</span></span><br><span class="line">  <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">  <span class="comment">// 可视区域的高度</span></span><br><span class="line">  <span class="keyword">var</span> winTop = <span class="built_in">window</span>.innerHeight; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; imgs.length;i++)&#123;</span><br><span class="line">    <span class="comment">// 当图片距离页面顶部的距离 &lt; 浏览器滚动过的高度 +  可视区域的高度</span></span><br><span class="line">    <span class="keyword">if</span>(imgs[i].offsetTop &lt; scrollTop + winTop )&#123;</span><br><span class="line">      imgs[i].src = imgs[i].getAttribute(<span class="string">'data-src'</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无限滚动</strong></p>
<p>图例：</p>
<img src="/shuliqi.github.io/2020/03/26/使用IntersectionObserver提高性能/wuxian.jpg">
<p>主要代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> page=<span class="number">1</span>; <span class="comment">//当前页的页码</span></span><br><span class="line"><span class="keyword">var</span> flagNoData = <span class="literal">false</span>; <span class="comment">//false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAjax</span>(<span class="params">page</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...请求数据啥啥的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//真实内容的高度</span></span><br><span class="line">  <span class="keyword">var</span> pageHeight = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollHeight,<span class="built_in">document</span>.body.offsetHeight);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//视窗的高度</span></span><br><span class="line">  <span class="keyword">var</span> viewportHeight = <span class="built_in">window</span>.innerHeight </span><br><span class="line">  	                 || <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">  	                 || <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">  	                 || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//隐藏的高度</span></span><br><span class="line">  <span class="keyword">var</span> scrollHeight = <span class="built_in">window</span>.pageYOffset </span><br><span class="line">                    || <span class="built_in">document</span>.documentElement.scrollTop </span><br><span class="line">                    || <span class="built_in">document</span>.body.scrollTop </span><br><span class="line">                    || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(falgNoData)&#123; <span class="comment">//数据全部加载完了</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pageHeight - viewportHeight - scrollHeight &lt; <span class="number">10</span>)&#123; <span class="comment">//如果满足触发条件，执行    </span></span><br><span class="line">      showAjax(page);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="built_in">window</span>).bind(<span class="string">"scroll"</span>,scrollFn);    <span class="comment">//绑定滚动事件</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>传统的实现方法是，监听到<code>scroll</code>事件后，获取相关元素的坐标来进行判断。这种方法是有缺点的。由于<code>scroll</code>事件密集发生，计算量很大，容易造成性能。</p>
<p>那么在这样的背景下， 我们有没有更好的办法呢？</p>
<h2 id="关于IntersectionObserver"><a href="#关于IntersectionObserver" class="headerlink" title="关于IntersectionObserver"></a>关于IntersectionObserver</h2><p><code>IntersectionObserver</code>的出现解决了这个问题。</p>
<p>MDN上给的官方概念：</p>
<blockquote>
<p><code>IntersectionObserver</code>接口 (Intersection Observer API)为开发者提供了一种可以异步监听目标元素与其祖先或者视窗（viewport）交叉状态的手段。祖先元素与视窗(viewport)被称为根(root)。</p>
</blockquote>
<p>这概念的重点就是：<strong>监听目标元素与其祖先或视窗交叉状态发生改变的手段</strong> </p>
<p>图解如下图：</p>
<img src="/shuliqi.github.io/2020/03/26/使用IntersectionObserver提高性能/2.jpg">
<p><strong>目标元素与root元素刚开始交叉</strong>和<strong>目标元素与root元素刚开始不交叉</strong>都能检测到。</p>
<p><strong>看看小🌰：</strong> </p>
<iframe height="598" style="width: 100%;" scrolling="no" title="wvKBBWb" src="https://codepen.io/shuliqi/embed/wvKBBWb?height=598&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/wvKBBWb" target="_blank" rel="noopener">wvKBBWb</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>



<h2 id="IntersectionObserver-如何解决？"><a href="#IntersectionObserver-如何解决？" class="headerlink" title="IntersectionObserver 如何解决？"></a>IntersectionObserver 如何解决？</h2><p>IntersectionObserver API 是异步的， 不随着目标元素的滚动同步触发。即只有在线程空闲下来才会执行观察器。这意味着这个观察器的优先级非常的低，只有在其他的任务执行完，浏览器空闲了才会执行。</p>
<h2 id="IntersectionObserver-API"><a href="#IntersectionObserver-API" class="headerlink" title="IntersectionObserver API"></a>IntersectionObserver API</h2><p>这个API的调用非常的简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, options)</span><br></pre></td></tr></table></figure>
<p><code>IntersectionObserver</code>支持两个参数：</p>
<ol>
<li><code>callback</code> 是当被监听元素的可见性变化时，触发的回调函数</li>
<li><code>options</code>是一个配置参数对象，可选的， 有默认的属性值</li>
</ol>
<p>构造函数的返回值是一个观察实例， 实例的<code>observe</code>方法可以指定观察哪个DOM节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  对元素target添加监听，当target元素变化时，就会触发回调</span></span><br><span class="line">io.observe(<span class="built_in">document</span>.getElementById(<span class="string">'shuliqi'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除一个监听，移除之后，target元素的交叉状态变化，将不再触发回调函数</span></span><br><span class="line">io.unobserve(element)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止所有的监听</span></span><br><span class="line">io.disconnect();</span><br></pre></td></tr></table></figure>
<p>上面的<code>observe()</code>的参数是一个DOM节点对象，如果要观察多个节点，就要多次调用这个方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">io.observe(eleA);</span><br><span class="line">io.observe(eleB);</span><br></pre></td></tr></table></figure>
<h2 id="callback-参数"><a href="#callback-参数" class="headerlink" title="callback 参数"></a>callback 参数</h2><p>目标元素的交叉状态发生改变时，就会调用观察器的回调函数<code>callback</code>。</p>
<p><code>callback</code>一般会调用两次。一次是目标元素刚刚进入root元素（开始交叉）, 另一次是完全离开root（开始不相交）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(entries);</span><br><span class="line">&#125;)</span><br><span class="line">io.observe($<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>以上的代码， 在chrome控制台进行调试，这里的$0代表我审查元素选中的节点。</p>
<p>运行的结果如下：</p>
<img src="/shuliqi.github.io/2020/03/26/使用IntersectionObserver提高性能/3.jpg">
<p>由图我们可知callback函数有个参数，它是<code>IntersectionObserverEntry</code>对象数组，举例来说，如果同时有两个被观察的对象的可见性发生变化， 那么entries数组就会有两个成员。</p>
<p>接下来我们重点讲<code>IntersectionObserverEntry</code></p>
<h2 id="IntersectionObserverEntry对象"><a href="#IntersectionObserverEntry对象" class="headerlink" title="IntersectionObserverEntry对象"></a>IntersectionObserverEntry对象</h2><p><code>IntersectionObserverEntry</code>对象提供目标元素的信息，</p>
<p>还是以上的例子：</p>
<img src="/shuliqi.github.io/2020/03/26/使用IntersectionObserver提高性能/4.jpg">
<p>一共有8 个属性：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  time: 78463997.025,</span><br><span class="line">  rootBounds: null,</span><br><span class="line">  boundingClientRect: DOMRectReadOnly &#123;</span><br><span class="line">   // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  intersectionRect: DOMRectReadOnly&#123;</span><br><span class="line">   // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  isIntersecting: true,</span><br><span class="line">  intersectionRatio: 1,</span><br><span class="line">  target: html,</span><br><span class="line">  isVisible: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个属性的含义如下：</p>
<ol>
<li><p><strong>time：</strong> </p>
<p>返回一个记录从<code>IntersectionObserver</code>开始实例化的时间到交叉状态发生改变的时间的时间戳对比时间：实例化的时间。例子：值为1000时，表示在IntersectionObserver实例化的1秒钟之后，目标元素的交叉状态发生改变了</p>
</li>
<li><p><strong>rootBounds：</strong> 根元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回<code>null</code></p>
</li>
<li><p><strong>boundingClientRect：</strong>  目标元素的矩形信息</p>
</li>
<li><p><strong>isIntersecting：</strong>目标元素当前是否可见 Boolean值 可见为true</p>
</li>
<li><p><strong>intersectionRect：</strong> 目标元素与视口（或root根元素）的交叉区域的信息</p>
</li>
<li><p><strong>intersectionRatio：</strong> 目标元素的可见比例，即<code>intersectionRect</code>占<code>boundingClientRect</code>的比例，完全交叉时为<code>1</code>，完全不交叉时小于等于<code>0</code></p>
</li>
<li><p><strong>target：</strong> 被观察的目标元素，是一个 DOM 节点对象</p>
</li>
</ol>
<p><strong>注意：</strong>在Chrome 78版本中会返回<code>isVisible</code>属性，但是不知道是不是Bug，无论元素是否可见，都为<code>false</code>，但是<code>isTntersecting</code>的表现是正常的，所以判断是否可见，可以根据<code>intersectionRatio</code>或者<code>isTntersecting</code>来进行判断。</p>
<p>上面的矩形信息的关系如下：</p>
<img src="/shuliqi.github.io/2020/03/26/使用IntersectionObserver提高性能/5.jpg">
<h2 id="options参数"><a href="#options参数" class="headerlink" title="options参数"></a>options参数</h2><p><code>IntersectionObserver</code>构造函数的第二参数是一个配置对象， 他可以设置以下属性：</p>
<ol>
<li><p><strong>threshold属性</strong></p>
<p><code>threshold</code>属性 决定了什么时候触发回调函数，它是一个数组， 每一个成员也是一个门槛值，当目标元素和根元素相交的面积占目标元素面积的百分比到达或跨过某些指定的临界值时就会触发回调函数</p>
<p><code>threshold</code>的默认值是<code>:[0]</code>，即只有在开始进入，或者是完全离开视图区域时，才会触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, &#123;</span><br><span class="line">	threshold: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>],</span><br><span class="line">&#125;)</span><br><span class="line">io.observe($<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>用户可以自定义这个属性， [0, 0.5, 1]就表示 0%， 50%，75%， 100%交叉状态发生改变时， 就会触发回调函数。</p>
<p>   <strong>看看小🌰：  </strong></p>
<iframe height="423" style="width: 100%;" scrolling="no" title="dyYoJJJ" src="https://codepen.io/shuliqi/embed/dyYoJJJ?height=423&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/dyYoJJJ" target="_blank" rel="noopener">dyYoJJJ</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>
</li>
<li><p><strong>rootMargin</strong>属性</p>
<p>用来扩大或者缩小视窗的大小， 使用css的定义方式，    <code>10px 10px 10px 20px</code> 表示top，right,bottom, left的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    threshold: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>],</span><br><span class="line">    rootMargin: <span class="string">'30px 20px 30px 20px'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<img src="/shuliqi.github.io/2020/03/26/使用IntersectionObserver提高性能/6.jpg">
<p>图上的绿色部分是定义好的root元素， 我们添加了<code>rootMargin</code>属性， 将视窗增大了。</p>
<p>由此可见，root元素只有在<code>rootMargin</code>为空的时候才是绝对的视窗。</p>
<p> <strong>看看小🌰：</strong></p>
<iframe height="628" style="width: 100%;" scrolling="no" title="PoGWJVv" src="https://codepen.io/shuliqi/embed/PoGWJVv?height=628&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/PoGWJVv" target="_blank" rel="noopener">PoGWJVv</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>
</li>
<li><p><strong>root </strong>属性</p>
<p><code>root</code>属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。</p>
</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li><p><strong>懒加载（lazy load）</strong></p>
<p>我们希望某些静态资源（比如图片），只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。这就叫做”惰性加载”。</p>
<p>有了 IntersectionObserver API，实现起来就很容易了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> IntersectionObserver(callback);</span><br><span class="line">    <span class="keyword">let</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"[data-src]"</span>); <span class="comment">// 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">entries</span>) </span>&#123;</span><br><span class="line">      entries.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历entries数组</span></span><br><span class="line">        <span class="keyword">if</span> (item.isIntersecting) &#123;</span><br><span class="line">          <span class="comment">// // 当前元素可见</span></span><br><span class="line">          item.target.src = item.target.dataset.src; <span class="comment">// 替换src</span></span><br><span class="line">          io.unobserve(item.target); <span class="comment">// 停止观察当前元素 避免不可见时候再次调用callback函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// io.observe接受一个DOM元素，添加多个监听 使用forEach</span></span><br><span class="line">    imgs.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      io.observe(item);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，只有目标区域可见时，才会将模板内容插入真实 DOM，从而引发静态资源的加载。</p>
<p><strong>看看小🌰： <a href="https://codepen.io/shuliqi/pen/gOababR" target="_blank" rel="noopener">小小例子</a></strong></p>
<iframe height="570" style="width: 100%;" scrolling="no" title="gOababR" src="https://codepen.io/shuliqi/embed/gOababR?height=570&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/gOababR" target="_blank" rel="noopener">gOababR</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>
</li>
<li><p><strong>无限加载</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> loadData = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">      div.className = <span class="string">"unit"</span>;</span><br><span class="line">      div.innerText = <span class="string">`第 <span class="subst">$&#123;sum&#125;</span> 个数据`</span>;</span><br><span class="line">      fragment.appendChild(div);</span><br><span class="line">      sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span></span><br><span class="line">      .getElementById(<span class="string">"app"</span>)</span><br><span class="line">   .insertBefore(fragment, <span class="built_in">document</span>.getElementById(<span class="string">"loading"</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="keyword">function</span> (<span class="params">entries</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entries[<span class="number">0</span>].isIntersecting) &#123;</span><br><span class="line">      <span class="comment">// 如果loading元素不可见，就加载数据</span></span><br><span class="line">      loadData();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  io.observe(<span class="built_in">document</span>.getElementById(<span class="string">"loading"</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   无限滚动时，最好在页面底部有一个页尾栏（又称<a href="http://www.ruanyifeng.com/blog/2016/11/sentinels" target="_blank" rel="noopener">sentinels</a>）。一旦页尾栏可见，就表示用户到达了页面底部，从而加载新的条目放在页尾栏前面。这样做的好处是，不需要再一次调用<code>observe()</code>方法，现有的<code>IntersectionObserver</code>可以保持使用。</p>
<pre><code>**看看小🌰： [小小例子](https://codepen.io/shuliqi/pen/KKdwdNb)**
</code></pre>   <iframe height="608" style="width: 100%;" scrolling="no" title="KKdwdNb" src="https://codepen.io/shuliqi/embed/KKdwdNb?height=608&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>     See the Pen <a href="https://codepen.io/shuliqi/pen/KKdwdNb" target="_blank" rel="noopener">KKdwdNb</a> by shuliqi<br>     (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br>   </iframe>



<h2 id="疑问的点"><a href="#疑问的点" class="headerlink" title="疑问的点"></a>疑问的点</h2><ol>
<li><p><strong>一次性到达或跨过的多个临界值中选一个最近的</strong></p>
<p><strong>问题：</strong>如果一个观察者实例设置了 11 个临界值：[0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]，那么当目标元素和根元素从完全不相交状态滚动到相交率为 1 这一段时间里，回调函数会触发几次？</p>
<p><strong>答案：</strong> 不确定的。</p>
<p>如果滚动速度足够慢，每次相交率到达下一个临界值的时间点都发生在了不同的帧里（浏览器至少绘制了 11 次），那么就会有 11 次相交被检测到，回调函数就会被执行 11 次</p>
<p>如果滚动速度足够快，从不相交到完全相交是发生在同一个帧里的，浏览器只绘制了一次，浏览器虽然知道这一次滚动操作就满足了 11 个指定的临界值（从不相交到 0，从 0 到 0.1，从 0.1 到 0.2 ··· ），但它只会考虑最近的那个临界值，那就是 1，回调函数只触发一次.</p>
<p> <strong>看看小🌰： <a href="https://codepen.io/shuliqi/pen/zYvGaLL" target="_blank" rel="noopener">例子</a></strong></p>
<p></p><p class="codepen" data-height="568" data-theme-id="dark" data-default-tab="js,result" data-user="shuliqi" data-slug-hash="zYvGaLL" style="height: 568px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="zYvGaLL"><br>  <span>See the Pen <a href="https://codepen.io/shuliqi/pen/zYvGaLL" target="_blank" rel="noopener"><br>  zYvGaLL</a> by shuliqi (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
</li>
<li><p><strong>如何判断当前是否相交？</strong></p>
<p><strong>问题：</strong> 前面的几个例子， 都使用了isIntersecting 来判断目标元素是否在窗口里面，为什么？难道用entry.intersectionRatio &gt; 0 判断不可以吗？</p>
<p>如果你滚动页面速度很慢，当目标元素的顶部和视口底部刚好挨上时，浏览器检测到相交了，回调函数触发了，但这时 entry.intersectionRatio 等于 0，会进入 else 分支，继续向下滚，回调函数再不会触发了，提示文字一直停留在不可见状态；但如果你滚动速度很快，当浏览器检测到相交时，已经越过了 0 那个临界值，存在了实际的相交面积，entry.intersectionRatio &gt; 0 也就为 true 了。所以这样写会导致代码执行不稳定，不可行。</p>
<p><strong>看看小🌰： <a href="https://codepen.io/shuliqi/pen/gOapKZP" target="_blank" rel="noopener">例子</a></strong></p>
<iframe height="444" style="width: 100%;" scrolling="no" title="gOapKZP" src="https://codepen.io/shuliqi/embed/gOapKZP?height=444&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/gOapKZP" target="_blank" rel="noopener">gOapKZP</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>
</li>
<li><p><strong>贴边的情况是特例</strong></p>
<p>当目标元素从距离根元素很远到和根元素贴边，这时也会触发回调（假如 thresholds 里有 0），但这和工作原理相矛盾啊，离的很远相交率是 0，就算贴边，相交率还是 0，值并没有变，不应该触发回调啊。的确，这和基本工作原理矛盾，但这种情况是特例，目标元素从根元素外部很远的地方移动到和根元素贴边，也会当做是满足了临界值 0，即便 0 等于 0。</p>
<p>还有一个反过来的特例，就是目标元素从根元素内部的某个地方（相交率已经是 1）移动到和根元素贴边（还是 1），也会触发回调（假如 thresholds 里有 1）</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在当前判断可视性的方法，基本就是监听<code>scroll</code>事件，但是由于其高频的计算频率，会导致浏览器性能的损失，尤其是，如果一个同一个页面中，有多个地方，需要这样的判断，那么就需要绑定多个<code>scroll</code>事件，或者有多个计时器在轮询的话，那么对性能的损失就更为客观了。</p>
<p>虽然现在的浏览器性能一直在增强，但是也有更多的消耗性能的比较炫的技术在产生，它们依然在占据着浏览器的大量的计算内存，所以，尽量在可以节省性能的时候，就节省一下性能吧。</p>
<p>而该方法给我们提供了一个更简单直接，性能更好的解决方案，希望以后的浏览器，可以越来越广泛的支持吧。</p>
<p>最后， 毕竟是一个新兴的<code>API</code>，所以浏览器的支持性并不好，这里可以看看当前浏览器对于<code>IntersectionObserver</code>的支持性：</p>
<img src="/shuliqi.github.io/2020/03/26/使用IntersectionObserver提高性能/caniuse.png">
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章的ppt也有哦， <a href="https://shuliqi.github.io/ppt/IntersectionObserver/%E5%85%B3%E4%BA%8EIntersectionObserver.html">请点击这里</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Delete`CR`eslint(prettier/prettier) 报错的解决方案</title>
    <url>/shuliqi.github.io/2020/06/06/%E5%85%B3%E4%BA%8EDelete%60CR%60eslint-prettier-prettier-%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>由于之前是一直使用 <code>mac</code> 笔记本开发，突然使用 <code>windows</code> 开发，发现拉完代码之后， 发现在<code>npm run dev</code> 运行代码之后。发现有如下的问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Delete <span class="string">`CR`</span>eslint(prettier/prettier)</span><br></pre></td></tr></table></figure>
 <a id="more"></a>
<img src="/shuliqi.github.io/2020/06/06/关于Delete%60CR%60eslint-prettier-prettier-报错的解决方案/1.png">
<h2 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h2><p>出现的问题的原因到底是什么呢？</p>
<p>根据调查发现出问题 : <strong>windows下和linux下的文本文件的换行符不一致。</strong></p>
<ul>
<li><code>Windows</code>在换行的时候，同时使用了回车符<code>CR(carriage-return character)和换行符LF(linefeed character)</code></li>
<li>而<code>Mac</code>和<code>Linux</code>系统，仅仅使用了换行符<code>LF</code></li>
<li>老版本的<code>Mac</code>系统使用的是回车符<code>CR</code></li>
</ul>
<p>表格解释如下：</p>
<table>
<thead>
<tr>
<th><strong>Windows</strong></th>
<th><strong>Linux/Mac</strong></th>
<th><strong>Old Mac(pre-OSX)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CRLF</td>
<td>LF</td>
<td>CR</td>
</tr>
<tr>
<td>‘\n\r’</td>
<td>‘\n’</td>
<td>‘\r’</td>
</tr>
</tbody>
</table>
<p>因此，文本文件在不同系统下创建和使用时就会出现不兼容的问题。</p>
<p>所以出现上面的报错是因为我的同事是在mac环境下提交的代码。文件默认是以LF结尾的。</p>
<p>当我使用 <code>Windows</code> 电脑<code>git clone</code>代码的时候， 若我的<code>autocrlf</code>(在<code>windows</code>下安装<code>git</code>，该选项默认为<code>true</code>)为true，那么文件每行会被自动转成以CRLF结尾，若对文件不做任何修改，pre-commit执行eslint的时候就会提示你删除CR。</p>
<h2 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h2><p>下面是上网查到的各种解决办法以及他们的优缺点。</p>
<h3 id="Crtl-S保存文件"><a href="#Crtl-S保存文件" class="headerlink" title="Crtl+S保存文件"></a>Crtl+S保存文件</h3><p>按Crtl+S保存当前报错文件，eslint错误消失，但是Git暂存区多了个文件改动记录，对比Working tree没发现任何不同。</p>
<p>缺点：你不可能一一保存所有文件，麻烦，还要commit，多余。</p>
<h3 id="yarn-run-lint-–fix"><a href="#yarn-run-lint-–fix" class="headerlink" title="yarn run lint –fix"></a>yarn run lint –fix</h3><p>比上面省事，eslint错误消失，但暂存区多了n个文件改动记录，对比Working tree也没发现任何不同。</p>
<p>缺点：需要commit所有文件，多余。</p>
<p><a href="https://github.com/prettier/eslint-plugin-prettier/issues/114" target="_blank" rel="noopener">参考的资料：”error Delete <code>⏎</code> prettier/prettier” in .vue files</a></p>
<h3 id="配置-prettierrc-文件"><a href="#配置-prettierrc-文件" class="headerlink" title="配置.prettierrc 文件"></a>配置.prettierrc 文件</h3><p>在项目的根目录的<code>.prettierrc</code>文件中写入即可。其实就是不让prettier检测文件每行结束的格式.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"endOfLine"</span>: <span class="string">"auto"</span></span><br></pre></td></tr></table></figure>
<p>缺点：不能兼容跨平台开发，从前端工程化上讲没有做到尽善尽美。</p>
<p><a href="https://stackoverflow.com/questions/53516594/why-do-i-keep-getting-delete-cr-prettier-prettier" target="_blank" rel="noopener">参考的资料：Why do I keep getting Delete ‘cr’ [prettier/prettier]?</a></p>
<h3 id="core-autocrlf配置"><a href="#core-autocrlf配置" class="headerlink" title="core.autocrlf配置"></a>core.autocrlf配置</h3><p>使用git 的一个配置属性： core.autocrlf </p>
<ul>
<li><p>Git 可以在你提交的时候自动的把行结束符CRLF转换成LF，而在签出代码时把LF转换成CRLF。用<code>core.autocrlf</code>来打开此项功能。如果是在Windows 系统上，把它设置为true。这样当签出代码时。LF会被转换成CRLF。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ git config --global core.autocrlf <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mac 系统使用LF作为行结束符， 因此你不想Git在签出文件时进行自动的转换；当一个CRLF为行结束符的文件不小心被引入时你想修正，把core.autocrlf 设置为input 来告诉Git 在提交的时候把CRLF 转成LF。签出时不转换；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ git config --global core.autocrlf input</span><br></pre></td></tr></table></figure>
<p>这样会在Windows系统上的签出文件中保留CRLF，会在Mac和Linux系统上，包括仓库中保留LF。</p>
</li>
<li><p>如果你是Windows程序员，且正在开发仅运行在Windows上的项目，可以设置false取消此功能，把回车符记录在库中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到问题的时候查找了很多的资料。但是结局的办法都不是很尽美 如方法1，方法 2，方法 3，都存在一定的缺点。 最后一个解决办法才是从灵魂上解决了问题。 所以在解决的问题还是追其根源。从根本上解决问题。</p>
]]></content>
      <tags>
        <tag>工作中遇到的问题</tag>
      </tags>
  </entry>
  <entry>
    <title>关于this的指向问题</title>
    <url>/shuliqi.github.io/2018/07/02/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>this关键字是<code>JavaScript</code>中最复杂的机制之一，是一个特别的关键字，被自动定义在所有函数的作用域中，但是相信很多<code>JavaScript</code>开发者并不是非常清楚它究竟指向的是什么。听说你很懂this,是真的吗？</p>
 <a id="more"></a>
<h2 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h2><p><strong>函数的<code>this</code>指向在函数定义的时候是不能确定的。只有在函数执行的时候才能确定函数的<code>this</code>指向谁</strong></p>
<p>总结普通函数的绑定规则主要分为以下这几种：</p>
<h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>默认绑定是在不能应用其他绑定规则的时候使用的默认规则， 通常是独立函数调用。</p>
<p>例子1:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'shuliqi'</span>;</span><br><span class="line">getName(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>在调用<code>getName</code>的时候，使用了默认绑定，<code>this</code>指向了全局对象。严格模式下，<code>this</code>指向<code>undefined</code>，<code></code>undefined`上没有this对象，会抛出错误。</p>
<p>这里例子是<code>window</code>调用了独立的函数，<code>this</code>就是指向<code>window</code>（非严格模式就是<code>windom</code>）</p>
<p>这里的例子可以这么看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'shuliqi'</span>;</span><br><span class="line"><span class="built_in">window</span>.getName(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>函数的调用时在某个对象上触发的。即调用位置上存在上下文对象。典型的形式为<code>XXX.fun()</code>。</p>
<p>例子2:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">'shuliqi2222'</span>,</span><br><span class="line">    getName: getName,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'shuliqi11111'</span>;</span><br><span class="line">person.getName(); <span class="comment">// shuliqi2222</span></span><br></pre></td></tr></table></figure>
<p>是对象<code>person</code>调用函数<code>logName</code>， 所以<code>this</code>指向<code>person</code>。</p>
<p><code>getName</code>函数在外部声明， 严格来说并不属于<code>person</code>，但是在调用<code>getName</code>时,调用位置会使用<code>person</code>的上下文来引用函数，隐式绑定会把函数调用中的<code>this</code>(即此例<code>getName</code>函数中的this)绑定到这个上下文对象（即此例中的<code>person</code>）.</p>
<p>注意：<strong>对象属性链中只有最后一层会影响到调用位置</strong></p>
<p>例子3:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name:<span class="string">'shuliqi11111'</span>,</span><br><span class="line">    getName: getName,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name:<span class="string">'shuliqi2222'</span>,</span><br><span class="line">    person: person1,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'shuliqi'</span>;</span><br><span class="line">person2.person.getName(); <span class="comment">// shuliqi11111</span></span><br></pre></td></tr></table></figure>
<p>因为只有最后一层会确定<code>this</code>指向的是什么，不管有多少层，在判断this的时候，我们只关注最后一层，即此处的<code>person</code>。</p>
<p><strong>隐式绑定</strong>有一个很大的缺陷，就是很容易丢失（即容易给我们造成误导，我们以为<code>this</code>指向的是什么，但是实际上并非如此）</p>
<p>例子4:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name:<span class="string">'shuliqi11111'</span>,</span><br><span class="line">    getName: getName,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name:<span class="string">'shuliqi2222'</span>,</span><br><span class="line">    person: person1,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'shuliqi'</span>;</span><br><span class="line"><span class="keyword">var</span> logName = person2.person.getName;</span><br><span class="line">logName(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>为什么结果是 <code>shuliqi</code>？</p>
<p>这是因为l<code>ogName</code> 直接指向了<code>getName</code>的引用， 跟<code>person</code>没关系。针对此类问题，我建议大家只需牢牢继续这个格式:<code>XXX.fn();fn()</code>前如果什么都没有，那么肯定不是隐式绑定。</p>
<p>除了上面这种丢失之外，隐式绑定的丢失是发生在回调函数中(事件回调也是其中一种)，我们来看下面一个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">'YvetteLau'</span>,</span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Hello,'</span>,<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">'Christina'</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">'Wiliam'</span>;</span><br><span class="line">person1.sayHi();</span><br><span class="line">setTimeout(person2.sayHi,<span class="number">100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    person2.sayHi();</span><br><span class="line">&#125;,<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, Wiliam</span><br><span class="line">Hello, Wiliam</span><br><span class="line">Hello, Christina</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一条输出很容易理解，<code>setTimeout</code>的回调函数中，<code>this</code>使用的是默认绑定，非严格模式下，执行的是全局对象</p>
</li>
<li><p>第二条输出是不是有点迷惑了？说好<code>XXX.fun()</code>的时候，<code>fun</code>中的<code>this</code>指向的是<code>XXX</code>呢，为什么这次却不是这样了！<code>Why</code>?</p>
<p>其实这里我们可以这样理解: <code>setTimeout(fn,delay){ fn(); }</code>,相当于是将<code>person2.sayHi</code>赋值给了一个变量，最后执行了变量，这个时候，<code>sayHi</code>中的<code>this</code>显然和<code>person2</code>就没有关系了。</p>
</li>
<li><p>第三条虽然也是在<code>setTimeout</code>的回调中，但是我们可以看出，这是执行的是<code>person2.sayHi()</code>使用的是隐式绑定，因此这是<code>this</code>指向的是<code>person2</code>，跟当前的作用域没有任何关系。</p>
</li>
</ul>
<h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><p>显示绑定就是通过<code>apply</code>，<code>call</code>，<code>bind</code>的方法， 显示的指定<code>this</code>所指的对象。</p>
<p><code>apply</code>，<code>call</code>，<code>bind</code>的第一个参数都是该函数this所指的对象。 <code>call</code>，<code>apply</code> 是一样的， 都会立即执行，只是传参方式不同。<code>call</code>和<code>apply</code>都会执行对应的函数，而<code>bind</code>方法不会。<code>apply</code>的第二个参数是一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'YvetteLau'</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Wiliam'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = person.sayHi;</span><br><span class="line">Hi.call(person); <span class="comment">//Hi.apply(person)</span></span><br></pre></td></tr></table></figure>
<p>结果：<code>Hello, YvetteLau</code>。因为明确将<code>this</code>绑定在了<code>person</code>上</p>
<p>那么，使用了硬绑定，是不是意味着不会出现隐式绑定所遇到的绑定丢失呢？显然不是这样的，不信，继续往下看。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'YvetteLau'</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Wiliam'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure>
<p>输出的结果是 H<code>ello, Wiliam.</code> 原因很简单，<code>Hi.call(person, person.sayHi)</code>的确是将<code>this</code>绑定到Hi中的<code>this</code>了。但是在执行<code>fn</code>的时候，相当于直接调用了<code>sayHi</code>方法(记住<code>: person.sayH</code>i已经被赋值给<code>fn</code>了，隐式绑定也丢了)，没有指定<code>this</code>的值，对应的是默认绑定。</p>
<p>如果我们现在希望绑定不要丢失， 我们该怎么做？ 很简单， 在调用<code>fn</code>的时候也是用显示绑定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'YvetteLau'</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Wiliam'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure>
<p>此时，输出的结果为<code>: Hello, YvetteLau</code>，因为<code>person</code>被绑定到<code>H</code>i函数中的<code>this</code>上，fn又将这个对象绑定给了<code>sayHi</code>的函数。这时，<code>sayHi</code>中的<code>this</code>指向的就是<code>person</code>对象。</p>
<p>如果我们将<code>null</code>或者是<code>undefined</code>作为<code>this</code>的绑定对象传入<code>call</code>、<code>apply</code>或者是<code>bind</code>,这些值在调用时会被忽略，实际应用的是默认绑定规则。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">'shuliqi11111'</span>,</span><br><span class="line">    getName: getName,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'shuliqi'</span></span><br><span class="line">hi.call(<span class="literal">null</span>, person.getName);  <span class="comment">//  shuliqi</span></span><br></pre></td></tr></table></figure>
<h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><p><code>new</code>的原理：</p>
<ul>
<li>创建一个空对象</li>
<li>将空对象的原型指向构造函数的原型属性，从而继承构造原型上的方法（<code>newObj.__proto__ === Fn.prototype</code>）</li>
<li>将构造函数的<code>this</code>指向新建的对象，并且执行构造函数的代码，从而获得构造函数的私有属性</li>
<li>最后看构造函数是否是返回一个对象，如果是直接返回该对象，如果不是， 则返回我们新建对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"shuliqi"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFn = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(newFn.name); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>这里<code>newFn</code>对象子所以可以点<code>name</code>出来，是因为<code>new</code>关键字可以改变<code>this</code>指向。</p>
<p><strong>实现new:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyNew</span>(<span class="params">Fn, ...args</span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建一个空对象</span></span><br><span class="line">  <span class="comment">// 2. 将空对象的原型指向构造函数的原型属性，从继承构造函数原型的方法（obj.__proto__ === Fn.prototype）</span></span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Fn.prototype);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 将构造函数的thia，指向新建的对象，并且执行构造函数，从而获得私有属性</span></span><br><span class="line">  <span class="keyword">const</span> result = Fn.apply(obj, args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.如果构造函数返回的是对象， 我们就返回此对象，不然返回新建的对象</span></span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span>  ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> MyPeople  = MyNew(People, <span class="string">'shuliqi'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(MyPeople); <span class="comment">// People &#123; name: 'shuliqi' &#125;</span></span><br><span class="line">MyPeople.getName(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<h3 id="普通函数的绑定优先级"><a href="#普通函数的绑定优先级" class="headerlink" title="普通函数的绑定优先级"></a>普通函数的绑定优先级</h3><p>我们知道了this有四种绑定规则，但是如果同时应用了多种规则，怎么办？</p>
<p>显然，我们需要了解哪一种绑定方式的优先级更高，这四种绑定的优先级为:</p>
<p><code>new</code>绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><strong>箭头函数<code>this</code>的定义： 箭头函数的<code>this</code>在定义的时候绑定。而不是在执行的时候绑定。它的<code>this</code>指向在定义的时候继承自外层第一个普通函数的<code>this</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">'shuliqi11111'</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">var</span> logName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">        logName();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">person.getName(); <span class="comment">// shuliqi11111</span></span><br></pre></td></tr></table></figure>
<p>内层箭头函数<code>logName</code>本身并没有<code>this</code>对象。它的<code>this</code>对象来自于外层作用域。<code>logName</code>函数的外层函数<code>getName</code>是一个普通的函数。 它是有<code>this</code>值的指向<code>person</code>对象。所以<code>logName</code>函数的<code>this</code>指向<code>person</code>对象。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>git提交规范及如何配置</title>
    <url>/shuliqi.github.io/2021/01/15/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p><code>Git</code> 是现在比较流行的版本控制工具，在开发的过程中，<code>Git</code>每次提交代码，都需要写<code>Commit message</code>（即提交说明）。如果没有对 <code>Commit message</code>进行规范，会造成很多的麻烦，比如：</p>
<ul>
<li>每个人的 <code>Commit message</code>风格不同，格式凌乱，查看就换个不方便</li>
<li>有一些commit  没有写 <code>message</code>，事后就很难知道对应修改的作用。</li>
</ul>
<p> 所以说规范的 Commit <code>message</code>是很有必要的。也是有很多的好处的，比如：</p>
<ul>
<li>可以统一团队的<code>Git commit</code>日志风格</li>
<li>方便日后查阅， <code>Reviewing Code</code>等</li>
<li>可以帮助我们写好 <code>Changelog</code></li>
<li><p>能提升项目的整体质量</p>
<a id="more"></a>
</li>
</ul>
<p>我们要配置<code>git</code>提交规范的话， 肯定需要知道它的规范是什么？先来看<code>Git Commit</code> 规范 是什么？</p>
<h1 id="Git-Commit-规范"><a href="#Git-Commit-规范" class="headerlink" title="Git Commit  规范"></a>Git Commit  规范</h1><p>目前规范使用较多的是 <a href="https://www.barretlee.com/blog/2019/10/28/commit-convention/" target="_blank" rel="noopener">Angular 团队得规范</a> 我们也叫这种规范做: <strong>Git 约定式提交规范</strong>。</p>
<p>这种规范提供了一中轻量级的的提交历史编写规则，它的内容十分的简单:</p>
<p>它包含了三个部分：<code>Heade</code>r，<code>Body</code>，<code>Footer</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意冒号 : 后有空格</span></span><br><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">//  空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<p>其中，<code>Header</code> 是必需的，<code>Body</code> 和<code>Footer</code> 可以省略。</p>
<blockquote>
<p><strong>注意：</strong> 不管是哪一个部分，任何一行都不得操作72个字符（或者100个字符）。 当然， 这只是避免自动换行影响美观而已。</p>
</blockquote>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p><code>Header</code> 部分 只有一行，包括三个字段：<strong><code>type(必填</code>)</strong>，<strong><code>scope(可选)</code></strong>，<strong><code>subject(必填)</code></strong></p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段用于说明<code>commit</code> 的类别，它允许使用下面的标识</p>
<ul>
<li><p><code>feat</code>：新功能（<code>feature</code>）</p>
</li>
<li><p><code>fix</code>： 修改<code>bug</code></p>
</li>
<li><p><code>docs</code>：文档（<code>documentation</code>）</p>
</li>
<li><p><code>style</code>：格式（不影响代码运行的变动）</p>
</li>
<li><p><code>refactor</code>：重构（即不是新增功能，也不是修改<code>bug</code>的代码变动）</p>
</li>
<li><p><code>test</code>：增加测试</p>
</li>
<li><p><code>chore</code>：构建过程或者辅助工具的变动</p>
</li>
</ul>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p><code>scope</code>用于说明  <code>commit</code>的影响范围，比如： 数据层，控制层，视图层等等。因具体项目而定。</p>
<h3 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h3><p><code>subject</code>用于说明 <code>commit</code> 目的的简短描述，最好不要操作50 个字符。我们在写<code>ubject</code>的时候需要注意：</p>
<ul>
<li>以动词开头，使用第一人称现在时，比如：<code>change</code>，而不是<code>changed</code> 或者 <code>changes</code></li>
<li>第一个字母小写</li>
<li>结尾不加句号</li>
</ul>
<h2 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h2><p><code>Body</code> 部分是对本次 <code>commit</code> 的详细描述，可以分成多行。写Body 部分的时候也需要注意：</p>
<ul>
<li>使用第一人称现在时候， 比如使用 <code>change</code> 而不是 <code>changed</code> 或 <code>changes</code></li>
<li>应该说明代码变动的动机，以及与以前行为的对比</li>
</ul>
<h2 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h2><p>Footer 部分只用于这两种情况：</p>
<h3 id="不兼容变动"><a href="#不兼容变动" class="headerlink" title="不兼容变动"></a>不兼容变动</h3><p>如果当前的代码与上一版本不兼容，则<code>Footer</code> 部分以<code>BREAKING CHANGE</code> 开头， 后面是对变动的描述，以及变动的理由和迁移的办法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: <span class="string">'attribute'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    After:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: <span class="string">'@'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed <span class="string">`inject`</span> wasn<span class="string">'t generaly useful for directives so there should be no code using it.</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭Issue"><a href="#关闭Issue" class="headerlink" title="关闭Issue"></a>关闭Issue</h3><p>如果当前的<code>commit</code> 是针对某个<code>issue</code>。那么在<code>footer</code>部分关闭这个<code>iissue</code>。可以一次性关系多个<code>issue</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">closes #123, #245, #992</span><br></pre></td></tr></table></figure>
<h2 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h2><p> 有一种特殊情况， 如果当前的<code>commit</code> 是用于撤销 以前的<code></code>commit <code>的，则必须以</code>Revert <code>开头。 后面紧跟着被撤销的</code>Commit<code>的</code>Header`。</p>
<p><code>Body</code>部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销<code>commit</code>的 <code>SHA</code> 标识符。</p>
<p>如果当前<code>commit</code> 与被撤销的<code>commit</code>，在同一个发布（<code>release</code>）里面，那么它们都不会出现在 <code>Change log</code> 里面。如果两者在不同的发布，那么当前 <code>commit</code>，会出现在 <code>Change log</code> 的<code>Reverts</code>小标题下面。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我们新建一个文件夹:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mkdir  gitCommit</span><br></pre></td></tr></table></figure>
<p>然后进入到这个文件夹:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd gitCommit</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>新建一个文件: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">touch index.js</span><br></pre></td></tr></table></figure>
<p>执行:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure>
<p>这时候我们开始写提交的<code>commit message</code>，命令行输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p>这时候会跳出编辑器让我们编写<code>message</code>， 我们则可以写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">feat:(*): 添加index.js文件</span><br><span class="line"></span><br><span class="line">在根目录添加了indexjs文件</span><br></pre></td></tr></table></figure>
<p>这<code>commit message</code>的 <code>Header</code> 为<code>feat:(*): 添加index.js文件</code>），表示：我们加了一个新功能（<code>type = feat</code>），它的影响范围是<em>（<code>scope =</code></em>）, 它的简短描述(<code>subject</code>)是：添加<code>index.js</code>文件</p>
<p>这<code>commit message</code> 的<code>Body</code> 为： <code>在根目录添加了indexjs文件</code>。表示这次的<code>commit</code> 的简单描述是： <code>在根目录添加了indexjs文件</code></p>
<p>如果我们要撤销上面的 <code>commit</code> 。 我们这可以 使用 <code>git revert &lt;commitId&gt;</code></p>
<p>我们可以下先使用 <code>git log</code>, 找出要 revert 的 commitId 0（f6c37576c793b2e2f4e66a87f96c2e825e073d35）</p>
<p>然后执行：<code>git revert f6c37576c793b2e2f4e66a87f96c2e825e073d35</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Revert <span class="string">"feat:(*): 添加index.js文件"</span></span><br><span class="line"></span><br><span class="line">This reverts commit f6c37576c793b2e2f4e66a87f96c2e825e073d35.</span><br></pre></td></tr></table></figure>
<p>这是的提交规范是这样的，已经默认帮我们写好了。当然我们也是可以修改的。</p>
<h1 id="配置-git-提交规范"><a href="#配置-git-提交规范" class="headerlink" title="配置 git 提交规范"></a>配置 git 提交规范</h1><p>当然，在我们的日常开发当中， 需要记住上面的规范， 有点繁琐。我们的目标还是要通过工具生成和约束。 那么我们现在就来配置吧！</p>
<h2 id="Commitizen"><a href="#Commitizen" class="headerlink" title="Commitizen"></a>Commitizen</h2><p>那么有什么 工具可以 做到生成规范并且约束呢？ <a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">Commitizen</a>就是一个很不错的， 很合格的工具，</p>
<p><code>Commitizen/cz-cli</code>: 是一个格式化 <code>commit message</code> 的工具，可以约束提交者按照制定的规范一步一步的填写 <code>commit message</code>。</p>
<p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install commitizen --save</span><br></pre></td></tr></table></figure>
<p>然后在项目的根目录里， 执行以下的命令，使其支持<code>Angular</code> 的 <code>commit message</code> 格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>
<p><strong>配置</strong></p>
<p>我们打开<code>packge.json</code>。 可以看到配置为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;config&quot;: &#123;</span><br><span class="line">  &quot;commitizen&quot;: &#123;</span><br><span class="line">    &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，只要是用到 <code>git commit</code>命令，一律改为使用 <code>git cz</code>， 然后就会出现选项， 用来生成符合格式的 <code>commit message</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git cz</span><br><span class="line"></span><br><span class="line">cz-cli@<span class="number">4.2</span><span class="number">.3</span>, cz-conventional-changelog@<span class="number">3.3</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">? Select the type <span class="keyword">of</span> change that you<span class="string">'re committing: (Use arrow keys)</span></span><br><span class="line"><span class="string">❯ feat:     A new feature </span></span><br><span class="line"><span class="string">  fix:      A bug fix </span></span><br><span class="line"><span class="string">  docs:     Documentation only changes </span></span><br><span class="line"><span class="string">  style:    Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) </span></span><br><span class="line"><span class="string">  refactor: A code change that neither fixes a bug nor adds a feature </span></span><br><span class="line"><span class="string">  perf:     A code change that improves performance </span></span><br><span class="line"><span class="string">  test:     Adding missing tests or correcting existing tests</span></span><br></pre></td></tr></table></figure>
<h2 id="cz-customizable"><a href="#cz-customizable" class="headerlink" title="cz-customizable"></a>cz-customizable</h2><p>上面是直接使用 <code>cz-conventional-changelog</code> 作为 Adapter。但是如果需要自定义<code>Adapter</code>， 比如：默认提交的<code>types</code>非常多；或者有些使用我们可能只需要其中的某些<code>type</code>。或者自定义一些<code>type</code>，那么就可以通过 <code>cz-customizable</code> 来自定义了。</p>
<p><strong>安装</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i cz-customizable --save</span><br></pre></td></tr></table></figure>
<p>将之前符合<code>Angular</code>规范的<strong><code>cz-conventional-changelog</code></strong>适配器路径改成<strong><code>cz-customizable</code></strong>适配器路径：  <strong>“<code>path</code>“: “<code>./node_modules/cz-conventional-changelog</code>“ </strong>改成  <strong>“<code>path</code>“: “<code>./node_modules/cz-customizable</code>“</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"config"</span>: &#123;</span><br><span class="line">   <span class="string">"commitizen"</span>: &#123;</span><br><span class="line">     <span class="string">"path"</span>: <span class="string">"./node_modules/cz-customizable"</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<p><strong>配置</strong></p>
<p>在跟目录下新建.<code>cz-config.js</code>。 内容的示例文件如：<a href="https://github.com/leonardoanalista/cz-customizable/blob/master/cz-config-EXAMPLE.js" target="_blank" rel="noopener">cz-config-EXAMPLE.js</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">  types: [</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">'feat'</span>,     <span class="attr">name</span>: <span class="string">'feat:     A new feature'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">'fix'</span>,      <span class="attr">name</span>: <span class="string">'fix:      A bug fix'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">'docs'</span>,     <span class="attr">name</span>: <span class="string">'docs:     Documentation only changes'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">'style'</span>,    <span class="attr">name</span>: <span class="string">'style:    Changes that do not affect the meaning of the code\n            (white-space, formatting, missing semi-colons, etc)'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">'refactor'</span>, <span class="attr">name</span>: <span class="string">'refactor: A code change that neither fixes a bug nor adds a feature'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">'perf'</span>,     <span class="attr">name</span>: <span class="string">'perf:     A code change that improves performance'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">'test'</span>,     <span class="attr">name</span>: <span class="string">'test:     Adding missing tests'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">'chore'</span>,    <span class="attr">name</span>: <span class="string">'chore:    Changes to the build process or auxiliary tools\n            and libraries such as documentation generation'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">'revert'</span>,   <span class="attr">name</span>: <span class="string">'revert:   Revert to a commit'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">'WIP'</span>,      <span class="attr">name</span>: <span class="string">'WIP:      Work in progress'</span>&#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  scopes: [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'accounts'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'admin'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'exampleScope'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'changeMe'</span>&#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// it needs to match the value for field type. Eg.: 'fix'</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  scopeOverrides: &#123;</span></span><br><span class="line"><span class="comment">    fix: [</span></span><br><span class="line"><span class="comment">      &#123;name: 'merge'&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: 'style'&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: 'e2eTest'&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: 'unitTest'&#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// override the messages, defaults are as follows</span></span><br><span class="line">  messages: &#123;</span><br><span class="line">    type: <span class="string">'Select the type of change that you\'re committing:'</span>,</span><br><span class="line">    scope: <span class="string">'\nDenote the SCOPE of this change (optional):'</span>,</span><br><span class="line">    <span class="comment">// used if allowCustomScopes is true</span></span><br><span class="line">    customScope: <span class="string">'Denote the SCOPE of this change:'</span>,</span><br><span class="line">    subject: <span class="string">'Write a SHORT, IMPERATIVE tense description of the change:\n'</span>,</span><br><span class="line">    body: <span class="string">'Provide a LONGER description of the change (optional). Use "|" to break new line:\n'</span>,</span><br><span class="line">    breaking: <span class="string">'List any BREAKING CHANGES (optional):\n'</span>,</span><br><span class="line">    footer: <span class="string">'List any ISSUES CLOSED by this change (optional). E.g.: #31, #34:\n'</span>,</span><br><span class="line">    confirmCommit: <span class="string">'Are you sure you want to proceed with the commit above?'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  allowCustomScopes: <span class="literal">true</span>,</span><br><span class="line">  allowBreakingChanges: [<span class="string">'feat'</span>, <span class="string">'fix'</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// limit subject length</span></span><br><span class="line">  subjectLimit: <span class="number">100</span></span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以对这个配置进行汉化处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// type 类型</span></span><br><span class="line">  types: [</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">'feat'</span>, <span class="attr">name</span>: <span class="string">'feat:     新增产品功能'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">'fix'</span>, <span class="attr">name</span>: <span class="string">'fix:      修复 bug'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">'docs'</span>, <span class="attr">name</span>: <span class="string">'docs:     文档的变更'</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      value: <span class="string">'style'</span>,</span><br><span class="line">      name:</span><br><span class="line">        <span class="string">'style:    不改变代码功能的变动(如删除空格、格式化、去掉末尾分号等)'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      value: <span class="string">'refactor'</span>,</span><br><span class="line">      name: <span class="string">'refactor: 重构代码。不包括 bug 修复、功能新增'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      value: <span class="string">'perf'</span>,</span><br><span class="line">      name: <span class="string">'perf:     性能优化'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">'test'</span>, <span class="attr">name</span>: <span class="string">'test:     添加、修改测试用例'</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      value: <span class="string">'build'</span>,</span><br><span class="line">      name: <span class="string">'build:    构建流程、外部依赖变更，比如升级 npm 包、修改 webpack 配置'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">'ci'</span>, <span class="attr">name</span>: <span class="string">'ci:       修改了 CI 配置、脚本'</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      value: <span class="string">'chore'</span>,</span><br><span class="line">      name: <span class="string">'chore:    对构建过程或辅助工具和库的更改,不影响源文件、测试用例的其他操作'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">'revert'</span>, <span class="attr">name</span>: <span class="string">'revert:   回滚 commit'</span> &#125;,</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scope 类型，针对 React 项目</span></span><br><span class="line">  scopes: [</span><br><span class="line">    [<span class="string">'components'</span>, <span class="string">'组件相关'</span>],</span><br><span class="line">    [<span class="string">'hooks'</span>, <span class="string">'hook 相关'</span>],</span><br><span class="line">    [<span class="string">'hoc'</span>, <span class="string">'HOC'</span>],</span><br><span class="line">    [<span class="string">'utils'</span>, <span class="string">'utils 相关'</span>],</span><br><span class="line">    [<span class="string">'antd'</span>, <span class="string">'对 antd 主题的调整'</span>],</span><br><span class="line">    [<span class="string">'element-ui'</span>, <span class="string">'对 element-ui 主题的调整'</span>],</span><br><span class="line">    [<span class="string">'styles'</span>, <span class="string">'样式相关'</span>],</span><br><span class="line">    [<span class="string">'deps'</span>, <span class="string">'项目依赖'</span>],</span><br><span class="line">    [<span class="string">'auth'</span>, <span class="string">'对 auth 修改'</span>],</span><br><span class="line">    [<span class="string">'other'</span>, <span class="string">'其他修改'</span>],</span><br><span class="line">    <span class="comment">// 如果选择 custom ,后面会让你再输入一个自定义的 scope , 也可以不设置此项， 把后面的 allowCustomScopes 设置为 true</span></span><br><span class="line">    [<span class="string">'custom'</span>, <span class="string">'以上都不是？我要自定义'</span>],</span><br><span class="line">  ].map(<span class="function">(<span class="params">[value, description]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value,</span><br><span class="line">      name: <span class="string">`<span class="subst">$&#123;value.padEnd(<span class="number">30</span>)&#125;</span> (<span class="subst">$&#123;description&#125;</span>)`</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allowTicketNumber: false,</span></span><br><span class="line">  <span class="comment">// isTicketNumberRequired: false,</span></span><br><span class="line">  <span class="comment">// ticketNumberPrefix: 'TICKET-',</span></span><br><span class="line">  <span class="comment">// ticketNumberRegExp: '\\d&#123;1,5&#125;',</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以设置 scope 的类型跟 type 的类型匹配项，例如: 'fix'</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    scopeOverrides: &#123;</span></span><br><span class="line"><span class="comment">      fix: [</span></span><br><span class="line"><span class="comment">        &#123; name: 'merge' &#125;,</span></span><br><span class="line"><span class="comment">        &#123; name: 'style' &#125;,</span></span><br><span class="line"><span class="comment">        &#123; name: 'e2eTest' &#125;,</span></span><br><span class="line"><span class="comment">        &#123; name: 'unitTest' &#125;</span></span><br><span class="line"><span class="comment">      ]</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 覆写提示的信息</span></span><br><span class="line">  messages: &#123;</span><br><span class="line">    type: <span class="string">"请确保你的提交遵循了原子提交规范！\n选择你要提交的类型:"</span>,</span><br><span class="line">    scope: <span class="string">'\n选择一个 scope (可选):'</span>,</span><br><span class="line">    <span class="comment">// 选择 scope: custom 时会出下面的提示</span></span><br><span class="line">    customScope: <span class="string">'请输入自定义的 scope:'</span>,</span><br><span class="line">    subject: <span class="string">'填写一个简短精炼的描述语句:\n'</span>,</span><br><span class="line">    body: <span class="string">'添加一个更加详细的描述，可以附上新增功能的描述或 bug 链接、截图链接 (可选)。使用 "|" 换行:\n'</span>,</span><br><span class="line">    breaking: <span class="string">'列举非兼容性重大的变更 (可选):\n'</span>,</span><br><span class="line">    footer: <span class="string">'列举出所有变更的 ISSUES CLOSED  (可选)。 例如.: #31, #34:\n'</span>,</span><br><span class="line">    confirmCommit: <span class="string">'确认提交?'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否允许自定义填写 scope ，设置为 true ，会自动添加两个 scope 类型 [&#123; name: 'empty', value: false &#125;,&#123; name: 'custom', value: 'custom' &#125;]</span></span><br><span class="line">  <span class="comment">// allowCustomScopes: true,</span></span><br><span class="line">  allowBreakingChanges: [<span class="string">'feat'</span>, <span class="string">'fix'</span>],</span><br><span class="line">  <span class="comment">// skip any questions you want</span></span><br><span class="line">  <span class="comment">// skipQuestions: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// subject 限制长度</span></span><br><span class="line">  subjectLimit: <span class="number">100</span>,</span><br><span class="line">  <span class="comment">// breaklineChar: '|', // 支持 body 和 footer</span></span><br><span class="line">  <span class="comment">// footerPrefix : 'ISSUES CLOSED:'</span></span><br><span class="line">  <span class="comment">// askForBreakingChangeFirst : true,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到此， 我们使用 <code>cz-customizable</code>  就自定义配置完了。</p>
<p>最后我们使用 <code>git cz</code>命令进行提交说明：</p>
   <img src="/shuliqi.github.io/2021/01/15/如何配置git提交规范/1.png">
<p>上图我们就可以看出此时的提交说明已经汉化， 我们继续写提交说明：</p>
   <img src="/shuliqi.github.io/2021/01/15/如何配置git提交规范/2.png">
<p>最后我们提交到远端看到效果如下：</p>
  <img src="/shuliqi.github.io/2021/01/15/如何配置git提交规范/3.png">
<h2 id="Commitizen校验"><a href="#Commitizen校验" class="headerlink" title="Commitizen校验"></a>Commitizen校验</h2><p>我们前面已经约束了一套代码规范提交说明了， 但是还是有人不按照规范提交代码说明怎么呢？， 那么就需要 <a href="https://github.com/marionebl/commitlint" target="_blank" rel="noopener">commitlint</a>来校验 commit 了。</p>
<p><strong>安装commitlint</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @commitlint/cli</span><br></pre></td></tr></table></figure>
<p><strong>安装@commitlint/config-conventional</strong></p>
<p>安装符合<code>Abgular</code>风格校验规则：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @commitlint/config-conventional</span><br></pre></td></tr></table></figure>
<p>然后在项目中新建 <code>commitlint.config.js</code>文件，并且设置校验规则：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'@commitlint/config-conventional'</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>安装安装huksy（git钩子工具）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install husky --save-dev</span><br></pre></td></tr></table></figure>
<p>然后在packge.json 中配置 <code>git commit</code>提交时的钩子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"husky"</span>: &#123;</span><br><span class="line">  <span class="string">"hooks"</span>: &#123;</span><br><span class="line">    <span class="string">"commit-msg"</span>: <span class="string">"commitlint -E HUSKY_GIT_PARAMS"</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意</strong>，使用该校验规则不能对<code>.cz-config.js</code>进行不符合<code>Angular</code>规范的定制处理，例如之前的汉化，此时需要将<code>.cz-config.js</code>的文件按照官方示例文件<a href="https://github.com/leonardoanalista/cz-customizable/blob/master/cz-config-EXAMPLE.js" target="_blank" rel="noopener">cz-config-EXAMPLE.js</a>进行符合<code>Angular</code>风格的改动。</p>
<p>最后我们来试一试：</p>
<p>提交不符合规范的错误提示：</p>
  <img src="/shuliqi.github.io/2021/01/15/如何配置git提交规范/4.png">
<p>提交符合规范的提示：</p>
  <img src="/shuliqi.github.io/2021/01/15/如何配置git提交规范/5.png">
<p><strong>需要注意</strong>：如果使用了 <strong>cz-customizable</strong>配器做了破坏<code>Angular</code>风格的提交说明配置，那么不能使用<strong>@commitlint/config-conventional</strong>规则进行提交说明校验，可以使用<a href="https://github.com/whizark/commitlint-config-cz" target="_blank" rel="noopener">commitlint-config-cz</a>对定制化提交说明进行校验。</p>
<p><strong>安装：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install commitlint-config-cz --save-dev</span><br></pre></td></tr></table></figure>
<p>然后加入<code>commitlint</code>校验规则配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [</span><br><span class="line">    <span class="string">'cz'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里推荐使用<strong>@commitlint/config-conventional</strong>校验规则，如果想使用<code>cz-customizable</code>适配器，那么定制化的配置不要破坏Angular规范即可。</p>
</blockquote>
<h1 id="git-commit-触发-git-cz"><a href="#git-commit-触发-git-cz" class="headerlink" title="git commit 触发 git cz"></a>git commit 触发 git cz</h1><p>在提交的时候，我们都习惯了 <code>git commit</code> ，虽然换成 <code>git cz</code> 不难，但是如果让开发者在 <code>git commit</code> 时无感知的触发 <code>git cz</code> 肯定是更好的， 而且也能避免不熟悉项目的人直接 <code>git commit</code> 提交一些不符合规范的信息。</p>
<p>我们可以在<code>husky.config.js</code>中设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"hooks"</span>: &#123;</span><br><span class="line">  <span class="string">"prepare-commit-msg"</span>: <span class="string">"exec &lt; /dev/tty &amp;&amp; git cz --hook || true"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考文档：</strong></p>
<p><a href="https://juejin.cn/post/6854573220176068615" target="_blank" rel="noopener">让你的commit更有价值</a></p>
<p><a href="https://github.com/leoforfree/cz-customizable" target="_blank" rel="noopener">cz-customizable</a></p>
<p><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">cz-cli</a></p>
<p><a href="https://www.barretlee.com/blog/2019/10/28/commit-convention/" target="_blank" rel="noopener">小胡子哥的个人博客</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a></p>
]]></content>
  </entry>
  <entry>
    <title>前端浏览器缓存</title>
    <url>/shuliqi.github.io/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="我们为什么要缓存"><a href="#我们为什么要缓存" class="headerlink" title="我们为什么要缓存"></a>我们为什么要缓存</h2><ul>
<li><p><strong>缓存可以减少用户的等待时间，提升用户的体验。</strong></p>
</li>
<li><p><strong>减少网络带宽消耗</strong></p>
<p>对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。如果可以使用缓存，只会产生极小的网络流量，这将有效的降低运营成本</p>
 <a id="more"></a>
</li>
<li><p><strong>降低服务器压力。</strong></p>
<p>给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。此外，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。</p>
</li>
</ul>
<p><strong>注意：</strong>如果缓存数据使用不当，会有“脏数据”。导致用户数据异常。</p>
<h2 id="前端缓存-后端缓存"><a href="#前端缓存-后端缓存" class="headerlink" title="前端缓存/后端缓存"></a>前端缓存/后端缓存</h2><p>首先我们定义一下：什么是前端缓存？什么是后端缓存？</p>
<p>基本的网络请求有三个步骤：<code>请求</code>，<code>处理</code>，<code>响应</code>。</p>
<p>后端缓存主要集中在<code>处理</code>步骤。通过保留数据库的连接，存储结果的处理等方式缩短处理时间。尽快进入“响应”步骤。本文不讲后端缓存。</p>
<p>前端缓存则可以在剩下的两步：<code>请求</code>和<code>响应</code>中进行。在请求的过程中，浏览器也可以通过存储结果的方式直接使用资源，省去了发送请求。而响应步骤则需要浏览器和服务器共同配合。通过减少响应内容来缩短传输的时间。</p>
<h2 id="按缓存位置分类"><a href="#按缓存位置分类" class="headerlink" title="按缓存位置分类"></a>按缓存位置分类</h2><p>按缓存位置分类可分为三个部分：<code>service worker</code>,    <code>memory cache</code>,   <code>disk cache</code> 。</p>
<p>在Chrome 的开发者工具中，Network -&gt; Size 一列看到一个请求最终的处理方式：如果是大小 (多少 K， 多少 M 等) 就表示是网络请求，否则会列出 <code>memory cache</code>,    <code>disk cache</code> 和    <code>ServiceWorker</code> </p>
<p>如图：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/1.jpg">
<p><strong>优先级是：</strong>(由上到下寻找，找到即返回；找不到则继续)</p>
<ul>
<li>service worker</li>
<li>memory cache</li>
<li>disk cache</li>
<li>网络请求</li>
</ul>
<h4 id="memory-cache"><a href="#memory-cache" class="headerlink" title="memory cache"></a>memory cache</h4><p>memory cache 是内存中的缓存。</p>
<p>几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。但是因为 <strong>数量很大</strong>，而且<strong>浏览器占的内存不能无限扩大</strong> 这两个原因。memory cache 就只能是个<strong>短期存储</strong>。</p>
<p>通常的情况下，浏览器的tab 关闭后该浏览器tab的memory cache 就会失效了(为了给其他的tab腾出空间)。</p>
<p>极端的情况下，如果一个页面的缓存用了超级多的内存，那么可能在它没有关闭前，排在前面的缓存就已经失效了。</p>
<h4 id="disk-cache-（HTTP-cache）"><a href="#disk-cache-（HTTP-cache）" class="headerlink" title="disk cache （HTTP cache）"></a>disk cache （HTTP cache）</h4><p>disk cache 也叫HTTP cache，是存储在硬盘上的缓存。因此它是持久存储的，是实际存在于文件系统中的。</p>
<p>disk cache 会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存，哪些资源不可以缓存；哪些资源是仍然可用的，哪些资源是过时需要重新请求的。当命中缓存之后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但比起网络请求还是快了不少的。绝大部分的缓存都来自 disk cache。</p>
<p>凡是永久性存储都会面临容量增长的问题。disk cache也是一样的。在浏览器自动清理时， 会有神秘的算法去把“最老的”或者“最可能过时的”资源删除。是一个一个删掉的。不过每个浏览器识别“最老的”和“最可能过时的”资源的算法不尽相同，可能也是它们差异性的体现。</p>
<h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>memory cache， disk cache的缓存策略以及缓存/读取/失效的动作都是由浏览器内部判断 &amp; 进行的，我们只能设置响应头的某些字段来告诉浏览器，而不能自己操作。而Service Worker是我们自己能够操作缓存的。</p>
<p>我们可以从 Chrome 的 F12 中，Application -&gt; Cache Storage 找到这个单独的“小金库”。</p>
<p><strong>Service Worker 的优点：</strong></p>
<ul>
<li>Service Worke 能够直接操作缓存。</li>
<li>缓存是永久的。即使tab或者浏览器关闭，下次打开依然还在。</li>
</ul>
<p>有两种情况会导致这个缓存中的资源被清除：手动调用 API cache.delete(resource) 或者容量超过限制，被浏览器全部清空。</p>
<h4 id="请求网络"><a href="#请求网络" class="headerlink" title="请求网络"></a>请求网络</h4><p>如果一个请求在上述 3 个位置都没有找到缓存，那么浏览器会正式发送网络请求去获取内容。之后容易想到，为了提升之后请求的缓存命中率，自然要把这个资源添加到缓存中去。</p>
<h2 id="前端缓存"><a href="#前端缓存" class="headerlink" title="前端缓存"></a>前端缓存</h2><p>前端缓存分类 <strong>HTTP缓存</strong> 和 <strong>浏览器缓存</strong>。</p>
<p><strong>HTTP缓存：</strong>在HTTP请求传输时用到的缓存，主要在服务器代码上设置（disk cache）。</p>
<p><strong>浏览器缓存：</strong>前端开发在前端js上进行设置(如：Service Worker )。</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/8.webp">
<h2 id="前端缓存的分析过程"><a href="#前端缓存的分析过程" class="headerlink" title="前端缓存的分析过程"></a>前端缓存的分析过程</h2><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。如图：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/9.webp">
<p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 </p>
<p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，</p>
<p><strong>强制缓存的情况主要有三种情况：</strong></p>
<ul>
<li><p><strong>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求</strong></p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/10.webp">
</li>
<li><p><strong>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存</strong></p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/11.webp">
</li>
<li><p><strong>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</strong></p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/12.webp">
</li>
</ul>
<p><strong>强制缓存的规则：</strong></p>
<p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应头中和请求结果一起返回给浏览器</p>
<p><strong>控制强制缓存的字段：</strong> <strong>Expires</strong>，<strong>Cache-Control</strong></p>
<p><strong>强缓存的直接优点：</strong>直接减少请求数，是提升最大的缓存策略。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>这是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p>
<p>例子：</p>
<p>后端的处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强缓存---&gt; Expires</span></span><br><span class="line">app.get(<span class="string">'/1.css'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> cssPath = path.join(__dirname, <span class="string">'./public/stylesheets/1.css'</span>);</span><br><span class="line">  <span class="comment">// 读取1.css 文件</span></span><br><span class="line">  fs.readFile(cssPath, (err, content) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(!err) &#123;</span><br><span class="line">      <span class="comment">// 设置到期时间</span></span><br><span class="line">      res.setHeader(<span class="string">'Expires'</span>, <span class="string">'Thu Dec 05 2019 20:13:08 GMT+0800 (CST)'</span>);</span><br><span class="line">      <span class="comment">// 发送1.css文件buffer</span></span><br><span class="line">      res.end(content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一次请求1.css 的结果：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/13.png">
<p>另打开一个tab再次请求1.css的结果：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/21.png">
<p><strong>缺点：</strong></p>
<ul>
<li><p>由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑自信修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。</p>
</li>
<li><p>写法太复杂了。表示时间的字符串多个空格，少个字母，都会导致非法属性从而设置失效。</p>
</li>
</ul>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求</p>
<p>这两者的区别就是前者是绝对时间，而后者是相对时间</p>
<p>例子：</p>
<p>后端的处理逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强缓存---&gt; Cache-Control</span></span><br><span class="line">app.get(<span class="string">'/2.css'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> cssPath = path.join(__dirname, <span class="string">'./public/stylesheets/2.css'</span>);</span><br><span class="line">  fs.readFile(cssPath, (err, content) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 设置到期时间，全部资源， 10秒请求使用本地资源</span></span><br><span class="line">    res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'public, max-age=600'</span>);</span><br><span class="line">    <span class="comment">// 发送2.css文件buffer</span></span><br><span class="line">    res.end(content);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一次请求的结果:</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/22.png">
<p>另打开一个tab再次请求的结果：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/23.png">
<p><strong>Cache-control 字段常用的值：</strong></p>
<ul>
<li>max-age: 即最大有效时间。</li>
<li>must-revalidate：如果超过了 max-age的时间，浏览器就必须向服务器发送请求，验证资源是否有效。</li>
<li>no-cache：然字面意思是“不要缓存”，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定。</li>
<li>no-store: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。</li>
<li>public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)。</li>
<li>private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。</li>
</ul>
<p>这些值是可以混合使用。</p>
<p><strong>总结：</strong>自从 HTTP/1.1 开始，Expires 逐渐被 Cache-control 取代。Cache-control 是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且 Cache-control 的可配置性比较强大。</p>
<p>Cache-control 的优先级高于 Expires，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段我们都会设置。如果两个设置都有效的话， 优先使用Cache-Control。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，</p>
<p><strong>协商缓存的两种情况：</strong></p>
<ul>
<li><p><strong>协商缓存生效，返回304</strong></p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/14.webp">
<ul>
<li><p><strong>协商缓存失效，返回200和请求结果结果</strong></p>
 <img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/15.webp">
</li>
</ul>
</li>
</ul>
<p><strong>对比缓存的流程：</strong></p>
<ol>
<li>浏览器请求缓存数据库，返回一个缓存标识。</li>
<li>浏览器拿这个标识和服务器通讯。</li>
<li>如果缓存未失效，则返回HTTP状态码 304 标识缓存可以继续使用。如果缓存失效，则返回新的数据和缓存规则。浏览器响应数据后，再写入到缓存数据库。</li>
</ol>
<p><strong>对比缓存的优点：</strong> 通过减少响应体体积，来缩短网络传输时间。</p>
<p>虽然请求数和没有缓存是一样的。但是如果是304的话，返回的仅仅是一个状态码而已。但是并没有实际的文件内容，因此在响应体体积上的节省是它优化点。虽然和强制缓存相比提升幅度较小。但总比没有缓存好。</p>
<p><strong>协商缓存的字段：</strong> <strong>Last-Modified / If-Modified-Since</strong>， <strong>Etag / If-None-Match</strong></p>
<p>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</p>
<h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h4><p>last-Modified是服务器在响应请求时用来说明资源的最后修改时间。与之对应的是<strong>if-Modified-Since</strong>.</p>
<p>在对比缓存中，浏览器发送HTTP请求中Header中会带上if-Modified-since字段，值为缓存资源的Last-Modified属性的值。</p>
<p>当服务器端接收到带有 If-Modified-Since 的请求时，则会将 If-Modified-Since 的值与被请求资源的最后修改时间做对比。如果相同，说明资源没有新的修改，则响应 HTTP Status Code 304，浏览器会继续使用缓存资源；如果最后修改时间比较新，则说明资源被修改过，则响应 HTTP Status Code 200，并返回最新的资源。</p>
<p><strong>例如：</strong></p>
<p>后端对处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对比缓存 [if-modified-since, Last-Modified, ]</span></span><br><span class="line">app.use(<span class="string">'/1.js'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> jsPath = path.join(__dirname, <span class="string">'./public/javascripts/1.js'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取文件1.js的信息</span></span><br><span class="line">  fs.stat(jsPath, (err, stat) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取文件内容被修改的时间 modify time</span></span><br><span class="line">    let lastModified = stat.mtime.toUTCString();</span><br><span class="line">   <span class="comment">// 判断 if-modified-since 的时间与资源的最后修改时间是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (req.headers[<span class="string">'if-modified-since'</span>] === lastModified) &#123;</span><br><span class="line">      <span class="comment">// 设置响应状态码</span></span><br><span class="line">      res.writeHead(<span class="number">304</span>, <span class="string">'not modified'</span>);</span><br><span class="line">      <span class="comment">// 不需要传输响应体</span></span><br><span class="line">      res.end();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 读取文件</span></span><br><span class="line">      fs.readFile(jsPath, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 设置Last-Modified</span></span><br><span class="line">        res.setHeader(<span class="string">'Last-Modified'</span>, lastModified);</span><br><span class="line">        <span class="comment">// 设置响应状态码</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, <span class="string">'ok'</span>);</span><br><span class="line">        <span class="comment">// 需要传输响应体</span></span><br><span class="line">        res.end(content);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一次请求的结果：第一次请求， 后端设置响应字段 Last-Modified</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/15.png">
<p>第二次请求的结果：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/16.png">
<p>当我修改1.js文件之后再次访问的结果：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/17.png">
<p><strong><code>存在的问题：</code></strong></p>
<ul>
<li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内被修改多次的话，它将不能准确标注文件的最后修改时间；</li>
<li>如果本地打开缓存文件，即使没有对文件进行修改，但 Last-Modified 却改变了，导致文件没法使用缓存</li>
</ul>
<h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h4><p>Etag是服务器端在响应请求时用来说明资源在服务器端的唯一标识，与之对应的是 <strong>If-None-Match</strong> 字段。</p>
<p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。</p>
<p>当服务器端接收到带有 If-None-Match 的请求时，则会将 If-None-Match 的值与被请求资源的唯一标识做对比。如果相同，说明资源没有新的修改，则响应 HTTP Status Code 304，浏览器会继续使用缓存资源；如果不同，则说明资源被修改过，则响应 HTTP Status Code 200，并返回最新的资源。</p>
<p>例子：</p>
<p>后端的处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 对比缓存 [ Etag, If-None-Match ]</span></span><br><span class="line">app.get(<span class="string">'/2.js'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> jsPath = path.join(__dirname, <span class="string">'./public/javascripts/2.js'</span>);</span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  fs.readFile(jsPath, (err, content) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 对文件内容使用md5加密形成一个唯一的标识</span></span><br><span class="line">    <span class="keyword">let</span> etag = md5(content);</span><br><span class="line">    <span class="comment">// 请求头的唯一标识和当前文件的唯一标识是一致的，标识文件没有被修改过</span></span><br><span class="line">    <span class="keyword">if</span> (req.headers[<span class="string">'if-none-match'</span>] === etag) &#123;</span><br><span class="line">      <span class="comment">// 设置响应头 304</span></span><br><span class="line">      res.writeHead(<span class="number">304</span>, <span class="string">'not modified'</span>);</span><br><span class="line">      <span class="comment">// 响应体为空，减少传输时间</span></span><br><span class="line">      res.end();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 设置响应头的Etag</span></span><br><span class="line">      res.setHeader(<span class="string">'Etag'</span>, etag);</span><br><span class="line">       <span class="comment">// 设置响应头 200</span></span><br><span class="line">      res.writeHead(<span class="number">200</span>, <span class="string">'ok'</span>);</span><br><span class="line">      <span class="comment">// 需要返回内容</span></span><br><span class="line">      res.end(content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一次请求的结果：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/18.png">
<p>再次请求的结果：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/19.png">
<p>修改文件2.js 之后再次请求：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/20.png">
<p>注意：Last-Modified 是 HTTP 1.0 的字段，而 Etag 是 HTTP 1.1 的字段，<strong>当 Last-Modified 与 Etag 同时存在时，Etag 的优先级要高于 Last-Modified</strong>。Etag 的出现主要是为了解决 Last-Modified 存在的问题。</p>
<h2 id="用户刷新-访问行为"><a href="#用户刷新-访问行为" class="headerlink" title="用户刷新/访问行为"></a>用户刷新/访问行为</h2><p>强缓存的例子，再次请求有让大家打开另一个tab，为什么呢？为什么不直接刷F5刷新，或者点击工具栏的帅秀楠按钮或者邮件菜单重新加载呢？</p>
<p>我们把刷新/访问界面的手段分为三类：</p>
<ul>
<li><strong>在url输入栏输入然后回车/通过书签访问</strong></li>
<li><strong>F5/点击工具栏的刷新按钮/右键菜单重新加载</strong></li>
<li><strong>ctl+F5/硬性重新加载/清空缓存并且硬性重新加载</strong></li>
</ul>
<p>对以上三种访问情况进行实践和讨论。</p>
<p><strong>准备工作：</strong>模拟第一次访问资源。请求头没有任何相关的缓存的信息。而响应体设置了以下头部信息：Cache-Control，Expires，Last-Modified。请求之后，浏览器会对该文件进行缓存。</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/24.png">
<p>后端代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 刷新/访问行为</span></span><br><span class="line">app.get(<span class="string">'/1.png'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 设置到期时间</span></span><br><span class="line">  res.setHeader(<span class="string">'Expires'</span>, <span class="string">'Thu Dec 05 2019 23:51:08 GMT+0800 (CST)'</span>);</span><br><span class="line">  res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'public, max-age=6000'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> imgPath = path.join(__dirname, <span class="string">'./public/images/1.png'</span>);</span><br><span class="line">  <span class="comment">// 获取文件1.png的信息</span></span><br><span class="line">  fs.stat(imgPath, (err, stat) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取文件内容被修改的时间 modify time</span></span><br><span class="line">    <span class="keyword">let</span> lastModified = stat.mtime.toUTCString();</span><br><span class="line">   <span class="comment">// 判断 if-modified-since 的时间与资源的最后修改时间是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (req.headers[<span class="string">'if-modified-since'</span>] === lastModified) &#123;</span><br><span class="line">      <span class="comment">// 设置响应状态码</span></span><br><span class="line">      res.writeHead(<span class="number">304</span>, <span class="string">'not modified'</span>);</span><br><span class="line">     <span class="comment">// 响应体为空，减少传输时间</span></span><br><span class="line">      res.end();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 读取文件</span></span><br><span class="line">      fs.readFile(jsPath, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 设置Last-Modified</span></span><br><span class="line">        res.setHeader(<span class="string">'Last-Modified'</span>, lastModified);</span><br><span class="line">        <span class="comment">// 设置响应状态码</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, <span class="string">'ok'</span>);</span><br><span class="line">        <span class="comment">// 响应体为空，减少传输时间</span></span><br><span class="line">        res.end(content);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>1.在url输入栏输入然后回车</strong></p>
<p>我们可以看到返回的响应码是<code>200 ok (disk cache)</code>。浏览器发现了该资源以及缓存了而且没有过期(Cache-Control或者Expires)。 没有跟服务器确认，而是直接使用了浏览器缓存的内容，其中响应的内容和上一次的响应内容是一样的。</p>
<p>如图：</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/25.png">
<p><strong>2.F5/点击工具栏的刷新按钮/右键菜单重新加载</strong></p>
<p><code>F5/点击工具栏的正常刷新按钮/右键菜单重新加载</code> 的作用和<code>在url输入栏输入然后回车</code>的作用是不一样的。前者是无论如何都要发一个HTTP Request 给server。即使先前的响应中有Cache-Control或者Expires。而发送的请求头中，包含了这样的header信息。</p>
<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/26.png">
<p>其中Cache-Control 是浏览器强制加上的。而If-Modified-Since是因为在获取资源的时候包含了Last-Modified的头部，所以浏览器会使用If-Modified-Since头部信息重新发送改该时间确认资源是否需要重新发送。世纪server 没有改过这个1.png这个文件， 所以返回了<code>304 not modified</code>.</p>
<p><strong>2.ctl+F5/硬性重新加载/清空缓存并且硬性重新加载</strong></p>
<p>而<code>ctl+F5/硬性重新加载/清空缓存并且硬性重新加载</code>是彻底的从server拿一份新的资源过来。所以不光耀发送HTTP request给server。而且这个请求里面连If-Modified-Since/If-None-Match都没有。这样就能逼着服务器不能返回304，而是把整个资源原原本本的返回一次。</p>
<p>为了保证拿到的是从server上获取的。 不只是去掉了f-Modified-Since/If-None-Match， 还添加了一些头部信息，如Cache-control：no-cache。因为cache不光是存在浏览器端，在浏览器端到服务器端的中间节点（如：Proxy）也可能扮演者Cache的角色。所以为了防止从这些节点获取缓存，所以加了Cache-control：no-cache。<img src="/shuliqi.github.io/2019/12/03/前端浏览器缓存/27.png"></p>
<p>最后，附上以上所有例子的代码：<a href="https://github.com/shuliqi/frontCache" target="_blank" rel="noopener">https://github.com/shuliqi/frontCache</a></p>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>学习计划</title>
    <url>/shuliqi.github.io/2019/05/12/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h3 id="拆解的学习小目标（先把手上现有的书看完）"><a href="#拆解的学习小目标（先把手上现有的书看完）" class="headerlink" title="拆解的学习小目标（先把手上现有的书看完）"></a>拆解的学习小目标（先把手上现有的书看完）</h3><ul>
<li>Javascript模式</li>
<li><p>Javascript高级程序设计（第三版）</p>
<a id="more"></a>
</li>
<li><p>学习Javascript数据结构与算法</p>
</li>
<li>Node.js实战</li>
</ul>
<p>这是2019年的计划， 加油！！！ 每天至少一个小时的学习时间</p>
<h4 id="前端学习计划"><a href="#前端学习计划" class="headerlink" title="前端学习计划"></a>前端学习计划</h4><p>总的方向： <a href="https://www.zhihu.com/question/22146521/answer/633571058" target="_blank" rel="noopener">https://www.zhihu.com/question/22146521/answer/633571058</a></p>
<p>从中查缺补漏</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*YTP0ii6kEqZtxUN0bOKADA.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>《javascript设计模式》读书笔记四：对象创建模式</title>
    <url>/shuliqi.github.io/2019/07/07/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>JavaScript 是一种简洁明了的语言，其中并没有在其他语言经常使用的一些特殊语法的特征：命名空间，模块，包，私有属性，以及静态成员等。让我们用JavaScript来实现。</p>
 <a id="more"></a>
<h3 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h3><p>命名空间有助于减少程序中所需要的全局变量的数量，并且同时还哟助于避免命名冲突或者过长的名字前缀。</p>
<p>可以为应用程序或者库创建一个全局对象，然后将所有的功能添加到全局对象中，从而在具有大量函数，对象和其他变量的情况下并不会污染全局范围。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="keyword">var</span> some_var = <span class="string">"shud"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.data = &#123; <span class="attr">a</span>:<span class="string">'a'</span>, <span class="attr">b</span>: <span class="string">'b'</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方式将会导致很多全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line">MYAPP.dd1= &#123;&#125;;</span><br><span class="line">MYAPP.some_var = <span class="string">"shud"</span>;</span><br><span class="line">MYAPP.module = &#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.module.data = &#123; <span class="attr">a</span>:<span class="string">'a'</span>, <span class="attr">b</span>: <span class="string">'b'</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这就避免了代码中的命名冲突。推荐使用这种方式。</p>
<p><strong>缺点</strong></p>
<ol>
<li>需要输入更多的字符，每个变量都需要添加前缀。</li>
<li>任何闭门的代码都可以修改全局实例。</li>
<li>长嵌套命名意味着的属性查询时间。</li>
</ol>
<h4 id="1-通用命名空间函数"><a href="#1-通用命名空间函数" class="headerlink" title="1.通用命名空间函数"></a>1.通用命名空间函数</h4><p>由于程序的复杂性。上面的做法已经变得不再健全。添加到命名空间中的属性可能已经存在，这将导致覆盖它们。因此在添一个属性或者创建一个命名空间之前，最好先检查它是否已经存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不健全的代码</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的代码风格</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> MYAPP === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者更短的语句</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = MYAPP || &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>但是这样每次检查读要针对一个对象或者属性。检查代码量太大。这就需要一个通用命名空间函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用命名空间函数</span></span><br><span class="line">MYAPP.namespace(<span class="string">'MYAPP.modules.module2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于如下代码</span></span><br><span class="line"><span class="comment">// var MYAPP = &#123;</span></span><br><span class="line"><span class="comment">//  modules: &#123;</span></span><br><span class="line"><span class="comment">//    module2: &#123;&#125;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>一个命名空间函数的实现事例。这个实现是肥破坏性的，也就是说，，如果已经存在一个命名空间， 将不会再重新创建。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = MYAPP || &#123;&#125;;</span><br><span class="line">MYAPP.namespace = <span class="function"><span class="keyword">function</span>(<span class="params">ns_string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parts = ns_string.splict(<span class="string">'.'</span>),</span><br><span class="line">      parent = MYAPP,</span><br><span class="line">      i,</span><br><span class="line">   <span class="comment">// 剥离最前面的多余的全局变量</span></span><br><span class="line">   <span class="keyword">if</span> (parent[<span class="number">0</span>] === <span class="string">'MYAPP'</span>) &#123;</span><br><span class="line">     parent = parts.slice(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; parts.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[parts[i]] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        parent[parts[i]] = &#123;&#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     parent = parent[parts[i]]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="声明依赖关系"><a href="#声明依赖关系" class="headerlink" title="声明依赖关系"></a>声明依赖关系</h3><p>JavaScript库通常是模块化且根据命名空间组织的，这时我们能够仅包含所需的模块。它有很多优点：</p>
<ul>
<li>显式的依赖声明向您代码的用户表明了他们所需要的特定的脚本文件。</li>
<li>在函数的顶部声明可以很容易的发现和解析依赖。</li>
<li>解析局部变量的速度要比解析全局变量的速度要快。</li>
<li>声明依赖在打包之后可以有更小的代码量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.modules.m1);</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.modules.m2);</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.modules.m3)</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.modules.m4);</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.modules.m5);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缩减的test1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> modules = MYAPP.modules</span><br><span class="line">  <span class="built_in">console</span>.log(modules.m1);</span><br><span class="line">  <span class="built_in">console</span>.log(modules.m2);</span><br><span class="line">  <span class="built_in">console</span>.log(modules.m3)</span><br><span class="line">  <span class="built_in">console</span>.log(modules.m4);</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPPmodulesm5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h3><p>JavaScript并没有特殊的语法来表示私有，保护，或者公共属性和方法。在JavaScript中所有对象的成员都是公共的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量的方式构造对象</span></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    name: <span class="string">'shuliqi'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    getNameAndAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'1111'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name + <span class="string">':'</span> + myObj.age) <span class="comment">// name 和 age 可以公公访问的</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.getNameAndAge()) <span class="comment">// myobj.getNameAndAge也是可以公公访问的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数创建对象</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">myObj2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="string">'shuliqi'</span>;</span><br><span class="line">   <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">   <span class="keyword">this</span>.getNameAndAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'1111'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="keyword">new</span> myObj2();</span><br><span class="line"><span class="built_in">console</span>.log(newObj.name + <span class="string">':'</span> + newObj.age) <span class="comment">// name 和 age 可以公公访问的</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.getNameAndAge()) <span class="comment">// myobj.getNameAndAge也是可以公公访问的</span></span><br></pre></td></tr></table></figure>
<h4 id="构造函数实现私有成员"><a href="#构造函数实现私有成员" class="headerlink" title="构造函数实现私有成员"></a>构造函数实现私有成员</h4><p>可以使用JavaScript的闭包来实现私有成员的功能。构造函数创建了一个闭包，而在这些闭包范围内部的任意变量都不会暴露给构造函数以外的代码。然而这些私有变量仍然可以用于公共方法中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 私有成员</span></span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">"shuliqi"</span>;</span><br><span class="line">   <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newMyFun = <span class="keyword">new</span> myFun();</span><br><span class="line"><span class="comment">// name 是私有的</span></span><br><span class="line"><span class="built_in">console</span>.log(newMyFun.name); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// getName 方法是公共的</span></span><br><span class="line"><span class="built_in">console</span>.log(newMyFun.getName()); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>所以只需要在函数中将需要保持为私有属性的数据包装起来，并确保它对函数来说是局部变量就可以实现私有成员。</p>
<h4 id="构造函数私有性失效"><a href="#构造函数私有性失效" class="headerlink" title="构造函数私有性失效"></a>构造函数私有性失效</h4><p>如果从一个特权方法中返回一个私有变量。且该变量是一个对象或者数组，那么外面的方法仍然可以访问修改该私有变量，因为它是通过引用传递的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     name: <span class="string">"shu"</span>,</span><br><span class="line">     age: <span class="number">20</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.getObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> obj;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFun = <span class="keyword">new</span> myFun();</span><br><span class="line"><span class="keyword">var</span> obj = newFun.getObj();</span><br><span class="line">obj.shu = <span class="string">"hahah"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newFun.getObj()); <span class="comment">// &#123;name: "shu", age: 20, shu: "hahah"&#125;</span></span><br></pre></td></tr></table></figure>
<p>解决的办法构造函数里面的特权方法不要传递需要有私有性的对象和数组的引用，而是传递克隆的对象或者数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     name: <span class="string">"shu"</span>,</span><br><span class="line">     age: <span class="number">20</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.getObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// es6方式克隆</span></span><br><span class="line">      <span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj); </span><br><span class="line">      <span class="keyword">return</span> newObj;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFun = <span class="keyword">new</span> myFun();</span><br><span class="line"><span class="keyword">var</span> obj = newFun.getObj();</span><br><span class="line">obj.shu = <span class="string">"hahah"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newFun.getObj()); <span class="comment">// &#123;name: "shu", age: 20 &#125; 不可以修改</span></span><br></pre></td></tr></table></figure>
<h4 id="对象字面量实现私有性"><a href="#对象字面量实现私有性" class="headerlink" title="对象字面量实现私有性"></a>对象字面量实现私有性</h4><p>实现私有性，需要的只是一个能够包装私有数据的函数，因此，在使用对象字面量的情况下，可以使用额外的匿名函数创建闭包来实现私有性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 私有成员</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"shuliqi"</span>;</span><br><span class="line">  <span class="comment">// 实现公共部分</span></span><br><span class="line">  <span class="comment">// 注意这里没有使用var字符</span></span><br><span class="line">  obj = &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// 'undefined' name 是私有的</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()) <span class="comment">// 'shuliqi'  特权方法是公共的</span></span><br></pre></td></tr></table></figure>
<p>另外的一种写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 私有成员</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"shuliqi"</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">  	getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> name;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// 'undefined' name 是私有的</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()) <span class="comment">// 'shuliqi'  特权方法是公共的</span></span><br></pre></td></tr></table></figure>
<h4 id="原型和私有性"><a href="#原型和私有性" class="headerlink" title="原型和私有性"></a>原型和私有性</h4><p>当私有成员与构造函数一起使用时，其中的一个缺点就是每次调用构造函数以创建对象时，这些私有成员都会被重新创建。构造函数中任何添加到this的任何成员都会有这种情况。为了避免这样重复的工作。可以把常用的方法和属性添加到构造函数的prototype属性中。这样就可以通过一个构造函数创建的多个实例共享常见的的部分数据。还可以在多个实例中共享隐藏的私有成员。即构造函数中的私有属性和对象字面量的私有属性。由于prototype仅仅是一个对象。所以可以使用对象字面量来创建它</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 私有属性</span></span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">"shuliqi"</span>;</span><br><span class="line">	<span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.prototype = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 私有成员</span></span><br><span class="line">	<span class="keyword">var</span> age = <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> age</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="keyword">new</span> myObj()</span><br><span class="line"><span class="built_in">console</span>.log(newObj.getName()) <span class="comment">// 'shuliqi'  自身的特权方法</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.getAge())  <span class="comment">// 12 原型的特权方法</span></span><br></pre></td></tr></table></figure>
<h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>由于我们Javascript是没有包的语法的。模块模式提供了一种创建自包含非耦合代码片段的有力工具，可以将它视为黑盒功能，并且可以根据自己所需添加，替换或者删除这些模块。</p>
<p>模块模式是有下面这几种组合的组合。</p>
<ul>
<li>命名空间</li>
<li>即使函数</li>
<li>私有和特权成员</li>
<li>声明依赖</li>
</ul>
<p><strong>第一步：</strong>定义一个命名空间：例如我们之前介绍的namespace()函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MYAPP.namespace(<span class="string">'MYAPP.utilities.array'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>第二步：</strong>定义该模块，对于需要保持私有性的情况，本模式可以提供就要有私有作用域的即使函数。该即时函数返回一个对象，即具有公共接口的实际模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.array = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ... todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p><strong>第三步：</strong>向公共接口添加一些方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.array = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     isArray: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p><strong>最后：</strong>通过即使函数提供的私有作用域，可以根据需要声明一些私有属性和方法。在即时函数的顶部，正好也是声明模块可能有任何依赖的位置。在声明变量后，可以任意的放置有助于建立该模块的任何一性的初始化代码。最后结果是一个由即时函数返回的对象，其中该对象包含了自己模块需要的公共API。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MYAPP.namespace(<span class="string">'MYAPP.utilities.array'</span>);</span><br><span class="line">MYAPP.utilities.array = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 依赖</span></span><br><span class="line">   <span class="keyword">var</span> uobj = MYAPP.utilities.object,</span><br><span class="line">       ulang = MYAPP.utilities.ulang,</span><br><span class="line">       <span class="comment">// 私有属性</span></span><br><span class="line">       name = <span class="string">"shuliqi"</span>,</span><br><span class="line">       age =  <span class="number">12</span>,</span><br><span class="line">       <span class="comment">// 私有方法</span></span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       <span class="comment">// var 变量定义结束</span></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">   <span class="comment">// 可选的一次性初始化过程</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 公共API</span></span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     isArray: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">     &#125;,</span><br><span class="line">     name: name,</span><br><span class="line">     <span class="comment">// ... 更多的属性和方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>这就是模块模式的基本创建方式。</p>
<h3 id="揭示模式"><a href="#揭示模式" class="headerlink" title="揭示模式"></a>揭示模式</h3><p>在模块模式里面，公共API:公共属性和方法都是写在对象字面量中， 如果想在闭包内部调用公有属性和方法，就需要通过暴露在全局变量中的对象名称去调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var MYAPP = (function() &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">       // 公有属性</span><br><span class="line">       firstName: &apos;Peppa&apos;,</span><br><span class="line">       // 公有属性</span><br><span class="line">       lastName: &apos;Pig&apos;,</span><br><span class="line">       getFullName: function() &#123;</span><br><span class="line">          return MYAPP.firstName + &apos; &apos; +  MYAPP.lastName;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;());</span><br><span class="line">console.log(MYAPP.getFullName()) // Peppa Pig</span><br></pre></td></tr></table></figure>
<p>就像上面实例中展示的，<code>getFullName</code> 方法中需要访问公有属性 <code>firstName</code> 和 <code>lastName</code>，就必须通过 <code>nameSpace</code> 对象名去调用。这样的确很别扭，如果想要给 <code>nameSpace</code> 换个对象名，就需要考虑闭包内部的调用</p>
<p>那么使用揭示模式就可以解决这个问题了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> firstName = <span class="string">'Peppa'</span></span><br><span class="line">	<span class="keyword">var</span> lastName = <span class="string">'Pig'</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		firstName: firstName,</span><br><span class="line">		lastName: lastName,</span><br><span class="line">		getFullName: getFullName</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">MYAPP.getFullName() <span class="comment">// "Peppa Pig"</span></span><br></pre></td></tr></table></figure>
<p>优化后的代码，我们将公有的变量和方法在返回前就做了处理，而返回的对象更加纯粹，增强了可读性。这也是揭示模块模式的<strong>优点</strong></p>
<h3 id="创建构造函数的的模块"><a href="#创建构造函数的的模块" class="headerlink" title="创建构造函数的的模块"></a>创建构造函数的的模块</h3><p>有时候使用构造函数创建对象更为方便。当然，仍然可以使用模块模式来执行创建对象的操作。区别就是在于包装了模块的即时函数最终将会返回一个函数，而不是一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MYAPP.namespace(<span class="string">'MYAPP.utilities.array'</span>);</span><br><span class="line">MYAPP.utilities.array = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 依赖</span></span><br><span class="line">   <span class="keyword">var</span> uobj = MYAPP.utilities.object,</span><br><span class="line">       ulang = MYAPP.utilities.ulang,</span><br><span class="line">       <span class="comment">// 私有属性</span></span><br><span class="line">       name = <span class="string">"shuliqi"</span>,</span><br><span class="line">       age =  <span class="number">12</span>,</span><br><span class="line">       constr;</span><br><span class="line">       <span class="comment">// 私有方法</span></span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       <span class="comment">// var 变量定义结束</span></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">   <span class="comment">// 可选的一次性初始化过程</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="comment">// 公共API-----构造函数</span></span><br><span class="line">   constr = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.elements = <span class="keyword">this</span>.toArray(o);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 公共API-----原型</span></span><br><span class="line">   constr.prototype = &#123;</span><br><span class="line">     <span class="keyword">constructor</span>: MYAPP.utilities.array,</span><br><span class="line">     toArray: function(o) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新构造函数的方法</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MYAPP.utilities.array(obj);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>手把手封装axios取消重复请求</title>
    <url>/shuliqi.github.io/2020/08/31/%E5%B0%81%E8%A3%85axios%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>在我们web开发过程中，很多地方需要我们取消重复的请求。但是哪种场合需要我们取消呢？ 我们如何取消呢？带着这些问题我们阅读本文。</p>
<p>阅读完本文，你将了解以下内容：</p>
 <a id="more"></a>
<ul>
<li>需要取消重复请求的场景</li>
<li>我们如何取消重复请求</li>
<li>axios如何取消重复的请求</li>
<li>封装axios</li>
<li>如何给开源的项目提供源码</li>
<li>如何在本地调试npm包</li>
</ul>
<h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><p>最近做的项目中，用的用户经常遇到这样的问题：</p>
<ul>
<li>用户频繁切换筛选条件去请求数据，初次的筛选条件数据量大。用的时间比较多。 后面的筛选条件的数据量小。导致后面请求的数据先返回。内容先显示在页面上。但是等一段时间，初次(或者前面)的请求数据返回了， 会覆盖后面的请求的数据。这就导致了筛选条件和内容不一致的情况。</li>
<li>用户点击了一次提交按钮，接口没有很快响应，导致页面没办法做逻辑语句判断的提示。用户觉得可能没提交上，便会快速又点了按钮几次。如果后端没有去重的判断，就会导致数据中有很多条重复的数据。</li>
</ul>
<p>这些问题给用户的体验是很不友好的。那么取消无用的请求是很有必要的。</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>我们用的请求库是axios。那么我们可以在请求的时候拦截请求判断当前的请求是否重复，如果重复我们就取消当前的请求。大致的实现过程如下：</p>
<p><strong>我们把目前处于pending的请求存储（假如我们放在一个数组）起来。每个请求发送之前我们都要判断当前这个请求是否已经存在于这个数组。如果存在，说明请求重复了，我们就在数组中找到重复的请求并且取消。如果不存在，说明这个请求不是重复的，正常发送并且把这个请求api添加在数据中，等请求结束之后删除数组中的这个api。</strong></p>
<p>我们这个解决思路有了，但是axios如何取消请求的呢？ 我们先来了解下</p>
<h1 id="axios-如何取消请求"><a href="#axios-如何取消请求" class="headerlink" title="axios 如何取消请求"></a>axios 如何取消请求</h1><p>查看axios文档发现axios <a href="http://www.axios-js.com/zh-cn/docs/#%E5%8F%96%E6%B6%88" target="_blank" rel="noopener">提供了两种取消请求的方法</a></p>
<ul>
<li><p>第一种方法</p>
<p>通过<code>axios.CancelToken.source</code>生成取消令牌<code>token</code>和取消方法<code>cancel</code></p>
<p>这是官方给的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  name: <span class="string">'new name'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel the request (the message parameter is optional)</span></span><br><span class="line">source.cancel(<span class="string">'Operation canceled by the user.'</span>);</span><br></pre></td></tr></table></figure>
<p>我们自己写个例子：<a href="http://jsfiddle.net/shuliqi/pfj6nsy9/354/" target="_blank" rel="noopener">axios取消请求第一种方法</a> </p>
<iframe width="100%" height="300" src="//jsfiddle.net/shuliqi/pfj6nsy9/356/embedded/js,result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

<p>在这个例子中可以通过注释：<code>source.cancel(&#39;手动把请求被取消了&#39;);</code>这段代码来看看</p>
</li>
<li><p>第二种方式</p>
<p>通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建 cancel token;</p>
<p>官方的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// executor 函数接收一个 cancel 函数作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel the request</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure>
<p>我们自己来写一个例子看看 <a href="http://jsfiddle.net/shuliqi/ucy6vde1/7/" target="_blank" rel="noopener">axios取消请求第二种方法]</a></p>
<iframe width="100%" height="300" src="//jsfiddle.net/shuliqi/ucy6vde1/7/embedded/js,result/dark/?bodyColor=1c2128" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

</li>
</ul>
<h1 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h1><p>解决取消请求的思路有了，取消请求的办法也有了，那么剩下的就是封装了</p>
<p>由于同事之前已经封装了axios <a href="https://github.com/verymuch/very-axios" target="_blank" rel="noopener">very-axios</a>（基于 axios 进行二次封装，更简单、更统一地使用 axios。）。那么我们就这个基础上提一个pr吧。那么从现在开始我们就一步一步的来实现，这个过程包含了【如何给开源的项目贡献代码】【如何在本地调试npm】如果已经料机的同学可以直接略过。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>由于同事已经封装了axios并且已经开源了。那么我贡献代码的方式主要有两种：</p>
<ul>
<li>代码仓库的管理者给我们添加这个仓库的写入权限，如果这样，我们就可以直接提push。</li>
<li>如果我们没有权限(大多数情况)。我们使用经典的fork &amp; pull request 的方式来提交代码。</li>
</ul>
<p>我们采用的第二种方式。 我们去 <a href="https://github.com/verymuch/very-axios" target="_blank" rel="noopener">very-axios</a>把代码fork到自己的仓库(如果你还没有自己的github,需要自己注册下哦)。</p>
<img src="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/1.png">
<p>那么你回到自己的github仓库下面就会看有一个一摸一样的项目</p>
<img src="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/2.png">
<p>那么我们现在就可以<code>git clone</code>这个仓库的代码到本地，新建branch进行开发,就比如我新建了一个这样的branch：</p>
<img src="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/3.png">
<p>现在已经有本地的代码了，但是我们调试呢？如何确保我们改的是对的呢？那么就需要我们本地调试本地的npm包了。 那就需要<code>npm link</code> 了 </p>
<p>首先在我们要修改的npm 包中<code>npm link</code>,,如：</p>
<img src="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/4.png">
<p>之后我们会得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Users/shuliqi/.nvm/versions/node/v12.17.0/lib/node_modules/very-axios -&gt; /Users/shuliqi/study/axios/very-axios</span><br></pre></td></tr></table></figure>
<p>这意思就是我们把<code>very-axios</code>链接到全局的<code>node_modules</code></p>
<p> 然后我们进入我们my-project-of-axios 目录下面执行<code>npm link very-axios</code> 如图：</p>
<img src="/shuliqi.github.io/2020/08/31/封装axios取消重复请求/5.png">
<p>这意思就是<code>very-axios</code>被安装在<code>my-project-of-axios</code> 下面了。<code>very-axios</code>的修改都会同步到<code>my-project-of-axios</code>。就实现本地测试了。</p>
<p>我们在<code>my-project-of-axios</code>中的<code>HelloWorld.vue</code>文件中做列子。</p>
<p>如果这里看的不是很懂的同学可以 看看这两篇文章 <a href="https://github.com/allenGKC/Blog/issues/13" target="_blank" rel="noopener">如何在本地调试npm包</a>  <a href="https://juejin.im/post/6844903636863041550" target="_blank" rel="noopener">如何使用 GitHub Flow 给开源项目贡献代码</a></p>
<h2 id="开始封装"><a href="#开始封装" class="headerlink" title="开始封装"></a>开始封装</h2><p>准备工作完成了, 那我们开始封装的事情。根据我们之前的思路。我们采用axios 如何取消请求的第一种方式。</p>
<p>声明一个Map。用来存储每个请求的 标识 和 取消的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stores the identity and cancellation function for each request</span></span><br><span class="line"><span class="keyword">this</span>.pendingAjax = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure>
<p>自定一个字段来让用户自己决定是否需要取消重复的请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// whether to cancel a duplicated request</span></span><br><span class="line">cancelDuplicated = <span class="literal">false</span>,</span><br></pre></td></tr></table></figure>
<p>自定一个字段来让用户是否有全局的统一的设置重复标识的函数。如果没有设置全局的统一的函数，则默认是请求的<code>method</code> 和<code>url</code>作为重复的标识</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// how to generate the duplicated key</span></span><br><span class="line">duplicatedKeyFn,</span><br><span class="line"><span class="keyword">this</span>.duplicatedKeyFn = isFunction(duplicatedKeyFn) ? duplicatedKeyFn : <span class="function">(<span class="params">config</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;config.method&#125;</span><span class="subst">$&#123;config.url&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>添加请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add request to pendingAjax</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; config</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addPendingAjax(config) &#123;</span><br><span class="line">  <span class="comment">// if need cancel duplicated request</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.cancelDuplicated) <span class="keyword">return</span> </span><br><span class="line">  <span class="keyword">const</span> veryConfig = config.veryConfig || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> duplicatedKey = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    duplicatedKey:  veryConfig.duplicatedKey || <span class="keyword">this</span>.duplicatedKeyFn(config), </span><br><span class="line">    type: REQUEST_TYPE.DUPLICATED_REQUEST,</span><br><span class="line">  &#125;);</span><br><span class="line">  config.cancelToken = config.cancelToken || <span class="keyword">new</span> axios.CancelToken(<span class="function">(<span class="params">cancel</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// if the current request does not exist in pendingAjax, add it</span></span><br><span class="line">    <span class="keyword">if</span> (duplicatedKey &amp;&amp; !<span class="keyword">this</span>.pendingAjax.has(duplicatedKey)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.pendingAjax.set(duplicatedKey, cancel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面我们可以使用<code>duplicatedKey</code>字段来让用户对单一请求自定义重复的标识。或者可以使用一个函数<code>duplicatedKeyFn</code>统一的让用户自定义重复的标识</p>
<p>删除请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * remove the request in pendingAjax</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; config</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">removePendingAjax(config) &#123;</span><br><span class="line">  <span class="comment">// if need cancel duplicated request</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.cancelDuplicated) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> veryConfig = config.veryConfig || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> duplicatedKey = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    duplicatedKey:  veryConfig.duplicatedKey || <span class="keyword">this</span>.duplicatedKeyFn(config), </span><br><span class="line">    type: REQUEST_TYPE.DUPLICATED_REQUEST,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// if the current request exists in pendingAjax, cancel the current request and remove it</span></span><br><span class="line">  <span class="keyword">if</span> (duplicatedKey &amp;&amp; <span class="keyword">this</span>.pendingAjax.has(duplicatedKey)) &#123;</span><br><span class="line">    <span class="keyword">const</span> cancel = <span class="keyword">this</span>.pendingAjax.get(duplicatedKey);</span><br><span class="line">    cancel(duplicatedKey);</span><br><span class="line">    <span class="keyword">this</span>.pendingAjax.delete(duplicatedKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装好了， 我们在在哪里使用呢？肯定是在请求开始之前和请求完成之后使用。</p>
<p>在请求之前</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// intercept response</span></span><br><span class="line"><span class="keyword">this</span>.axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// check the previous request for cancellation before the request starts</span></span><br><span class="line">  <span class="keyword">this</span>.removePendingAjax(config);</span><br><span class="line">  <span class="comment">// add the current request to pendingAjax</span></span><br><span class="line">  <span class="keyword">this</span>.addPendingAjax(config);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在请求完成之后去掉该请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// intercept response</span></span><br><span class="line"><span class="keyword">this</span>.axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  removePending(response) </span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>到现在已经完成了该有的功能， 但是取消请求的错误我们不该返回给用户。所以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(err) =&gt; &#123;</span><br><span class="line"><span class="comment">// whether is the type of duplicated request</span></span><br><span class="line"><span class="keyword">let</span> isDuplicatedType;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> errorType = (<span class="built_in">JSON</span>.parse(error.message) || &#123;&#125;).type</span><br><span class="line">  isDuplicatedType = errorType === REQUEST_TYPE.DUPLICATED_REQUEST;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  isDuplicatedType = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isDuplicatedType) <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在请求完成之后的err里面做一个判断，判断如果当前请求是取消的类型，我们就不返回给用户错误的提示信息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此 完成了我们的封装。<a href="https://github.com/verymuch/very-axios/pull/1" target="_blank" rel="noopener">完成的pr可以点击这里查看</a>   <a href="https://github.com/shuliqi/my-project-of-axios" target="_blank" rel="noopener">本文测试npm包的项目</a></p>
<p>有任何问题可以联系我联系，联系方式：<a href="mailto:shuliqi@outlook.com" target="_blank" rel="noopener">shuliqi@outlook.com</a>  ，<a href="mailto:shuliqi@360.cn" target="_blank" rel="noopener">shuliqi@360.cn</a> </p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>必备的网络基础</title>
    <url>/shuliqi.github.io/2019/11/19/%E5%BF%85%E5%A4%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>以前，前端只需要了解 <code>HTML</code> ,  <code>css</code> , <code>js</code>这些就可以了。关于网络基础，数据结构上等的都是不甚于了解。</p>
<p>但是现在的前端圈已经发生了天翻地覆的变化，<code>Vue</code>，<code>React</code>，<code>ES6</code>，<code>HTML5</code>，<code>CSS3</code>，<code>Webpack</code>,<code>PostCss</code>等技术层出不穷，对网络基础的知识是需要了然于心的。</p>
 <a id="more"></a>
<p> 接下来，我会总结以下几个内容：</p>
<ul>
<li>五层因特网协议栈</li>
<li>HTTP 与 HTTPS 的区别</li>
<li>TCP/IP 协议</li>
<li>三次握手和四次挥手</li>
<li>DNS 域名解析</li>
<li>五类 IP 地址</li>
<li>跨域的原因及处理方式</li>
<li>正向代理和反向代理</li>
<li>CDN 带来的性能优化</li>
<li>HTTP 强缓存&amp;协商缓存</li>
</ul>
<h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><p>我五层因特网协议栈这个知识点可能会有点枯燥，但是了解了因特网协议栈之后， 你之前的某些疑问可能豁然开朗。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层（application-layer）的任务：通过应用程序之前的交互来完成特定的网络应用。协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p>
<p>对于不同的网络应用需要不同的应用层协议。</p>
<p>在互联网的应用层协议很多，比如域名系统DNS，HTTP协议等。</p>
<blockquote>
<h5 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h5><p>域名系统（Domain Name System）是因特网的一项核心服务。它作为可以将域名与ip地址相互映射的一个分布式系统，能让人更加方便的访问互联网，而不是去记住能够直接被机器读取的IP 数串。</p>
<h5 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h5><p>超文本传输协议（ HyperText Transfer Protocol ）是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。</p>
</blockquote>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层（transport layer）的任务：负责两个主机进程之间的通信提供通用的<strong>数据传输服务</strong></p>
<p>应用进程利用该服务传输应用层的报文。</p>
<blockquote>
<p>传输层常用的两种协议</p>
<ul>
<li>传输控制协议-TCP: 提供面向连接的，可靠的数据传输服务</li>
<li>用户数据协议-UDP: 提供无连接的，尽最大的努力的数据传输服务（不保证数据传输的可靠性）</li>
</ul>
</blockquote>
<h5 id="TCP-Transmissor-Control-Ptotocal"><a href="#TCP-Transmissor-Control-Ptotocal" class="headerlink" title="TCP (Transmissor Control Ptotocal)"></a>TCP (Transmissor Control Ptotocal)</h5><ul>
<li>TCP是面向连接的（即需要先建立连接）;</li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能一对一；</li>
<li>TCP提供可靠交付的服务，通过TCP连接的传送的数据，是不会有差错，不会丢失，不会重复，而且是按序到达；</li>
<li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li>面向字节流。TCP 中的“流“（Stream）指的是流入进程或者从进程流出的字节序列；</li>
</ul>
<h5 id="UDP-User-Datagram-Protocol"><a href="#UDP-User-Datagram-Protocol" class="headerlink" title="UDP (User Datagram Protocol)"></a>UDP (User Datagram Protocol)</h5><ul>
<li>UDP是无连接的；</li>
<li>UDP是尽最大的努力交付，即不保证可靠交付，因此主机是不需要维持复杂的链接状态的；</li>
<li>UDP 是面向报文的；</li>
<li>UDP 没有拥塞控制的，因此网络出现拥塞不会使源主机的发送效率降低（对实时应用比较有用，如：直播）</li>
<li>UDP 支持一对一， 一对多，多对一，多对多的交互通信</li>
<li>UDP 的首部开销小，只有8 个字节，比TCP的20个字节的首部要短</li>
</ul>
<blockquote>
<ol>
<li>单工数据传输只支持数据在一个方向上传输</li>
<li>半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；</li>
<li>全双工数据通信允许数据同时在两个方向上传输，因此，<strong>全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。</strong></li>
</ol>
</blockquote>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层的任务：选择可是的网间路由和交换节点，确保几端机通信的数据及时送达。在发送数据时，网络层把运输层产生的报文或长用户数据报封装成分组和包进行传送。在TCP/IP的体系结构中，由于网络层使用IP协议，因此分组也叫IP 数据报，简称数据报。</p>
<blockquote>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互链接起来的, 互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多的路由选择协议，因此互联网的网络层也叫做网际层或者IP层。</p>
</blockquote>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输， 总是在一段一段的的链路上传送，这就需要使用专门的链路层的协议。</p>
<p>两个相邻节点之间传输数据时，数据链路层将网络层接下来的IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息等。</p>
<blockquote>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。</p>
</blockquote>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。</p>
<h5 id="OSI七层协议模型-和-TCP-IP四层模型的区别"><a href="#OSI七层协议模型-和-TCP-IP四层模型的区别" class="headerlink" title="OSI七层协议模型 和 TCP/IP四层模型的区别"></a>OSI七层协议模型 和 TCP/IP四层模型的区别</h5><blockquote>
<p> <strong>OSI 七层模型：</strong> 应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p>
<p> <strong>TCP/IP四层模型：</strong>应用层、传输层、网络层和链路层</p>
</blockquote>
<img src="/shuliqi.github.io/2019/11/19/必备的网络基础/1.webp">
<h3 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h3><table>
<thead>
<tr>
<th>区别</th>
<th style="text-align:center">HTTP</th>
<th style="text-align:center">HTTPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>协议</td>
<td style="text-align:center">运行在 TCP 之上，明文传输，<strong>客户端与服务器端都无法验证对方的身份</strong></td>
<td style="text-align:center">身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， <strong>是添加了加密和认证机制的 HTTP</strong>。</td>
</tr>
<tr>
<td>端口</td>
<td style="text-align:center">80</td>
<td style="text-align:center">443</td>
</tr>
<tr>
<td>资源消耗</td>
<td style="text-align:center">较少</td>
<td style="text-align:center">由于加解密处理，会消耗更多的 CPU 和内存资源</td>
</tr>
<tr>
<td>开销</td>
<td style="text-align:center">无需证书</td>
<td style="text-align:center">需要证书，而证书一般需要向认证机构购买</td>
</tr>
<tr>
<td>加密机制</td>
<td style="text-align:center">无</td>
<td style="text-align:center">共享密钥加密和公开密钥加密并用的混合加密机制</td>
</tr>
<tr>
<td>安全性</td>
<td style="text-align:center">弱</td>
<td style="text-align:center">由于加密机制，安全性强</td>
</tr>
</tbody>
</table>
<h4 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h4><p>对称密钥加密是指加密和解密使用同一个密钥的方式，<strong>这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</strong><br>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。<br>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢.</p>
<p>综上所诉：我们还是用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><p>HTTP2 可以提高了网页的性能。</p>
<p>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</p>
<p>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</p>
<h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><h4 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h4><p>按层次分，IP（Internet Protocol）网际协议位于网络层，IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件，其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。</p>
<blockquote>
<p>IP 地址和 MAC 地址： 指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址，IP 地址可以和 MAC 地址进行配对。<strong>IP 地址可变换，但 MAC 地址基本上不会更改。</strong></p>
</blockquote>
<p><strong>使用 ARP 协议凭借 MAC 地址进行通信</strong></p>
<ol>
<li>IP 间的通信依赖 MAC 地址。</li>
<li>ARP 是一种用以解释地址的协议，根据通信方的 IP 地址就可以反查出对应方的 MAC 地址。</li>
</ol>
<h4 id="TCP-协议如何保持传输的可靠性"><a href="#TCP-协议如何保持传输的可靠性" class="headerlink" title="TCP 协议如何保持传输的可靠性"></a>TCP 协议如何保持传输的可靠性</h4><p><strong>1. 面向连接</strong><br>意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；<br><strong>2. 字节流服务</strong><br>意味着两个应用程序通过 TCP 连接交换 8bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。</p>
<p><strong>TCP 之所以可靠，大体上由于以下原因：</strong></p>
<ol>
<li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</li>
<li>对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；</li>
<li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li>
<li>应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li>
<li>超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li>
<li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。</li>
</ol>
<h4 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h4><p>图解：</p>
<img src="/shuliqi.github.io/2019/11/19/必备的网络基础/3.webp">
<p>发送端在层与层之间传输数据时，每经过一层必定会加上一个该层的首部信息。反之，接收端在层与层之间传输数据时，每经过一层会把相关的首部信息</p>
<h3 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h3><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><img src="/shuliqi.github.io/2019/11/19/必备的网络基础/4.webp">
<p><strong>第一次握手：</strong><br>建立连接时，向服务器发出连接请求报文，这是报文首部中的同部位 SYN = 1，同时选择一个初始序列号 seq = x ，客户端进程进入了 SYN-SENT （同步已发送状态）状态,等待服务器确认；<br><strong>第二次握手：</strong><br>服务器收到 syn 包后，如果同意连接，则发出确认报文; 确认报文 ACK = 1，SYN = 1，确认号是 ack = x + 1，同时也要为自己初始化一个序列号 seq = y，此时服务器进程进入了 SYN-RCVD（同步收到）状态；<br><strong>第三次握手：</strong><br>客户端收到服务器的 SYN+ACK 包，要向服务器给出确认。确认报文的 ACK = 1，ack = y + 1，自己的序列号 seq = x + 1，此时，TCP 连接建立，客户端进入 ESTABLISHED （已建立连接）状态。</p>
<p>完成三次握手，客户端与服务器开始传送数据。</p>
<blockquote>
<p>注：<br>seq:”sequance” 序列号；<br>ack:”acknowledge” 确认号；<br>SYN:”synchronize” 请求同步标志；<br>ACK:”acknowledge” 确认标志；<br>FIN:”Finally” 结束标志。</p>
</blockquote>
<p><strong>未连接队列</strong><br>在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户端发出确认，正在等待客户端的确认包。这些条目所标识的连接在服务器处于 SYN_RECV状态，当服务器收到客户端的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p>
<blockquote>
<p>建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由 TCP 的半关闭（half-close）造成的。</p>
</blockquote>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><img src="/shuliqi.github.io/2019/11/19/必备的网络基础/4.webp">
<p> <strong>第一次挥手：</strong><br>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN=1，其序列号为 seq = u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入 FIN-WAIT-1（终止等待1）状态。<br><strong>第二次挥手：</strong><br>服务器收到连接释放报文，发出确认报文，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。</p>
<blockquote>
<p>TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。<br>客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p>
</blockquote>
<p><strong>第三次挥手：</strong><br>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN = 1，ack = u + 1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。 <strong>第四次挥手：</strong><br>客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1，ack = w + 1，而自己的序列号是 seq = u + 1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。</p>
<blockquote>
<p>注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</p>
</blockquote>
<p>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。</p>
<blockquote>
<p>可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p>
</blockquote>
<p><strong>四次的原因</strong></p>
<p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。 但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你未必会马上会关闭 SOCKET ,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的.</p>
<blockquote>
<p>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
</blockquote>
<h3 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h3><p>当你在浏览器的地址栏输入 <code>https://www.baidu.com/</code> 后会发生什么，大家在心中肯定是有一个大概的想法。</p>
<img src="/shuliqi.github.io/2019/11/19/必备的网络基础/6.webp">
<h4 id="查找域名对应的-IP-地址的具体过程"><a href="#查找域名对应的-IP-地址的具体过程" class="headerlink" title="查找域名对应的 IP 地址的具体过程"></a>查找域名对应的 IP 地址的具体过程</h4><ol>
<li>浏览器搜索自己的 DNS 缓存（浏览器维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步；</li>
<li>搜索操作系统中的 DNS 缓存；如果没有命中，进入下一步；</li>
<li>搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步；</li>
</ol>
<blockquote>
<ol>
<li>操作系统将域名发送至 LDNS （本地区域名服务器），LDNS 查询自己的 DNS 缓存（一般命中率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：</li>
<li>LDNS向 Root Name Server（根域名服务器，如com、net、im 等的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 im 域的顶级域名服务器的地址；</li>
<li>LDNS 向 im 域的顶级域名服务器发起请求，返回 juejin.im 域名服务器地址；</li>
<li>LDNS 向 juejin.im 域名服务器发起请求，得到 juejin.im 的 IP 地址；</li>
<li>LDNS 将得到的 IP 地址返回给操作系统，同时自己</li>
</ol>
</blockquote>
<h4 id="DNS-Prefetch"><a href="#DNS-Prefetch" class="headerlink" title="DNS Prefetch"></a>DNS Prefetch</h4><p>即 DNS 预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点：</p>
<ol>
<li>减少 DNS 的请求次数</li>
<li>进行 DNS 预获取</li>
</ol>
<p>典型的一次 DNS 解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验。</p>
<h3 id="五类-IP-地址"><a href="#五类-IP-地址" class="headerlink" title="五类 IP 地址"></a>五类 IP 地址</h3><p><strong>网络地址：</strong>用于识别主机所在的网络；<br><strong>主机地址：</strong>用于识别该网络中的主机。</p>
<p>IP地址分为五类：</p>
<ol>
<li>A 类保留给政府机构</li>
<li>B 类分配给中等规模的公司</li>
<li>C 类分配给任何需要的人</li>
<li>D 类用于用于特殊用途. 又称做广播地址</li>
<li>E 类暂时保留</li>
</ol>
<blockquote>
<p>各类可容纳的地址数目不同。其中A类、B类、和C类这三类地址用于 TCP/IP 节点，其它两类D类和E类被用于特殊用途。</p>
</blockquote>
<p>图解如下：</p>
<img src="/shuliqi.github.io/2019/11/19/必备的网络基础/6.webp">
<h5 id="一-A类地址"><a href="#一-A类地址" class="headerlink" title="一. A类地址"></a>一. A类地址</h5><p>第一个八位段为网络地址，其它为主机地址，第一个八位段首位一定为0；<br>范围：1.0.0.1—126.155.255.254；<br>私有地址和保留地址：<br>10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。<br>127.X.X.X是保留地址，用做循环测试用的。</p>
<h5 id="二-B类地址"><a href="#二-B类地址" class="headerlink" title="二. B类地址"></a>二. B类地址</h5><p>第一个八位段和第二个八位段为网络地址，其它为主机地址，第一个八位段首位一定为10；<br>范围：128.0.0.1—191.255.255.254。<br>私有地址和保留地址:<br>172.16.0.0—172.31.255.255是私有地址<br>169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。</p>
<h5 id="三-C类地址"><a href="#三-C类地址" class="headerlink" title="三. C类地址"></a>三. C类地址</h5><p>前三个八位段为网络地址，第4个个字节为主机地址，第一个八位段首位一定为110。<br>范围：192.0.0.1—223.255.255.254。<br>私有地址：<br>192.168.X.X是私有地址。</p>
<h5 id="四-D类地址"><a href="#四-D类地址" class="headerlink" title="四. D类地址"></a>四. D类地址</h5><p>不分网络地址和主机地址，第一个八位段首位一定为1110。<br>范围：224.0.0.1—239.255.255.254</p>
<h5 id="五-E类地址"><a href="#五-E类地址" class="headerlink" title="五. E类地址"></a>五. E类地址</h5><p>不分网络地址和主机地址，第一个八位段首位一定为11110。<br>范围：240.0.0.1—255.255.255.254</p>
<h3 id="跨域的原因及处理方式"><a href="#跨域的原因及处理方式" class="headerlink" title="跨域的原因及处理方式"></a>跨域的原因及处理方式</h3><p>出现跨域的原因是由于 浏览器的同源策略 所决定的。</p>
<blockquote>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>
</blockquote>
<p>这个说法一如既往的很官方，犹如女神的一句 呵呵，让人不知所以然。接下来就从 Dom 查询和接口请求来说明同源策略的必要性</p>
<h4 id="接口请求-假设没有同源策略"><a href="#接口请求-假设没有同源策略" class="headerlink" title="接口请求(假设没有同源策略)"></a>接口请求(假设没有同源策略)</h4><p>我们来看场景：<br>1.你打开 <code>www.taobao.com</code>，准备购买你已经添加在购物车的《JavaScript 高级程序设计》。<br>2.当你刚想付款的时候，有一个人发给你一个链接 <code>www.heiheihei.com</code>，你的眼神突然变得正经了，而后毫不犹豫的点了进去。<br>3.你很正经的观看 <code>www.heiheihei.com</code> 中的内容， <code>www.heiheihei.com</code> 也没有闲着，由于没有同源策略的限制，它向 <code>www.taobao.com</code> 发起了请求！暗地里为所欲为的做一些为所欲为的事情。</p>
<h4 id="Dom-查询-假设没有同源策略"><a href="#Dom-查询-假设没有同源策略" class="headerlink" title="Dom 查询(假设没有同源策略)"></a>Dom 查询(假设没有同源策略)</h4><p>1.星期一的早上，你像往常一样点开淘宝，在淘宝里逛起了街，不过今天你没有在意为什么今天需要登陆。</p>
<p>为什么需要登录呢？我就假设这是有心之人恶意为之，这个登陆页面做了什么呢？我再假设页面有以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// HTML&lt;iframe name=&quot;taobaoo&quot; src=&quot;www.taobaoo.com&quot;&gt;&lt;/iframe&gt;// JS// 由于没有同源策略的限制， Dom 可以直接拿到。const iframe = window.frames[&apos;taobaoo&apos;];const account = iframe.document.getElementById(&apos;***&apos;)const pw = iframe.document.getElementById(&apos;***&apos;)// 密码账号被偷走了</span><br></pre></td></tr></table></figure>
<p>从上面两种情况，我们初步了解同源策略确实能规避一些危险，不是说有了同源策略就安全，只是说同源策略是一种浏览器最基本的安全机制，毕竟能提高一点攻击的成本。</p>
<h4 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h4><ol>
<li>通过 jsonp 跨域</li>
<li>document.domain + iframe 跨域</li>
<li>location.hash + iframe</li>
<li>window.name + iframe跨域</li>
<li>postMessage 跨域</li>
<li>跨域资源共享（ CORS ）</li>
<li>nginx 代理跨域</li>
<li>nodejs 中间件代理跨域</li>
<li>WebSocket 协议跨域</li>
</ol>
<p>挑几个方案讲解</p>
<h5 id="一、JSONP"><a href="#一、JSONP" class="headerlink" title="一、JSONP"></a>一、JSONP</h5><p>JSONP 的原理很简单，就是利用 <code>标签没有跨域限制的漏洞。通过</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。 JSONP 使用简单且兼容性不错，但是只限于 get 请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>); </span><br><span class="line">  script.src = url;</span><br><span class="line">  script.async = <span class="literal">true</span>;</span><br><span class="line">  script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChi ld(script);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="二、CORS"><a href="#二、CORS" class="headerlink" title="二、CORS"></a>二、CORS</h5><p>CORS 需要浏览器和后端同时支持。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<h5 id="三、nginx-代理跨域"><a href="#三、nginx-代理跨域" class="headerlink" title="三、nginx 代理跨域"></a>三、nginx 代理跨域</h5><p>利用 Nginx 反向代理实现跨域。</p>
<p>虚拟主机的配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 8080;                         # 监听的端口</span><br><span class="line">  server_name  192.168.1.1;            # 配置访问域名    </span><br><span class="line">  root  /data/toor;                    # 站点根目录    </span><br><span class="line">  error_page 502 404 /page/404.html;   # 错误页面    </span><br><span class="line">  location ^~ /api/  &#123;                 # 使用 /api/ 代理 proxy_pass 的值                         proxy_pass http://192.168.20.1:8080;          # 被代理的应用服务器 HTTP 地址    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制代码以上简单的配置就可以实现反向代理的功能，跨域的问题也就解决了。</p>
<p>在 Vue 中就可以使用 proxyTable 这个属性进行相关的配置来解决跨域问题带来的烦恼。配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxyTable: &#123;    </span><br><span class="line">  <span class="string">'/weixin'</span>: &#123;        </span><br><span class="line">     target: <span class="string">'http://192.168.48.11:8100/'</span>, <span class="comment">// 接口的域名         </span></span><br><span class="line">     secure: <span class="literal">false</span>,      <span class="comment">// 如果是 https 接口，需要配置这个参数        </span></span><br><span class="line">     changeOrigin: <span class="literal">true</span>, <span class="comment">// 如果接口跨域，需要进行这个参数配置        </span></span><br><span class="line">       pathRewrite: &#123;            </span><br><span class="line">         <span class="string">'^/weixin'</span>: <span class="string">''</span>        </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h3><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><ol>
<li>代理客户;</li>
<li>隐藏真实的客户，为客户端收发请求，使真实客户端对服务器不可见;</li>
<li>一个局域网内的所有用户可能被一台服务器做了正向代理，由该台服务器负责 HTTP 请求;</li>
<li>意味着同服务器做通信的是正向代理服务器;</li>
</ol>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ol>
<li>代理服务器;</li>
<li>隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见;</li>
<li>负载均衡服务器，将用户的请求分发到空闲的服务器上;</li>
<li>意味着用户和负载均衡服务器直接通信，即用户解析服务器域名时得到的是负载均衡服务器的 IP ;</li>
</ol>
<h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ol>
<li><p>都是做为服务器和客户端的中间层</p>
</li>
<li><p>都可以加强内网的安全性，阻止 web 攻击</p>
</li>
<li><p>都可以做缓存机制</p>
</li>
</ol>
<h3 id="CDN-带来的性能优化"><a href="#CDN-带来的性能优化" class="headerlink" title="CDN 带来的性能优化"></a>CDN 带来的性能优化</h3><blockquote>
<p>CDN的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。</p>
</blockquote>
<p>举个例子</p>
<p>1.在淘宝购物<br>我们在淘宝购物，大部分个人卖家只是在一个地方发货，江浙沪以外的地方好像收货都比较慢。</p>
<p>2.在京东购物<br>而我们在京东上买自营产品的话，它会根据我们的收货地点，在全国范围内找离我们最近、送达最快的仓库，不管我们在江浙沪，还是新疆西藏内蒙古，我们的收货时间都会大大减少。京东建立的仓储系统，就类似于 CDN。</p>
<h4 id="CDN的优势"><a href="#CDN的优势" class="headerlink" title="CDN的优势"></a>CDN的优势</h4><ol>
<li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；</li>
<li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载。</li>
</ol>
<blockquote>
<p>访问速度快是电商网站取胜的必要法宝之一。</p>
</blockquote>
<h4 id="DN-的工作模式"><a href="#DN-的工作模式" class="headerlink" title="DN 的工作模式"></a>DN 的工作模式</h4><p>比如我们 SHEIN 主站的根服务器中国深圳，CDN 服务器在美国加州，欧洲法国，印度等三个地方（真实的细致很多）。</p>
<h5 id="没有-CDN-服务器"><a href="#没有-CDN-服务器" class="headerlink" title="没有 CDN 服务器"></a>没有 CDN 服务器</h5><p>那么全球 6000 万用户请求的资源都是从中国深圳的机房发出的，这样一位美国加州的用户在打开首页的延时可能足够她画一个精致的妆容了。（PS: 深圳前端团队在招前端开发，有需求的可以私信我）</p>
<h5 id="有-CDN-服务器"><a href="#有-CDN-服务器" class="headerlink" title="有 CDN 服务器"></a>有 CDN 服务器</h5><p>此时还是这位加州的用户想打开 SHEIN 打算购买一件晚礼服参加晚会。这次她视线还没有移到梳妆台，首页就已经打开了，然后她就开心的购物了。</p>
<p>这就是因为 CDN 服务器。</p>
<p>美国加州的 CDN 服务器，已经将根节点的资源复制过来了。并且我们有个机制，CDN 节点的资源十分钟会回源更新一次。所以在用户请求资源的时候是不会回源到深圳的根服务器请求的。这样不会出现用户在请求资源的时候，因为回源而导致的网络延时。</p>
<blockquote>
<p>CDN 的核心点有两个: 一个是缓存，一个是回源。</p>
</blockquote>
<h5 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h5><ol>
<li>内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；</li>
<li>内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程 POP 上均衡用户的请求，以使用户请求得到最近内容源的响应；</li>
<li>内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；</li>
<li>性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。</li>
</ol>
<p>前端往往认为 CDN 是不需要了解的知识。可是我们前端工程首先是软件工程师。多了解一些东西肯定是有益的。</p>
<h4 id="CDN-amp-静态资源"><a href="#CDN-amp-静态资源" class="headerlink" title="CDN &amp; 静态资源"></a>CDN &amp; 静态资源</h4><p>态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。CDN 是静态资源提速的重要手段。</p>
<p><strong>淘宝</strong></p>
<img src="/shuliqi.github.io/2019/11/19/必备的网络基础/taobao.webp">
<p><strong>掘金</strong></p>
<img src="/shuliqi.github.io/2019/11/19/必备的网络基础/juejin.webp">
<p>我们随手打开一个网站点开一个静态资源，可以看到它都是从 CDN 服务器上请求来的。可以看出 “静态资源走 CDN” 是最佳实践。</p>
<h4 id="CDN-amp-Cookie"><a href="#CDN-amp-Cookie" class="headerlink" title="CDN &amp; Cookie"></a>CDN &amp; Cookie</h4><p>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带相同的 Cookie。</p>
<p>但是如果我们只是请求一张图片，我们在请求中还要携带一个笨重的 Cookie 来回的跑，Cookie 中的信息和图片又是没有关联的，这种情况就很让人头痛了。Cookie 虽然小，但是随着请求的越来越多，这种的不必要的 Cookie 带来的开销将是无法想象的……</p>
<blockquote>
<p>静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，就可以完美地避免请求中携带不必要的 Cookie。</p>
</blockquote>
<p>看起来是一个不起眼的小细节，但带来的效用却是惊人的。电商网站静态资源的流量之庞大，如果没把这个多余的 Cookie 拿下来，不仅用户体验会大打折扣，每年因性能浪费导致的开销也会非常之高。</p>
<h3 id="HTTP-强缓存-amp-协商缓存"><a href="#HTTP-强缓存-amp-协商缓存" class="headerlink" title="HTTP 强缓存&amp;协商缓存"></a>HTTP 强缓存&amp;协商缓存</h3><p><strong>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。</strong> 当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。<br>这样带来的好处是缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。<br>缓存大致可归为两类：<strong>私有缓存与共享缓存</strong>。<br>共享缓存能够被多个用户使用；<br>私有缓存只能用于单独用户；</p>
<blockquote>
<p><code>HTTP</code> 协议主要是通过请求头当中的一些字段来和服务器进行通信，从而采用不同的缓存策略。<br><code>HTTP</code> 通过缓存将服务器资源的副本保留一段时间，这段时间称为<strong>新鲜度限值</strong>。这在一段时间内请求相同资源不会再通过服务器。<br><code>HTTP</code> 协议中 <code>Cache-Control</code> 和 <code>Expires</code> 可以用来设置新鲜度的限值。</p>
</blockquote>
<h4 id="强缓存-Cache-Control-和-Expires"><a href="#强缓存-Cache-Control-和-Expires" class="headerlink" title="强缓存 ( Cache-Control 和 Expires )"></a>强缓存 ( Cache-Control 和 Expires )</h4>]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>文本超出显示省略号的一个完美的方案</title>
    <url>/shuliqi.github.io/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>之前做项目需求的时候呢。会经常碰到文本内容超出的问题。通常UI设计师会叫我们超出的话显示省略号。由于之前做这样的需求一直没有整理文本内容超出省略的方案。那么这篇博客就好好整理一下吧。</p>
<a id="more"></a>
<p>我们知道CSS3定义了一个文本省略方案<code>text-overflow</code></p>
<p>MDN上是这么说的：</p>
<blockquote>
<p>text-overflow 是一个css 属性，确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号（…）或者显示一个自定义的字符串</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">text-overflow: ellipsis || clip ||  &lt;string&gt;</span><br></pre></td></tr></table></figure>
<p><code>clip:</code> 在内容区域的极限处截断文本。因此在字符串的中间可能在中间发生截断</p>
<p><code>ellipsis:</code>用一个省略号（…）表示被截断的文本。这个省略号被添加在内容区域中。因此会减少显示文本。 如果是空间太少，那么省略号也会被截断。</p>
<p><code>&lt;string&gt;:</code>用自定义字符串来表示被截断的文本。字符串内容将被添加在内容区域中，所以会减少显示出的文本。如果空间太小到连省略号都容纳不下，那么这个字符串也会被截断。</p>
<p>但是有一点要非常注意：</p>
<blockquote>
<p>这个属性只对那些块级元素溢出的内容有效。但是必须与块级元素内联(inline)方向一致（举一个反例：内容在盒子的下方溢出。此时就不会生效）</p>
</blockquote>
<p>这句话简单的理解就是：text-overflow 只管行文本溢出的省略。</p>
<p>于是文本省略分成了<strong>单行文本省略</strong>和<strong>多行文本省略</strong>。</p>
<h2 id="单行文本省略"><a href="#单行文本省略" class="headerlink" title="单行文本省略"></a>单行文本省略</h2><p>由以上我们知道<strong>text-overflow</strong> 是可以解决单行文本省略的。但是毕竟是css3出的属性， 我们先看看它的兼容性：</p>
<img src="/shuliqi.github.io/2020/06/22/文本超出显示省略号的一个完美的方案/1.webp">
<p>可以看出它的兼容性是非常好的。所以可以放心愉快的使用吧</p>
<p>当然了，不是只使用<strong>text-overflow：ellipsis</strong> 就可以实现文本省略的。</p>
<p>上头我们我们也说过：</p>
<blockquote>
<p>这个属性只对那些块级元素溢出的内容有效。但是必须与块级元素内联(inline)方向一致（举一个反例：内容在盒子的下方溢出。此时就不会生效）</p>
</blockquote>
<p>文本可能在以下情况下溢出：当其因为某种原因而无法换行(例如：设置了”white-space:nowrap”)，或者一个单词因为太长而不能合理地被安置(fit)。</p>
<p>因此为了让<strong>text-overflow</strong> 能够生效。我们必须要在元素上添加几个属性和满足一些规则：</p>
<ul>
<li>块级元素</li>
<li>overflow：计算值非visible</li>
<li>元素的宽度：超出时， 有一个确切的计算值</li>
<li>white-space：nowrap ||  pre</li>
</ul>
<p>解释一下这几个规则：</p>
<ul>
<li>overflow确实是非visible， 但是计算值并不是设定值， 因为css有个叫inhert的关键字</li>
<li>元素宽度： 不是元素的width。max-width，以及flex 布局都是可以的。</li>
<li>white-space:pre也是可以的， 因为这个属性的设置主要就是为了不折行。</li>
</ul>
<p>举个比较普遍的例子：</p>
<p>html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">  我的名字我的名字  我的名字  我的名字  我的名字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.name</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 元素的宽度: 超出时， 有一个确切的计算值 */</span></span><br><span class="line">  <span class="comment">/* 元素宽度： 不只可以是元素的width。max-width，以及flex 布局都是可以的。 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* overflow：计算值非visible */</span></span><br><span class="line">  <span class="comment">/*  overflow确实是非visible， 但是计算值并不是设定值， 因为css有个叫inhert的关键字  */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 不折行:white-space: pre || nowrap */</span></span><br><span class="line">  <span class="comment">/* pre也是可以的， 因为这个属性的设置主要就是为了不折行。  */</span></span><br><span class="line">  <span class="attribute">white-space</span>: pre;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果： </p>
<img src="/shuliqi.github.io/2020/06/22/文本超出显示省略号的一个完美的方案/2.png">
<p><a href="https://codepen.io/shuliqi/pen/WNrjoya" target="_blank" rel="noopener"><strong>本例子代码–&gt;可点击查看</strong></a></p>
<p><strong>flex布局实现</strong></p>
<p>html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ellipsis"</span>&gt;</span></span><br><span class="line">    元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的		元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的		元素的宽度我使用flex布局也是可行的</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.name</span> &#123;</span><br><span class="line">  display：flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ellipsis</span> &#123;</span><br><span class="line">   <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 元素的宽度: 超出时， 有一个确切的计算值 */</span></span><br><span class="line">  <span class="comment">/* 元素宽度： 不只可以是元素的width。max-width，以及flex 布局都是可以的。 */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* overflow：计算值非visible */</span></span><br><span class="line">  <span class="comment">/*  overflow确实是非visible， 但是计算值并不是设定值， 因为css有个叫inhert的关键字  */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 不折行:white-space: pre || nowrap */</span></span><br><span class="line">  <span class="comment">/* pre也是可以的， 因为这个属性的设置主要就是为了不折行。  */</span></span><br><span class="line">  <span class="attribute">white-space</span>: pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<img src="/shuliqi.github.io/2020/06/22/文本超出显示省略号的一个完美的方案/3.png">
<p><a href="https://codepen.io/shuliqi/pen/LYGyWRM" target="_blank" rel="noopener"><strong>本例子代码—&gt;可点击查看</strong></a></p>
<p> <strong>其他的规则：</strong></p>
<ul>
<li><a href="https://codepen.io/shuliqi/pen/VwebprJ" target="_blank" rel="noopener"><strong>max-width设置元素宽度</strong></a></li>
<li><a href="https://codepen.io/shuliqi/pen/GRomWxp?editors=1100" target="_blank" rel="noopener"><strong>overflow 设置为其他值（auto, scroll等）</strong></a></li>
<li><a href="https://codepen.io/shuliqi/pen/mdVmWKe" target="_blank" rel="noopener"><strong>white-space设置为nowrap</strong></a></li>
</ul>
<p>其余的其他设置我就不一一举例验证了。如果验证的时候有问题可以给我留言。</p>
<h2 id="多行文本省略"><a href="#多行文本省略" class="headerlink" title="多行文本省略"></a>多行文本省略</h2><h4 id="使用-webkit-line-clamp"><a href="#使用-webkit-line-clamp" class="headerlink" title="使用 webkit-line-clamp"></a>使用 webkit-line-clamp</h4><p>多行文本的省略，也有实现方法，但是只是针对<strong>webkit系</strong>浏览器<strong>-webkit-line-clamp</strong></p>
<p>MDN上是这么说的：</p>
<blockquote>
<p>–webkit-line-clamp： CSS属性 可以把<strong>块容器</strong>中的内容限定为指定的行数</p>
</blockquote>
<p><strong>–webkit-line-clamp</strong> 的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-webkit-line-clamp: none || integer</span><br></pre></td></tr></table></figure>
<ul>
<li>none:表示值显示的内容不会被限制</li>
<li>integer： 这个值表示内容显示多少行之后会被限制，必须大于0</li>
</ul>
<p>这个属性的规则：</p>
<ul>
<li>-webkit-line-clamp 只有在 <strong>display</strong> 设置为<strong>-webkit-box</strong> 或者<strong>-webkit-inline-box</strong> 并且设置<strong>-webkit-box-orient</strong> 为<strong>vertical</strong>时才有效果</li>
<li>在大部分情况下,也需要设置overflow属性为 <code>hidden</code>, 否则,里面的内容不会被裁减,并且在内容显示为指定行数后还会显示省略号(ellipsis ).</li>
</ul>
<p>来看个例子：</p>
<p>html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"line"</span>&gt;</span></span><br><span class="line">  我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* display 设置为-webkit-box 或者-webkit-inline-box */</span></span><br><span class="line">   <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="comment">/* -webkit-box-orient 必须设置为vertical */</span></span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">  <span class="comment">/*   -webkit-line-clamp: none || integer */</span></span><br><span class="line">  <span class="attribute">-webkit-line-clamp</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/* 在大部分情况下,也需要设置overflow属性为 `hidden`, 否则,里面的内容不会被裁减,并且在内容显示为指定行数后还会显示省略号(ellipsis ). */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<img src="/shuliqi.github.io/2020/06/22/文本超出显示省略号的一个完美的方案/4.png">
<p>我们最后来看看 -webkit-line-clamp的兼容性：</p>
<img src="/shuliqi.github.io/2020/06/22/文本超出显示省略号的一个完美的方案/5.webp">
<p>兼容性和上头的 text-overflow 比起来，很惨。都是清一色的Webkit。 而且-wbkit-line-clamp 连 line-clamp 都不是。为什么是<code>-webkit-line-clamp</code>呢？因为</p>
<ol>
<li>W3C没规范</li>
<li>Webkit系自己YY的：所以带-webkit-</li>
</ol>
<p>而且由以上的规则我们知道-webkit-line-clamp 依赖与 box 布局，而且是最老的Flex布局方案，已经由最新版的代替flex替代。 如果这个这个属性要进W3C规范，就得改改了。 换一句话来说，现在的写法很有可能在未来不再使用。估计结局是这两种：</p>
<ul>
<li>W3C收录规范：规则要改，因为box迟早会被废弃</li>
<li>W3C自己定义一个新的属性：整个废弃掉</li>
</ul>
<p>结论：如果是不是别误选择，还是不建议使用</p>
<h4 id="大多数网上的方案（css）"><a href="#大多数网上的方案（css）" class="headerlink" title="大多数网上的方案（css）"></a>大多数网上的方案（css）</h4><p>本着一种能使用css 实现的， 就不用js实现的想法。</p>
<p>在使用其他css 方式之前， 我们来看一下无论单行还是多行实现超出省略的原理：</p>
<blockquote>
<p>不管是多行截断还是多行截断，实际上，浏览器并没有把超长的文字删除，而是在渲染的时候在块尾渲染一个”…”覆盖在上面。规则里面的overflow的计算值为非visible， 所以在视觉上是看不到的。</p>
</blockquote>
<p>所以我们自己实现的方式的原理也是这样的（<strong>拿个… 盖到上面去</strong>）</p>
<p>…的方案很简单，可以使用一个特定的元素， 也可以使用::after伪元素。我们可以看一个例子。</p>
<p>html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"line"</span>&gt;</span></span><br><span class="line">  我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.line</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"..."</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">42px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<img src="/shuliqi.github.io/2020/06/22/文本超出显示省略号的一个完美的方案/6.png">
<p><a href="https://codepen.io/shuliqi/pen/LYGyaom?editors=1100" target="_blank" rel="noopener"><strong>此例子的代码–&gt;可点击查看</strong></a></p>
<p>现在， 一切看都挺不错的。顺便网上一搜， 都是这样的实现方案。</p>
<p>但是，这个方案存在一个很严重的问题：<strong>默认的认为内容一定会溢出</strong></p>
<p>网上写这个方案的时候有些也会还有一些提示：计算一下内容会不会溢出。</p>
<p>额，这提示…还不入不提示。 如果需要 js 计算， 那好不如一开始就使用js的方式实现了呢。为啥还整出 css + js 的方案呢？</p>
<h4 id="一个完美的方案"><a href="#一个完美的方案" class="headerlink" title="一个完美的方案"></a>一个完美的方案</h4><p>如果我们想实现 <strong>仅仅当内容溢出时， 显示…省略</strong> 这样的方案， 我们该如何做呢？</p>
<p>我们回想一下我们上头的方案，我们是拿”…“ 盖住了右下角的内容来实现的省略。其实， 同样的道理，我们可以 <strong>拿个东西盖住…</strong></p>
<p>原理还是那个原理，只是换了谁盖谁，所以我们的实现方案可以是：<strong>当且仅当内容溢出时，不盖住…</strong></p>
<p>但是， 我们如何使用css 实现这样的效果呢？ 我们怎么知道什么时候内容溢出呢？</p>
<p>我们抽象理解一下这个方案：</p>
<ul>
<li><p>假设我们的内容是用一个数组存储的，我们的内容框只能承载20个字，也就是说，我们的数组length一旦大于20，index &gt;= 20的元素就不能再显示了。</p>
</li>
<li><p>现在，我们的数组是空的，我们给它丢个字（假设为：略）进去，使用栈方法，从头往里一直丢字（unshift(‘X’)，X为某个字），那第一次丢进去的“略”字，就会被一直往后推，直到它被推到20的位置，“略”字就“不再显示”了。</p>
</li>
</ul>
<p><strong>原理：</strong></p>
<p>对<code>...</code>的覆盖，我们也用“推”的方法，想象一下，我们找个<code>东西</code>，把它盖到<code>...</code>上，这就是第一个字“略”，然后，我们一直在这个<code>东西</code>前面添加我们的文本内容，当我们把这个<code>东西</code>推到框外时，就意味着我们的内容溢出了，<code>...</code>需要显示。而在此之前，由于<code>东西</code>一直处在<code>index &lt; 20</code>，所以，它就一直存在，一直盖住<code>...</code>，这就是：内容未溢出，不显示<code>...</code></p>
<p>原理讲完了， 我们来简单实现一下这个方案，这个原理实现的方案很多， 看自己怎么写。看个例子：</p>
<p>html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"line"</span>&gt;</span></span><br><span class="line"> 手动添加这里的内容看结果哦 手动添加这里的内容看结果哦 手动添加这里的内容看结果哦 手动添加这里的内容看结果哦</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">90px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 实现省略号 */</span></span><br><span class="line"><span class="selector-class">.line</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"..."</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">70px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 盖住...的内容 */</span></span><br><span class="line"><span class="selector-class">.line</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果： 当内容没有超出的时候， 省略号（…）被盖住。当内容超出时。省略号（…）不被盖住</p>
<img src="/shuliqi.github.io/2020/06/22/文本超出显示省略号的一个完美的方案/7.png">
<img src="/shuliqi.github.io/2020/06/22/文本超出显示省略号的一个完美的方案/8.png">
<p><a href="https://codepen.io/shuliqi/pen/abdWxEa?editors=1101" target="_blank" rel="noopener"><strong>这个例子的代码—&gt; 点击查看</strong></a></p>
<p>这是我认为的比较完美的纯css 方案了</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的渲染流程</title>
    <url>/shuliqi.github.io/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="导航流程"><a href="#导航流程" class="headerlink" title="导航流程"></a>导航流程</h2><p>浏览器从输入<code>URL</code>到页面展示间到底发生了什么？这整个流程涉及到<strong>网络请求</strong>和<strong>渲染流程</strong>两大块内容。我们可以先看一下总体的导航流程。</p>
 <a id="more"></a>
<h3 id="浏览器进程构建完整的URL"><a href="#浏览器进程构建完整的URL" class="headerlink" title="浏览器进程构建完整的URL"></a>浏览器进程构建完整的URL</h3><ul>
<li>浏览器进程会检查输入的URL，组装协议，构建完整的的URL</li>
<li>浏览器进程会通过进程间通信（IPC）把URL请求发送网络进程</li>
</ul>
<h3 id="网络进程发起URL请求"><a href="#网络进程发起URL请求" class="headerlink" title="网络进程发起URL请求"></a>网络进程发起URL请求</h3><ul>
<li>检查本地缓存是有效，如果有有效，则使用本地缓存；如果无效，则进入网络请求流程</li>
<li>网络请求的第一步：DNS解析，获取请求域名的IP地址</li>
<li>和服务器建立TCP链接，并且构建请求信息</li>
<li>服务器接收到请求之后，会构建响应信息</li>
<li>浏览器接收到响应信息后，网络请求会解析响应信息， 若状态码是301/302，则会重定向到新的地址，重新发起URL请求</li>
<li>浏览器根据响应的类型（ConTent-Type）进行处理</li>
</ul>
<h3 id="浏览器进程向渲染进程提交文档"><a href="#浏览器进程向渲染进程提交文档" class="headerlink" title="浏览器进程向渲染进程提交文档"></a>浏览器进程向渲染进程提交文档</h3><ul>
<li>浏览器接收到响应信息后， 会开始准备渲染进程， 同一个站点（同根域名，同协议）会复用同一个渲染进程</li>
<li>浏览器进程准备完毕后，浏览器进程会和渲染进程进行通信，传输文档</li>
</ul>
<h3 id="渲染进程开始解析页面和加载子资源，完成页面的渲染"><a href="#渲染进程开始解析页面和加载子资源，完成页面的渲染" class="headerlink" title="渲染进程开始解析页面和加载子资源，完成页面的渲染"></a>渲染进程开始解析页面和加载子资源，完成页面的渲染</h3><p>这个过程就是渲染流程，就是我们本文重点讲的</p>
<h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>为什么要构建DOM树呢？因为浏览器无法识别HTML，所以需要HTML解析成浏览器识别的数据结构——DOM树。</p>
<img src="/shuliqi.github.io/2018/03/24/浏览器的渲染流程/1.jpg">
<h3 id="构建CSSOM树"><a href="#构建CSSOM树" class="headerlink" title="构建CSSOM树"></a>构建CSSOM树</h3><p>一样的，浏览器也无法识别CSS，所以浏览器会先将CSS解2.jpg析成浏览器能识别的数据结构—styleSheets</p>
<p>然后浏览器会将属性值转化成标准值，因为标准值才容易被渲染引擎理解和使用。</p>
<img src="/shuliqi.github.io/2018/03/24/浏览器的渲染流程/2.jpg">
<p>最后，计算DOM树˙中的每个节点的演示， 生成最终的CSSDOM树，这个过程涉及到CSS的继承规则和层叠规则。</p>
<img src="/shuliqi.github.io/2018/03/24/浏览器的渲染流程/3.jpg">
<h3 id="构建渲染树（Render-Tree），并计算布局"><a href="#构建渲染树（Render-Tree），并计算布局" class="headerlink" title="构建渲染树（Render Tree），并计算布局"></a>构建渲染树（Render Tree），并计算布局</h3><p>将DOM树和CSSDOM树结合就可以得到渲染树。</p>
<p>首先，浏览器会遍历所有可见的元素(像hea这类不可见的标签或者display设置为none的元素等会被排除在外)。</p>
<p>接着，找到节点所适配的的样式并应用， 最终生成渲染树。</p>
<img src="/shuliqi.github.io/2018/03/24/浏览器的渲染流程/4.jpg">
<p>即使现在有了渲染树，但是浏览器不知道每个节点的位置信息，所以浏览器会遍历渲染树，计算每个节点的位置信息，这就是计算布局。</p>
<h3 id="分层和绘制"><a href="#分层和绘制" class="headerlink" title="分层和绘制"></a>分层和绘制</h3><p>经过计算布局之后，并不是立马进行绘制，而是会为有3D或透视变换、z轴排序等复杂效果的节点创建图层，并生成图层树，这样做的目的是方便地实现复杂效果。浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p>
<p>什么情况下会创建图层呢？</p>
<ul>
<li>有层叠上下文（明确定位属性的元素， 定义透明属性的元素，使用CSS 滤镜）</li>
<li>需要裁剪（overflow: hidden;溢出部分被剪裁）</li>
</ul>
<p>有了图层树之后，接下来就是绘制图层了。</p>
<p>接着，浏览器会将图层划分为图块，这么做的目的是因为视口显示的内容有限，如果直接将整个结构进行绘制开销比较大，所以浏览器会优先将视口内的图块转为位图，这个过程叫栅格化。</p>
<p>最后，将位图合成，浏览器开始显示。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="/shuliqi.github.io/2018/03/24/浏览器的渲染流程/5.jpg">
<p>如上图所示，HTML的渲染过程如下：</p>
<ul>
<li><p>将HTML解析为DOM树</p>
</li>
<li><p>将CSS解析为CSSOM树</p>
</li>
<li><p>将DOM树和CSSOM树构建成渲染树，并计算布局</p>
</li>
<li><p>进行分层和绘制</p>
</li>
</ul>
<h2 id="渲染进程的特点"><a href="#渲染进程的特点" class="headerlink" title="渲染进程的特点"></a>渲染进程的特点</h2><h3 id="回流和绘制"><a href="#回流和绘制" class="headerlink" title="回流和绘制"></a>回流和绘制</h3><p>回流和绘制是渲染进程比较重要的概念了，了解其中的概念并进行合理的的应用，可以提升性能。</p>
<h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><p>当元素的几何属性(尺寸),隐藏属性等改变而触发重新布局的渲染，这个过程就是回流。回流需要更新完整的渲染流程（布局-分层-绘制-图块-栅格化-合成-显示）， 所以开销比较大,需要尽量避免.</p>
<h4 id="触发回流的属性"><a href="#触发回流的属性" class="headerlink" title="触发回流的属性"></a>触发回流的属性</h4><ul>
<li>盒子模型相关属性（width、padding、margin、display、border等）</li>
<li>定位属性和浮动（position、top、float等）</li>
<li>文字结构（text-align、font、white-space、overflow等）</li>
</ul>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>当元素的外观、风格等属性发生改变但不会影响布局的渲染，这个过程就是重绘。重绘省去了布局和分层阶段（绘制-图块-栅格化-合成-显示），所以性能比回流要好。回流必将引起重绘，重绘不一定会触发回流。</p>
<h4 id="触发重绘的属性"><a href="#触发重绘的属性" class="headerlink" title="触发重绘的属性"></a>触发重绘的属性</h4><p>color，border-style, background，outlinee，box-shadow，visibility， text-decoration</p>
<h3 id="避免回流和重绘"><a href="#避免回流和重绘" class="headerlink" title="避免回流和重绘"></a>避免回流和重绘</h3><p>频繁触发重绘和回流，会导致UI频繁渲染，最终导致性能变差。所以要尽量避免重绘和回流：</p>
<ul>
<li>避免使用触发重绘和回流的CSS属性</li>
<li>将频繁重绘回流的元素创建为一个独立图层</li>
</ul>
<h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>使用transform实现效果：可以避开回流和重绘，直接进入合成阶段（图块-栅格化-合成-显示）</li>
<li>用opacity替代visibility：visibility会触发重绘</li>
<li>使用class替代DOM频繁操作样式</li>
<li>DOM离线后修改，如果有频繁修改，可以先把DOM隐藏，修改完成后再显示</li>
<li>不要在循环中读取DOM的属性值：offsetHeight会使回流缓冲失效</li>
<li>尽量不要使用table布局，小改动会造成整个table重新布局</li>
<li>动画的速度：200~500ms最佳</li>
<li>对动画新建图层</li>
<li>启用GPU硬件加速：启用translate3D</li>
</ul>
<h3 id="HTML解析的特点"><a href="#HTML解析的特点" class="headerlink" title="HTML解析的特点"></a>HTML解析的特点</h3><h4 id="顺序执行，并发加载"><a href="#顺序执行，并发加载" class="headerlink" title="顺序执行，并发加载"></a>顺序执行，并发加载</h4><ul>
<li>顺序执行：HTML的词法分析事从上到下， 顺序执行</li>
<li>并发加载：当HTML解析被脚本阻碍时，解析器虽然会停止构建DOM，但仍会识别脚本后面的内容，并进行加载</li>
<li>并发上限：浏览器对同域名的并发数是有限制的</li>
</ul>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><h5 id="css阻塞"><a href="#css阻塞" class="headerlink" title="css阻塞"></a>css阻塞</h5><ul>
<li>css 在head中阻塞页面的渲染：避免页面闪动</li>
<li>css会阻塞jsd的执行：CSSOM构建的时候，Javascript执行将被暂停，知道CSSDOM构建完成</li>
<li>css不会阻塞外部脚本的加载</li>
</ul>
<h5 id="js阻塞"><a href="#js阻塞" class="headerlink" title="js阻塞"></a>js阻塞</h5><ul>
<li>直接引入的js会阻塞页面的渲染：当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行</li>
<li>js不阻塞资源的加载</li>
<li>js顺序执行，会阻塞后续js的执行</li>
<li>js可以查询和修改 DOM 与 CSS</li>
</ul>
<h5 id="改变js的阻塞"><a href="#改变js的阻塞" class="headerlink" title="改变js的阻塞"></a>改变js的阻塞</h5><p><code>defer</code>和<code>async</code>属性可以改变js的阻塞情形，不过这两个只对src方式引入的script有效，对于inline-script无效。</p>
<p><code>defer</code>表示延迟执行，浏览器会异步地加载该脚本并且不会影响到后续DOM的渲染，该脚本将在文档完成解析后，<code>DOMContentLoaded</code>事件触发前执行。对动态嵌入的脚本使用 <code>async=false</code> 来达到类似的效果。</p>
<p><code>async</code>表示异步执行，浏览器会异步地加载脚本并在允许的情况下执行。与 defer 的区别在于，无论是 HTML 解析阶段还是<code>DOMContentLoaded</code>触发之后，如果脚本加载完成，就会开始执行。需要注意的是，这种方式加载的 JavaScript 依然会阻塞<code>load</code>事件。</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解Object.defineProperty</title>
    <url>/shuliqi.github.io/2018/02/19/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Object-defineProperty/</url>
    <content><![CDATA[<p>了解到vue的实现原理是使用了Object.defineProperty()方法。 之前对这个方法没深入了解。知道的就只有这个方法可以设置对象的的属性。现在了解了之后，感觉还是有很多点很值得记录一下。</p>
 <a id="more"></a>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>Object。defineProperty()</code> 方法会直接在一个对象上添加新的属性， 或者修改一个对象的现有属性。然后返回这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, pro, descripor)</span><br></pre></td></tr></table></figure>
<p><strong>obj：</strong> 要定义属性的对象</p>
<p><strong>prop:</strong> 要定义的属性名或者是要修改的属性的名字</p>
<p><strong>descriptor:</strong>要 定义的属性或者是要修改的属性的描述</p>
<p><strong>返回值</strong>：返回此对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"asjdha"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">  value: <span class="number">12</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writeable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>其中<strong>obj</strong> 和 <strong>prop</strong> 参数没什么好说。 主要是这个descriptor(描述符)参数有比较深究的东西</p>
<h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>javacript 有三种类型的属性</p>
<ol>
<li>命名数据属性：拥有一个确定的值的属性。这也是最常见的属性</li>
<li>命名访问器属性：通过<code>getter</code>和<code>setter</code>进行读取和赋值的属性</li>
<li>内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性<code>[[Prototype]]</code>，你不能直接访问这个属性，但可以通过<code>Object.getPrototypeOf()</code>方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性</li>
</ol>
<p>在js中可以访问到的对象中有两种属性： <strong>数据属性</strong> 和 <strong>访问器属性</strong>； 所以描述符也分为<strong>数据描述</strong> 和<strong>访问器描述</strong></p>
<p><strong>注意：</strong> 在使用描述符时， 必须是两种描述符之一，且两者是不能并存的。</p>
<h2 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h2><p>数据描述符是一个具有值的属性，该值可写可不写</p>
<p>具有以下的键值：</p>
<ol>
<li><strong>configurable：</strong> 该属性表示是否可以通过delete删除，是否能够修改属性的特征或者访问器属性。默认值是false；</li>
<li><strong>enumerable:</strong> 属性述否可枚举。 即 可否通过for..in 访问属性；默认值为 false</li>
<li><strong>value:</strong> 属性的值； 默认为undefined；</li>
<li><strong>writable：</strong> 该属性的值是否可写。 默认值为false。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"asjdha"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">  value: <span class="number">12</span>,</span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// 不可写</span></span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// 不可删除，不可修改属性的特性和防访问器属性</span></span><br><span class="line">  enumerable: <span class="literal">false</span>, <span class="comment">// 不可枚举</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.age = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.age;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);   <span class="comment">// name, 没有把age 枚举出来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 12，  值没有被删除</span></span><br></pre></td></tr></table></figure>
<p>由例子可以知道：当我们设置不可写， 不可删除，不可枚举的时候， 我们是分别改变不了它们的值，删除不了， 枚举不了的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   name: <span class="string">"asjdha"</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">   value: <span class="number">12</span>,</span><br><span class="line">   writable: <span class="literal">true</span>, <span class="comment">// 可写</span></span><br><span class="line">   configurable: <span class="literal">true</span>, <span class="comment">// 可删除，可修改属性的特性和防访问器属性</span></span><br><span class="line">   enumerable: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line"> &#125;)</span><br><span class="line"> obj.age = <span class="number">15</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(key);   <span class="comment">// name, age   把age 枚举出来</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(obj.age); <span class="comment">// 15， 值被改变了</span></span><br><span class="line"> <span class="keyword">delete</span> obj.age;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(obj.age); <span class="comment">// undefined  值已经被删除了</span></span><br></pre></td></tr></table></figure>
<p>由例子可以知道：当我们设置可写， 可删除，可枚举的时候， 我们是分别可改变它们的值，可删除， 可枚举不的。</p>
<h2 id="访问器描述符"><a href="#访问器描述符" class="headerlink" title="访问器描述符"></a>访问器描述符</h2><ol>
<li><strong>configurable：</strong> 该属性表示是否可以通过delete删除，是否能够修改属性的特征或者访问器属性。默认值是false；</li>
<li><strong>enumerable:</strong> 属性述否可枚举。 即 可否通过for..in 访问属性；默认值为 false</li>
<li><strong>get：</strong>在读取属性的时候调用的函数， 默认值为undefned</li>
<li><strong>set：</strong>在写入属性时调用的函数， 默认值是undefined</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"asjdha"</span>,</span><br><span class="line">    _age: <span class="literal">null</span>, <span class="comment">// 私有变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'set'</span>, value);</span><br><span class="line">      <span class="keyword">this</span>._age = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._age;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  obj.age = <span class="number">12</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h2><p> 数据描述符 和访问器描述符是不能同时是使用的</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"asjdha"</span>,</span><br><span class="line">    _age: <span class="literal">null</span>, <span class="comment">// 私有变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>, <span class="comment">//  数据描述符 和 访问描述符 共同有的</span></span><br><span class="line">    enumerable: <span class="literal">true</span>, <span class="comment">// 数据描述符 和 访问描述符 共同有的</span></span><br><span class="line">    writable: <span class="literal">true</span>, <span class="comment">// 数据描述符单有的</span></span><br><span class="line">    value: <span class="string">"shuliqi"</span>, <span class="comment">// </span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123;    <span class="comment">// 访问器描述符</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'set'</span>, value);</span><br><span class="line">      <span class="keyword">this</span>._age = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>() &#123; <span class="comment">// 访问器描述符</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._age;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  obj.age = <span class="number">12</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是页面报错了</p>
<img src="/shuliqi.github.io/2018/02/19/深入了解Object-defineProperty/1.jpg">]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>《javascript设计模式》读书笔记二：字面量和构造函数</title>
    <url>/shuliqi.github.io/2019/05/23/%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="一-对象"><a href="#一-对象" class="headerlink" title="一.对象"></a>一.对象</h3><p>对象由下面这三种方式创建：</p>
<ul>
<li><strong>对象字面量</strong></li>
<li><strong>来自构造函数的对象</strong></li>
<li><p><strong>来自自定义构造函数的对象</strong></p>
<a id="more"></a>
</li>
</ul>
<h5 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h5><p>在大括号里面写上键值对，键和值之间以分号分割，不同的键值对以逗号分隔。这种方式就是字面量。值可以是任意类型对象，除值是函数外我们都称为属性。值是函数我们称为方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  age: <span class="number">12</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 像对象添加一个属性name</span></span><br><span class="line">obj.name = <span class="string">"shu"</span>  </span><br><span class="line"><span class="comment">// 向对象添加一个方法fun</span></span><br><span class="line">obj.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> obj.age&#125;</span><br></pre></td></tr></table></figure>
<h5 id="来自构造函数的对象"><a href="#来自构造函数的对象" class="headerlink" title="来自构造函数的对象"></a>来自构造函数的对象</h5><p>可以使用类似 Object(), Date(), String()的内置构造函数来创建对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>但是这种方式是不推荐的， 原因：</p>
<ul>
<li><p>在构造时，解析器需要从调用Object()的位置开始一直向上查询作用域链，直到发现全局的object函数（可能以同样的命名创建了一个局部构造函数）—&gt;但字面量并没哟作用域解析。</p>
</li>
<li><p>使用内置构造函数来创建对象。对于不同的内置函数会有自己的特征。例如：Object()构造函数会接受一个参数。并且以来传递进来的参数，导致Object()会委托其他的内置函数来创建对象，并且返回一个并非期望的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor === <span class="built_in">Object</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor === <span class="built_in">Number</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.toFixed(<span class="number">2</span>)) <span class="comment">// 1.00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">'tss'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor === <span class="built_in">String</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o.substring())  <span class="comment">//Object并没有substring方法。但是字符串是由的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor === <span class="built_in">Boolean</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="自定义构造函数创建的对象"><a href="#自定义构造函数创建的对象" class="headerlink" title="自定义构造函数创建的对象"></a>自定义构造函数创建的对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newPerson = <span class="keyword">new</span> Person(<span class="string">"shuliqi"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newPerson.name)  <span class="comment">// shuliqi</span></span><br><span class="line">newPerson.getName()  <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure>
<p>使用new 操作符调用构造函数（自定义+内置）时。函数内部发生的事：</p>
<ul>
<li>创建一个空对象.</li>
<li>this指向该空对象.并且继承函数的原型。</li>
<li>属性和方法被加入到this引用的对象中</li>
<li>新对象由this值引用，并且最后隐式的返回（如果没有显示的返回值）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">this</span> = &#123;&#125;;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return this; 隐式的返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用new操作符创建对象时，构造函数总会返回一个对象。默认情况下返回的是this所引用的对象。如果在构造函数中不向this添加任何属性和方法，将会返回一个空对象（这里的”空”，实际上并不空，它已经从构造函函数的原型继承了很多成员）。</p>
<p>当然构造函数你可以返回你想要的信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> that = &#123;&#125;</span><br><span class="line">  that.name = name;</span><br><span class="line">  <span class="keyword">return</span> that;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newPerson = <span class="keyword">new</span> Person(<span class="string">"shuliqi"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newPerson.name) <span class="comment">// shuliqi</span></span><br><span class="line">newPerson.getName  <span class="comment">// 报错： newPerson.getName is not a function</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：在用new操作符创建对象时，构造函数总会返回一个对象。默认情况下返回的时this所引用的对象。如果在构造函数中没有向this添加任何属性和方法。那么将返回一个空对象（除了从构造函数的原型继承的成员）</p>
<p>构造函数将隐式的返回this。甚至在函数中没有显式的加入return语句。但是可以根据需要返回任意其他对象。</p>
<h5 id="强制使用new的模式"><a href="#强制使用new的模式" class="headerlink" title="强制使用new的模式"></a>强制使用new的模式</h5><hr>
<p>构造函数也是函数，只不过它却以new的方式调用。如果在调用构造函数时忘记添加new操作符会发生？这虽然不会导致语法和运行时的错误。但是可能导致逻辑错误和意外的行为发生。忘记加new操作符。导致构造函数的this指向全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name =<span class="string">"shuliqi"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新对象</span></span><br><span class="line"><span class="keyword">var</span> newPerson = <span class="keyword">new</span> person();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> newPerson)  <span class="comment">// 'object'</span></span><br><span class="line"><span class="built_in">console</span>.log(newPerson.name) <span class="comment">// "shuliqi"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 忘记使用"new"模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newPerson1 = person();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> newPerson1) <span class="comment">// "undefined"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)  <span class="comment">//  "shuliqi"</span></span><br></pre></td></tr></table></figure>
<p><strong>解决的办法</strong></p>
<ul>
<li><p>命名约定。使构造函数的函数名首字母是大写的。有助于在一定程度上能避免忘记new操作符。</p>
</li>
<li><p>构造函数不使用this。构造函数中并不用将方法和属性添加到this。而是添加到一个自定义的变量，最后返回。甚至不需要一个这样的局部变量。直接返回一个对象即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		name: <span class="string">"shuliqi"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="keyword">new</span> name();</span><br><span class="line"><span class="keyword">var</span> secondtName = name();</span><br><span class="line"><span class="built_in">console</span>.log(firstName.name) <span class="comment">// "shuliqi"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondtName.name) <span class="comment">// "shuliqi"</span></span><br></pre></td></tr></table></figure>
<p>但是这种方式的缺点是会丢失到原型的链接。构造函数的原型属性都是不可用的。</p>
</li>
<li><p>自调用构造函数</p>
<p>为了使得构造函数的属性在实例对象中也能使用。可以在构造函数中检查this是否为构造函数的实例。如果为否。可以再次调用自身。并且在这次调用中正确的使用了new操作符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"shuliqi"</span>;</span><br><span class="line">&#125;</span><br><span class="line">name.prototype.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newName = name();</span><br><span class="line"><span class="built_in">console</span>.log(newName.name,newName.age) <span class="comment">// "shuliqi", 12</span></span><br></pre></td></tr></table></figure>
<p>另一种检测实例对象的方法是使用arguments.callee进行比较。callen属性指向被调用的函数。这样就不用在编码的时候硬编构造函数的名字了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">arguments</span>.callee)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"shuliqi"</span>;</span><br><span class="line">&#125;</span><br><span class="line">name.prototype.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newName = name();</span><br><span class="line"><span class="built_in">console</span>.log(newName.name,newName.age) <span class="comment">// "shuliqi", 12</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二-数组"><a href="#二-数组" class="headerlink" title="二.数组"></a>二.数组</h3><p> 数组对象可以通过下面这三种方式创建：</p>
<ul>
<li>数组字面量</li>
<li><p>数组构造函数</p>
<h5 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h5></li>
</ul>
<p>数组字面量表示法：逗号分隔的元素列表。并且元素列表包装在一个方括号中。可以给元素指定任意类型的值。包括对象或者其他数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure>
<h5 id="数组构造函数"><a href="#数组构造函数" class="headerlink" title="数组构造函数"></a>数组构造函数</h5><p>可以通过内置的构造函数Arrry()来创建数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>最好不要使用构造函数来创建数组。因为当向构造函数传递单个数字时，它并不会成为数组的第一个元素的值。而是设置了数组的长度。但是数组中并没有实际的元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length, arr[<span class="number">0</span>])  <span class="comment">// 1, 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr2.length, arr2[<span class="number">0</span>])  <span class="comment">// 3, undefined</span></span><br></pre></td></tr></table></figure>
<p>如果传入的是浮点数将会更糟糕</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3.14</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length, arr[<span class="number">0</span>])  <span class="comment">// 1, 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3.14</span>)  <span class="comment">// Uncaught RangeError: Invalid array length（不合法的数组长度）</span></span><br></pre></td></tr></table></figure>
<p>因此坚决使用字面量将使程序更加安全。</p>
<h5 id="检查数组的性质"><a href="#检查数组的性质" class="headerlink" title="检查数组的性质"></a>检查数组的性质</h5><p>因为以数组为操作数的并且使用typeof操作符。结果都会返回”object”。</p>
<p>检查一个对象是否是数组的办法：</p>
<ul>
<li><p>可以检查对象是否存在数组的一些属性(length)和方如slice()，split()等。以此来确定该值是否具有”数组性质”。</p>
<p><strong>缺点</strong>：不能保证任何其他非数组对象不能具有相同名称的属性和方法。</p>
</li>
<li><p>instance Array进行检查</p>
<p><strong>缺点：</strong>在某些浏览器版本中的不同框架运行并不正确。</p>
</li>
<li><p>ES5中的Array.isAarray()方法。该函数在参数为数组的时候返回true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([])) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试以一个类似数组的对象欺骗检查</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(&#123;</span><br><span class="line">  length: <span class="number">1</span>,</span><br><span class="line">  slice: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;))   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果无法使用rray.isAarray()方法， 可以通过调用Object.prototype.toString()方法进行检查。如果在数组上，详细问调用toString()的call()方法，它应该返回”[object Array]”。如果是上下文是对象，则它应该返回字符串”[object object]”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.isArray === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">	<span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">"[object Array]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON是一种轻量级的数据交换格式。是一个数组和对象字面量表示方法的结合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">"name"</span>: <span class="string">'shu'</span>, <span class="string">"age"</span>: <span class="number">23</span>, <span class="string">"some"</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br></pre></td></tr></table></figure>
<h5 id="JSON文字对象之间的区别"><a href="#JSON文字对象之间的区别" class="headerlink" title="JSON文字对象之间的区别"></a>JSON文字对象之间的区别</h5><p>在JSON中，属性名称需要在包装在引号才能成为合法的JSON。</p>
<p>在对象字面量中。仅当属性名称不是有效的标识符的时候菜会需要使用引号。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"first name"</span>: <span class="string">"jsdhs"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>注意： 在JSON中不能使用正则表达式字面量和函数。</p>
<h5 id="使用JSON"><a href="#使用JSON" class="headerlink" title="使用JSON"></a>使用JSON</h5><p>使用JSON.parse()解析字符串。</p>
<p>使用JSON.stringify()将基本数据类型序列化成为一个JSON数组。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式也是对象，可以通过两种方式创建正则表达式：</p>
<ul>
<li>使用正则表达式字面量</li>
<li>使用new RegExp()</li>
</ul>
<h5 id="使用正则表达式字面量"><a href="#使用正则表达式字面量" class="headerlink" title="使用正则表达式字面量"></a>使用正则表达式字面量</h5><p>正则表达式字面量表示法使用了些刚（”/“）来包装用于匹配的正则表达式模式。在第二个斜杆之后，可以将该模式修改为不加引号的字母形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var reg = /shuliqi/gm</span><br></pre></td></tr></table></figure>
<h5 id="使用new-RegExp"><a href="#使用new-RegExp" class="headerlink" title="使用new RegExp()"></a>使用new RegExp()</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"shuliqi"</span>, <span class="string">"i"</span>)</span><br></pre></td></tr></table></figure>
<p>能使用久使用字面量。</p>
<h3 id="基本值类型包装器"><a href="#基本值类型包装器" class="headerlink" title="基本值类型包装器"></a>基本值类型包装器</h3><p>javascript中的基本数据类型：number，string， boolean，null， undefined。除了null和undefined，其他三个具有所谓的基本包装对象。可以使用内置构造函数Number()，String()和Boolean()创建包装对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个基本数值</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n); <span class="comment">// "number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> nObj);<span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>
<p>基本值只要调用包装对象的方法，就可以在后台杯临时转换为一个对象，并且表现得犹如一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来作为对象的基本字符串</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"shu"</span></span><br><span class="line"><span class="built_in">console</span>.log(s.toUpperCase()); <span class="comment">// 'SHU'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值本身可以作为一个对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"mokey"</span>.slice(<span class="number">3</span>,<span class="number">6</span>)); <span class="comment">// "key"</span></span><br></pre></td></tr></table></figure>
<p>由此可看出：基本值也可以充当对象，只要需要他们这么做。但是通常没有理由去使用更长的包装构造函数。</p>
<p>通常使用包装对象的原因之一是有扩充值及持久保存状态的需要。这是由于基本类型不是对象，他们不可能扩充属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本字符串</span></span><br><span class="line"><span class="keyword">var</span> greet = <span class="string">"shu"</span>;</span><br><span class="line"><span class="comment">// 为了使用slice()方法，基本数据类型杯转换成对象</span></span><br><span class="line"><span class="built_in">console</span>.log(greet.slice(<span class="string">''</span>)[<span class="number">0</span>]); <span class="comment">//  "s"</span></span><br><span class="line"><span class="comment">// 试图添加一个原始数据类型并不会导致错误</span></span><br><span class="line">greet.smile = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 但它并不是实际运行</span></span><br><span class="line"><span class="built_in">console</span>.log(greet.smile) <span class="comment">//"undefined"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《javascript设计模式》读书笔记一：编写可维护的代码</title>
    <url>/shuliqi.github.io/2019/05/14/%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%88%E5%9F%BA%E7%A1%80%E6%8A%80%E5%B7%A7%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一-尽量少用全局变量"><a href="#一-尽量少用全局变量" class="headerlink" title="一. 尽量少用全局变量"></a>一. 尽量少用全局变量</h3><p>Javascript 使用的是函数作用域，在函数内声明的变量，只有在函数内有效，不能在函数外使用。全局变量则是在函数外部声明，在函数内无需声明就可以使用。</p>
 <a id="more"></a>
<p>每一个javascript环境都有一个全局对象，在函数外部使用this进行访问。创建的全局变量都归全局对象所有。</p>
<p>在浏览器中，使用window表示全局变量本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myName = <span class="string">"haha"</span></span><br><span class="line"><span class="built_in">console</span>.log(myName)  <span class="comment">//haha</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.myName) <span class="comment">//haha</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>[<span class="string">"myName"</span>]) <span class="comment">//haha</span></span><br></pre></td></tr></table></figure>
<h5 id="全局变量的产生"><a href="#全局变量的产生" class="headerlink" title="全局变量的产生"></a>全局变量的产生</h5><p>javascript的两个特性总让我们在不知不觉中就创建了全局变量</p>
<ol>
<li><p><strong>可直接使用变量。甚至无需声明</strong></p>
</li>
<li><p><strong>javascript有个隐含全局变量。即任何变量，如果未经声明，就为全局对象所有</strong></p>
<p>例1:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	result = x + y;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong>例子中result未经声明， 归全局对象所有，在一般情况下可以正常使用， 但是在相同的全局命名空间使用了另外的result 变量， 就会有问题。</p>
</li>
</ol>
<p>   带有var声明的链式赋值有可能导致隐含全局变量</p>
<p>   面的例子中你估计想要的结果？</p>
<p>   例2:</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = b = <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   <strong>结果</strong>：a是局部变量，b是全局变量</p>
<p>   <strong>原因</strong>：从右到左的操作符优先级。首先是优先级较高的表达式b=0,此时b未经声明(归全局对象所有)。表达式的返回值是0， 被赋给了var声明的局部变量a。</p>
<h5 id="全局变量的问题"><a href="#全局变量的问题" class="headerlink" title="全局变量的问题"></a>全局变量的问题</h5><ol>
<li><p>全局变量存在于同一个全局命名空间内，很有可能发生命名冲突</p>
</li>
<li><p>变量释放时的副作用</p>
<p>隐含全局变量与明确定义的全局变量有细微的不同。</p>
<ul>
<li><p>使用var创建的全局变量（这类变量在函数外部创建），不可以使用delete操作符撤销变量</p>
</li>
<li><p>不使用var创建的隐含全局变量（即使它是在函数内部创建），也可以使用delete操作符撤销变量</p>
<p>例3:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	c = <span class="number">3</span>;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// 企图删除</span></span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">delete</span> b; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> c; <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 测试删除情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a, <span class="keyword">typeof</span> b, <span class="keyword">typeof</span> c)</span><br><span class="line"><span class="comment">// "number", "undefined", "undefined"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>这说明隐含全局变量不是真正的变量。而是只是全局对象的属性，属性是可以通过delete操作符删除的，但是变量不可以</p>
<h5 id="如何最小化全局变量的数量"><a href="#如何最小化全局变量的数量" class="headerlink" title="如何最小化全局变量的数量"></a>如何最小化全局变量的数量</h5><ol>
<li>命名空间模式</li>
<li>即时函数</li>
<li>使用var声明变量</li>
</ol>
<p>最重要的方式还是使用var声明。上面的例子改造如下：</p>
<p>例1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = x + y; <span class="comment">// result 就不会变成全局变量。</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a, b；</span><br><span class="line">	a = b = <span class="number">0</span>; <span class="comment">//都是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二-变量声明提升-凌散变量-的问题"><a href="#二-变量声明提升-凌散变量-的问题" class="headerlink" title="二. 变量声明提升(凌散变量)的问题"></a>二. 变量声明提升(凌散变量)的问题</h3><p>javascript允许在任何地方声明变量，无论在哪里声明，效果都等同于在函数顶部进行声明。这就是<strong>变量声明提升</strong>。注意：提升的只是声明部分，赋值部分不提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"shu"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a) </span><br><span class="line">	<span class="keyword">var</span> a = <span class="string">"liqi"</span></span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong>‘undefined’，’ liqi’</p>
<p><strong>原因：</strong>在函数getName作用域内，a被看做函数作用域内的变量。函数中所有的变量声明都会被提升的函数的最顶成，但是赋值部分位置不变。所以导致log出：’undefined’， liqi。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">name = <span class="string">"shu"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name;</span><br><span class="line">	<span class="built_in">console</span>.log(name) </span><br><span class="line">	name = <span class="string">"liqi"</span></span><br><span class="line">	<span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></figure>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>为了避免的这样的混乱， 我们最好在开始就声明要用的变量。</p>
<h3 id="三-for循环"><a href="#三-for循环" class="headerlink" title="三. for循环"></a>三. for循环</h3><p>for循环常用在数组或者类数组对象（伪数组）上面。类对象数组例如：arguments，HTML DOM对象:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">document.getElementsByName()</span><br><span class="line">document.getElementsByClassName()</span><br><span class="line">document.getElementsByTagName()</span><br></pre></td></tr></table></figure>
<h5 id="通常的for循环使用："><a href="#通常的for循环使用：" class="headerlink" title="通常的for循环使用："></a>通常的for循环使用：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法在于每次循环都需要访问数组的长度。这样会使代码变慢。特别当arr不是数组，是HTML DOM</p>
<p>对象的时候。更耗时。</p>
<h5 id="第一种改进的方案："><a href="#第一种改进的方案：" class="headerlink" title="第一种改进的方案："></a>第一种改进的方案：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">	 <span class="built_in">console</span>.log(i) <span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式下， 对长度的值只提取一次。但是可以应用的整个循环。</p>
<h5 id="第二种改进的方案："><a href="#第二种改进的方案：" class="headerlink" title="第二种改进的方案："></a>第二种改进的方案：</h5><p>逐步减到0，因为同0比较比同数组的长度比较（同非0数组）比较更有效率</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = arr.length; i--;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="两种方式的比较："><a href="#两种方式的比较：" class="headerlink" title="两种方式的比较："></a>两种方式的比较：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'同长度比较'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">	<span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'同长度比较'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'同0比较'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = arr.length; i--;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">	<span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'同0比较'</span>)</span><br></pre></td></tr></table></figure>
<p>但是也存在一些缺点，就是处理的顺序倒过来了。</p>
<h3 id="四-for-in循环"><a href="#四-for-in循环" class="headerlink" title="四. for-in循环"></a>四. for-in循环</h3><p>for-in是用来循环非数组对象的。当遍历对象属性时遇到原型链的属性时，使用hasOwnProperty()方法来过滤是非常重要的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name: <span class="string">"shu"</span>,</span><br><span class="line">	age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将一个方法clone添加到对象上</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype.clone === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免在枚举的时候出现clone()。 需要调用hasOwnproperty()方法来过滤原型链属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">	<span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(key,<span class="string">':'</span>, obj[key] )</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong> name : shu， age : 12</p>
<h3 id="五-避免使用隐式类型转换"><a href="#五-避免使用隐式类型转换" class="headerlink" title="五.避免使用隐式类型转换"></a>五.避免使用隐式类型转换</h3><p>#####1.字符串连接符与算术运算符（+ - * / %）隐式转换规则</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="string">'true'</span>)</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>结果会是什么样的？</p>
<p><strong>转换规则：</strong></p>
<p>​    1.字符串连接符(“+”两边有一边是字符串)：会把其他数据类型调用String()方法然后拼接。</p>
<p>​    2.运算操作符(除了不是字符串连接符的”+”就都是是运算操作符)：会把其他数据类型调用Number()方法转成数字然后做运算。</p>
<p>所以例子的结果是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// "+“ 是字符串连接符：String(1) + 'true' = '1true'</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="string">'true'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// "+“ 是算术运算符： 1 + Number(true) = 1 + 1 = 2</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">true</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment">// "+“ 是算术运算符： 1 + Number(undefined) = 1 + NaN = NaN</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">undefined</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// "+“ 是算数运算符： 1 + Number(null) = 1 + 0 = 1</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span>+ <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h5 id="2-关系运算符-gt-lt-gt-lt-：会把其他数据类型转换成number之后再比较关系"><a href="#2-关系运算符-gt-lt-gt-lt-：会把其他数据类型转换成number之后再比较关系" class="headerlink" title="2.关系运算符( &gt; &lt; &gt;= &lt;= == != === !==)：会把其他数据类型转换成number之后再比较关系"></a>2.关系运算符( &gt; &lt; &gt;= &lt;= == != === !==)：会把其他数据类型转换成number之后再比较关系</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span> &gt; <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span> &gt; <span class="string">'10'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span> &gt; <span class="string">'b'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span> &gt; <span class="string">'aad'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> ==  <span class="literal">NaN</span>)</span><br></pre></td></tr></table></figure>
<p>结果会是什么样的呢？</p>
<p><strong>转换规则：</strong></p>
<p>1.关系运算符两边有一边是字符串，会将其使用Number()转成数字，然后比较关系。</p>
<p>2.关系运算符两边都是字符串，两边按照字符串对应的unicode编码（可以使用charCodeAt()查看）转成数字，然后比较。</p>
<p>3.当有多个字符串进行比较，依次从左到右比较。</p>
<p>4.如果数据类型是null，undefined 不是严格比较两者都是相等的。</p>
<p>5.NaN 类型与任何数据类型比较都是NaN</p>
<p>所以例子的结果是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// false  Number(2) &gt; 10 = 2 &gt; 10 = false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span> &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true  '2'.charCodeAt() &gt; '10'.charCodeAt() = 50 &gt; 49 = true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span> &gt; <span class="string">'10'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>.charCodeAt()); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'10'</span>.charCodeAt()); <span class="comment">// 49</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false 先比较a和b：  'a'.charCodeAt() &gt; 'b'.charCodeAt() = 97 &gt; 98 = false,直接得出结果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span> &gt; <span class="string">'b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>.charCodeAt()); <span class="comment">// 97</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>.charCodeAt()); <span class="comment">// 98</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//true 先比较 a和a, 两者相等。则比较b和a：'b'.charCodeAt() &gt; 'a'.charCodeAt() = 98 &gt; 97 = true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'abc'</span> &gt; <span class="string">'aad'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true 特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// false 严格比较</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ===  <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true 特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true  特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// false 特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> ==  <span class="literal">NaN</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> ===  <span class="literal">NaN</span>)</span><br></pre></td></tr></table></figure>
<h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>JavaScript在语句比较时会执行隐式类型转换(除了严格比较)。 有时候自己理不清。最好避免使用。使用就最好使用严格比较如：===,   !==。</p>
<h3 id="六-避免使用eval"><a href="#六-避免使用eval" class="headerlink" title="六. 避免使用eval()"></a>六. 避免使用eval()</h3><p><strong>eval函数的作用</strong>:  在当前作用域中执行一段JavaScript代码字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> one = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'one = 3'</span>);</span><br><span class="line">    <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="不推荐使用使用eval-的原因"><a href="#不推荐使用使用eval-的原因" class="headerlink" title="不推荐使用使用eval()的原因"></a>不推荐使用使用eval()的原因</h4><h5 id="1-eval-可以访问和修改它外部作用域的变量"><a href="#1-eval-可以访问和修改它外部作用域的变量" class="headerlink" title="1. eval()可以访问和修改它外部作用域的变量"></a>1. eval()可以访问和修改它外部作用域的变量</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunOne</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> local = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">eval</span>(<span class="string">'local = 3; console.log("eval:", local)'</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(local)	 <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line">myFunOne();</span><br></pre></td></tr></table></figure>
<h5 id="2-eval-只在被直接调用并且调用函数就是-eval-本身时，才在当前作用域中执行，-否则就是在全局作用域执行"><a href="#2-eval-只在被直接调用并且调用函数就是-eval-本身时，才在当前作用域中执行，-否则就是在全局作用域执行" class="headerlink" title="2.eval() 只在被直接调用并且调用函数就是 eval ()本身时，才在当前作用域中执行， 否则就是在全局作用域执行"></a>2.eval() 只在被直接调用并且调用函数就是 eval ()本身时，才在当前作用域中执行， 否则就是在全局作用域执行</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> one = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">eval</span>; <span class="comment">//这里将a变量指向了eval函数的引用</span></span><br><span class="line">    a(<span class="string">'one = 3'</span>);</span><br><span class="line">    <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>这段代码等价于在全局作用域中调用 eval。</p>
<h5 id="3-安全问题"><a href="#3-安全问题" class="headerlink" title="3.安全问题"></a>3.安全问题</h5><p>eval 也存在安全问题，因为它会执行任意传给它的代码字符串， 在代码字符串未知或者是来自一个不信任的源时就会有安全问题。</p>
<h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><p>​        绝对不要使用 eval，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。 如果一些情况必        须使用到 eval 才能正常工作，首先它的设计会受到质疑，这不应该是首选的解决方案。</p>
<h4 id="eval-的替代方式"><a href="#eval-的替代方式" class="headerlink" title="eval() 的替代方式"></a>eval() 的替代方式</h4><p>new Fuction()构造函数和eval()比较类似。如果一定需要使用eval()，那么可以考虑使用new Fuction()来代替eval()。这样的好处是：<strong>new Function()中的代码将在局部函数空间中运行， 因此代码中的任何采用var定义的变量不会自定成为全局变量</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> one); <span class="comment">// "undefine"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> two); <span class="comment">// "undefine"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'var one = 1; console.log(one);'</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'var two = 2; console.log(two);'</span>)() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> one); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> two); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>setInterval(),setTimeout,function()等构造函数来传递参数。在特殊情况下，会导致类似eval()的隐患。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1111'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 认为 "myFun()" 是可执行的代码  不建议这么写</span></span><br><span class="line">setInterval(<span class="string">"myFun()"</span>, <span class="number">1000</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 认为 "myFun(1,2,3)" 是可执行的代码 不建议这么写</span></span><br><span class="line">setInterval(<span class="string">"myFun(1,2,3)"</span>, <span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐这种方式: 函数的引用</span></span><br><span class="line">setInterval(myFun, <span class="number">1000</span>)</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	myFun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// myFun是对函数的直接调用，也就是说当setInterval还没有开始函数func就执行了, 果这个函数没有返回值或者返回值不是可执行的函数或者其他的代码的话，就以上代码而言只会打印一次。</span></span><br><span class="line">setInterval(myFun(), <span class="number">1000</span> )</span><br></pre></td></tr></table></figure>
<h3 id="七-不要增加内置的原型"><a href="#七-不要增加内置的原型" class="headerlink" title="七. 不要增加内置的原型"></a>七. 不要增加内置的原型</h3><p>增加内置构造函数（Object(),Array(),Fuction()等）的原型，但是这可能会严重影响可维护性。因为这种做法使得代码更加不可预测。其他开发者在使用你的代码的时候可能期望的内置的Javascript方法，而不是期望有一些你自己添加的方法。</p>
<p>并且，给原型添加属性在没有使用hasOwnproperpty()时可能会在循环中出现。这会导致一些混乱。</p>
<h3 id="八-switch模式："><a href="#八-switch模式：" class="headerlink" title="八. switch模式："></a>八. switch模式：</h3><p>可以使用一下switch模式来提高代码的的可读性和健壮性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		result = <span class="string">'default'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：每一个case 需要有一个明确的break语句</p>
<p>​        </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>总结实现瀑布流的三种方式</title>
    <url>/shuliqi.github.io/2020/11/17/%E7%80%91%E5%B8%83%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>最近在参加一个<a href="http://umapp-docs-dev.lap.qihoo.net/" target="_blank" rel="noopener">小程序</a> 比赛， 其中在开发页面的时候，设计图设计是瀑布流的样式。本以为很简单的浮动就能实现的。但是其实并没有那么简单。通过这次写瀑布流。感觉受益颇多。于是通过这篇博客记录一下瀑布流是如何实现的以及每个方法的原理。</p>
 <a id="more"></a>
<h1 id="什么是瀑布流？"><a href="#什么是瀑布流？" class="headerlink" title="什么是瀑布流？"></a>什么是瀑布流？</h1><p>瀑布流我们又称瀑布流式布局。这种布局视觉表现为参差不齐的多栏布局，随着页面的滚动条向下滚动，还会不断加载数据块并附加到当前结尾。瀑布流布局即不会出现错乱现象，而且会最大限度显示图片的内容。</p>
<h1 id="瀑布流的原理"><a href="#瀑布流的原理" class="headerlink" title="瀑布流的原理"></a>瀑布流的原理</h1><p>瀑布流的原理就是页面容器内多个高度不固定的div之间按照一定的间隔参差不齐的无序浮动，数据滚动时不断的在容器内的尾部加载数据，且自动加载到空缺位置。不断循环。瀑布流布局的核心就是基于一个网格的布局，而且每行包含的项目列表的高度(高度)是随机的(随着自己的内容动态变化的高度或者宽度)。</p>
<h1 id="等宽瀑布流"><a href="#等宽瀑布流" class="headerlink" title="等宽瀑布流"></a>等宽瀑布流</h1><p>根据以上的瀑布流的原理我们也知道，瀑布流可以分为两种形式：等宽瀑布流，等高瀑布流。。我们这篇博文主要讲等宽瀑布流</p>
<p>等宽瀑布流形式如下：</p>
<img src="/shuliqi.github.io/2020/11/17/瀑布流的实现方式/2.png">
<p>我们可以看出来， 每块的宽度是一定的，但是高度是不一样的，其中高度取决于图片的高度。</p>
<p>我们来使用具体几种方式来实现：</p>
<h1 id="css-实现：column-count-方式"><a href="#css-实现：column-count-方式" class="headerlink" title="css 实现：column-count 方式"></a>css 实现：column-count 方式</h1><p><strong>column-count</strong>: 用于定义栏目的的列数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">column-count：auto | 整数</span><br></pre></td></tr></table></figure>
<ul>
<li>auto: 取计算机值</li>
<li>整数：有浮点数和单位标识符组成的长度值，不可为负数</li>
</ul>
<p><strong>浏览器的兼容：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th><img src="https://www.zhangxinxu.com/css3/img/IE.png" alt="IE">Internet Explorer</th>
<th><img src="https://www.zhangxinxu.com/css3/img/Firefox.png" alt="Firefox">Firefox</th>
<th><img src="https://www.zhangxinxu.com/css3/img/Chrome.png" alt="Chrome">Chrome</th>
<th><img src="https://www.zhangxinxu.com/css3/img/Opera.png" alt="Opera">Opera</th>
<th><img src="https://www.zhangxinxu.com/css3/img/Safari.png" alt="Safari">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>版本</td>
<td>(×) IE6</td>
<td>(×) Firefox 2.0</td>
<td>(√ )Chrome 1.0.x</td>
<td>(× )Opera 9.63</td>
<td>(√)Safari 3.1</td>
</tr>
<tr>
<td>(×)IE7</td>
<td>(×) Firefox 3.0</td>
<td>(√) Chrome 2.0.x</td>
<td></td>
<td>(√)Safari 4</td>
<td></td>
</tr>
<tr>
<td>(x)IE8</td>
<td>(√ )Firefox 3.5</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>可以看出还是有很多浏览器不兼容的。使用的时候还是很需要谨慎。</p>
<p>所有有些浏览器前缀是必要的：</p>
<table>
<thead>
<tr>
<th>引擎类型</th>
<th>Gecko</th>
<th>Webkit</th>
<th>Presto</th>
</tr>
</thead>
<tbody>
<tr>
<td>column-count</td>
<td>-moz-column-count</td>
<td>-webkit-column-count</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>具体的瀑布流的例子：</strong></p>
<iframe height="800" style="width: 100%;" scrolling="no" title="瀑布流-column" src="https://codepen.io/shuliqi/embed/QWKjYMr?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/QWKjYMr" target="_blank" rel="noopener">瀑布流-column</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>


<p>其中例子重要的代码其实也就是如下的代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">column-count</span>: 2;</span><br><span class="line"><span class="selector-tag">column-gap</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">-webkit-column-count</span>: 2;</span><br><span class="line"><span class="selector-tag">-webkit-column-gap</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">-webkit-column-gap</span>: 10<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p>其中 <strong>column-gap</strong> 属性用来设置元素列之间的间隔大小。</p>
<p>但是这种方式有一个缺点：数据不是从上到下排列， 而是从左到右边的排列方式。在例子中可以看出来，1，2，3，4 是在左边的一列的。左边的排完了，才到右边的。</p>
<p>而且这次的<a href="http://umapp-docs-dev.lap.qihoo.net/" target="_blank" rel="noopener">360家小程序</a> 。 我们在模拟器上和一些手机上这种方式实现是ok的。但是8p， 5s在我们360家app 上是不支持的。 使用还是需要谨慎。</p>
<h1 id="css实现：-display-flex-方式"><a href="#css实现：-display-flex-方式" class="headerlink" title="css实现： display: flex 方式"></a>css实现： display: flex 方式</h1><p>如果还不了解弹性布局的可以先看 <a href="https://shuliqi.github.io/shuliqi.github.io/2018/03/31/Flex%E5%B8%83%E5%B1%80/">Flex布局教程</a></p>
<p>实现原理：</p>
<ol>
<li>先使用：<code>display: flex;</code>, <code>flex-direction: row;</code>将容器的主轴变成垂直方向。</li>
<li>然后再使用：<code>justify-content: space-between;</code>将主轴的列两端对齐。</li>
<li>我们需要几列就需要把数据分为几列。</li>
</ol>
<p>具体例子：</p>
<iframe height="800" style="width: 100%;" scrolling="no" title="瀑布流css实现-flex" src="https://codepen.io/shuliqi/embed/BaLogpG?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/BaLogpG" target="_blank" rel="noopener">瀑布流css实现-flex</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>例子的主要代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">space-between</span>;</span><br></pre></td></tr></table></figure>
<p>这主要是布局的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载数据， 把数据分成两列</span></span><br><span class="line"> onLoadImg() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> colIndex = i % <span class="number">2</span> ; <span class="comment">// 两列</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">`https://shuliqi.github.io/xiaozhan/<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>.jpeg`</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.imgList[colIndex]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.imgList[colIndex].push(url)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$<span class="keyword">set</span>(this.imgList, colIndex, [url])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这主要将数据变成多少列的代码</p>
<p><strong>缺点：</strong></p>
<p>当然了这也是有缺点的。就是可能某一列特别长。以为我们在将数据分为几列的时候， 并没有判断图片的高度，而放入不同的列当中。</p>
<h1 id="JS-计算方式"><a href="#JS-计算方式" class="headerlink" title="JS 计算方式"></a>JS 计算方式</h1><p>js实现的具体步骤：</p>
<ol>
<li>确定每行放几张图片， 每行的个数（column）=页面宽度（pageWidth）/（图片盒子宽度+图片间距） </li>
<li>确定一行多少个之后首先需要将第一行排列好 （绝对定位的方式，使用js排列好）</li>
<li>找出每一行的最小高度，排列完每一张图片之后更新最小高度</li>
</ol>
<p>具体的实现：</p>
<iframe height="800" style="width: 100%;" scrolling="no" title="瀑布流JS 实现" src="https://codepen.io/shuliqi/embed/wvzMBxW?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/shuliqi/pen/wvzMBxW" target="_blank" rel="noopener">瀑布流JS 实现</a> by shuliqi<br>  (<a href="https://codepen.io/shuliqi" target="_blank" rel="noopener">@shuliqi</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>其中重要的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">waterFall() &#123;</span><br><span class="line">  <span class="keyword">var</span> items = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'img-item'</span>);</span><br><span class="line">  <span class="keyword">if</span> (items.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//定义间隙10像素</span></span><br><span class="line">  <span class="keyword">var</span> gap = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">//首先确定列数 = 页面的宽度 / 图片的宽度</span></span><br><span class="line">  <span class="keyword">var</span> pageWidth = <span class="keyword">this</span>.$refs.waterfall.offsetWidth;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> itemWidth = items[<span class="number">0</span>].offsetWidth;</span><br><span class="line">  <span class="keyword">var</span> columns = <span class="built_in">parseInt</span>(pageWidth / (itemWidth + gap));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> arr = [];<span class="comment">//定义一个数组，用来存储元素的高度</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; items.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; columns) &#123;</span><br><span class="line">          <span class="comment">//满足这个条件则说明在第一行，文章里面有提到</span></span><br><span class="line">          items[i].style.top = <span class="number">0</span>;</span><br><span class="line">          items[i].style.left = (itemWidth + gap) * i + <span class="string">'px'</span>;</span><br><span class="line">          arr.push(items[i].offsetHeight);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//其他行，先找出最小高度列，和索引</span></span><br><span class="line">          <span class="comment">//假设最小高度是第一个元素</span></span><br><span class="line">          <span class="keyword">var</span> minHeight = arr[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++)&#123;<span class="comment">//找出最小高度</span></span><br><span class="line">            <span class="keyword">if</span>(minHeight &gt; arr[j])&#123;</span><br><span class="line">                minHeight = arr[j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125; </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//设置下一行的第一个盒子的位置</span></span><br><span class="line">          <span class="comment">//top值就是最小列的高度+gap</span></span><br><span class="line">          items[i].style.top = arr[index] + gap + <span class="string">'px'</span>;</span><br><span class="line">          items[i].style.left = items[index].offsetLeft + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//修改最小列的高度</span></span><br><span class="line">          <span class="comment">//最小列的高度 = 当前自己的高度 + 拼接过来的高度 + 间隙的高度</span></span><br><span class="line">          arr[index] = arr[index] + items[i].offsetHeight + gap;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>js 实现目前来说是最好的方式， 我们也是采用的这种方式。 但是在使用的过程中也有一些问题，就是在图片还没加载出来的是， 是获取不到每个容器img-item的<code>offsetHeight</code>。 所以有时候会有重叠的时候。</p>
<p>目前总结的就这三种方式，可以按需使用。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
</search>
