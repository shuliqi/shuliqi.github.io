<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何开发一个react UI组件库</title>
      <link href="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
      <url>/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>一直都想实现一个自己的 <code>UI</code> 组件<code>npm</code>库。这样可以沉淀自己的组件，也可以学习更多的知识点；但是有很多的概念不是很了解，所以一致觉得目标太过遥远。但是在了解一些细节和原理之后，构建自己的组件库其实也是一件很简单的事。</p> <span id="more"></span><h1 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h1><p>通过一通查找阅读， 最终觉得使用  <a href="https://d.umijs.org/zh-CN">dumi</a> 来构建是最好的。<code>dumi</code> 是一款为组件开发场景而生的文档工具。它提供的脚手架可以直接帮我们构建组件开发，文档编写， 打包文档，打包组件等功能。 能帮助我们省掉很多的工作。</p><blockquote><p>当然了， 也是可以不用的， 只是你需要自己搭个架子， 自己引入一编写的工具如 <a href="https://www.docz.site/">docz</a>。自己编写打包脚本等等。</p></blockquote><p>那我们我们接下来一步一步的开始吧！</p><p>预览地址： <a href="https://shuliqi.github.io/shuliqi-design/">https://shuliqi.github.io/shuliqi-design/</a></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>首先我们的有 <a href="https://nodejs.org/en/">node</a> 环境， 确保node的版本在 10.13 以上。可通过如下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v14.17.6</span><br></pre></td></tr></table></figure><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p><code>dumi </code>提供两种不同的脚手架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npx @umijs/create-dumi-lib        <span class="comment"># 初始化一个文档模式的组件库开发脚手架</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ yarn create @umijs/dumi-lib</span><br><span class="line"></span><br><span class="line">$ npx @umijs/create-dumi-lib --site <span class="comment"># 初始化一个站点模式的组件库开发脚手架</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ yarn create @umijs/dumi-lib --site</span><br></pre></td></tr></table></figure><p>我们先创建个空目录, 之后再使用脚手架构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir shuliqi-ui</span><br><span class="line">$ <span class="built_in">cd</span> shuliqi-ui</span><br><span class="line">$ npx @umijs/create-dumi-lib        <span class="comment"># 初始化一个文档模式的组件库开发脚手架</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>脚手架创建完成的目录为：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/1.png" class=""><p>我们可以看出来开发脚手架创建了包含  <code>dumi</code>和基础的文档之外， 还包含了一个简单的组件，单元测试，组件文档和 <code>father build</code>。</p><p>执行<code>npm run start</code>或 <code>npx dumi start</code> 即可开始调试组件和编写文档。 </p><p><code>执行npm run build</code> 即可打包编译。</p><h1 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h1><p>我们执行<code>npm run start</code>之后，可得到这样的服务界面：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/3.png" class=""><p>上面有很多信息不是我们想要的，如<code>favicon</code>,<code>logo</code>图片等。 那么这些信息我们是可以 <code>.umirc.ts</code>文件中进行修改和添加配置。具体的配置项可参考 <a href="https://d.umijs.org/zh-CN/config">dumi配置项</a></p><h1 id="组件调试"><a href="#组件调试" class="headerlink" title="组件调试"></a>组件调试</h1><p> 本地完成组件的开发之后，在发布到<code>npm </code>之前，需要在本地调试，避免带着问题上传到<code>npm</code>。那怎么调试呢？ 那就需要用到<code>npm link / yarn link</code> 了。</p><blockquote><p>什么是<code>npm link</code>/ yarn link ？</p><p>在本地开发模块的时候， 我们可以使用<code>npm link</code>/  <code>yarn link</code>命令，将模块链接到对应的运行项目中去， 方便地对模块进行调试和测试。</p></blockquote><p><strong>如何使用？</strong></p><p>我们这里使用<code>yarn link</code>为例：</p><p>我们开发完组件之后， 执行<code>npm run build</code>。之后再项目的根目录执行<code>yarn link</code>;如下：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/2.png" class=""><p>其实我们创建一个测试的组件的<code>demo</code>项目。这里我们就直接使用<code>react</code> 脚手架创建一个项目结构：<code> create-react-app demo --typescript</code>可得到如下的项目结构：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/4.png" class=""><p>我们在跟目录执行：<code>yarn link shuliqi-ui</code>如下便成功引入我们的组件：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/5.png" class=""><p>这时候我们使用我们的组件： <code>app.txs</code>的代码改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// demo/src/app.tsx</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import  &#123; Foo &#125; from &#x27;shuliqi-ui&#x27;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">     &lt;Foo title=&quot;引用shuliqi-ui的 Foo 组件&quot;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>最后执行<code>npm run start</code></p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/6.png" class=""><p>可以看出来， 没任何问题。</p><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试是书写组件库必备的。 在<code>React</code> 中常见的测试库有两个：    <a href="https://link.juejin.cn/?target=https://github.com/enzymejs/enzyme">Enzyme</a> 和 <a href="https://link.juejin.cn/?target=https://github.com/testing-library/react-testing-library">react-testing-library</a>。</p><p>我们使用<code>dumi</code>创建项目结构的时候， 默认给我们写了一个测试文档， 我们可以先它的命令<code>npm run  test</code> 执行试试看：</p><blockquote><p>小提示：关于这些命令是如何知道–&gt;具体是在<code>package.json</code>中的<code>script</code>字段知道的</p></blockquote><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/7.png" class=""><p>可看出单元测试是通过的。 我们这里主要看看是用的什么测试框架和测试库。 使用的测试框架是 <a href="https://testing-library.com/docs/react-testing-library/intro/">jest</a>。测试库是</p><p><a href="https://link.juejin.cn/?target=https://github.com/testing-library/react-testing-library">react-testing-library</a></p><blockquote><p>小提示：测试库是需要在测试框架上运行的。所以单元测试是需要测试库和测试框架的</p></blockquote><h2 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h2><p>如果不会使用<code>jest</code> 的话， 我们就简单的介绍一下。</p><h3 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h3><p><code>describe</code>用来包含一块测试的代码， 通常用它来对记个测试进行分组，它也可以自己嵌套多层的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&#x27;&lt;Foo /&gt;组件&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line"> describe(<span class="string">&#x27;文案检查&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// xxx</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p><code>test</code> 则是每一个测试，内部包含需要测试的方法，它的别名函数是<code>it</code>， 它们是等效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;组件文案是否正确&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它可以写在<code>describe</code>里面或者外面。</p><h3 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h3><p><code>expect</code>  是期望值，它需要和很多匹配器使用，如<code>toBe</code>， <code>toEqual</code>匹配器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(<span class="number">1</span>).toBe(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里的意思： 期望 1 的值是 1。<code>toBe</code>默认是直接比较，如果想要判断对象是否相等就需要使用<code>toEqual</code>。</p><h3 id="toBeCalled"><a href="#toBeCalled" class="headerlink" title="toBeCalled"></a>toBeCalled</h3><p><code>toBeCalled</code> 用来匹配函数使用被调用了。通常用来测试传入组件的事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;onClick&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn()</span><br><span class="line">  <span class="keyword">const</span> btn = <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;fn&#125;</span>&gt;</span>button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="comment">// 点击btn</span></span><br><span class="line">  expect(fn).toBeCalled()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>传入的测试函数需要使用<code>jest.fn()</code>创建。</p><h3 id="toBeTruthy-和-toBeFalsy"><a href="#toBeTruthy-和-toBeFalsy" class="headerlink" title="toBeTruthy 和 toBeFalsy"></a>toBeTruthy 和 toBeFalsy</h3><p>和名字一样，用来判断值得真假</p><h3 id="not"><a href="#not" class="headerlink" title="not"></a>not</h3><p>如果我们想要的测试的值不为某个值得时候， 就可以使用<code>not</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(<span class="number">2</span>).not.toBe(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>表示想测试的是： 2 值不为 1</p><h2 id="React-Testing-Library"><a href="#React-Testing-Library" class="headerlink" title="React Testing Library"></a>React Testing Library</h2><p>虽然它的名字叫 <code>React Testing Library </code> 但是包名叫：<code>@testing-library/react</code>。 为了测试<code>dom</code>。<code>@testing-library/jest-dom</code> 包添加了一些额外的配置。</p><p>关于<code>@testing-library/react</code> 的使用， 这里就不细说了，可以到官网 <a href="https://testing-library.com/docs/queries/bylabeltext">testing-library.com</a>学习。</p><p>下面会简单举几个例子， 我们在我的项目目录<code>src</code>下创建<code>demo.test.tsx</code>。 用来写下面这几个例子的。</p><h3 id="测试点击"><a href="#测试点击" class="headerlink" title="测试点击"></a>测试点击</h3><p>通常我们无法判断判断按钮是否点击，所以都是通过模拟用户点击后，按钮的事件是否被调用来判断的。</p><p>用到的相关的知识点： <a href="https://testing-library.com/docs/dom-testing-library/api-events">fireEvent</a>，<a href="https://testing-library.com/docs/angular-testing-library/api/#render">render</a>，<a href="https://testing-library.com/docs/queries/bylabeltext">Bylabeltext</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@testing-library/jest-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render, fireEvent &#125; <span class="keyword">from</span> <span class="string">&#x27;@testing-library/react&#x27;</span>;</span><br><span class="line">describe(<span class="string">&#x27;单元测试demo&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;测试点击&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 测试函数</span></span><br><span class="line">    <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render 用来渲染元素</span></span><br><span class="line">    <span class="keyword">const</span> &#123; getByLabelText &#125; =render(<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">aria-label</span>=<span class="string">&quot;Button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;fn&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getByLabelText 可以通过aria-label的值来获取元素</span></span><br><span class="line">    <span class="keyword">const</span> btn = getByLabelText(<span class="string">&#x27;Button&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  模拟点击事件</span></span><br><span class="line">    fireEvent.click(btn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望 fn 函数被调用</span></span><br><span class="line">    expect(fn).toBeCalled();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望 fn 被调用一次</span></span><br><span class="line">    expect(fn).toBeCalledTimes(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们<code>npn run test</code>测试一下：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/7.png" class=""><h3 id="测试-input-的值和输入"><a href="#测试-input-的值和输入" class="headerlink" title="测试 input 的值和输入"></a>测试 input 的值和输入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">it(<span class="string">&#x27;测试 input 的值和输入&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 测试函数</span></span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; getByTestId &#125; = render(<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">data-testid</span>=<span class="string">&quot;input&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;fn&#125;/</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  通过 data-testid 获取元素</span></span><br><span class="line">  <span class="keyword">const</span> inputDom = getByTestId(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟 change 事件</span></span><br><span class="line">  fireEvent.change(inputDom, &#123; <span class="attr">target</span>: &#123; <span class="attr">value</span>: <span class="string">&quot;shuliqi&quot;</span>&#125;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 期望函数 fn 被调用</span></span><br><span class="line">  expect(fn).toBeCalled();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 期望input的值是： shuliqi</span></span><br><span class="line">  expect(inputDom).toHaveValue(<span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="测试元素是否被-disable"><a href="#测试元素是否被-disable" class="headerlink" title="测试元素是否被 disable"></a>测试元素是否被 <code>disable</code></h3><p>我们可以使用<code>toBeDisabled</code>来匹配是否被<code>disable</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;测试元素是否被disable&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; getByText &#125; = render(<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getByText 从 text 获取元素</span></span><br><span class="line">    <span class="keyword">const</span> btnDom = getByText(<span class="string">&#x27;按钮&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望元素是禁的状态</span></span><br><span class="line">    expect(btnDom).toBeDisabled();</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="测试元素包含某类名"><a href="#测试元素包含某类名" class="headerlink" title="测试元素包含某类名"></a>测试元素包含某类名</h3><p>我们可以使用<code>toHaveClass</code>来匹配是否包含某个类名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;测试元素包含某类名&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; getByText &#125; = render(<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getByText 从 text 获取元素</span></span><br><span class="line">  <span class="keyword">const</span> btnDom = getByText(<span class="string">&#x27;按钮&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 期望元素有 btn 类名</span></span><br><span class="line">  expect(btnDom).toHaveClass(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="props-改变元素是否生效"><a href="#props-改变元素是否生效" class="headerlink" title="props 改变元素是否生效"></a>props 改变元素是否生效</h3><p>在<code>@testing-library/react</code> 中需要使用<code>rerender</code>方法来改变<code>props</code>, <code>toHaveTextContent</code>来匹配内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;props 改变元素是否生效&#x27;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> Demo = <span class="function">(<span class="params">&#123; text &#125; : any</span>) =&gt;</span>  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">aria-label</span>=<span class="string">&quot;shuliqi&quot;</span>&gt;</span>&#123; text || &#x27;默认值&#x27;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">   <span class="keyword">const</span> &#123;getByLabelText, rerender&#125; = render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span>/&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 aria-label 的元素</span></span><br><span class="line">   <span class="keyword">const</span> dom = getByLabelText(<span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当没有传 props 参数时， 期望内容是： 默认值</span></span><br><span class="line">   expect(dom).toHaveTextContent(<span class="string">&#x27;默认值&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 rerender来模拟 props 改变</span></span><br><span class="line">   rerender(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">text</span>=<span class="string">&quot;传入的值&quot;</span>/&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  props 改变之后，期望值是传入的值</span></span><br><span class="line">   expect(dom).toHaveTextContent(<span class="string">&#x27;传入的值&#x27;</span>);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h3 id="子元素是否包含某一类名"><a href="#子元素是否包含某一类名" class="headerlink" title="子元素是否包含某一类名"></a>子元素是否包含某一类名</h3><p>有时候会通过受控值为子元素添加类名，可以用<code>getElementByClassName</code>通过类名获取子元素，应用的场景如：判断下拉框是否有开启某类名，或者是列表是否存在被选择元素的类名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;子元素是否包含某一类名&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 组件</span></span><br><span class="line">  <span class="keyword">const</span> Demo = <span class="function">(<span class="params">&#123; className &#125;: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span>子元素1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span>子元素2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; baseElement&#125; = render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">className</span>=<span class="string">&quot;shuliqi&quot;</span>/&gt;</span></span>);</span><br><span class="line">  <span class="comment">// 获取具有相同名字的子类元素</span></span><br><span class="line">  <span class="keyword">const</span> childrenEle = baseElement.getElementsByClassName(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 期望子类元素有两个</span></span><br><span class="line">  expect(childrenEle.length).toBe(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 当然测试单元测试不仅仅只是这些,还有很多如： 测试异步， 定时器等等。我们就不在这里一一举例了。有需要的时候可以搜索看看即可</p><h1 id="组件发布npm"><a href="#组件发布npm" class="headerlink" title="组件发布npm"></a>组件发布npm</h1><p>最后， 我们的组件开发调试测试都完成之后， 就需要发布，这样别人就能<code>npm install </code> 来使用我们的组件了</p><h2 id="package-json-相关字段"><a href="#package-json-相关字段" class="headerlink" title="package.json 相关字段"></a>package.json 相关字段</h2><p>打包发布这一部分跟<code>package.json </code>里面的字段是有一些关系， 我们来看主要的一些字段解释。</p><ul><li><p><code>main</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="attr">main</span>:<span class="string">&quot;lib/index.js&quot;</span></span><br></pre></td></tr></table></figure><p>定义<code>npm</code> 包的入口文件，<code>browser</code> 和<code> node</code> 环境都是可用的</p></li><li><p><code>module</code>: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="attr">main</span>:<span class="string">&quot;es/index.js&quot;</span></span><br></pre></td></tr></table></figure><p>定义<code>npm</code>包的<code>esm</code>规范的入口文件，<code>browser</code> 和<code> node</code> 环境都是可用的</p><blockquote><p>关于打包的规范， 有哪规范，每种规范是如何引用的可看这篇文章：<a href="https://shuliqi.github.io/2021/03/06/webpack%E5%AD%A6%E4%B9%A0-%E4%BC%98%E5%8C%96%EF%BC%88optimization%EF%BC%89/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/">Javascript模块化编程总结</a></p></blockquote></li><li><p><code>typings</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="string">&quot;typings&quot;</span>: <span class="string">&quot;es/index.d.ts&quot;</span>,</span><br></pre></td></tr></table></figure><p>定义包的类型声明文件。</p></li></ul><h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p><code>dumi </code> 已经为我们弄好打包的脚本了, 采用的是 <a href="https://github.com/umijs/father">father</a> 这个包来进行构建打包。只需要执<code>npm run build</code>即可</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/9.png" class=""><p>之后我们就可以进行发布了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm version patch</span><br><span class="line">$ npm publish</span><br></pre></td></tr></table></figure><blockquote><p>如果没有登录的话， 需要<code>npm login</code>登录一下</p></blockquote><p>由于在这过程中出现了包名已被注册了， 所以改了个名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;name&quot;: &quot;shuliqi-design&quot;,</span><br></pre></td></tr></table></figure><p>之后发布：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/10.png" class=""><p>只有登录 <a href="https://www.npmjs.com/">npm官网</a>就可以看到自己发布的包</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/11.png" class=""><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>发布了包之后我们来测试一下， 还是继续使用的之前的 <code>demo</code>项目。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i shuliqi-design --save</span><br></pre></td></tr></table></figure><p>我们之前的<code>APP.tsx</code> 修改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo/src/app.tsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span>   &#123;Foo&#125;  <span class="keyword">from</span> <span class="string">&quot;shuliqi-design&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">Foo</span> <span class="attr">title</span>=<span class="string">&quot;引用shuliqi-ui的 Foo 组件&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行之后是可以的。</p><p>那么到现在我们关于组件的编写，本地调试， 单元测试， 发布 <code>npm</code> 已经完成了。</p><p><strong>上传组件代码到github:</strong></p><p>到目前我们把我们的组件代码上传到<code>github</code>。</p><p>我们在<code>github</code>上创建一个仓库， 然后在我们的项目跟目录执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init    </span><br><span class="line">$ git remote add origin &lt;自己创建的仓库.git 地址&gt;</span><br></pre></td></tr></table></figure><h1 id="文档编写"><a href="#文档编写" class="headerlink" title="文档编写"></a>文档编写</h1><p>我们写完一个组件之后，需要写文档，别人才知道是怎么使用你的组件的， 所以文档的编写他也是重中之重的。</p><p>我们使用的  <a href="https://d.umijs.org/zh-CN">dumi</a> 就是一款为组件开发场景而生的文档工具。我们构建的时候默认给我们做好了配置。使用<code>markdown</code>方式写的。</p><p>那么接下来我们就写个例子：</p><p>修改 <code>Foo</code> 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line">interface Props &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 可以这样写属性描述</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description      </span>不是必填的</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@default <span class="variable">_</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="attr">title</span>: string; <span class="comment">// 文案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo: React.FC&lt;Props&gt; = <span class="function">(<span class="params">&#123;title&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Foo;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Foo</code>组件目录中修改<code>index.md</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section"># Foo 组件文档</span></span><br><span class="line">----</span><br><span class="line"><span class="section">## 例子:</span></span><br><span class="line"></span><br><span class="line"><span class="code">```tsx</span></span><br><span class="line"><span class="code">import React from &#x27;react&#x27;;</span></span><br><span class="line"><span class="code">import Foo from &#x27;./index.tsx&#x27;;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">export default () =&gt; &lt;Foo title=&quot;我是一个例子&quot; /&gt;;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"><span class="section">## API </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">API</span> <span class="attr">hideTitle</span> <span class="attr">src</span>=<span class="string">&quot;./index.tsx&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">API</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后执行<code>npm run start</code>。 即可看到文档的界面。</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/12.png" class=""><p>这样呢， 一个组件的文档就写完了。 当然这是很简单的写法， 可以根据自己的需要编写。具体的编写配置需要看： <a href="https://d.umijs.org/zh-CN">dumi 文档</a>  </p><h1 id="文档打包部署"><a href="#文档打包部署" class="headerlink" title="文档打包部署"></a>文档打包部署</h1><p>执行<code>npm run docs:build </code> 可把文档全部打包到<code>docs-dist</code>。 我们可以将 <code>docs-dist</code> 目录部署在 <code>now.sh</code>、<code>GitHub Pages </code>等静态站点托管平台或者某台服务器即可访问。</p><p>这里我们以 <code>GitHub Pages</code> 为例,</p><p>由于我自己的博客也是用的<code>GitHub Pages</code>， 所以文档就是新加的一个页面。</p><p>执行<code>npm run deploy</code>将会打包文档并且上传到<code>github</code>。 分支为：gh-page。</p><p>我们之前在<code>github</code>上创建了仓库，并且上传了我们的代码。设置<code>page</code>:</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/13.png" class=""><p>之后就可以访问到我们的组件文档说明：<a href="https://shuliqi.github.io/shuliqi-design/">https://shuliqi.github.io/shuliqi-design/</a></p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/14.png" class=""><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样呢！我们就有了属于我们自己的组件库。之后就可以考虑我们写哪些组件进去了。放到之后慢慢写吧</p><p>如果有兴趣的可以看  <a href="https://github.com/shuliqi/shuliqi-design/tree/master">组件库的代码</a></p><h1 id="结构优化"><a href="#结构优化" class="headerlink" title="结构优化"></a>结构优化</h1><p>上面的构建虽然大体的流程是可以的， 但是结构上有点混乱: 组件里面包含了单元测试，文档md等。其实我们可以把文件目录改成如下：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/16.png" class=""><p>这样的目录就很清晰明了。</p><h1 id="开发组件遇到的抗"><a href="#开发组件遇到的抗" class="headerlink" title="开发组件遇到的抗"></a>开发组件遇到的抗</h1><p>上面的步骤虽然都完毕了， 但不可避免有一些坑在实际开发的时候才会遇到的。 接下来的篇幅将会记录实际开发过程中遇到的坑以及如何解决。</p><h2 id="组件的-css-无法被加载"><a href="#组件的-css-无法被加载" class="headerlink" title="组件的 css 无法被加载"></a>组件的 css 无法被加载</h2><p>当我开发一个<code>Button</code>组件的时候， 用了一个<code>less</code> 文件。 整体如下：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/15.png" class=""><p>我们在写<code>Demo</code>文档的时候， 是直接引用的源文件组件，所以预览是完全符预期的。但是我们测试组件（如果还不知道如何调试：可以看<strong>组件调试</strong>）， 发现我们的组件<code>css</code>  没有引用上。我们打包之后看到的<code>less</code>文件没有被打包。应该是要打包成<code>css</code> 文件才可以呀。</p><p>由于组件是 由<a href="https://github.com/umijs/father">father</a>打包的。 我们看它的配置有这么一个配置 <a href="https://github.com/umijs/father#lessinbabelmode">lessInBabelMode</a>。 这配置用于在<code>babel</code>模式下作品<code>less</code>编译。默认不开启。</p><p>那我们只需要在我们的<code>.fatherrc.ts</code>开启这个配置即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">esm</span>: <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">  <span class="attr">lessInBabelMode</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这之后再打包，<code> less</code> 就被转义成<code>css</code>文件了。 组件调试的时候完全符合预期。</p><h1 id="组件开发值得记录的点"><a href="#组件开发值得记录的点" class="headerlink" title="组件开发值得记录的点"></a>组件开发值得记录的点</h1><h2 id="Button-按钮"><a href="#Button-按钮" class="headerlink" title="Button 按钮"></a>Button 按钮</h2><p>写<code>Button</code> 按钮的时候， 主要是参考 <a href="https://element-plus.gitee.io/zh-CN/component/button.html">element Button</a>功能来做的。主要包含 按钮类型，按钮大小，是否是朴素按钮，是否是圆形，是否是文字按钮，是否禁用， 支持自己添加<code>class</code> 和 <code>style</code>。</p><h3 id="容易实现的点"><a href="#容易实现的点" class="headerlink" title="容易实现的点"></a>容易实现的点</h3><p>其中做：按钮类型，按钮大小，是否是朴素按钮，是否是圆形，是否是文字按钮，支持自己添加<code>class</code> 和 <code>style</code> 很容易就能得出方案如何做。可通过添加不同的<code>class</code> 来完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btnClassName = cs(&#123;</span><br><span class="line">   <span class="string">&#x27;slq--button&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">   [<span class="string">`slq--button--<span class="subst">$&#123;type&#125;</span>`</span>]: <span class="literal">true</span>,</span><br><span class="line">   [<span class="string">`slq--button--type--<span class="subst">$&#123;type&#125;</span>`</span>]: <span class="literal">true</span>,</span><br><span class="line">   [<span class="string">`slq--button--size--<span class="subst">$&#123;size&#125;</span>`</span>]: <span class="literal">true</span>,</span><br><span class="line">   <span class="string">&#x27;is--plain&#x27;</span>: plain,</span><br><span class="line">   <span class="string">&#x27;is--round&#x27;</span>: round,</span><br><span class="line">   [<span class="string">`<span class="subst">$&#123;className&#125;</span>`</span>]: className,</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>而我们的<code>css</code> 是需要做成有可以覆盖的。 所以我们把一些可能需要定制的属性值设置成变量：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* variables.less */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主题 */</span></span><br><span class="line">@--theme-primary: #<span class="number">66</span>b1ff;</span><br><span class="line">@--theme-success: #<span class="number">67</span>c23a;</span><br><span class="line">@--theme-warning: #e6a23c;</span><br><span class="line">@--theme-danger: #f56c6c;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 常用变量 */</span></span><br><span class="line">@--white: #fff;</span><br><span class="line">@--grey: #ccc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* button */</span></span><br><span class="line">@--button-default: #ecf5ff;</span><br><span class="line">@--button-primary: @--theme-primary;</span><br><span class="line">@--button-success: @--theme-success;</span><br><span class="line">@--button-warning: @--theme-warning;</span><br><span class="line">@--button-danger: @--theme-danger;</span><br><span class="line">@--button-info: #<span class="number">909399</span>;</span><br><span class="line">@--button-border-radius-round: <span class="number">20px</span>;</span><br><span class="line">@--button-text-color: #<span class="number">606266</span>;</span><br><span class="line">@--button-size-default: <span class="number">40px</span>;</span><br><span class="line">@--button-size-medium: <span class="number">36px</span>;</span><br><span class="line">@--button-size-small: <span class="number">32px</span>;</span><br><span class="line">@--button-size-mini: <span class="number">28px</span>;</span><br></pre></td></tr></table></figure><p>这个文件我们不同的按钮类型，大小等定义了不同的颜色值变量。</p><p>接下来就是定义这些不同的<code>class</code>样式。 由于我们很多的样式属性是一致的， 只是属性值不一样。 所以我们可以使用  <a href="https://less.bootcss.com/functions/">less 函数</a>方式来写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 按钮类型函数 */</span></span><br><span class="line">.slq-button-<span class="function"><span class="title">type</span>(<span class="params">@type</span>)</span> &#123;</span><br><span class="line">  .slq--button--type--@&#123;type&#125; &#123;</span><br><span class="line">    <span class="attr">color</span>: @--white;</span><br><span class="line">    background-color: ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">    border: 1px solid ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">      background-color: rgba(color(~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>), <span class="number">0.8</span>);</span><br><span class="line">      border-color: rgba(color(~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>), <span class="number">0.8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;:active &#123;</span><br><span class="line">      <span class="attr">color</span>: @--white;</span><br><span class="line">      background-color: ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">      border-color: ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 是否朴素按钮函数 */</span></span><br><span class="line">.slq-button-<span class="function"><span class="title">plain</span>(<span class="params">@type</span>)</span> &#123;</span><br><span class="line">  .slq--button--@&#123;type&#125;.is--plain &#123;</span><br><span class="line">    <span class="attr">color</span>: ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">    background-color: rgba(color(~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>), <span class="number">0.2</span>);</span><br><span class="line">    border-color: rgba(color(~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>), <span class="number">0.8</span>);</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">      <span class="attr">color</span>: @--white;</span><br><span class="line">      background-color: rgba(color(~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>), <span class="number">0.9</span>);</span><br><span class="line">      border-color: rgba(color(~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>), <span class="number">0.9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;:active,</span><br><span class="line">    &amp;:visited &#123;</span><br><span class="line">      background-color: ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">      border-color: ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按钮大小函数  */</span></span><br><span class="line">.slq-button-<span class="function"><span class="title">size</span>(<span class="params">@type</span>)</span> &#123;</span><br><span class="line">  .slq--button.slq--button--size--@&#123;type&#125; &#123;</span><br><span class="line">    min-height: ~<span class="string">&#x27;@&#123;--button-size-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.slq-button-type(primary);</span><br><span class="line">.slq-button-plain(primary);</span><br><span class="line"></span><br><span class="line">.slq-button-type(success);</span><br><span class="line">.slq-button-plain(success);</span><br><span class="line"></span><br><span class="line">.slq-button-type(info);</span><br><span class="line">.slq-button-plain(info);</span><br><span class="line"></span><br><span class="line">.slq-button-type(warning);</span><br><span class="line">.slq-button-plain(warning);</span><br><span class="line"></span><br><span class="line">.slq-button-type(danger);</span><br><span class="line">.slq-button-plain(danger);</span><br><span class="line"></span><br><span class="line">.slq-button-size(medium);</span><br><span class="line">.slq-button-size(small);</span><br><span class="line">.slq-button-size(mini);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  是否是圆形按钮*/</span></span><br><span class="line">.is--round &#123;</span><br><span class="line">  border-radius: @--button-border-radius-round;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  是否是文字按钮 */</span></span><br><span class="line">.slq--button--text &#123;</span><br><span class="line">  <span class="attr">color</span>: @--theme-primary;</span><br><span class="line">  background: transparent;</span><br><span class="line">  border-color: transparent;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="attr">color</span>: rgba(color(@--theme-primary), <span class="number">0.8</span>);</span><br><span class="line">    background: transparent;</span><br><span class="line">    border-color: transparent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而默认按钮的样式属性和属性值都和别的不太一样，所以我们还是单独写；还有一些公共的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.slq--button</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">min-height</span>: @--button-size-default;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: @--button-text-color;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.slq--button--type--default</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: @--white;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid @--grey;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: @--theme-primary;</span><br><span class="line">    <span class="attribute">background-color</span>: @--button-default;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(@--theme-primary, <span class="number">0.3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.slq--button--type--default</span><span class="selector-class">.is--plain</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: @--white;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: @--theme-primary;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样这些功能就已经完成了，效果如下：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/17.png" class=""><h3 id="有点有趣的点"><a href="#有点有趣的点" class="headerlink" title="有点有趣的点"></a>有点有趣的点</h3><p>而我在做 是否禁用 的时候，遇到了一点困难；刚开始我的想法是：如果是禁用的按钮， 那么就添加<code>is-disabled</code>的  <code>class</code>， 设置<code>cursor</code> 为 不可选，然后按钮的整体透明度是0.5。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.is-disabled</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是效果不太理想：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/18.gif" class=""><p>效果就是如此，按钮的不同类型，是有不同的状态的，如<code>hover</code>, <code>visited</code>等； 而我们的禁用只是加了一个透明度和<code>cursor</code>。 <code>cursor: not-allowed;</code>只是改变了鼠标的样式而已。</p><p>那有其他的办法呢？ 假如我们禁掉事件？–&gt;<code> pointer-events: none;</code> 这样就不会有<code>hover</code>等这样的样式出现了， 但是点击事件啥的也不能了呀。 这办法行不通的。</p><p>那还有其他的办法呢？我如何知道每个按钮类型的样色值呢？</p><p>于是我去看了 <a href="https://github.com/element-plus/element-plus">element</a> 和 <a href="https://github.com/arco-design/arco-design">arco.design</a>实现禁用的源码。</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/20.png" class=""><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/19.png" class=""><p>他们实现的原理都是：不同的类型的按钮都需要设置相应的<code>background-color</code> 和 <code>border</code>等。而不是靠统一的一个样式如我们值设置了<code>.is-disabled </code>来实现的。</p><p>name解决的办法来了，我们在禁用的按钮的时候根据不同的类型添加不同的禁用<code>class</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[`is--disabled--$&#123;type&#125;`]</span>: disabled,</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.slq-button-disabled</span>(<span class="keyword">@type</span>) &#123;</span><br><span class="line">  <span class="selector-class">.slq--button--</span>@&#123;type&#125;<span class="selector-class">.is--disabled--</span>@&#123;type&#125; &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">background-color</span>: ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">      <span class="attribute">border-color</span>: ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">      <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.slq--button--</span>@&#123;type&#125;<span class="selector-class">.is--plain</span><span class="selector-class">.is--disabled--</span>@&#123;type&#125; &#123;</span><br><span class="line">    <span class="attribute">color</span>: ~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">color</span>(~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>), <span class="number">0.2</span>);</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">color</span>(~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>), <span class="number">0.8</span>);</span><br><span class="line">    <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">color</span>(~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>), <span class="number">0.2</span>);</span><br><span class="line">      <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">color</span>(~<span class="string">&#x27;@&#123;--button-@&#123;type&#125;&#125;&#x27;</span>), <span class="number">0.8</span>);</span><br><span class="line">      <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slq-button-disabled</span>(primary);</span><br><span class="line"><span class="selector-class">.slq-button-disabled</span>(success);</span><br><span class="line"><span class="selector-class">.slq-button-disabled</span>(info);</span><br><span class="line"><span class="selector-class">.slq-button-disabled</span>(warning);</span><br><span class="line"><span class="selector-class">.slq-button-disabled</span>(danger);</span><br></pre></td></tr></table></figure><p> 最后实现的效果如下：</p><img src="/2021/12/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAreact-UI%E7%BB%84%E4%BB%B6%E5%BA%93/21.gif" class=""><p>这样就实现我们想要的效果了。</p><p>上面可能只贴出了一部分的代码，如果想看具体的完整实现 可到  <a href="https://github.com/shuliqi/shuliqi-design/tree/master">shuliqi-design</a>查看。</p><p><strong>感悟</strong>： 有时间多看看源码， 学习学习别人的思想也是很有用的 😄</p><p>参考文章：</p><ul><li><p><a href="https://d.umijs.org/zh-CN">https://d.umijs.org/zh-CN</a></p></li><li><p><a href="https://github.com/jokingzhang/blog/issues/2">https://github.com/jokingzhang/blog/issues/2</a></p></li><li><p><a href="https://juejin.cn/post/6968821346088255525">https://juejin.cn/post/6968821346088255525</a></p></li><li><p><a href="https://segmentfault.com/a/1190000021663334?utm_source=sf-similar-article">https://segmentfault.com/a/1190000021663334?utm_source=sf-similar-article</a></p></li><li><p><a href="https://juejin.cn/post/6862494892569051143#heading-2">https://juejin.cn/post/6862494892569051143#heading-2</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 基础学习</title>
      <link href="/2021/11/24/TypeScript%E5%85%A5%E9%97%A8-%E4%B8%80/"/>
      <url>/2021/11/24/TypeScript%E5%85%A5%E9%97%A8-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>最近做的项目用到了<code>TypeScript</code> ，之前也看过一些，但是没有看完。所以既然项目用到了，觉得还是有必要过一遍，趁着最近正好有点时间可以再看看，把之前没学习完也正好补上。本文就当是一个学习的记录，方便供后期翻阅。</p><blockquote><p>TypeScript <a href="http://www.typescriptlang.org/docs/handbook/basic-types.html">官方文档</a>, <a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook">非官方中文文档</a></p></blockquote><span id="more"></span><h1 id="TypeScript-是什么"><a href="#TypeScript-是什么" class="headerlink" title="TypeScript 是什么"></a>TypeScript 是什么</h1><p>TypeScript官网是这么解释的：</p><blockquote><p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.</p></blockquote><p>翻译过来就是：</p><blockquote><p>TypeScript 是 JavaScript 的类型的一个超集，它可以编译成纯<code>JavaScript</code>。编译出来的<code>JavaScrip</code>t可以运行在任何的浏览器上。<code>TypeScript</code>编译的工具可以运行在任何服务器和任何系统上。<code>TypeScript</code>是开源 的。</p></blockquote><p>而我自己的理解是：</p><p><code>TypeScript</code>是 <code>JavaScript</code>的一个超集。主要提供了<strong>类型系统</strong>和对<strong>es6</strong>的支持。</p><h1 id="TypeScript的优点"><a href="#TypeScript的优点" class="headerlink" title="TypeScript的优点"></a>TypeScript的优点</h1><p><a href="http://www.typescriptlang.org/">TypeScript 官网</a>列举了TypeScript的很多优点。 自己总结的话， 我觉得有以下优点：</p><p><strong>增加代码的可读性和可维护性</strong></p><ul><li>在编译的过程中发现大部分的bug的错误。</li><li>增强了编辑器和<code> IDE</code> 的功能，包括代码补全、接口提示、跳转到定义、重构等。</li><li>类型系统非常好。大部分看类型的定义就知道函数该如何使用了。</li></ul><p><strong>非常包容</strong></p><ul><li><code>TypeScript</code>是<code>JavaScript</code>的一个超集。所以后缀<code>.js</code>可以直接改名为<code>.ts</code>。</li><li><code>TypeScript</code>编译报错， 也可以生成JavaScript文件。</li></ul><h1 id="TypeScript的缺点"><a href="#TypeScript的缺点" class="headerlink" title="TypeScript的缺点"></a>TypeScript的缺点</h1><ul><li><p>有一定的学习成本，需要理解接口（<code>Interfaces</code>）、泛型（<code>Generics</code>）、类（Classes）、枚举类型（<code>Enums</code>）等前端工程师可能不是很熟悉的概念。</p></li><li><p>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，<code>TypeScript </code>能够减少其维护成本。</p></li><li><p>集成到构建流程需要一些工作量。</p></li><li><p>可能和一些库结合的不是很完美。</p></li></ul><h1 id="TypeScript的安装"><a href="#TypeScript的安装" class="headerlink" title="TypeScript的安装"></a>TypeScript的安装</h1><p><code>TypeScript</code> 的命令行工具安装方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><h1 id="TypeScript-的例子"><a href="#TypeScript-的例子" class="headerlink" title="TypeScript 的例子"></a>TypeScript 的例子</h1><p>我们创建一个文件：<code>hello.ts</code></p><p>在该文件中写入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">person: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(helloWorld(user));</span><br></pre></td></tr></table></figure><p>然后我们进行编辑，可以执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><p>执行完，会生成一个编译好的文件：hello.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(helloWorld(user));</span><br></pre></td></tr></table></figure><p>注：<code>TypeScript</code>中使用 <strong>：</strong>指定变量的类型。 <strong>：</strong>前后有没有空格都无所谓。</p><p>上面的例子中，我们的变量 <code>person </code>的类型是 string。 但是在编译之后的js 中， 并没有检查变量类型的代码插入进来。</p><p><strong>TypeScript只会静态检查，如果有错误。在编译的时候会抛出错误</strong></p><p>例如：我们在hello.ts中的user变量赋值一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">person: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(helloWorld(user));</span><br></pre></td></tr></table></figure><p>编译的时候就会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello.ts:<span class="number">6</span>:<span class="number">24</span> - error TS2345: Argument <span class="keyword">of</span> type <span class="string">&#x27;number[]&#x27;</span> is not assignable to parameter <span class="keyword">of</span> type <span class="string">&#x27;string&#x27;</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="built_in">console</span>.log(helloWorld(user));</span><br><span class="line">                         ~~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> error.</span><br></pre></td></tr></table></figure><p><strong>TypeScript在编译的时候检查出错误，抛出错误，但还是会生成js文件</strong>。</p><p>如上的例子，还是会生成**.js**文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(helloWorld(user));</span><br></pre></td></tr></table></figure><h1 id="TypeScript-类型"><a href="#TypeScript-类型" class="headerlink" title="TypeScript 类型"></a>TypeScript 类型</h1><blockquote><p>TypeScript支持与Javascript几乎相同的数据类型。</p><p>Javascript分为原始数据类型（布尔值，数值，字符串，null, undefined）和对象类型。</p></blockquote><h2 id="布尔值（boolean）"><a href="#布尔值（boolean）" class="headerlink" title="布尔值（boolean）"></a>布尔值（boolean）</h2><p>在typeScript中使用<code>boolean</code>定义布尔值类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isOk:boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span></span><br></pre></td></tr></table></figure><p>注意：只有构造函数 <code>Boolean</code>创建的对象不是布尔值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isOk:boolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>编译的时候报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello.ts:<span class="number">10</span>:<span class="number">5</span> - error TS2322: Type <span class="string">&#x27;Boolean&#x27;</span> is not assignable to type <span class="string">&#x27;boolean&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;boolean&#x27;</span> is a primitive, but <span class="string">&#x27;Boolean&#x27;</span> is a wrapper object. Prefer using <span class="string">&#x27;boolean&#x27;</span> when possible.</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="keyword">let</span> isOk : boolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>原因：new Boolean()返回的是一个 <code>Boolean</code> 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isOk:<span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>编译不会报错</p><p>其次直接调用 <code>Boolean</code>也是返回布尔值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isOk:boolean = <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="数值（number）"><a href="#数值（number）" class="headerlink" title="数值（number）"></a>数值（number）</h2><p>在TypeScript中使用<code>number</code>定义数值类型。</p><p><code>TypeScript</code>和<code>Javascript</code>一样，所有的数字都是浮点数。类型都<code>number</code>。<code>TypeScript</code>除了支持十进制和十六进制字面量外，还支持<a href="http://es6.ruanyifeng.com/#docs/number">ES6的八进制和二进制的字面量</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: number = <span class="number">0b1010</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: number = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> notANumber: number = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> infinityNumber: number = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure><p>编辑的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decLiteral = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> hexLiteral = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">var</span> binaryLiteral = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">var</span> octalLiteral = <span class="number">484</span>;</span><br><span class="line"><span class="keyword">var</span> notANumber = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> infinityNumber = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure><p>其中 <code>0b1010</code> 和 <code>0o744</code> 是 <a href="http://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p><h2 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h2><p>用<code>string</code>表示文本数据类型。 和<code>JavaScript</code>一样，可以使用双引号（<code>&quot;</code>），单引号（<code>’</code>）或 <code>模版字符串</code> 表示字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双引号</span></span><br><span class="line"><span class="keyword">let</span> firstName:string = <span class="string">&quot;shu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单引号</span></span><br><span class="line"><span class="keyword">let</span> lastName:string = <span class="string">&quot;liqi&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版字符串</span></span><br><span class="line"><span class="keyword">let</span> name:string = <span class="string">`my name is <span class="subst">$&#123;firstName&#125;</span><span class="subst">$&#123;lastName&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// my name is shu liqi</span></span><br></pre></td></tr></table></figure><h2 id="空值-void"><a href="#空值-void" class="headerlink" title="空值    (void)"></a>空值    (void)</h2><p><code>JavaScript</code>中时没有空值的概念。但在<code>TypeScript</code> 中可以使用<code>void</code> 表示没有任何返回值的函数。</p><p>注意：定义一个空值的变量是没有用的。因为只能赋值 null 或者 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;my name is shuliqi&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name:<span class="keyword">void</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><p>可以使用 <code>Null</code> 和 <code>Undefined</code> 来定义这两个原始类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName:<span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> age:<span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>注意：null 和 undefined 是所有类型的子集。也就是说 null ，undefined 可以赋值给其他类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: string = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> age: number = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myName: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> myLastName: number = myName;</span><br><span class="line"><span class="keyword">let</span> myAge = age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都不会报错</span></span><br></pre></td></tr></table></figure><p>但是 <code>void</code> 类型的变量不能赋值给 其他 类型的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAge:<span class="keyword">void</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> myGender:<span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age: number = myAge;</span><br><span class="line"><span class="keyword">let</span> gender: string = myGender;</span><br></pre></td></tr></table></figure><p>编译报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello.ts:<span class="number">52</span>:<span class="number">5</span> - error TS2322: Type <span class="string">&#x27;void&#x27;</span> is not assignable to type <span class="string">&#x27;number&#x27;</span>.</span><br><span class="line"><span class="number">52</span> <span class="keyword">let</span> age: number = myAge;</span><br><span class="line">hello.ts:<span class="number">53</span>:<span class="number">5</span> - error TS2322: Type <span class="string">&#x27;void&#x27;</span> is not assignable to type <span class="string">&#x27;string&#x27;</span>.</span><br><span class="line"><span class="number">53</span> <span class="keyword">let</span> gender: string = myGender;</span><br></pre></td></tr></table></figure><h2 id="任意值（any）"><a href="#任意值（any）" class="headerlink" title="任意值（any）"></a>任意值（any）</h2><p>任意值（any）用来表示允许赋值为任何类型。</p><h3 id="什么是任意值类型"><a href="#什么是任意值类型" class="headerlink" title="什么是任意值类型"></a>什么是任意值类型</h3><p>在TypeScript中普通的类型，如果在赋值的过程中改变类型是不允许的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: string = <span class="string">&#x27;12&#x27;</span>;</span><br><span class="line">age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>编译时报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello.ts:<span class="number">62</span>:<span class="number">1</span> - error TS2322: Type <span class="string">&#x27;5&#x27;</span> is not assignable to type <span class="string">&#x27;string&#x27;</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">62</span> age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>但是类型是任意值类型的话。就允许在赋值的过程中改变类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let age: any = &#x27;12&#x27;;</span><br><span class="line">age = 5</span><br></pre></td></tr></table></figure><h3 id="任意值的属性和方法"><a href="#任意值的属性和方法" class="headerlink" title="任意值的属性和方法"></a>任意值的属性和方法</h3><p>访问任意值的属性和方法都是允许的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anyName: any = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anyName.firstName);</span><br><span class="line">anyName.setName(<span class="string">&#x27;shulina&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p><h3 id="未声明的类型的变量"><a href="#未声明的类型的变量" class="headerlink" title="未声明的类型的变量"></a>未声明的类型的变量</h3><p>如果在声明变量的时候，没有制指定类型。那么会被识别为任意值类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName;</span><br><span class="line">myName = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line">myName = <span class="number">12</span>;</span><br><span class="line">myName = <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line">myName = <span class="literal">null</span>; </span><br><span class="line">myName = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h2 id="枚举（Enum）"><a href="#枚举（Enum）" class="headerlink" title="枚举（Enum）"></a>枚举（Enum）</h2><p>在我们的实际应用中， 有的变量只有几种可能取值， 如人的性别就只有两种可能取值，星期就只有七种可能取值。所谓的枚举就是将变量的值一一列举出来，变量只限于列举出来的范围内取值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum weekday &#123;sun,mon,tue,wed,thu,fri,sat&#125;</span><br></pre></td></tr></table></figure><p>如上， 我们定义了一个枚举类型 <code>weekday</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> day: weekday = weekday.mon;</span><br></pre></td></tr></table></figure><p>如上， 定义了一个枚举类型变量<code>day</code>。<code>sun</code>, <code>mon</code>… 我们称为枚举元素或者枚举常量。</p><p>关于枚举常量，有以下几点说明：</p><ul><li>枚举常量不是变量，而是常量，所以是不能对枚举元素进行赋值操作的。</li><li>枚举常量作为常量，它们是有值的，值为 1,2,3,….</li></ul><p>所以说，<code>sun</code> 的值为 0，<code>mon</code> 的值为 1，…<code>sat </code>的值为 6。</p><h2 id="数组类型（array）"><a href="#数组类型（array）" class="headerlink" title="数组类型（array）"></a>数组类型（array）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr1: string[] = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]; </span><br><span class="line">// 或</span><br><span class="line">const arr2: Array&lt;string&gt; = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;];</span><br><span class="line"></span><br><span class="line">const arr3: number[] = [1,2,3];</span><br><span class="line">const arr4: any[] = [&#x27;shu&#x27;, 3, &#123;name: &#x27;shuliqi&#x27;&#125;]</span><br></pre></td></tr></table></figure><h2 id="元组类型（tuple）"><a href="#元组类型（tuple）" class="headerlink" title="元组类型（tuple）"></a>元组类型（tuple）</h2><p>在<code>TypeScript</code>中，元组类型表示一个已知数量和类型的数组， 其实可以理解为是一种也特殊的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tupleArr:[number, string, boolean] = [<span class="number">1</span> ,<span class="string">&#x27;2&#x27;</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure><h2 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a>unknown 类型</h2><p><code>unknown</code> 指的是不可预先定义的类型，在很多的场景下可以替代<code>any</code>的功能并且同时保持静态检查的能力。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myName: unknown = <span class="string">&#x27;shuliqi, shulina&#x27;</span>;</span><br><span class="line">myName.join(<span class="string">&#x27;,&#x27;</span>); <span class="comment">//  Error: 静态检查不通过报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myAge: any = <span class="string">&#x27;12, 24&#x27;</span>;</span><br><span class="line">myAge.join(<span class="string">&#x27;&#x27;</span>); <span class="comment">// Pass: any类型相当于放弃了静态检查</span></span><br></pre></td></tr></table></figure><h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><p><code>never</code>类型表示那些永远不存在的值的类型。 如<code>nerve</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或者箭头函数表达式的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwFun</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="comment">// return true; // error</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;我是一个抛出异常的函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwFun</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;我是一个抛出异常的函数&quot;</span>); <span class="comment">// PASS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> throwFuncton = ():<span class="function"><span class="params">never</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;123&quot;</span>); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> throwFuncton = ():<span class="function"><span class="params">never</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;我是一个抛出异常的箭头函数函数&quot;</span>); <span class="comment">// pass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>never</code> 与 <code>void</code>的区别：<code>void</code>是可以被赋值为<code>null </code>和<code> undefined</code> 类型。<code> never</code> 则是一个不包含值得类型。 拥有<code>void</code>返回值类型的函数能够正常运行。 拥有 <code>never </code>返回值的类型的函数无法正常运行，无法终止， 或会抛出异常</p></blockquote><h2 id="bigInt"><a href="#bigInt" class="headerlink" title="bigInt"></a>bigInt</h2><p>因为 <code>JavaScript</code>的所有数字成 64 位浮点数， 这就会给数字的表示带来了两个比较大的限制；第一个限制：数值的精度只能给到53个二进制位（相当与16 个十进制位）， 大于这个范围的数，<code>JavaScript</code> 是无法精确表示的，这使得<code>JavaScript</code>不适合科学和金融方面的精确计算，第二个限制：大于或者等于 2 的1024次方的数值，<code>JavaScript</code>是无法表示，会返回 <code>Infinity</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过53个二进制的数值，无法保持精度</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">53</span>) + <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过或等于 2 的 1.24次方的数值，无法表示</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">1024</span>)); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>于是为了解决该问题，<code>ES2020</code>引入了一种新的数据类型 <code>BigInt </code>（大整数）来解决这个问题。<code>BigInt</code>只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。为了区别 与<code>Number</code> 类型的区别，<code>BigInt</code> 类型的数据必须添加后缀n</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通整数</span></span><br><span class="line"><span class="keyword">const</span> number =  <span class="number">123</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number); <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大整数</span></span><br><span class="line"><span class="keyword">const</span> big = <span class="number">1231243141n</span> </span><br><span class="line"><span class="keyword">const</span> big2 =  <span class="built_in">BigInt</span>(<span class="number">12312</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> big, <span class="keyword">typeof</span> big2); <span class="comment">// bigint bigint</span></span><br></pre></td></tr></table></figure><p>在 <code>TypeScript</code> 中也是有 <code>BigInt</code>类型的。我们可以如下表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bigNum: bigint = <span class="number">123123n</span>;</span><br></pre></td></tr></table></figure><h2 id="object-Object-和-类型"><a href="#object-Object-和-类型" class="headerlink" title="object,Object 和 {} 类型"></a>object,Object 和 {} 类型</h2><p><code>object</code> 类型用来表示非o原始数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objCase: object;</span><br><span class="line"> objCase = <span class="string">&#x27;string&#x27;</span> <span class="comment">//  error</span></span><br><span class="line"> objCase = <span class="number">1123</span> <span class="comment">//  error</span></span><br><span class="line"> objCase = <span class="literal">true</span> <span class="comment">//  error</span></span><br><span class="line"> objCase = <span class="literal">null</span> <span class="comment">//  error</span></span><br><span class="line"> objCase = <span class="literal">undefined</span> <span class="comment">//  error</span></span><br><span class="line"> objCase = &#123;&#125; <span class="comment">//  ok</span></span><br></pre></td></tr></table></figure><p><code>Object</code>表示所有拥有 <code>toString</code> 和 <code>hasOwnProperty</code>方法的类型。所有的原始类型，非原始类型都可以赋给 <code>Object</code>（严格模式下 <code>nul</code>l 和 <code>undefined </code>不行 ）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objCase: <span class="built_in">Object</span>;</span><br><span class="line"> objCase = <span class="string">&#x27;string&#x27;</span> <span class="comment">//  ok</span></span><br><span class="line"> objCase = <span class="number">1123</span> <span class="comment">//  ok</span></span><br><span class="line"> objCase = <span class="literal">true</span> <span class="comment">//  ok</span></span><br><span class="line"> <span class="comment">// 非严格模式</span></span><br><span class="line"> objCase = <span class="literal">null</span> <span class="comment">//  ok</span></span><br><span class="line"> objCase = <span class="literal">undefined</span> <span class="comment">//  ok</span></span><br><span class="line"></span><br><span class="line"> objCase = &#123;&#125; <span class="comment">//  ok</span></span><br></pre></td></tr></table></figure><p> <code>&#123;&#125;</code>对象和 <code>Object</code>类型一样， 都是表示原始类型和非原始类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objCase: &#123;&#125;;</span><br><span class="line"> objCase = <span class="string">&#x27;string&#x27;</span> <span class="comment">//  ok</span></span><br><span class="line"> objCase = <span class="number">1123</span> <span class="comment">//  ok</span></span><br><span class="line"> objCase = <span class="literal">true</span> <span class="comment">//  ok</span></span><br><span class="line"> objCase = <span class="literal">null</span> <span class="comment">//  ok</span></span><br><span class="line"> objCase = <span class="literal">undefined</span> <span class="comment">//  ok</span></span><br><span class="line"> objCase = &#123;&#125; <span class="comment">//  ok</span></span><br></pre></td></tr></table></figure><h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>如果在定义一个变量的时候。没有明确的指定类型。那么在TypeScript就会按照<strong>类型推论</strong>规则来推断出一个类型。</p><p><strong>什么是类型推论</strong></p><p>如以下的代码虽然没有指定类型，但是在编译时会出错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">34</span>;</span><br><span class="line">age = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错：</span></span><br><span class="line">Type <span class="string">&#x27;&quot;shuliqi&quot;&#x27;</span> is not assignable to type <span class="string">&#x27;number&#x27;</span>.</span><br></pre></td></tr></table></figure><p>其实上面的代码等价于这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: number = <span class="number">34</span>;</span><br><span class="line">age = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错：</span></span><br><span class="line">Type <span class="string">&#x27;&quot;shuliqi&quot;&#x27;</span> is not assignable to type <span class="string">&#x27;number&#x27;</span>.</span><br></pre></td></tr></table></figure><p>原因：<code>TypeScript</code>会在没有明确定义变量的类型的时候推测出一个类型。这就是<strong>类型推论</strong></p><p>注意：在定义的时候没有赋值。不管之后有没有赋值，都会被推断为<code>any</code>类型。而不做类型检查。sss</p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型表示取值可以为多种类型中的一种。</p><p>联合类型 用 <code>|</code>分隔每个类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> haha: string | number;</span><br><span class="line">haha = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line">haha = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>以上例子表示：haha这个变量类型可以是<code>string</code> , <code>number</code>     但是不能是其他的类型。</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有时候我们会遇到这种情况，我们会比<code>TypeScript</code>更了解某个值的详细信息，通常这种情况会发生在我们清楚地知道一个实体具有比它现在类型更加确切的类型。其实这时候我们需要手动告诉<code>TypeScript</code>就按照我们自己断言的类型通过编译（这很关键， 有时间会帮助我们解决很多的编译报错）</p><p>类型断言都两种形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someValue: any  = <span class="string">&quot;我是字符串&quot;</span>;</span><br><span class="line"><span class="comment">// as 语法</span></span><br><span class="line"><span class="comment">//  当前我们更加确切的知道 someValue 的类型是 string</span></span><br><span class="line"><span class="keyword">const</span> len: number = (someValue <span class="keyword">as</span> string).length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someNum: any = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 尖括号 语法</span></span><br><span class="line"><span class="comment">//  当前我们更加确切的知道 someNum 的类型是 数组</span></span><br><span class="line"><span class="keyword">const</span> myLen: number = (<span class="xml">&lt;number[]&gt;someNum).length;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意： 以上这两种做法没有任何的区别，但是尖括号会与 <code>React</code>语法的<code>JSX</code>语法产生语法冲突，所以更加推荐使用 <code>as</code>语法。</p></blockquote><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>在<code>TypeScript</code>中，字面量不仅可以表示类型， 也可以表示类型， 即所谓的字面量类型，目前 <code>TypeScript</code> 包含了三种字面量类型：字符串字面量类型，布尔值字面量类型，数字字面量类型， 对应的字符串字面量，布尔值字面量，数字字面量分别拥有与其值一样的字面量类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  字符串字面量类型</span></span><br><span class="line"><span class="keyword">const</span> str: <span class="string">&#x27;string&#x27;</span> = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字字面量类型</span></span><br><span class="line"><span class="keyword">const</span> num: <span class="number">12</span> = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  布尔值字面量类型</span></span><br><span class="line"><span class="keyword">const</span> isOk: <span class="literal">true</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名就是给类型起个新名字, <code>TypeScript</code>中使用<code>type</code>来给类型起新名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  给类型起新的名字</span></span><br><span class="line">type  myType = string |  number;</span><br><span class="line"><span class="keyword">const</span> name:myType = <span class="string">&quot;shuliqi&quot;</span></span><br></pre></td></tr></table></figure><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>交叉类型就是将多个类型合并成一个类型， 通过 &amp; 运算符将现有的多种类型叠加到一起成为一种新的类型，该新类型包含了所有类型的特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type  myType1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">&#125;</span><br><span class="line">type  myType2 = &#123;</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user: myType1 &amp; myType2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p><code>TypeScript</code> 熟知 <code>JavaScript</code> 中 <code>instanceof</code> 和 <code>typeof</code>运算符的用法。如果在一个条件块中上使用这些，<code>TypeScript</code>将会推导出在条件块中的变量类型。<code>TypeScript</code> 甚至能够理解 <code>else</code>。当你使用 <code>if</code> 来缩小类型时，TypeScript 知道在其他块中的类型并不是 <code>if</code> 中的类型。</p><p><strong>typeof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSome</span>(<span class="params">value: string |  number[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这个语句块中， ts 知道 value 的类型必须是 string</span></span><br><span class="line">    <span class="built_in">console</span>.log(value.join(<span class="string">&#x27;,&#x27;</span>)); <span class="comment">// err: 类型“string”上不存在属性“join”。</span></span><br><span class="line">    <span class="built_in">console</span>.log(value.split(<span class="string">&quot;,&quot;</span>)); <span class="comment">//ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 在这个语句块中， ts 知道 value 的类型必须是 number[]</span></span><br><span class="line">    <span class="built_in">console</span>.log(value.join(<span class="string">&#x27;,&#x27;</span>)); <span class="comment">//  ok</span></span><br><span class="line">    <span class="built_in">console</span>.log(value.split(<span class="string">&quot;,&quot;</span>)); <span class="comment">// err: 类型“number[]”上不存在属性“split”。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>instanceof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  catName = <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">  catAge = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  dogName = <span class="string">&quot;nani&quot;</span>;</span><br><span class="line">  dogAge = <span class="number">122</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomthing</span>(<span class="params">arg: Cat | Dog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">    <span class="comment">// 在这个语句块中，ts 知道 arg 的类型必须是 Cat</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.catName); <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.dogName); <span class="comment">// error: 类型“Cat”上不存在属性“dogName”</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 在这个语句块中，ts 知道 arg 的类型必须是 Dog</span></span><br><span class="line">     <span class="built_in">console</span>.log(arg.catName); <span class="comment">// error: 类型“Dog”上不存在属性“catName”</span></span><br><span class="line">     <span class="built_in">console</span>.log(arg.dogName); <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>in</strong></p><p><code>in</code>操作符可以安全的检查一个对象上是否存在一个属性，也通常被作为类型保护来使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">  <span class="attr">x</span>: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B &#123;</span><br><span class="line">  <span class="attr">y</span>: number[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toDo</span>(<span class="params">arg: A | B</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> arg) &#123;</span><br><span class="line">    <span class="comment">// arg: A</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// arg: B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TypeScript-函数"><a href="#TypeScript-函数" class="headerlink" title="TypeScript 函数"></a>TypeScript 函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>可以指定参数的类型和返回值的类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// viod 表示该函数没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">name: string, age: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数有返回值， 返回值是一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">name: string, age: number</span>): </span>&#123;&#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  函数无返回值</span></span><br><span class="line"><span class="keyword">const</span> getUser: <span class="function">(<span class="params">name: string, age: number</span>) =&gt;</span> <span class="keyword">void</span> = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>,age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">type funType =  <span class="function">(<span class="params">name: string, age: number</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"><span class="keyword">const</span> getUser: funType = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数有返回值</span></span><br><span class="line">type funType =  <span class="function">(<span class="params">name: string, age: number</span>) =&gt;</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">const</span> getUser: funType = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>使用<code>?</code>来表示参数是可选的，需要注意的是： 可选参数必须在必须参数之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// age 参数是可选的</span></span><br><span class="line">type funType =  <span class="function">(<span class="params">name: string, age?: number</span>) =&gt;</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">const</span> getUser: funType = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    <span class="attr">age</span>: age || <span class="number">12</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// age 默认的值为 12</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">name: string, age: number = <span class="number">12</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age); <span class="comment">// name: shuliqi age: 12</span></span><br><span class="line">&#125;</span><br><span class="line">getUser(<span class="string">&quot;shuliqi&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">name: string, ...arg: number[]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">getUser(<span class="string">&quot;shuliqi&quot;</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载/方法重载就是使用相同名称和不同参数或类型创建多个方法的一种功能， 在<code>TypeScript</code>中表现为给同一个函数提供多个函数类型定义。</p><p>函数重载真正执行的是同名函数最后定义的函数体，在最后一个函数体定义之前全部数据函数类型定义，不能写具体的函数实现方法，只能定义类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数重载：给同一个函数提供多个函数类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toDo</span>(<span class="params">value: string </span>): <span class="title">void</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toDo</span>(<span class="params">value: number </span>): <span class="title">void</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toDo</span>(<span class="params">value: any </span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...to</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  直接写成这样不香吗？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toDo</span>(<span class="params">value: string | number | any </span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...to</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TypeScript-类"><a href="#TypeScript-类" class="headerlink" title="TypeScript 类"></a>TypeScript 类</h1><h2 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h2><p>在 <code>TypeScript</code> 中，我们也是可以通过 <code>Class</code> 关键字来定义一个类。 类的类型和接口类型类似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">_name: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = _name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(people.getName()); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>在<code>TypeScript</code>中， 我们可以通过存取器来来改变一个类中属性的读取和赋值的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="attr">myName</span>: string</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">_name: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.myName = _name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.myName</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.myName = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line">people.name = <span class="string">&quot;世界那么大&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(people.name); <span class="comment">//  世界那么大</span></span><br></pre></td></tr></table></figure><h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h2><p>只读属性关键字，只允许出现在属性声明或者索引签名或构造函数中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  readonly myName: string</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">_name: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.myName = _name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line">people.myName = <span class="string">&quot;世界那么大&quot;</span>; <span class="comment">// error:  无法分配到 &quot;myName&quot; ，因为它是只读属性。</span></span><br></pre></td></tr></table></figure><h2 id="类修饰符"><a href="#类修饰符" class="headerlink" title="类修饰符"></a>类修饰符</h2><p>在<code>TypeScript</code> 中可以使用三种修饰符：<code>public</code>,<code>private</code>,<code>protected</code>:</p><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认的所有属性和方法都是<code>public</code>的</li><li><code>private</code>修饰的属性或方法是私有的，不可以在声明它的类的外部访问</li><li><code>protected</code>修饰的属性或方法都是搜保护的，它和<code>private</code>类似，区别是它在子类中也是允许被访问的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  public myName: string</span><br><span class="line">  private age: string</span><br><span class="line">  protected sex: string</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">_name: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.myName = _name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span>  <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.sex); <span class="comment">// 可以被访问</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age); <span class="comment">// err：属性“age”为私有属性，只能在类“People”中访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(people.age); <span class="comment">// err: 属性“age”为私有属性，只能在类“People”中访问</span></span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>使用<code>abstract</code>来定义一个抽象类；所谓的抽象类就是指不能被实例化的类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个抽象类</span></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  public myName: string</span><br><span class="line">  private age: string</span><br><span class="line">  protected sex: string</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">_name: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.myName = _name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类是不允许被实例化的</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&quot;shuliqi&quot;</span>); <span class="comment">// ERR: 无法创建抽象类的实例。</span></span><br></pre></td></tr></table></figure><h1 id="TypeScript-接口"><a href="#TypeScript-接口" class="headerlink" title="TypeScript 接口"></a>TypeScript 接口</h1><p>接口既可以在面向对象编程中表示为行为的抽象，也可以用来描述对象的形状。</p><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>在<code>TypeScript</code>中，使用<code>interface</code>关键字来定义接口，在接口中可以使用分号或者逗号分割每一项，也可以什么也不加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以什么分割号都不加</span></span><br><span class="line">interface Props &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用 逗号分割</span></span><br><span class="line">interface Props &#123;</span><br><span class="line">  <span class="attr">name</span>: string,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用分号分割</span></span><br><span class="line">interface Props &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象形状"><a href="#对象形状" class="headerlink" title="对象形状"></a>对象形状</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述对象的形状</span></span><br><span class="line">interface Person &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;shuliqi&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中我们定义了一个接口 <code>Person</code>， 然后我们定义了一个变量 <code>shu</code>，它的类型是 <code>Person</code>。这就约束了<code>shu</code>的形状必须和<code>Person</code>一致。</p><p>注意：接口的首字母一般大写。</p><p>如果我们定义的变量比接口少一些属性是不允许的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;shuliqi&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时会报错的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;age&#x27;</span> is declared here.</span><br></pre></td></tr></table></figure><p>如果我们定义的变量比接口多一些属性也是不允许的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;shuliqi&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">parent</span>: <span class="string">&#x27;shulina&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error TS2322: Type <span class="string">&#x27;&#123; name: string; age: number; parent: string; &#125;&#x27;</span> is not assignable to type <span class="string">&#x27;Person&#x27;</span>.</span><br><span class="line">  <span class="built_in">Object</span> literal may only specify known properties, and <span class="string">&#x27;parent&#x27;</span> does not exist <span class="keyword">in</span> type <span class="string">&#x27;Person&#x27;</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>  parent: <span class="string">&#x27;shulina&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>有的时候我们不需要完全匹配一个形状。我们可以使用可选属性：在属性后端加 ？ 符号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age?: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;shuliqi&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选属性的含义可以不存在。注意： 这时候仍然不可以添加未定义的属性。</p><h2 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h2><p>如果我们在定义接口的时候无法预先知道哪些属性的时候，可以使用<code>[propName: string]:any</code>。<code>propName</code> 属性名是任意的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;shuliqi&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>如果我们的定义了任意属性，那么确定属性和可选属性都必须是它值类型的子集：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age?: number</span><br><span class="line">  [propName: string]: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;shuliqi&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">parent</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译额时候会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Type <span class="string">&#x27;&#123; name: string; age: number; parent: string; &#125;&#x27;</span> is not assignable to type <span class="string">&#x27;Person&#x27;</span>.</span><br><span class="line">  Property <span class="string">&#x27;age&#x27;</span> is incompatible <span class="keyword">with</span> index signature.</span><br><span class="line">    Type <span class="string">&#x27;number&#x27;</span> is not assignable to type <span class="string">&#x27;string&#x27;</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="keyword">let</span> shu: Person = &#123;</span><br><span class="line">      ~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found <span class="number">2</span> errors.</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：可选属性age的值的类型是number， 任意属性的值的类型 是string。number 不是stringl类型。所以会报错.</p><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象的属性只能在对象刚刚创建的时候能修改其值。 可以在属性，可以在属性前面加<code>readonly</code> 来指定可读属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  <span class="comment">// name 属性的值是只读的</span></span><br><span class="line">  readonly name: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> people: User = &#123; <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;;</span><br><span class="line"><span class="comment">// 尝试修改 name 属性的值， 会 err</span></span><br><span class="line">people.name = <span class="string">&quot;haha&quot;</span>; <span class="comment">// err</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现-implements-接口"><a href="#实现-implements-接口" class="headerlink" title="实现(implements)接口"></a>实现(implements)接口</h2><p>实现是面向对象中的一个重要概念，一般来讲，一个类只能继承自另外一个类， 但是有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口<code>interface</code>。</p><p>举个例子：门是一个类，防盗门是门的子类。 如果防盗门有一个报警器的功能，我们就可以简单的给防盗门添加一个报警方法。这时候如果有另外一个类 车，也有该报警器的功能，我们就可以考虑把报警器提取出来，作为一个接口，让防盗门和车都去实现它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报警器</span></span><br><span class="line">interface Alarm &#123;</span><br><span class="line">  <span class="comment">// 报警方法</span></span><br><span class="line">  alert(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类 门</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：SecurityDoor继承Door; 并且要实现（implements）报警器接口(Alarm)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是防盗门的报警方法&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类：Car 实现 Alarm 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是车的报警方法&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个也可以实现多个接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Alarm接口</span></span><br><span class="line">interface Alarm &#123;</span><br><span class="line">  <span class="comment">// 报警方法</span></span><br><span class="line">  alert(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Light 接口</span></span><br><span class="line">interface Light &#123;</span><br><span class="line">  lightOn(): <span class="keyword">void</span>;</span><br><span class="line">  lightOff(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类 门</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：SecurityDoor继承Door; 并且要实现（implements）报警器接口(Alarm)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="title">implements</span> <span class="title">Alarm</span>, <span class="title">Light</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是防盗门的报警方法&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">lightOn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;防盗门灯打开&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">lightOff</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;防盗门灯关闭&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>implements</code>的意义是什么？</p><h2 id="接口-extends-继承"><a href="#接口-extends-继承" class="headerlink" title="接口(extends)继承"></a>接口(extends)继承</h2><p>除了类可以继承，接口同样也是可以继承。同样的使用 <code>extends</code>关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口 DetailUser 继承了 User</span></span><br><span class="line">interface  DetailUser <span class="keyword">extends</span> User &#123;</span><br><span class="line">  <span class="attr">sex</span>: string</span><br><span class="line">  <span class="attr">getName</span>: <span class="function">() =&gt;</span> string</span><br><span class="line">  <span class="attr">other</span>: <span class="built_in">Object</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">DetailUser</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&quot;shuliqi&quot;</span></span><br><span class="line">  age =  <span class="number">12</span></span><br><span class="line">  sex = <span class="string">&#x27;女&#x27;</span></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">  other = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h2><p>在<code>javaScript</code>中，有两种常见定义函数的方法— 函数声明 和 函数表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDetail</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> getDetail = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用接口来定义函数的形状：</p><p><strong>函数声明:</strong></p><p>函数声明的类型定义比较简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明 类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDetail</span>(<span class="params">name: string, age: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>函数表达式:</strong></p><p>如果我们现在要对一个函数表达式的ts 约定， 可能会写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式 类型定义</span></span><br><span class="line"><span class="keyword">const</span> getDetail = (name: string, <span class="attr">age</span>: number) : <span class="function"><span class="params">void</span>  =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这种方式是可以通过编译的。但是事实上，上面的代码只是对等号右边的匿名函数进行了类型定义。而等号右边的<code>getDetail</code>是通过赋值操作进行类型推论而推断出来的。 如果需要我们手动给<code>getDetail</code>添加类型的话，则应该是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给等号右边的 getDetail 进行类型定义</span></span><br><span class="line"><span class="keyword">const</span> getDetail:<span class="function">(<span class="params">name: string, age: number</span>)=&gt;</span> <span class="keyword">void</span>= (name: string, <span class="attr">age</span>: number) : <span class="function"><span class="params">void</span>  =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意： 不要混淆 <code>TypeScript</code>中的 <code>=&gt;</code>  和 <code>ES6</code>中的<code>=&gt;</code></p><p>在<code>TypeScript</code>的类型定义中，<code>=&gt;</code>是用来表示函数的定义，左边是输入的类型。需要用括号括起来，右边是输出的类型</p></blockquote><p> 上面函数表达式的类型定义我们可以使用接口的方式来定义一个函数需要符合的形状：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Detail &#123;</span><br><span class="line">  (name: string, <span class="attr">age</span>: number): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getDetail:Detail = (name: string, <span class="attr">age</span>: number) : <span class="function"><span class="params">void</span>  =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用接口这种方式，对函数表达式等号左边的进行类型限制，就可以保证以后对该函数赋值时保证参数个数，参数类型，返回值类型不变。</p><h2 id="构造函数的类型接口"><a href="#构造函数的类型接口" class="headerlink" title="构造函数的类型接口"></a>构造函数的类型接口</h2><p>当我们需要把一个类作为参数的时候， 需要对传入的构造函数类型进行约束就需要使用 <code>new</code>  关键字来代表类的构造函数类型，用以与普通函数进行区别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name: string</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface NewPeople &#123;</span><br><span class="line">  <span class="comment">// 使用 new  说明是构造函数</span></span><br><span class="line">  <span class="keyword">new</span> (name: string): People</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPeople</span>(<span class="params"> createClass:NewPeople </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> createClass(<span class="string">&quot;shuliqi&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TypeScript-泛型"><a href="#TypeScript-泛型" class="headerlink" title="TypeScript 泛型"></a>TypeScript 泛型</h1><p>泛型（Generics）是指在定义函数，接口或者类的时候，不预先指定具体的类型，而是在使用的时候再指定类型的一种特性。</p><h2 id="简单例子："><a href="#简单例子：" class="headerlink" title="简单例子："></a>简单例子：</h2><p>为了更加了解泛型的作用， 我们先来看一个简单的例子：实现可以创建指定的长度的数组，每一项都是填充一个默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">length: number, value: any</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面的代码编译是不会出错的， 但是有一个缺陷，它没有准确的定义返回值的类型： 无论我们传入什么类型的<code>value</code>。返回的数组用以是<code>any</code>类型。如果我们想要的效果是： 我们预先不知道会传入什么类型的值，但是我们希望不管我们传入什么类型，我们返回的数组里面的类型应该和参数一致。那么这时候就需要用到泛型了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: number, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">createArray&lt;string&gt;(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><p>我们在函数名后端添加<code>&lt;T&gt;</code>,其中<code>T</code>用来指代任意输入的类型，在后面输入 <code>value: T</code> 和<code>Array&lt;T&gt;</code>即可。</p><h2 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h2><p>定义泛型的时候，可以一次性定义多个类型参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;(<span class="params">value: [T,U]</span>): [<span class="title">U</span>,<span class="title">T</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [value[<span class="number">1</span>], value[<span class="number">0</span>]]</span><br><span class="line">&#125;</span><br><span class="line">swap([<span class="number">1</span>,<span class="string">&#x27;str&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意操作它的属性或方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logLen</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr.length); <span class="comment">// err: 类型“T”上不存在属性“length”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中 泛型 <code>T</code> 不一定包含属性<code>length</code>， 所以编译的时候出错了。 </p><p>这时候我们可以对泛型进行约束，只允许这个函数传入那些包含<code>length</code> 属性的变量。这就是泛型约束：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Length&#123;</span><br><span class="line">  <span class="attr">length</span>: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logLen</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Length</span>&gt;(<span class="params">arr: T</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr.length);  <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子使用<code>extends</code>约束了泛型<code>T</code>必须符合接口<code>Length</code>。 </p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>上面有说道可以使用接口的方式来定义一个函数需要符合的形状：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Detail &#123;</span><br><span class="line">  (name: string, <span class="attr">age</span>: number): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getDetail:Detail = (name: string, <span class="attr">age</span>: number) : <span class="function"><span class="params">void</span>  =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也是可以使用泛型的接口来定义函数的形状</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Detail &#123;</span><br><span class="line">  &lt;T&gt;(name: string, <span class="attr">age</span>: T): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getDetail:Detail = &lt;T&gt;(name: string, <span class="attr">age</span>: T) : <span class="function"><span class="params">void</span>  =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把泛型提到接口名上, 但是这时候需要注意使用泛型接口的时候，需要定义泛型的类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将泛型提到接口名上</span></span><br><span class="line">interface Detail&lt;T&gt; &#123;</span><br><span class="line">  (name: string, <span class="attr">age</span>: T): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用泛型的时候，需要定义泛型的类型</span></span><br><span class="line"><span class="keyword">const</span> getDetail:Detail&lt;any&gt; = &lt;T&gt;(name: string, <span class="attr">age</span>: T) : <span class="function"><span class="params">void</span>  =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>与泛型接口类似，泛型也可以用于类的类型定义中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> People&lt;number&gt;();</span><br><span class="line">user.name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">user.age =  <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h2 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h2><p>我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型采纳数， 从实际值参数中也无法推测出时，这个默认值类型就会起到作用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&lt;<span class="title">T</span> </span>= string&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学习参考文章：</p><ul><li> <a href="https://ts.xcatliu.com/advanced/class-and-interfaces.html">https://ts.xcatliu.com/advanced/class-and-interfaces.html</a></li><li><a href="https://juejin.cn/post/7031787942691471396#heading-35">https://juejin.cn/post/7031787942691471396#heading-35</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么函数组件也需要引入 React？</title>
      <link href="/2021/11/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B9%9F%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5-React%EF%BC%9F/"/>
      <url>/2021/11/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B9%9F%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5-React%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近一直使用 <code>React</code> 开发， 是遇到一些觉得比较疑惑的问题；如： 我写的都是纯粹的函数组件，我们明明没有使用<code>React</code>， 为什么仍然需要在头部引入 <code>import React from &#39;react&#39;;</code>呢？如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Hello = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello shuliqi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Hello;</span><br></pre></td></tr></table></figure><span id="more"></span><p>如这个例子， 我们在头部引入了 <code>import React from &#39;react&#39;;</code>但是我们在代码中并没有使用<code>React</code>，但是我们去掉的话， 程序执行的时候就会报错：</p><img src="/2021/11/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B9%9F%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5-React%EF%BC%9F/1.png" class=""><p>这是为什么呢？</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>深入了解<code>React</code> 的底层执行原理之后我们其实就能找到答案。</p><p>原因是： <code>JSX</code> 语法只是一种语法糖，它最终是会被转译成<code>javaScript</code>语法，因为在<code>babel</code>转译之后，我们的代码就变成了：</p><img src="/2021/11/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B9%9F%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5-React%EF%BC%9F/2.png" class=""><p>在<code>babel</code>转译我们的函数组件的代码之后， 会把<code>JSX</code>语法糖转换成<code>React.createElement</code>。所以说这就是为什么我们在写纯粹的函数组件的时候， 也需要引入<code>import React from &#39;react&#39;;</code></p><h1 id="自动引入-React"><a href="#自动引入-React" class="headerlink" title="自动引入 React"></a>自动引入 React</h1><p>当然，我们有时候频繁的手动引入<code>React</code>过于繁琐，我们能不能直接写纯函数组件，不需要在头部引入<code>React</code>语句：<code>import React from &#39;react&#39;;</code>呢？</p><p>当然是可以的，我们可以使用插件<code>babel-plugin-react-require</code>: <a href="https://github.com/vslinko/babel-plugin-react-require">babel-plugin-react-require</a>来实现自动实现<code>React</code>的自动导入， 实际上这个插件的功能非常简单，在转移的时候，在文件头部插入<code>import React from &#39;react&#39;</code>。</p><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-react-require --save-dev</span><br></pre></td></tr></table></figure><p><code>.babelrcreact-require</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;react-require&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React hook 学习</title>
      <link href="/2021/09/14/React-hook-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/09/14/React-hook-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>又要开始抗起<code>React</code> 搬砖了，感觉棒棒哒 😭。多了很多的 <code>hook</code>， 嗯 😔，先好好学学吧！</p><h1 id="什么是-Hook？"><a href="#什么是-Hook？" class="headerlink" title="什么是 Hook？"></a>什么是 Hook？</h1><p><code>Hook</code> 是<code>React 16.8</code>的新特性。它的主要作用是让我们在不写 <code>class</code>的情况下可以使用<code>state</code>和<code>React</code>本身的一些特性。</p><p><code>Hook</code>本质上就是一个函数， 它有自己的状态管理，生命周期管理，状态共享等；如下面的<code>Hook</code>：</p><ul><li><code>useState</code></li><li><code>useEffect</code></li><li><code>useContext</code></li><li><code>useReducer</code></li></ul><span id="more"></span><h1 id="Hook-解决什么问题"><a href="#Hook-解决什么问题" class="headerlink" title="Hook 解决什么问题"></a>Hook 解决什么问题</h1><p>我们来看看<code>Hook</code>到底解决了什么问题。</p><p>我们首先来看 这两种组件类型有什么区别：</p><iframe height="654" style="width: 100%;" scrolling="no" title="class 组件" src="https://codepen.io/shuliqi/embed/QWgJBQQ?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/QWgJBQQ">  class 组件</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><iframe height="379" style="width: 100%;" scrolling="no" title="函数 组件" src="https://codepen.io/shuliqi/embed/eYRQPmB?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/eYRQPmB">  函数 组件</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>由上面的例子我们可以看出：</p><p><strong>class 组件特点：</strong></p><ul><li>有组件实例</li><li>有生命周期</li><li>有<code>state</code> 和 <code>setState</code></li></ul><p><strong>函数组件的特点：</strong></p><ul><li>没有组件实例</li><li>没有有生命周期</li><li>没有<code>state</code> 和 <code>setState</code>；只能接收 <code>props</code></li><li>函数组件只是一个纯函数， 执行完就会被销毁，无法存储 <code>state</code></li></ul><p><strong><code>class</code>组件存在的问题是什么呢？</strong></p><ul><li><p>大型的组件很难拆分和重构</p></li><li><p>相同的业务逻辑分散到各个方法中，变得混乱</p></li><li><p>复用的逻辑变得很复杂</p><p>所以 <code>React</code> 更提倡函数式编程，因为函数更加灵活，更容易拆分。但是呢！！！！ 函数组件又太简单， 所以才出现了<code> hook</code>；<code>hook</code> 就是用来增强函数组件的功能的</p></li></ul><hr><h1 id="Hook-的规则"><a href="#Hook-的规则" class="headerlink" title="Hook 的规则"></a>Hook 的规则</h1><p><code>Hook</code> 有两条比较重要的规则；</p><ul><li><p><strong>只能在最最顶层使用<code>Hook</code></strong></p></li><li><p><strong>只有在 React 组件中才能调用</strong></p></li></ul><ol><li>为什么需要在最顶层使用???????</li></ol><p>其实是为了保证多个 <code>hook</code> 的调用顺序是一致的</p><p>也就是说不要**循环，条件或者嵌套的函数中调用<code>hook</code>**。这样可以做到各个<code>hook</code> 每一次渲染中， 调用的顺序是一致的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useState(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&quot;xxx&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 错误，没有在最顶层调用</span></span><br><span class="line">    useState(<span class="string">&quot;22222&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 会出现未知问题，有时候是第二次调用，有时候是第三次</span></span><br><span class="line">  useState(<span class="string">&quot;3333&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>为什么我们需要保证多个 <code>hook</code> 的调用顺序一致呢？</p><p>这个就跟<code>React</code> 实现的 <code>hook</code> 的原理有关了。因为每次在渲染的时候， <code>React</code>会把所有调用的<code>hook</code> 存储起来。</p><p>关于这一块原理感兴趣， 可以看看这篇文章 <a href="https://github.com/bricksp">React Hooks 原理</a>， 写得很好。</p></li></ol><blockquote><p><code>React</code> 也发布了 <code>ESlint</code> 插件 <a href="https://link.zhihu.com/?target=https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a>帮助我们强制执行这两条规则。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">&quot;plugin:react-hooks/recommended&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="React-内置的-Hook"><a href="#React-内置的-Hook" class="headerlink" title="React 内置的 Hook"></a>React 内置的 Hook</h1><p>我们来看看<code>React</code> 内置的<code>hook</code> 有哪些：</p><ul><li><p><code>useState</code> 状态管理</p></li><li><p><code>useEffect</code> 生命周期管理</p></li><li><p><code>useContext</code> 共享状态数据</p></li><li><p><code>useMemo</code> 缓存值</p></li><li><p><code>useRef</code> 获取<code>Dom</code> 操作</p></li><li><p><code>useCallback</code> 缓存函数</p></li><li><p><code>useImperativeHandle</code> 子组件暴露值/方法</p></li><li><p><code>useLayoutEffect</code> 完成副作用操作，会阻塞浏览器绘制</p></li><li><p><code>useReducer</code> 与 <code>redux</code> 一样</p><p>下面我们来分别学习一下这些内置的<code>Hook</code></p></li></ul><hr><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><p>在<code> class</code> 组件中，我们获取 <code> state</code> 是从<code>this.state</code> 中获取的。但是在函数组件中是没有 <code> this</code> 的。</p><p>所以在函数组件中就可以使用<code>hook</code> 提供的<code> useState</code>来管理和维护<code> state</code>。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = useState(initName);</span><br></pre></td></tr></table></figure><ul><li><code>useState</code>: 定义 state 变量的函数<code>hook</code></li><li><code>name</code>: 定义出来的变量</li><li><code>setName</code>：为更新 <code>satate</code> 方法</li><li><code>initName</code>: <code>name</code>变量的初始值</li></ul><p>使用<code>useState</code> 可以定义一个变量，如上我们这个变量叫<code>name</code>。<code>useState</code>有一个参数（如上<code>initName</code>），为变量的初始值。初始值可以根据我们自己的需要使用不同类型（即可以是字符串，数字， 布尔值等， 不一定是非是对象）<code>useState</code>的返回值是返回当前的<code>state</code>和更新<code>state</code>的函数。</p><h2 id="举个-🌰"><a href="#举个-🌰" class="headerlink" title="举个 🌰"></a>举个 🌰</h2><iframe height="426" style="width: 100%;" scrolling="no" title="React Hook useEffect()" src="https://codepen.io/shuliqi/embed/ZEJzrby?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/ZEJzrby">  React Hook useEffect()</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe>---<h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><p><code>useEffect</code> 可以看作是函数式组件的生命周期管理，因为在函数式组件中无法使用生命周期。这就可以使用<code>useEffect</code>来进行管理了。</p><p><code>useEffect</code>主要管理三个生命周期函数：</p><ul><li><p><code>componentDidmount</code></p><p>组件第一次渲染完成，此时 dom 节点已经生成，可以在这里调用 ajax 请求，返回数据<code>setState</code>后组件会重新渲染</p></li><li><p><code>componentDidUpdate</code></p><p>组件更新完毕后，react 只会在第一次初始化成功会进入<code>componentDidmount</code>,之后每次重新渲染后都会进入这个生命周期，<code>componentDidUpdate(prevProps,prevState</code>这里可以拿到<code>prevProps</code>和<code>prevState</code>，即更新前的 props 和 state。</p></li><li><p><code>componentWillUnmount</code></p><p>组件销毁之后触发的生命周期。一般用来：</p><blockquote><ul><li>清除在组件中的定时器（<code>setTimeout</code>,<code>setInterval</code>）</li><li>移除组件中的监听（<code>removeEventListener</code>）</li><li>取消还没有请求结果的<code>ajax</code>请求</li></ul></blockquote></li></ul><h2 id="无需清除的-effect"><a href="#无需清除的-effect" class="headerlink" title="无需清除的 effect"></a>无需清除的 effect</h2><p>有时候我们只希望在<code>React</code>更新<code>DOM</code>之后运行一些额外的代码，那么只需要在<code>class</code> 组件生命周期<code>componentDidmount</code>和<code>componentDidUpdate</code>中执行即可。</p><p>那么在<code>useEffect</code>中如何写呢？我们可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 默认会执行这部分，相当于 class 组件的生命周期（componentDidmount， componentDidUpdate）</span></span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="需要清除-effect"><a href="#需要清除-effect" class="headerlink" title="需要清除 effect"></a>需要清除 effect</h2><p>当我们希望在一个组件销毁的时候执行一些逻辑处理。那么就需要在 class 组件的 <code>componentWillUnmount</code> 执行即可。</p><p>那么在<code>useEffect</code>中如何写呢？我们可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 组件销毁时执行的函数</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="监听-state-的变化"><a href="#监听-state-的变化" class="headerlink" title="监听 state 的变化"></a>监听 state 的变化</h2><p>当我们需要监听的<code>state</code>的变化然后做一些处理的时候,我们可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 监听num，count  状态的变化， 变化了则执行里面的代码</span></span><br><span class="line">  <span class="comment">// 不监听时为空 [] , 或者不写</span></span><br><span class="line">&#125;, [num, count]);</span><br></pre></td></tr></table></figure><h2 id="举个-🌰-1"><a href="#举个-🌰-1" class="headerlink" title="举个 🌰"></a>举个 🌰</h2><iframe height="732" style="width: 100%;" scrolling="no" title="React Hook useEffect()" src="https://codepen.io/shuliqi/embed/RwZbQRm?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/RwZbQRm">  React Hook useEffect()</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><p><code>useRef</code>返回一个 <code>ref</code> 对象。这个对象的<code>.current</code>属性被初始化为<code>useRef</code>传入的参数。该对象在整个生命周期内持续存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const domRef = useRef(initialValue);</span><br></pre></td></tr></table></figure><blockquote><p><code>ref</code> 对象:<code>ref</code>是<code>React</code>提供的用来操纵<code>React</code>组件实例或者<code>DOM</code>元素的接口。 回调函数就是在<code>dom</code>节点或组件上挂载函数，函数的入参是<code>dom</code>节点或组件实例，达到的效果与字符串形式是一样的， 都是获取其引用。</p><p>如果你将 <code>ref</code> 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 <code>.current</code> 属性设置为相应的<code> DOM</code> 节点</p></blockquote><p>这个 <code>hook</code>的作用：获取<code>Dom</code>操作。如获取一个<code>input</code>的焦点</p><h2 id="举个-🌰-2"><a href="#举个-🌰-2" class="headerlink" title="举个 🌰"></a>举个 🌰</h2><iframe height="459" style="width: 100%;" scrolling="no" title="React Hook useEffect()" src="https://codepen.io/shuliqi/embed/oNeNeNY?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/oNeNeNY">  React Hook useEffect()</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><hr><h1 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const value = useContext(MyContext);</span><br></pre></td></tr></table></figure><p><code>useContext</code>接受以一个<code>context</code>对象（<code>React.createContext</code>的返回值）， 并返回当前 <code>Context</code>的当前值。<code>Context</code>的当前值是由上层组件中距离当前组件最近的<code>MyContext.Provider</code> 的<code>value</code>决定。</p><p>上面我们提到了 <code>Context</code>对象， 那么这个对象能帮助我们解决什么问题呢？</p><h2 id="Context-能解决什么问题"><a href="#Context-能解决什么问题" class="headerlink" title="Context 能解决什么问题"></a>Context 能解决什么问题</h2><p>在平成的开发过程中，我们进行通信（父子）使用之最多的是 <code>props</code>来进行通信； 但是 跨级组件 的通信我们就不好用 <code>props</code>来通信了。那这时候我们怎么可以把组件状态共享出去呢？ <code>Redux</code>?， 或者 <code>Context</code></p><blockquote><p><code>react</code> 中的 <code>Context</code>: 在典型的 React 应用程序中，数据通过 props 自上而下（父到子）传递，但对于应用程序中许多组件所需的某些类型的 props（例如环境偏好,UI 主题），这可能很麻烦。 上下文(Context) 提供了在组件之间共享这些值的方法，而不必在树的每个层级显式传递一个 prop</p></blockquote><blockquote><p>注意：<code>Context</code>主要的应用场景是很多不同层级的组件需要访问同样一些数据， 谨慎使用， 因为这会让组件的复用性变差</p></blockquote><h2 id="创建-Context"><a href="#创建-Context" class="headerlink" title="创建 Context"></a>创建 Context</h2><p>使用 <code>Context</code>的前提，必须创建它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export const MyContext = React.createContext();</span><br></pre></td></tr></table></figure><h2 id="使用-Context"><a href="#使用-Context" class="headerlink" title="使用 Context"></a>使用 Context</h2><p>在使用 <code>Context</code>的时候，它通常用在顶层组件上，它包裹的内部组件都可以享受到 <code>state</code>的使用和修改， 一般是通过 <code>Context.provider</code>来包裹， 通过<code>value</code>来传递。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContext.Provider value=&#123;&#123; name &#125;&#125;&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;handleName&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ComponentA</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/MyContext.Provider&gt;</span><br></pre></td></tr></table></figure><h2 id="子组件使用-context-传过来的值"><a href="#子组件使用-context-传过来的值" class="headerlink" title="子组件使用 context 传过来的值"></a>子组件使用 context 传过来的值</h2><p>子组件通过<code>useContext()</code> <code>Hook</code>就可以很方便的拿到值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name &#125; = React.useContext(MyContext);</span><br></pre></td></tr></table></figure><h2 id="完整的-🌰"><a href="#完整的-🌰" class="headerlink" title="完整的 🌰"></a>完整的 🌰</h2><iframe height="712" style="width: 100%;" scrolling="no" title="React Hook useRef()" src="https://codepen.io/shuliqi/embed/qBXZaOM?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/qBXZaOM">  React Hook useRef()</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><hr><h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function">() =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure><p>官网文档：<code>useMemo</code>返回的是一个<code>memoized</code>值(具有记忆的值)，<code>useMemo</code>主要是用于性能优化，通过记忆值来避免在每个渲染上进行高开销的计算。</p><p>根据官方文档的介绍，我们可以这么理解：</p><blockquote><p>在 <code>a </code>值 ，<code>b</code>值 不变的情况下，<code>memoizedValue</code>的值不变，也就是<code>useMemo</code>的第一个入参函数不会被执行， 从而达到节省计算量的目的</p></blockquote><p>有两个参数：</p><ul><li>第一个是一个回调函数， 主要是暴露出来让我们自己如何去计算这个值的。</li><li>第二个参数是一个数组，数组中的<code>state</code> 发生改变才会重新执行回调函数。</li></ul><blockquote><p>注意：</p><ul><li>如果不传数组，则每次更新都会重新计算</li><li>空数组，只会计算一次</li><li>数组里面有依赖值，则当对应的值发生变化时，才会重新计算</li></ul></blockquote><h2 id="举个-🌰-3"><a href="#举个-🌰-3" class="headerlink" title="举个 🌰"></a>举个 🌰</h2><iframe height="556" style="width: 100%;" scrolling="no" title="React Hook useContext()" src="https://codepen.io/shuliqi/embed/zYdqKLm?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/zYdqKLm">  React Hook useContext()</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>上面的例子中， 我们点击<strong>count 自增</strong> <code>newValue</code>会发生改变； 但是我们点击<strong>num 自增</strong> ，<code>newValue</code>是不会发生改变的。</p><p>那是因为在<code>useMemo</code>依赖的是 <code>count</code>的变化。</p><blockquote><p>如果没有提供依赖值， 那么<code>useMemo</code>在每次渲染的时候都会重新计算值</p></blockquote><h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  doSomething(a, b);</span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></figure><p><code>useCallback</code>返回的是一个 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 回调函数(<code>useMemo</code>返回的是<code>memoized</code>值)。</p><p>官方文档：把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染</p><p>我们可以这么理解：</p><blockquote><p>在 <code>a</code>值, <code>b</code>值不变的情况下，函数<code> memoizedCallback</code>的引用不变，也就是<code>useCallback</code>的第一个入参加函数会被缓存，从而达到渲染性能优化的目的。</p></blockquote><p>不过能使用<code>useCallback</code>来实现的都能使用<code>useMemo</code>来实现： <code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><p>有两个参数：</p><ul><li>第一个是一个回调函数。</li><li>第二个参数是一个数组，数组中的<code>state</code> 发生改变才会重新执行回调函数。</li></ul><blockquote><p>注意：</p><ul><li>如果不传数组，则每次更新都会重新计算</li><li>空数组，只会计算一次</li><li>数组里面有依赖值，则当对应的值发生变化时，才会重新计算</li></ul></blockquote><h2 id="举个-🌰-4"><a href="#举个-🌰-4" class="headerlink" title="## 举个 🌰"></a>## 举个 🌰</h2><iframe height="603" style="width: 100%;" scrolling="no" title="React Hook useMemo()" src="https://codepen.io/shuliqi/embed/XWaNzJO?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/XWaNzJO">  React Hook useMemo()</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>整个例子跟<code>useMemo差不多的，只不过</code>useMemo<code> 返回的是值， 而</code>useCallback<code>返回的是一个函数。其功能都是一样的， 当前的依赖项是</code>count<code>， 当</code>count <code>发生改变时 </code>newValueFn` 会被触发。</p><p>关于 <code>useMemo</code>和<code>useCallback</code>的使用场景是什么？ 都有什么作用呢？能优化什么呢？ 这些问题，这篇文章文章会解答：</p><h1 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps]);</span><br></pre></td></tr></table></figure><p><code>useImperativeHandle</code>可以在使用<code>ref</code> 的时候自定义暴露给父组件的实例值。在大多数情况下，应当避免使用<code>ref</code>这样的命令式。<code>useImperativeHandle</code>应当与 <code>forwardRef</code>一起使用。</p><blockquote><p>说白了就是子组件暴露给父组件实例使用</p></blockquote><p>有三个参数：</p><ul><li>参数 1: 子组件向父组件暴露的实例</li><li>参数 2：参数 2 是一个函数，传递的父组件可操作的实例和方法</li><li>参数 3: 监听状态， 更新的状态， 可以忽略</li></ul><h2 id="举个-🌰-5"><a href="#举个-🌰-5" class="headerlink" title="举个 🌰"></a>举个 🌰</h2><iframe height="818" style="width: 100%;" scrolling="no" title="React Hook useImperativeHandle" src="https://codepen.io/shuliqi/embed/vYJyWdx?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/vYJyWdx">  React Hook useImperativeHandle</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><hr><h1 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h1><p><code>useLayoutEffect</code> 与 <code>useEffect</code>是差不多的， 它们都是接受一个函数和一个数组， 只有数组里面的值发生了变化， 才会执行<code>effect</code>。</p><p>差异：</p><ul><li><code>useEffect</code>是异步的，<code>useLayoutEffect</code> 是同步的</li><li><code>useEffect</code>的渲染时机是浏览器完成渲染之后， 而<code>useLayoutEffect</code> 是浏览器把内容真正渲染到浏览器之前，和<code>componentDidMount</code>是等价的。</li></ul><h2 id="举个-🌰-6"><a href="#举个-🌰-6" class="headerlink" title="举个 🌰"></a>举个 🌰</h2><p>把<code>useEffect</code>替换成<code>useLayoutEffect</code>几乎是看不到任何问题的。 他们之前的区别是什么呢？ 我们来举个 🌰</p><ul><li><p>使用 <code>useEffect</code></p><iframe height="505" style="width: 100%;" scrolling="no" title="React Hook useState()" src="https://codepen.io/shuliqi/embed/ZEJzrby?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/ZEJzrby">  React Hook useState()</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe></li></ul><p>上面例子中 点击 div，页面会更新一串随机数。当我们连续点击时，就会发现这串数字在发生抖动。这是因为当我们每次点击 <code>div</code>， count 会更新为 0， 之后 <code>useEffect</code> 内又把 <code>count </code>改为一串随机数。</p><p>所以页面会先渲染成 0，然后再渲染成随机数，由于更新很快，所以出现了闪烁。</p><blockquote><p>刨根问底就是因为：<code>useEffect</code>的渲染时机是浏览器完成渲染之后</p></blockquote><ul><li><p>使用<code>useLayoutEffect</code></p><p>如果我们把上面的例子改用<code>useLayoutEffect</code>。 我们来看看效果：</p><iframe height="501" style="width: 100%;" scrolling="no" title="React Hook useLayoutEffect()" src="https://codepen.io/shuliqi/embed/eYEBKXj?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/eYEBKXj">  React Hook useLayoutEffect()</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>我们可以看出来闪烁消失了。</p><p>相比使用 <code>useEffect</code>，当你点击 <code>div</code>，<code>count </code>更新为 0，此时页面并不会渲染，而是等待<code> useLayoutEffect</code> 内部状态修改后，才会去更新页面，所以页面不会闪烁。</p><blockquote><p>刨根问底就是因为：<code>useLayoutEffect</code> 是浏览器把内容真正渲染到浏览器之前。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li><p><code>useLayoutEffect </code>相比 <code>useEffect</code>，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题。</p></li><li><p><code>useEffect </code>可以满足百分之 99 的场景，而且<code>useLayoutEffect</code>会阻塞渲染，请谨慎使用。</p></li></ul><hr><h1 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p><code>useReducer</code>是<code>useState</code>的升级版（实际上是原始版）， 可以实现复杂的逻辑修改，而不是像<code>useState</code>那样只是直接赋值修改。</p><blockquote><p>在 <code>React</code> 源码中，实际上<code>useState</code>是由<code>useReducer</code>实现的，所以准确来说<code>useReducer</code>是<code>useState </code>的原始版</p></blockquote><p><code>useReducer</code> 通常传入两个参数：</p><ul><li>第一个参数：由<code>dispatch</code>引发的数据修改的处理函数</li><li>第二个参数：自定义数据的默认值</li></ul><h2 id="举个-🌰-7"><a href="#举个-🌰-7" class="headerlink" title="举个 🌰"></a>举个 🌰</h2><iframe height="722" style="width: 100%;" scrolling="no" title="React Hook useReducer" src="https://codepen.io/shuliqi/embed/zYdZGON?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/zYdZGON">  React Hook useReducer</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解DSL</title>
      <link href="/2021/08/07/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3DSL/"/>
      <url>/2021/08/07/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3DSL/</url>
      
        <content type="html"><![CDATA[<p>从一个简单的问题开始：</p><p>如何使用程序来描述下面的问题？</p><p>在一组候选人中，找到满足以下条件的的数据：</p><ul><li>所有的候选人性别为女</li><li>数据按照年龄来排序</li><li>输出姓名以及年龄的信息</li></ul> <span id="more"></span><p>问题跑出来，那么让我们使用<code>JavaScript</code>来实现这个需求：</p><blockquote><p>假设数据集合叫<code>data</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = data.filter(<span class="function">(<span class="params">people</span>) =&gt;</span> people.sex === <span class="string">&#x27;女&#x27;</span>)</span><br><span class="line">                    .sort(<span class="function">(<span class="params">cur, pre</span>) =&gt;</span> cur.age - pre.age)</span><br><span class="line">                    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> &#123; <span class="attr">name</span>: item.name, <span class="attr">age</span>: item.age &#125;</span><br><span class="line">                    &#125;)</span><br></pre></td></tr></table></figure><p>上面的代码看起来，在对于<code>JavaScript</code>语言十分熟悉的人来看， 可以很快的看明白代码的意思，但是如果是外行，那就可能有点难猜了。</p><p>那怎么办呢？有没有什么更好的办法/更简单易懂的方式来描述这个问题呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;name&#x27;, &#x27;age&#x27; from &quot;data&quot; where sex = &quot;女&quot; sortBy &quot;age&quot;;</span><br></pre></td></tr></table></figure><p>上面这个语句是一个<code>SQL</code>语句, 相信不管是不是程序员，都能快速的理解这段语句的含义。</p><p>显然<code>SQL</code>在查询这个领域比<code>JavaScript</code>更加简洁，表达力更强；我们管这种针对特殊领域的语言就叫<code>DSL</code>(特殊领域语言)。</p><h1 id="什么是DSL"><a href="#什么是DSL" class="headerlink" title="什么是DSL"></a>什么是DSL</h1><p><code>DSL</code>是(Domain Specific Language)特定领域语言， 是为了处理某一特定领域的问题而设计出来的语言，这类语言比较简单，在专属的领域内，有着非常强的表达力。</p><p>与之相对应的是的<code>GPL</code>(General Purpose Language) 通用编程语言。这类语言是能够表达科倍计算的逻辑，必须是图灵完备，他们的侧重点是灵活，全面。 <code>Java</code>,<code>python</code>,<code>JavaScript</code>,<code>go</code>,<code>C 这类都属于</code>GPL`。</p><h1 id="典型的DSL-有哪些"><a href="#典型的DSL-有哪些" class="headerlink" title="典型的DSL 有哪些"></a>典型的DSL 有哪些</h1><ul><li><code>HTML</code></li><li><code>CSS</code></li><li><code>JSX</code></li><li><code>PUG</code></li><li><code>REGEX</code></li><li><code>SQL</code></li><li><code>XML</code></li><li><code>YMAL</code></li></ul><p>上面的这些语言，几乎都不是图灵完备的计算机语言，他们的语法很简单，主要以声明式的表达方式来进行编写的。</p><p>因为是使用声明式的表达方式, 所以在在阅读上会更加流畅。</p><blockquote><p>关于什么是图灵机，什么是图灵完备等，可阅读这篇文章  <a href="https://www.zhihu.com/question/20115374">什么是图灵完备？</a></p></blockquote><h1 id="为什么要用-DSL"><a href="#为什么要用-DSL" class="headerlink" title="为什么要用 DSL"></a>为什么要用 DSL</h1><p><code>DSL</code>语法往往简单，并且非常易于阅读，在其擅长的领域内编码是非常高效的。</p><p>我们再拿 <code>HTML</code> 和 <code>JavaScript</code>对象来最一个对比：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>: <span class="string">&quot;div&quot;</span>, <span class="attr">class</span>: <span class="string">&quot;container&quot;</span>, <span class="attr">children</span>: <span class="string">&quot;shuliqi&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>使用<code>JavaScript</code>来描述一个<code>HTML</code>节点，只能把所有的的属性平铺到一个对象中，让人在阅读中无法找到重点，无法有效的做区分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> &gt;</span> shuliqi <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用了 <code>XML</code>标签，就可以快速的辨别标签的类型，内容，整体语义化很强，缺点就是多余的符号和为了表达嵌套关系的的闭合标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div(class=&#x27;container&#x27;) hello world</span><br></pre></td></tr></table></figure><p>使用<code>pug</code>独特的语法，在不损失<code>XML</code>的表达力的前提下，省略了无用的符号，并通过缩进来表达嵌套逻辑，降低了很多的语法噪音。</p><p>可以看出来, <code>DSL</code>的引入确实能够有效的提高特定场景的表达效率, 在熟悉了相关语法后, 能够是代码更易理解, 也更加简洁。</p><h1 id="要不要引入DSL"><a href="#要不要引入DSL" class="headerlink" title="要不要引入DSL"></a>要不要引入DSL</h1><p>在日常的开发中， 为了解决某一场景的需求而引入一个新的<code>DSL</code>, 在我看来是需要慎重考虑的。因为这是引入了一种新的语言，这可能会让整个项目的维护难度提升。</p><p>所以否引入<code>DSL</code>需要考虑几个点：</p><ul><li>产能的提升是否能够抹平新语言引入带来的学习成本</li><li>是否可以使用第三方工具替代<code>DSL</code></li></ul><h1 id="内部DSL-外部DSL"><a href="#内部DSL-外部DSL" class="headerlink" title="内部DSL? 外部DSL?"></a>内部DSL? 外部DSL?</h1><p>既然引入<code>DSL</code>是有成本的，那么有没有什么成本比较低的引入方法呢？</p><p>也许有的，上面我们谈到的<code>DSL</code>在广义上作区分的话可以叫做<strong>外部DSL</strong>，既然有<strong>外部DSL</strong>， 那么肯定有<strong>内部DSL</strong>，我们举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;name&#x27; from &#x27;applications&#x27; where id = 234</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">.from(<span class="string">&#x27;applications&#x27;</span>)</span><br><span class="line">.where(id, <span class="string">&#x27;=&#x27;</span>, <span class="number">234</span>)</span><br></pre></td></tr></table></figure><p>上面的<code>SQL</code> 和下面的<code>JavaScript</code>代码实际上是等价的， 上面的<code>SQL</code>代码我们叫它<code>外部的DSL</code>， 下面的<code>JavaScript</code>我们叫做<code>内部DSL</code>—-&gt; <a href="https://knexjs.org/">knexjs</a></p><p>可以再来举个例子:</p><p><strong>外部DSL</strong>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="selector-class">.content</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">10px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部的DSL</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;.container .content&#x27;</span>)</span><br><span class="line">.css(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;#fff&#x27;</span>)</span><br><span class="line">.css(<span class="string">&#x27;margin&#x27;</span>, <span class="string">&#x27;10px&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显然这个内部的<code>DSL</code>看着很眼熟，感觉就是我们普调的<code>js</code>方法调用，就是普调的第三方接口调用。</p><p>类似这样的内部<code>DSL</code>我们见到还很多：</p><p><strong>Jquery：</strong></p><p><code>JQuery</code>可以被称作是对<code>DOM</code>的操作的<strong>内部DSL</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;.mydiv&#x27;</span>)</span><br><span class="line">.addClass(<span class="string">&#x27;flash&#x27;</span>)</span><br><span class="line">.draggable()</span><br><span class="line">.css(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>Moment：</strong></p><p><code>Moment</code>可以被称作是对日期操作的<strong>内部DSL</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moment()</span><br><span class="line">.subtract(<span class="number">10</span>, <span class="string">&#x27;days&#x27;</span>)</span><br><span class="line">.calendar();</span><br></pre></td></tr></table></figure><p><strong>Chai</strong></p><p><code>Chai</code>就可以被称作是对断言的<strong>内部DSL</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tea.should.have.property(<span class="string">&#x27;flavors&#x27;</span>).with.lengthOf(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h1 id="如何区分内部或外部DSL"><a href="#如何区分内部或外部DSL" class="headerlink" title="如何区分内部或外部DSL"></a>如何区分内部或外部DSL</h1><p>通常来讲, 如果实现的功能,无法被宿主语言直接支持, 需要自己额外实现代码的编译和解析, 都属于外部DSL</p><p>如果实现的功能, 可以呗宿主语言直接支持, 就想上面的例子一样, 都是简单的函数形式, 那么这就属于内部的DSL</p><p>那么现在这里有一个问题, 就是我们写<code>React</code>常用的<code>JSX</code>算是什么? 是内部的<code>DSL</code>么? 下面放一点示例代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Menu</span> <span class="attr">list</span>=<span class="string">&#123;this.state.list&#125;/</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Footer</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会被转成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  Container,</span><br><span class="line">  null,</span><br><span class="line">  React.createElement(Menu, &#123;</span><br><span class="line">    list: this.state.list</span><br><span class="line">  &#125;),</span><br><span class="line">  React.createElement(Footer, null)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>虽然转义后的代码是合法的<code>javaScript</code>代码，但是源代码并不是一个合法的<code>javaScript</code>代码，正常的浏览器是无法正常识别这些代码的。</p><p>因为这些代码再被浏览器执行前, 会被<code>Babel</code>进行转移, 转移成可被浏览器识别的<code>javaScript</code>代码，而<code>Babel</code>在转义这些<code>JSX</code>的时候,<br>实际上内部已经实现了对这种特殊语法的编译和解析, 所以, 虽然<code>jsx</code>通常也写在<code>.js</code>文件中, 但它还是一个外部的<code>DSL</code></p><h1 id="如何看待内部DSL"><a href="#如何看待内部DSL" class="headerlink" title="如何看待内部DSL"></a>如何看待内部DSL</h1><p><code>DSL</code>实际上就是为了解决特定问题而出现的.<br>使用内部<code>DSL</code>来对某个领域进行扩展,在我看来是一个很好的解决方案, 因为没有引入新语言带来的新问题,</p><p>社区对,内部<code>DSL</code>的划分界定实际上很模糊, 希望大家不要过于纠结, 无论是<code>API</code> 还是<code> DSL</code>, 能够有效的抽象并解决问题的, 都是好的解决之道。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端如何发起http请求及各方法的优缺点</title>
      <link href="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>对于前端开发来说， 请求是日常工作必备的；前端主要通过请求与后端进行交互，特别在前后端分离的模式开发下，请求就更重要了。那么掌握前端发送请求的方式很重要的。那么前端请求常用的方式有哪些呢？具体做业务的时候我们选择什么样的请求方式呢？</p> <span id="more"></span><h1 id="from表单"><a href="#from表单" class="headerlink" title="from表单"></a>from表单</h1><p>这属于最原始的<code>http</code>请求方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>from表单方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>账号：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入你的名字&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入密码&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span> 男</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span> 女</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们点击提交的时候：</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/1.png" class=""><p>这种方式的请求的整个过程是什么呢？</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/4.png" class=""><p>这种交互方式的缺陷是显而易见的，任何和服务器的交互都是需要刷新页面的，造成的问题就是用户体验很差</p><blockquote><p>这是最原始的一直请求方式， 现在几乎都不会采用这种方式了， 所以这里就不细讲了</p></blockquote><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>由于之前的<code>web</code>交互方式是需要刷新页面的， 所以导致用户的体验很差；<code>Ajax</code>的出现解决了这个问题。<code>Ajax</code>全称 <code>Asynchronous JavaScript + XML</code>（异步<code>JavaScript</code>和<code>XML</code>）；</p><p><code>Ajax</code>本身不是一种新技术，而是用来描述一种使用现有技术集合实现的一个技术方案，使用<code>Ajax</code>，网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。</p><p>那<code>Ajax</code>这个方案是如何实现的呢？其实<code>Ajax</code>的实现主要是浏览器的<code>XMLHttpRequest</code>（在<code>IE6</code>以下使用<code>ActiveXObject</code>）。 那我们来看看这个原生的<code>XMLHttpRequest</code>的<code>api</code>。</p><h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><p><code>XMLHttpRequest</code>一开始只是微软浏览器提供的一个接口，但是后来各大浏览器也效仿提供了这个接口， 再后来<code>W3C</code>对它进行了标准化，按照标准的前后可以分为两个版本；</p><h3 id="XMLHttpRequest-老版本"><a href="#XMLHttpRequest-老版本" class="headerlink" title="XMLHttpRequest 老版本"></a>XMLHttpRequest 老版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 XMLHttpRequest 对象</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行请求</span></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(&#123; <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待服务器的响应</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 该函数会被调用四次， 因此需要判断状态是否是4</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( xhr.status === <span class="number">200</span> ) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;请求数据成功：&quot;</span>, <span class="built_in">JSON</span>.parse(xhr.responseText) )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;请求数据失败：&quot;</span>, xhr.statusText );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的属性说明如下：</p><ul><li><code>readyState</code>: 返回当前 <code>XMLHttpRequest</code>对象当前所处的状态， 有四个状态<ul><li>0：表示代理已被创建，但是尚未调用 <code>open</code>方法</li><li>1：表示<code>open</code>已经被调用，在这个状态中可以通过 <code>setRequestHeader()</code>方法来设置请求的头部。</li><li>2：表示<code>send()</code>方法已经被调用，响应头也已经被接收</li><li>3：表示响应了部分结果，但是没有全部响应完</li><li>4：表示请求操作已经完成，以为着传输已经彻底的完成和失败</li></ul></li><li><code>status</code>：表示服务器返回的状态码， 等于200表示成功响应</li><li><code>responesText</code>： 表示服务器返回的文本数据</li><li><code>responseXML</code>：表示服务器返回的XML格式的数据</li><li><code>statusText</code>：表示服务器返回的状态文本</li></ul><blockquote><p>由于老版本不是统一的标准，各大浏览器在实现上有一定的差异性，所以存在一些缺陷</p><ul><li>只支持文本数据的传送，无法用来读取和上传二进制文件</li><li>传送和和接收数据时，没有进度信息，只能提示没有完成或者已完成</li><li>受到”同域限制“只能向同一域名的服务器请求数据</li></ul></blockquote><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>XMLHttpRequest老版本<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 新建一个 XMLHttpRequest 对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 进行请求</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    xhr.send(&#123; <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 等待服务器的响应</span></span></span><br><span class="line"><span class="javascript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 该函数会被调用四次， 因此需要判断状态是否是4</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> ) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> ( xhr.status === <span class="number">200</span> ) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&quot;请求数据成功：&quot;</span>, <span class="built_in">JSON</span>.parse(xhr.responseText) )</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&quot;请求数据失败：&quot;</span>, xhr.statusText );</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开页面之后，可得到结果：</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/2.png" class=""><p>由以上方式， 我们<code>web</code>是这样工作的：</p><h3 id="XMLHttpRequest-新版本"><a href="#XMLHttpRequest-新版本" class="headerlink" title="XMLHttpRequest 新版本"></a>XMLHttpRequest 新版本</h3><p>为了更好的使用<code>XMLHttpRequest</code>，<code>w3school</code>发布了标准版本，该版本弥补了老版本的一些缺陷，也是被各大浏览器厂商接受和实现，具体的功能如下：</p><ul><li>可以设置<code>http</code>请求的时限</li><li>可以上传文件</li><li>可以跨域请求</li><li>可以获取服务端的二进制数据</li><li>可以获取数据传输的进度信息</li></ul><p>一般为了更加友好的进行兼容各个浏览器，会对浏览器进行判断并进行兼容性模式来获取<code>XMLHttpRequest</code>的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 XMLHttpRequest 对象</span></span><br><span class="line"><span class="keyword">let</span> xhr;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123; <span class="comment">// Mozilla, Safari...</span></span><br><span class="line">  xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123; <span class="comment">// IE</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Msxml2.XMLHTTP&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>); <span class="comment">//IE5,6</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求成功回调函数</span></span><br><span class="line">xhr.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求成功&#x27;</span>, xhr.response);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求结束</span></span><br><span class="line">xhr.onloadend = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求失败&#x27;</span>, xhr.response);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求出错</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求出错&#x27;</span>, e);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求超时</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求超时&#x27;</span>, e);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求取消触发</span></span><br><span class="line">xhr.onabort = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;请求被取消了&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置超时时间，0 表示永不超时</span></span><br><span class="line">xhr.timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化请求</span></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9da822417/qixiao/getFileDetail&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置期望的返回数据类型 &#x27;json&#x27; &#x27;text&#x27; &#x27;document&#x27; ...</span></span><br><span class="line">xhr.responseType = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line"><span class="comment">// xhr.setRequestHeader(&#x27;&#x27;, &#x27;&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.send(&#123; <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">xhr.abort();</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>XMLHttpRequest老版本<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 新建一个 XMLHttpRequest 对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> xhr;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123; <span class="comment">// Mozilla, Safari...</span></span></span><br><span class="line"><span class="javascript">      xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123; <span class="comment">// IE</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">          xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Msxml2.XMLHTTP&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">              xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>); <span class="comment">//IE5,6</span></span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 请求成功回调函数</span></span></span><br><span class="line"><span class="javascript">    xhr.onload = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;请求成功&#x27;</span>, xhr.response);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">        </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置超时时间，0 表示永不超时</span></span></span><br><span class="line"><span class="javascript">    xhr.timeout = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 初始化请求</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置期望的返回数据类型 &#x27;json&#x27; &#x27;text&#x27; &#x27;document&#x27; ...</span></span></span><br><span class="line"><span class="javascript">    xhr.responseType = <span class="string">&#x27;json&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 发送请求</span></span></span><br><span class="line"><span class="javascript">    xhr.send(&#123; <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/3.png" class=""><p>最后总结的来说<code>XMLHttpRequest</code>的功能如下：</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/5.png" class=""><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>不重新加载页面的情况下更新网页</li><li>在页面已加载后从服务器请求/接收数据</li><li>在后台向服务器发送数据</li></ul><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul><li>使用起来也比较繁琐，需要设置很多值。</li><li>早期的IE浏览器有自己的实现，这样需要写兼容代码。</li></ul><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>为了更快捷的操作<code>DOM</code>，并且规避了一些浏览器兼容问题，就产生了<code>jQuery</code>。它里面的<code>AJAX</code>请求也兼容了各浏览器，可以有简单易用的方法<code>$.get</code>，<code>$.post</code>。简单点说，就是对<code>XMLHttpRequest</code>对象的封装。</p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>jquery封装的ajax<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">url</span>:<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// 设置返回值类型</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">contentType</span>: <span class="string">&#x27;application/json&#x27;</span>, <span class="comment">// 设置参数类型</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">headers</span>: &#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span> &#125;,<span class="comment">// 设置请求头</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">xhrFields</span>: &#123; <span class="attr">withCredentials</span>: <span class="literal">true</span> &#125;, <span class="comment">// 跨域携带cookie</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>&#125;), <span class="comment">// 传递参数</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">error</span>:<span class="function"><span class="keyword">function</span>(<span class="params">xhr,status</span>)</span>&#123;  <span class="comment">// 错误处理</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&quot;数据请求失败:&quot;</span>, xhr,status);</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;  <span class="comment">// 获取结果</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&quot;数据请求成功&quot;</span>, data);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/6.png" class=""><blockquote><p>这里也不细讲， 有兴趣或者需要的话可以点击学习<a href="https://jquery.com/">jquery官方</a></p></blockquote><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul><li>对原生<code>XHR</code>的封装，做了兼容处理，简化了使用。</li><li>增加了对<code>JSONP</code>的支持，可以简单处理部分跨域。</li></ul><h2 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h2><ul><li>如果有多个请求，并且有依赖关系的话，容易形成回调地狱。</li><li>本身是针对MVC的编程，不符合现在前端MVVM的浪潮。</li><li>ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。</li></ul><h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p><code>fetch</code>提供了一个<code>JavaScript</code>接口，是<code>window</code>的一个函数对象，用于访问网络和操作<code>HTTP</code>管道的部分，例如请求和响应。提供了一个全局的<code>fech（）</code>方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p><p><code>fetch</code>是底层的<code>api</code>， 替代了<code>XMLHttpRequest</code>。可以轻松的处理各种格式，非文本化格。而且可以很容易的被其他的技术使用。例如 <code>Service Workers</code></p><p><code>fetch</code>功能与<code>XMLHttpRequest</code>基本是相同的，但是有三哥主要的差异。</p><ul><li><code>fetch()</code>是使用的<code>Promise</code>，不使用回调函数，因此写法上就大大的简化了</li><li><code>fetch()</code>采用模块化的设计，<code>API</code>分散在多个对象上（<code>Response</code>对象，<code>Request</code>对象，<code>Header</code>对象），比输入，输出，状态等<code>API</code>都在<code>XMLHttpRequest</code>对象上更合理一些。</li><li><code>fetch()</code>是使用数据流处理数据，可以分开读取，有利于提高网站的性能，减少内存占用，对于请求大文件或者网速慢的场景相当有用。</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>fetch()</code>接受两个参数，第一个参数是一个<code>url</code>，第二个参数是一个配置项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, options)</span><br></pre></td></tr></table></figure><ul><li><code>url</code>是一个字符串，默认向该网址发出<code>get</code>请求，返回一个<code>Promise</code>对象</li><li><code>options</code> 是一个对象，用于定制 HTTP 请求</li></ul><p>一个基本用法的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>fetch()基本用法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    fetch(<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>)</span></span><br><span class="line"><span class="javascript">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;数据请求成功：&quot;</span>, response.json());</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;数据请求失败：&quot;</span>, err)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/7.png" class=""><p>这个例子说明 <code>fetch()</code>接收到<code>Promise</code>的一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API">Stream 对象</a>，<code>response.json()</code>是一个异步操作，取出所有的内容，，并将其转化为<code>JSON</code>对象。</p><p>还可以使用 <code>async/await</code>的语法改写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>fetch()基本用法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;数据请求成功：&quot;</span>, response.json())</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;获取数据失败：&quot;</span>, err)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    getData();</span></span><br><span class="line"><span class="javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>async/await</code>需要注意的是 <code>await</code>语句必须放在<code>try...catch</code>里面，这样才能捕获到异步操作中可能发生错误。</p><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><p><code>Response</code>对象主要是处理<code> HTTP</code> 响应。 <code>fetch()</code>请求成功之后，得到的是一个<code>Response</code>对象，它对应的是服务器<code>HTTP</code>回应。</p><h3 id="Response-对象的同步属性"><a href="#Response-对象的同步属性" class="headerlink" title="Response 对象的同步属性"></a>Response 对象的同步属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br></pre></td></tr></table></figure><p><code>Response</code> 包含的数据通过 <code>Stream</code> 接口异步读取，但是它还包含一些同步属性，对应<code> HTTP</code> 回应的标头信息（<code>Headers</code>），可以立即读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;数据请求成功：&quot;</span>, response.status, response.statusText)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;获取数据失败：&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">getData();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>像这个例子，<code>response.status</code>,<code>response.statusText</code>就是<code>Response</code>的同步属性，是可以立即读取的。</p><p><strong>全部的同步属性如下</strong>：</p><ul><li><p><strong>Response.ok</strong>：</p><p><code>Response.ok</code>属性返回一个布尔值，表示请求是否成功，<code>true</code>对应 HTTP 请求的状态码 200 到 299，<code>false</code>对应其他的状态码。</p></li><li><p><strong>Response.status</strong></p><p><code>Response.status</code>属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）。</p></li><li><p><strong>Response.statusText</strong></p><p><code>Response.statusText</code>属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回”OK”）</p></li><li><p><strong>Response.url</strong></p><p><code>Response.url</code>属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</p></li><li><p><strong>Response.type</strong></p><p><code>Response.type</code>属性返回请求的类型。可能的值如下：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>basic</td><td>普通请求，即同源请求</td></tr><tr><td>cors</td><td>跨域请求</td></tr><tr><td>error</td><td>网络错误，主要用于 Service Worker</td></tr><tr><td>opaque</td><td>如果<code>fetch()</code>请求的<code>type</code>属性设为<code>no-cors</code>，就会返回这个值，详见请求部分。表示发出的是简单的跨域请求，类似<code>&lt;form&gt;</code>表单的那种跨域请求</td></tr><tr><td>opaqueredirect</td><td>如果<code>fetch()</code>请求的<code>redirect</code>属性设为<code>manual</code>，就会返回这个值，详见请求部分</td></tr></tbody></table></li><li><p><strong>Response.redirected</strong></p><p><code>Response.redirected</code>属性返回一个布尔值，表示请求是否发生过跳转</p></li></ul><h3 id="判断请求是否成功"><a href="#判断请求是否成功" class="headerlink" title="判断请求是否成功"></a>判断请求是否成功</h3><p><code>fetch()</code>发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，<code>fetch()</code>才会报错，其他情况都不会报错，而是认为请求成功。</p><p>这就是说，即使服务器返回的状态码是 4xx 或 5xx，<code>fetch()</code>也不会报错（即 <code>Promise</code> 不会变为 <code>rejected</code>状态）。</p><p>只有通过<code>Response.status</code>属性，得到 <code>HTTP</code> 回应的真实状态码，才能判断请求是否成功。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>);</span><br><span class="line">    <span class="comment">// 第一种判断请求是否成功的方式：response.status</span></span><br><span class="line">    <span class="keyword">if</span> (response.status &gt;= <span class="number">200</span> &amp;&amp; response.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> response.json();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;获取数据成功：&quot;</span>, result)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;获取数据失败&quot;</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(response.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;网络错误，或者无法连接时:&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">getData();</span><br></pre></td></tr></table></figure><p>这个例子中，<code>response.status</code>属性只有等于 2xx （200~299），才能认定请求成功。这里不用考虑网址跳转（状态码为 3xx），因为<code>fetch()</code>会将跳转的状态码自动转为 200。</p><p> 另外一种判断请求是否成功是使用<code>response.ok</code>。判断是否为<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种判断是否成功的方式：response.ok</span></span><br><span class="line">    <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> response.json();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;获取数据成功：&quot;</span>, result)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;获取数据失败&quot;</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(response.statusText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;网络错误，或者无法连接时:&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">getData();</span><br></pre></td></tr></table></figure><h3 id="Response-headers-属性"><a href="#Response-headers-属性" class="headerlink" title="Response.headers 属性"></a>Response.headers 属性</h3><p><code>Response</code>对象还有一个<code>Response.headers</code>属性， 指向一个<code>Headers</code>对象，对应<code>HTTP</code>响应的所有标头。</p><p><code>Headers</code>对象可以使用<code>for...of</code>来进行循环遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> headers = response.headers; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> response.headers) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> : <span class="subst">$&#123;value&#125;</span>`</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;获取数据失败：&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">getData();</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content-type : application/json; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure><p><code>Headers</code>对象还提供了以下方法，用来操作标头</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>Headers.get()</code></td><td>根据指定的键名，返回键值</td></tr><tr><td><code>Headers.has()</code></td><td>返回一个布尔值，表示是否包含某个标头</td></tr><tr><td><code>Headers.set()</code></td><td>如果该键名不存在则会添加。</td></tr><tr><td><code>Headers.append()</code></td><td>添加标头</td></tr><tr><td><code>Headers.delete()</code></td><td>删除标头</td></tr><tr><td><code>Headers.keys()</code></td><td>返回一个遍历器，可以依次遍历所有键名</td></tr><tr><td><code>Headers.values()</code></td><td>返回一个遍历器，可以依次遍历所有键值</td></tr><tr><td><code>Headers.entries()</code></td><td>返回一个遍历器，可以依次遍历所有键值对（<code>[key, value]</code>）。</td></tr><tr><td><code>Headers.forEach()</code></td><td>依次遍历标头，每个标头都会执行一次参数函数</td></tr></tbody></table><p>上面的这些方法有些是可以修改标头，那是因为继承自<code>Headers</code>接口，对于<code>HTTP</code>响应来说， 修改标头没有很大的意义，而且很多标头都是只读的，浏览器不允许修改。</p><p>这些方法中， 最常用的就是<code>response.headers.get()</code>，用于获取某个标头的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> headers = response.headers; </span><br><span class="line">    <span class="built_in">console</span>.log(headers.get(<span class="string">&quot;Content-Type&quot;</span>)) <span class="comment">// application/json; charset=utf-8</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;获取数据失败：&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">getData();</span><br></pre></td></tr></table></figure><h3 id="读取内容的方法"><a href="#读取内容的方法" class="headerlink" title="读取内容的方法"></a>读取内容的方法</h3><p><code>Response</code>对象根据服务器返回的不同类型的数据，提供了不同的读取方法。</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>response.text()</code></td><td>得到文本字符串</td></tr><tr><td><code>response.json()</code></td><td>得到 JSON 对象。</td></tr><tr><td><code>response.blob()</code></td><td>得到二进制 Blob 对象</td></tr><tr><td><code>response.formData()</code></td><td>得到 FormData 表单对象</td></tr><tr><td><code>response.arrayBuffer()</code></td><td>得到二进制 ArrayBuffer 对象。</td></tr></tbody></table><p><code>response.json()</code>上面讲过了，我们再举个<code>response.text()</code>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>response.text()读取内容<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> result = <span class="keyword">await</span> response.text();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(result); </span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;获取数据失败：&quot;</span>, err)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    getData();</span></span><br><span class="line"><span class="javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/8.png" class=""><h3 id="Response-clone"><a href="#Response-clone" class="headerlink" title="Response.clone()"></a>Response.clone()</h3><p><code>Stream</code> 对象只能读取一次，读取完就没了。这意味着，前一节的五个读取方法，只能使用一个，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text =  <span class="keyword">await</span> response.text();</span><br><span class="line"><span class="keyword">let</span> json =  <span class="keyword">await</span> response.json();  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><code>Response</code> 对象提供<code>Response.clone()</code>方法，创建<code>Response</code>对象的副本，实现多次读取。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Response.clone()<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> response1 = <span class="keyword">await</span> fetch(<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> response2 = response1.clone();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> result1 = <span class="keyword">await</span> response1.json();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> result2 = <span class="keyword">await</span> response2.text();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;result1--------:&quot;</span>, result1); </span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;result2--------:&quot;</span>, result2); </span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;获取数据失败：&quot;</span>, err)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    getData();</span></span><br><span class="line"><span class="javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/9.png" class=""><h3 id="Response-body-属性"><a href="#Response-body-属性" class="headerlink" title="Response.body 属性"></a>Response.body 属性</h3><p><code>Response.body</code>属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作。</p><p>它可以用来分块读取内容，应用之一就是显示下载的进度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Response.body()<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://shuliqi.github.io/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/1.gif&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> reader = response.body.getReader();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.read();</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (done) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">`Received <span class="subst">$&#123;value.length&#125;</span> bytes`</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;获取数据失败：&quot;</span>, err)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    getData();</span></span><br><span class="line"><span class="javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/10.png" class=""><h2 id="fetch-配置对象"><a href="#fetch-配置对象" class="headerlink" title="fetch()配置对象"></a>fetch()配置对象</h2><p><code>fetch()</code>的第一个参数是 <code>URL</code>，还可以接受第二个参数，作为配置对象，定制发出的 <code>HTTP</code> 请求。</p><p><code>fetch()</code>第二个参数的完整 API 如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = fetch(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain;charset=UTF-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&quot;about:client&quot;</span>,</span><br><span class="line">  <span class="attr">referrerPolicy</span>: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;cors&quot;</span>, </span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line">  <span class="attr">cache</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&quot;follow&quot;</span>,</span><br><span class="line">  <span class="attr">integrity</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">keepalive</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">signal</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>fetch()</code>请求的底层用的是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request">Request() 对象</a>的接口，参数完全一样，因此上面的 API 也是<code>Request()</code>的 API。</p><ul><li><code>method</code>：HTTP 请求的方法，<code>POST</code>、<code>DELETE</code>、<code>PUT</code>都在这个属性设置。</li><li><code>headers</code>：一个对象，用来定制 HTTP 请求的标头。</li><li><code>body</code>：POST 请求的数据体。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// GET, POST,PUT,DELETE等</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="string">&#x27;foo=bar&amp;lorem=ipsum&#x27;</span>,</span><br><span class="line">  <span class="comment">// body: blob, //直接上传二进制数据</span></span><br><span class="line">  <span class="comment">// body: new FormData(form) // 提交表单</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br></pre></td></tr></table></figure><p>注意，有些标头不能通过<code>headers</code>属性设置，比如<code>Content-Length</code>、<code>Cookie</code>、<code>Host</code>等等。它们是由浏览器自动生成，无法修改。</p><p><strong>cache</strong></p><p><code>cache</code>属性指定如何处理缓存。可能的取值如下：</p><blockquote><ul><li><code>default</code>：默认值，先在缓存里面寻找匹配的请求。</li><li><code>no-store</code>：直接请求远程服务器，并且不更新缓存。</li><li><code>reload</code>：直接请求远程服务器，并且更新缓存。</li><li><code>no-cache</code>：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存。</li><li><code>force-cache</code>：缓存优先，只有不存在缓存的情况下，才请求远程服务器。</li><li><code>only-if-cached</code>：只检查缓存，如果缓存里面不存在，将返回504错误。</li></ul></blockquote><p><strong>mode</strong></p><p><code>mode</code>属性指定请求的模式。可能的取值如下：</p><blockquote><ul><li><code>cors</code>：默认值，允许跨域请求。</li><li><code>same-origin</code>：只允许同源请求。</li><li><code>no-cors</code>：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单所能发出的请求。</li></ul></blockquote><p><strong>credentials</strong></p><p><code>credentials</code>属性指定是否发送 Cookie。可能的取值如下：</p><blockquote><ul><li><code>same-origin</code>：默认值，同源请求时发送 Cookie，跨域请求时不发送。</li><li><code>include</code>：不管同源请求，还是跨域请求，一律发送 Cookie。</li><li><code>omit</code>：一律不发送。</li></ul></blockquote><p>跨域请求发送 Cookie，需要将<code>credentials</code>属性设为<code>include</code>。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;http://another.com&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;include&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p><strong>signal</strong></p><p><code>signal</code>属性指定一个 AbortSignal 实例，用于取消<code>fetch()</code>请求，详见下一节。</p><p><strong>keepalive</strong></p><p><code>keepalive</code>属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。</p><p>一个典型的场景就是，用户离开网页时，脚本向服务器提交一些用户行为的统计信息。这时，如果不用<code>keepalive</code>属性，数据可能无法发送，因为浏览器已经把页面卸载了。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">&#x27;/analytics&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&quot;statistics&quot;</span>,</span><br><span class="line">    <span class="attr">keepalive</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p><strong>redirect</strong></p><p><code>redirect</code>属性指定 HTTP 跳转的处理方法。可能的取值如下：</p><blockquote><ul><li><code>follow</code>：默认值，<code>fetch()</code>跟随 HTTP 跳转。</li><li><code>error</code>：如果发生跳转，<code>fetch()</code>就报错。</li><li><code>manual</code>：<code>fetch()</code>不跟随 HTTP 跳转，但是<code>response.url</code>属性会指向新的 URL，<code>response.redirected</code>属性会变为<code>true</code>，由开发者自己决定后续如何处理跳转。</li></ul></blockquote><p><strong>integrity</strong></p><p><code>integrity</code>属性指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。</p><p>比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;http://site.com/file&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">integrity</span>: <span class="string">&#x27;sha256-abcdef&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p><strong>referrer</strong></p><p><code>referrer</code>属性用于设定<code>fetch()</code>请求的<code>referer</code>标头。</p><p>这个属性可以为任意字符串，也可以设为空字符串（即不发送<code>referer</code>标头）。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;/page&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p><strong>referrerPolicy</strong></p><p><code>referrerPolicy</code>属性用于设定<code>Referer</code>标头的规则。可能的取值如下：</p><blockquote><ul><li><code>no-referrer-when-downgrade</code>：默认值，总是发送<code>Referer</code>标头，除非从 HTTPS 页面请求 HTTP 资源时不发送。</li><li><code>no-referrer</code>：不发送<code>Referer</code>标头。</li><li><code>origin</code>：<code>Referer</code>标头只包含域名，不包含完整的路径。</li><li><code>origin-when-cross-origin</code>：同源请求<code>Referer</code>标头包含完整的路径，跨域请求只包含域名。</li><li><code>same-origin</code>：跨域请求不发送<code>Referer</code>，同源请求发送。</li><li><code>strict-origin</code>：<code>Referer</code>标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送<code>Referer</code>标头。</li><li><code>strict-origin-when-cross-origin</code>：同源请求时<code>Referer</code>标头包含完整路径，跨域请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头。</li><li><code>unsafe-url</code>：不管什么情况，总是发送<code>Referer</code>标头。</li></ul></blockquote><h2 id="取消fetch-请求"><a href="#取消fetch-请求" class="headerlink" title="取消fetch()请求"></a>取消<code>fetch()</code>请求</h2><p><code>fetch()</code>请求发送以后，如果中途想要取消，需要使用<code>AbortController</code>对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>取消fetch()请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> abortController = <span class="keyword">new</span> AbortController();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> signal = abortController.signal; <span class="comment">// 获取取消的标识</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://www.fastmock.site/mock/d867c364f89208a7672e9e9d0a822417/qixiao/getFileDetail&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">          signal, <span class="comment">// 将该请求变成是可以取消的请求</span></span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">        abortController.abort();  <span class="comment">// 可通过注释老看是否取消了</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> result = <span class="keyword">await</span> response.json();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(result);</span></span><br><span class="line"><span class="javascript">       </span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;获取数据失败：&quot;</span>, error)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    getData();</span></span><br><span class="line"><span class="javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2021/07/30/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/11.png" class=""><p>如果我们注释掉 <code>abortController.abort();</code>就可以得到结果的。</p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>对于跨域实现起来就很方便，在配置中，添加mode： ‘no-cors’就可以跨域了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(URL, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>, </span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;no-cors&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* handle response */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><code>fetch</code>只对网络请求/无法链接报错，对<code>400</code>，<code>500</code>都当做成功的请求，需要封装去处理</li><li><code>fetch</code>默认不会带<code>cookie</code>，需要添加配置项。</li></ul><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p><code>axios</code>是基于<code>Promise</code>对原生的<code>XMLHttpRequest</code>进行了全面的封装，使用的方式也很优雅。并且也提供了在<code>node</code>环境下的支持。它本质也是对原生<code>XMLHttpRequest</code>的封装，只不过它是<code>Promise</code>的实现版本，符合最新的ES规范。</p><p>举个简单的<code>GET</code>请求的官方例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的请求也可以这样做</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>具体的学习可到  <a href="https://axios-http.com/">axios</a> ，<a href="http://axios-js.com/zh-cn/docs/index.html">axios中文文档|axios中文网</a>进行学习</p></blockquote><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul><li>从浏览器中创建<code>XMLHttpRequests</code></li><li>可在 <code>node.js</code> 中使用</li><li>支持 <code>Promise API</code></li><li>提供了并发请求的接口</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 <code>JSON</code> 数据</li><li>客户端支持防御 <code>XSRF</code></li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>只支持现代浏览器.</li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>所有的例子代码有需要的可到 <a href="https://github.com/shuliqi/howToSendHttpRequest/tree/master">howToSendHttpRequest</a>获取</p><p>参考文档:</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></p><p><a href="https://segmentfault.com/a/1190000018668190">全面分析前端的网络请求方式</a>]</p><p><a href="https://www.cnblogs.com/qianxiaox/p/13821887.html">前端http请求和常见的几个请求技术做具体的讲解</a></p><p><a href="https://cynthia0329.github.io/2019/05/24/HTTP%E7%BD%91%E7%BB%9C/%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/">前端发送http请求的几种常用方法</a></p><p><a href="https://juejin.cn/post/6844904058466074637">异步网络请求xhr、ajax、fetch与axios对比</a></p><p><a href="https://segmentfault.com/a/1190000038300383">Fetch还是Axios——哪个更适合HTTP请求？</a></p><p><a href="https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html">Fetch API 教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 实现动画边框的奇思妙想</title>
      <link href="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/"/>
      <url>/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>最近在找一些周刊文章的时候读到一篇挺有意思的文章 <a href="https://juejin.cn/post/6918921604160290830">CSS 奇思妙想边框动画</a>，经过学习之后，每实现一个效果的背后都有一些值得去复习或者是学习的知识点，觉得收获挺大。记录一下学习或者是复习到的一些知识点。</p><span id="more"></span><h1 id="思考？"><a href="#思考？" class="headerlink" title="思考？"></a>思考？</h1><p>如果我们希望实现一个有样式的边框，比如说：给边框加上一些动画，我们改如何实现呢？</p><p>既然说到边框， 我们肯定会想到 <code>border</code>。那么<code>border</code>都有哪些属性呢？那我们了可以先复习一下<code>border</code></p><h1 id="border-属性"><a href="#border-属性" class="headerlink" title="border 属性"></a>border 属性</h1><p><code>border</code> 主要有三个属性：</p><ul><li><code>border-width</code>: 设置盒子模型的边框宽度</li><li><code>border-style</code>：用来设定元素所有边框的样式</li><li><code> border-color</code>:  用于设置元素四个边框颜色的快捷属性</li></ul><p>而我们一般可以简写成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border">MDN-border 详情</a></p><p>而关于<code>border-style</code>我们常用到的可能就是<code>solid</code>，<code>dashed</code>，<code>dotted</code>。但是还有很多其他的设置， 我们来看看：</p><iframe height="300" style="width: 100%;" scrolling="no" title=" border-style" src="https://codepen.io/shuliqi/embed/wvJLdqE?defaultTab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/wvJLdqE">   border-style</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><hr><h1 id="效果1：hover边框长度变化"><a href="#效果1：hover边框长度变化" class="headerlink" title="效果1：hover边框长度变化"></a>效果1：hover边框长度变化</h1><img src="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/1.gif" class=""><p>这种效果的实现，我们的<code>border</code>属性好像实现不了， 那有没有其他的方式来实现呢？</p><p><strong>实现思路：</strong>我们有一个元素，然后生成这个元素的两个伪元素，目的是用来设置上、左边框 和 下、右边框， 鼠标hover改变伪元素长度。</p><img src="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/2.png" class=""><p>蓝色的是我们的元素，绿色和红色是两个伪元素，这两个元素的是有宽和高的。</p><p>最后我们只需要 <code>hover</code>上去的时候，改变这两个伪元素的宽和高即可。</p><iframe height="300" style="width: 100%;" scrolling="no" title="hover边框长度变化" src="https://codepen.io/shuliqi/embed/OJpegdV?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/OJpegdV">  hover边框长度变化</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><hr><h1 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h1><p>因为下面的效果会用到渐变相关的内容， 所以我们先来复习一下渐变。</p><p>浏览器支持的渐变类型三种：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/orphaned/Web/CSS/linear-gradient()">线性渐变 (linear-gradient)</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/orphaned/Web/CSS/radial-gradient()">径向渐变 (radial-gradient)</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient()">圆锥渐变(conic-gradient)</a></li></ul><p>渐变在 CSS 中属于一种 Image 类型，可以结合 background-image 属性使用。</p><p>由于篇幅有限， 我们主要讲下面特效用到的线性渐变相关的一些小知识点。</p><h2 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h2><p><strong>使用方式：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linear-gradient( angle, start-<span class="attribute">color</span>, end-<span class="attribute">color</span> )</span><br></pre></td></tr></table></figure><ul><li><code>angle</code>：是渐变的角度，可以是具体的角度（45deg），也可以是 to + 方向（to bottom right）</li><li><code> start-color</code>：是渐变的初始颜色。</li><li><code>end-color</code>：是结束的颜色。</li></ul><p>其中颜色的 <code> start-color</code> 和<code> end-color</code> 我们可以称为<strong>色标</strong>, 色标可以是多个的,只是至少两个。</p><p>例子1:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">70deg</span>, <span class="number">#077373</span>, <span class="number">#1b6708</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/4.png" class=""><p>例子2：色标可以是多个的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">70deg</span>, <span class="number">#077373</span>, yellow, red, <span class="number">#1b6708</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/5.png" class=""><p>例子3: 如果需要自定义间距，可以在色标后面接具体的位置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, <span class="number">#077373</span> <span class="number">30px</span>, red <span class="number">80%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/6.png" class=""><p><strong>特点：</strong>如果多个色标具有相同的位置，他们会产生一个无限小的过渡区域，过渡的起止色分别是第一个和最后一个指定值。从效果上看，颜色会在那个位置突然变化，而不是一个平滑的渐变过程。</p><iframe height="300" style="width: 100%;" scrolling="no" title="线性渐变特点" src="https://codepen.io/shuliqi/embed/mdWZZej?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/mdWZZej">  线性渐变特点</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><hr><h1 id="效果2：虚线边框动画"><a href="#效果2：虚线边框动画" class="headerlink" title="效果2：虚线边框动画"></a>效果2：虚线边框动画</h1><img src="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/3.gif" class=""><p>提到虚线，我们是不是就想到了 <code>border-style</code>的<code>dashed</code> 属性？</p><iframe height="300" style="width: 100%;" scrolling="no" title="border-style" src="https://codepen.io/shuliqi/embed/YzZoboY?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/YzZoboY">  border-style</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>但是存在一个问题：<code>dashed</code> 不能让边框动起来呀。所以这个方法 <code>pass</code>掉。</p><p>那有没有其他的方法呢？那当然是有的， 实现虚线的方式在<code>CSS</code>中有很多种，比如我们上面复习到的渐变。</p><p><strong>实现思路:</strong></p><ol><li>我们首先来实现一条横着的虚线，这个虚线其实就是“—”的循环，所以我们只需要实现一个“—”， 然后使用 <code>background-repea</code>t进行循环即可。</li></ol><iframe height="300" style="width: 100%;" scrolling="no" title="一条虚线" src="https://codepen.io/shuliqi/embed/OJpevXG?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/OJpevXG">  一条虚线</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>我们使用<code> linear-gradient</code>来生成一个背景图，或利用<code> linear-gradient</code>的特点</p><blockquote><p>如果多个色标具有相同的位置，他们会产生一个无限小的过渡区域，过渡的起止色分别是第一个和最后一个指定值。从效果上看，颜色会在那个位置突然变化，而不是一个平滑的渐变过程</p></blockquote><p>来生成元素的50%曲线是黑色，50%是透明的背景图。并且渐变方向是<code>90deg</code>即使左右渐变的。使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"> background-size</a>来设置背景图片的大小，背景图片宽<code>10px</code>，高<code>4px</code>。背景图的循环方式是 x 轴循环。使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position">background-position</a>来设置初始位置。</p><ol><li>有了第一条， 同理， 就可以有第二，三，四条, 然后，利用 animation 变换每条虚线边框位置，然后虚线动起来。</li></ol><iframe height="300" style="width: 100%;" scrolling="no" title="虚线动画" src="https://codepen.io/shuliqi/embed/qBrzXyW?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/qBrzXyW">  虚线动画</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>画其他虚线的时候， 需要注意的 背景图片的大小，和位置。</p><hr><h1 id="效果3：动画彩条边框"><a href="#效果3：动画彩条边框" class="headerlink" title="效果3：动画彩条边框"></a>效果3：动画彩条边框</h1><img src="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/7.gif" class=""><p>这个效果也是可以使用渐变来实现的， 我们来一步一步的实现它</p><p>首先使用伪元素和渐变实现一个如下效果：</p><iframe height="300" style="width: 100%;" scrolling="no" title="彩条框" src="https://codepen.io/shuliqi/embed/MWpMGbQ?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/MWpMGbQ">  彩条框</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>上面这个效果的重要的一点为：伪元素实现这个元素， 每一个色块都是父元素的2倍大， 再通过父级的<code>overflow: hidden</code>将超出部分隐藏</p><p>然后给色块加上动画效果，让色块动起来:</p><iframe height="300" style="width: 100%;" scrolling="no" title="动画彩条框" src="https://codepen.io/shuliqi/embed/NWpZMvg?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/NWpZMvg">  动画彩条框</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>上面代码中的 1turn：一圈，一个圆共一圈。 90deg = 0.25turn。</p><p>最后再添加一个伪元素， 将div内部部分遮住， 即可实现想要的效果，</p><iframe height="285" style="width: 100%;" scrolling="no" title="动画边框" src="https://codepen.io/shuliqi/embed/PoprRaM?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/PoprRaM">  动画边框</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><hr><h1 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h1><p>下面的效果会用到这个<code>CSS</code>属性， 我们先来了解下：</p><p>CSS 的 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path">clip-path</a> 属性是 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clip">clip</a> 属性的升级版，它们的作用都是对元素进行 “剪裁”，不同的是 clip 只能作用于 position 为 absolute 和 fixed 的元素且剪裁区域只能是正方形，而 clip-path 更加强大，可以以任意形状去裁剪元素，且对元素的定位方式没有要求。基于这样的特性，clip-path 常用于实现一些炫酷的动画效果。</p><p><strong>clip-path 的其中两大类，分别为：</strong></p><ol><li><code>basic-shape</code>：基本图形，包括<code> inset()</code>、<code>circle()</code>、<code>ellipse()</code>、<code>polygon()</code></li><li><code>clip-source</code>：通过 url() 方法引用一段 SVG 的 <clipPath> 来作为剪裁路径</li></ol><p> 我们接下来重点学习 <code>basic-shape</code></p><h2 id="inset"><a href="#inset" class="headerlink" title="inset"></a>inset</h2><p>用于定义一个插进的矩形，即剪裁元素内部的一块矩形区域。</p><p>参数类型：<code>inset( &lt;shape-arg&gt;&#123;1,4&#125; [round &lt;border-radius&gt;]? )</code></p><ul><li><code>shape-arg</code>：分别为矩形的上右下左边框到被剪裁元素边缘的距离</li></ul><img src="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/10.PNG" class=""><ul><li><code>border-radius</code>：为可选参数，用于定义 <code>border</code> 的圆角。</li></ul><p>我们举个例子：</p><iframe height="298" style="width: 100%;" scrolling="no" title="clip-path:inset" src="https://codepen.io/shuliqi/embed/ExWBGBB?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/ExWBGBB">  clip-path:inset</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>这里例子中，我们初始是没有做任何的裁剪的（clip-path: inset(0);）。当hover 上去的时候我们使用<code>inset</code>来进行一个矩形的裁剪，并且裁剪出来的是矩形是有<code>30px</code>的圆角的。</p><h2 id="ellipse"><a href="#ellipse" class="headerlink" title="ellipse"></a>ellipse</h2><p> 用于定义一个椭圆。</p><p>参数类型：<code>ellipse( [&lt;shape-radius&gt;&#123;2&#125;]? [at &lt;position&gt;]? )</code></p><ul><li><code>shape-radius</code>: 为椭圆x、y轴的半径</li><li><code>position</code>: 为椭圆中心的位置。</li></ul><p>举个例子：</p><iframe height="300" style="width: 100%;" scrolling="no" title="clip-path:ellipes" src="https://codepen.io/shuliqi/embed/poeXGvx?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/poeXGvx">  clip-path:ellipes</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><h2 id="polygon"><a href="#polygon" class="headerlink" title="polygon"></a>polygon</h2><p> 用于定义一个多边形。</p><p>参数类型：<code>polygon( [&lt;fill-rule&gt;,]? [&lt;shape-arg&gt; &lt;shape-arg&gt;]# )</code></p><ul><li>fill-rule： 可选，表示填充规则用来确定该多边形的内部。可能的值有nonzero和evenodd,默认值是nonzero</li><li>后面的每对参数表示多边形的顶点坐标（X,Y），也就是连接点</li></ul><p>举个例子:</p><iframe height="300" style="width: 100%;" scrolling="no" title="clip-path:polygon" src="https://codepen.io/shuliqi/embed/YzZoByp?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/YzZoByp">  clip-path:polygon</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><hr><h1 id="效果4：-追逐的边框"><a href="#效果4：-追逐的边框" class="headerlink" title="效果4： 追逐的边框"></a>效果4： 追逐的边框</h1><img src="/2021/06/26/CSS-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E8%BE%B9%E6%A1%86%E7%9A%84%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/8.gif" class=""><h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>根据我们上一个例子的效果，我们实现这个效果其实就很简单了， 我们只需要把：我们将 彩条边框 4个背景图变成 1 个背景图就可实现了。</p><iframe height="300" style="width: 100%;" scrolling="no" title="追逐边框" src="https://codepen.io/shuliqi/embed/wvJLjje?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/wvJLjje">  追逐边框</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p><strong>缺陷：</strong>如果是单线条，边框的末尾是一个小三角而不是垂直的，可能些      场景不适用或者 PM 接受不了</p><h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>有没有什么办法可以消除这些小三角形呢? 肯定是有的。那就是我们上面学到的 <code>clip</code>。</p><p><strong>实现思路：</strong>借用伪元素作为背景进行裁剪并动画即可</p><iframe height="350" style="width: 100%;" scrolling="no" title="clip-path: 追逐边框" src="https://codepen.io/shuliqi/embed/QWpXPBO?defaultTab=css%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shuliqi/pen/QWpXPBO">  clip-path: 追逐边框</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><p>这种方式的优点就是：切割出来的边框不会产生小三角</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目首屏加载优化</title>
      <link href="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>最近这几个月一直在开发一个使用 <code>vue-cli</code>搭建起来的项目。最近打包上线之后。发现首屏打开特别慢，在网络好的情况下大约需要4s 至 5 s。 在网络不好的情况下，还需要7s 8 s。加载的期间一直显示白屏，导致用户的体验非常不好。所以针对这个问题来做一些优化；期望的结果是首屏加载得快一点。白屏缩短。</p> <span id="more"></span><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>首先我们来看没有优化之前的耗时时间：</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/2.png" class=""><p>在网络比较好的情况下， 耗时：6.86s。 平均是 7s 左右。</p><h1 id="什么是首屏加载"><a href="#什么是首屏加载" class="headerlink" title="什么是首屏加载"></a>什么是首屏加载</h1><p>首屏时间（First Contentfull Paint）: 指的是响应用户在浏览器上输入<code>URL</code>网址， 到首屏内容渲染完后才能的一个时间。此时整个网页不一定要渲染完成，但旭要展示当前视窗需要的内容。</p><h2 id="首屏加载时间的计算"><a href="#首屏加载时间的计算" class="headerlink" title="首屏加载时间的计算"></a>首屏加载时间的计算</h2><p>可以通过<code>DOMContentLoad</code> 或者是 <code>performance</code> 来计算首屏时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windown.addEventListner(<span class="string">&quot;DOMContentLoad&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">performance.getEntriesByName(<span class="string">&quot;first-contentfull-paint&quot;</span>)[<span class="number">0</span>].startTime;</span><br><span class="line"><span class="comment">// performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0]</span></span><br><span class="line"><span class="comment">// 会返回一个 PerformancePaintTiming的实例，结构如下：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;first-contentful-paint&quot;</span>,</span><br><span class="line">  <span class="attr">entryType</span>: <span class="string">&quot;paint&quot;</span>,</span><br><span class="line">  <span class="attr">startTime</span>: <span class="number">507.80000002123415</span>,</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="加载慢的原因"><a href="#加载慢的原因" class="headerlink" title="加载慢的原因"></a>加载慢的原因</h1><p>在页面渲染的过程，导致加载速度慢的因素可能如下：</p><ul><li><p>网络请求慢</p></li><li><p>资源体积过大</p></li><li><p>重复请求资源</p></li><li><p>加载脚本堵塞了渲染</p></li></ul><h1 id="解决的办法"><a href="#解决的办法" class="headerlink" title="解决的办法"></a>解决的办法</h1><p>我们知道 <code>vue</code>， <code>react</code> 等框架都是<code>js</code> 渲染的<code>html</code>。是典型的单页应用，首次加载耗时多，因此优化<code>Vue</code>项目首屏加载对于提升用户体验非常重要。所以必须要等到这个<code>js</code>文件加载完成后界面才会显示。</p><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">[Vue Router路由懒加载]</a></p><p><code>vue-router</code>实现路由懒加载的方法有哪些？首先我们先来看<code>vue-router</code>的一些官方解释</p><h3 id="什么是路由懒加载？"><a href="#什么是路由懒加载？" class="headerlink" title="什么是路由懒加载？"></a>什么是路由懒加载？</h3><blockquote><p>也叫延迟加载，即在需要的时候进行加载，随用随载。</p></blockquote><h3 id="为什么需要懒加载呢？"><a href="#为什么需要懒加载呢？" class="headerlink" title="为什么需要懒加载呢？"></a>为什么需要懒加载呢？</h3><ul><li>首先，我们知道路由中通常会定义很多不同的页面。</li><li>这个页面这项目build打包后，一般情况下，会放在一个单独的js文件中</li><li>但是，如果很多的页面都放在同一个js文件中，必然会造成这个页面非常大</li><li>如果我们一次性的从服务器中请求下来这个页面，可能会花费一定时间，用户体验不好</li></ul><p>在我们的vue 项目中：</p><ul><li><p>像vue这种单页面应用，如果没有应用懒加载，运用<code>webpack</code>打包后的文件将会异常的大。</p></li><li><p>造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了<code>loading</code>也是不利于用户体验。</p></li><li><p>而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时</p></li></ul><p>总的来说：进入页面不用也不需要一次性加载过多资源造成加载时间过程！</p><h3 id="路由懒加载的原理"><a href="#路由懒加载的原理" class="headerlink" title="路由懒加载的原理"></a>路由懒加载的原理</h3><ul><li><p>主要作用是将路由对应的组件打包成一个个的js代码块</p></li><li><p>只有在这个路由被访问到的时候，才加载对应的组件，否则不加载！</p></li></ul><p>总结的来说：只有在这个路由被访问到的时候，才加载对应的组件，否则不加载！</p><p>路由懒加载，在访问到当前页面才会加载相关的资源，异步方式分模块加载文件</p><h3 id="如何实现路由懒加载？"><a href="#如何实现路由懒加载？" class="headerlink" title="如何实现路由懒加载？"></a>如何实现路由懒加载？</h3><ul><li><code>Vue</code>异步组件</li><li><code>ES6</code>标准语法<code>import（）</code>———推荐使用</li><li><code>webpac</code>k的<code>require</code>，<code>ensure()</code></li></ul><p>我们使用<code>ES6</code>标准语法<code>import（）</code>来实现懒加载</p><p>没有用到路由加载懒加载之前是这么写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> page404 <span class="keyword">from</span> <span class="string">&quot;@/views/error/page404.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/page404&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;page404&quot;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;404&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">      <span class="attr">slideMenu</span>: slideMenu,</span><br><span class="line">      <span class="attr">topBar</span>: topBar,</span><br><span class="line">      <span class="attr">content</span>: page404</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes;</span><br></pre></td></tr></table></figure><p>使用路由懒加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page404 = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/error/page404.vue&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h2><p>我们先看打包之后下面的img 的图片的大小：</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/7.png" class=""><p>总的5.6M。 有点大</p><p>我们使用 <code>vue inspect &gt; output.js</code>导出<code> vue-cli</code> 做的的默认<code>webpoack</code>配置：</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/8.png" class=""><p>发现对于图片， 只用到了 url-loader 。 相对一些比较大的图片。是可以进行压缩的。可以使用 <a href="https://www.npmjs.com/package/image-webpack-loader">image-webpack-loader</a></p><p>我们在 <code>vue-config.js</code>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chainWebpack = <span class="function"><span class="keyword">function</span> <span class="title">chainWebpacks</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config.module</span><br><span class="line">    .rule(<span class="string">&quot;images&quot;</span>)</span><br><span class="line">    .use(<span class="string">&quot;image-webpack-loader&quot;</span>)</span><br><span class="line">    .loader(<span class="string">&quot;image-webpack-loader&quot;</span>)</span><br><span class="line">    .options(&#123;</span><br><span class="line">      <span class="attr">bypassOnDebug</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .end();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再进行<code>npm run build</code>打包在看看<code>img</code>:</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/9.png" class=""><p>图片的大小从 5.8M 变到了 1.8M。 感觉效果还是明显的。</p><p>经过上面这两步优化，我们再看来首屏加载的时间：</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/18.png" class=""><p>首页加载的数据的耗时明显减少了大概 1/2 时间， 棒棒哒</p><h2 id="gzip-压缩"><a href="#gzip-压缩" class="headerlink" title="gzip 压缩"></a>gzip 压缩</h2><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/11.png" class=""><p>从上面我们可以看出:<code>vendor-chunks.js</code> 很大。当我们的项部署了之后， 我们的资源文件请求会保持原来的大小。如果文件过大，并且很多的情况下，会导致网络请求耗时。严重点可能会阻塞后面的进程。针对这样的情况， 我们有没有什么比较好的解决方法呢?  有的， 那就进行 <code>gzip</code>压缩。</p><p><code>gzip</code>压缩有两种方式：</p><ul><li>服务器压缩文件</li><li>前端 webpack 打包生成 gz 文件</li></ul><p>那我们先来看看这两种方式：</p><h3 id="服务器压缩文件"><a href="#服务器压缩文件" class="headerlink" title="服务器压缩文件"></a>服务器压缩文件</h3><p>这种方式是浏览器请求文件时，服务器对该文件进行压缩后传输给浏览器。前端不用做任何的配置，不需要 <code>webpack</code>生成 <code>.gz</code>文件。而是服务器自己处理。就拿 <a href="https://zh.wikipedia.org/wiki/Nginx">Nginx</a> 来举例，我么打开 nginx.conf 文件， 会有默认配置，默认的   <code>#gzip  on;</code>即不打开。</p><p><strong>nginx 文件结构</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...              <span class="comment"># 全局块</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;         <span class="comment"># events块</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">http</span>      <span class="comment"># http块</span></span><br><span class="line">&#123;</span><br><span class="line">    ...   <span class="comment"># http全局块</span></span><br><span class="line">    <span class="attribute">server</span>        <span class="comment"># server块</span></span><br><span class="line">    &#123; </span><br><span class="line">        ...       <span class="comment"># server全局块</span></span><br><span class="line">        <span class="attribute">location</span> [PATTERN]   <span class="comment"># location块</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span></span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     <span class="comment"># http全局块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 http 块这里开启 <code>gzip</code>和相关的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"> <span class="comment"># ... 已省略</span></span><br><span class="line">   <span class="comment"># 开启gzip</span></span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置缓冲区大小</span></span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#压缩级别官网建议是6</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#压缩的类型</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ... 已省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方案的特点：使用<code>nginx</code>在线<code>gzip</code>，缺点就是耗性能，需要实时压缩，但是<code>vue</code>打包后的文件体积小。</p><h3 id="前端-webpack-打包生成-gz-文件"><a href="#前端-webpack-打包生成-gz-文件" class="headerlink" title="前端 webpack 打包生成 gz 文件"></a>前端 webpack 打包生成 gz 文件</h3><p>这次优化主要是采用这种方式。</p><p>这种方式是打包的时候通过 <code>webpack</code>配置生成对应的<code>.gz</code>文件，浏览器请求文件时，服务器返回相应的的文件的 <code>.gz </code>文件。</p><p>安装 <code>compression-webpack-plugin</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i compression-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>然后再<code>vue.config.js</code>中设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> productionGzipExtensions = <span class="regexp">/\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i</span>;</span><br><span class="line"><span class="comment">// ... 已省略</span></span><br><span class="line">plugins: [</span><br><span class="line">     <span class="comment">// ... 已省略</span></span><br><span class="line">      <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">        <span class="attr">test</span>: productionGzipExtensions, <span class="comment">// 所有匹配此&#123;RegExp&#125;的资产都会被处理</span></span><br><span class="line">        <span class="attr">threshold</span>: <span class="number">512</span>, <span class="comment">// 只处理大于此大小的资产。以字节为单位</span></span><br><span class="line">        <span class="attr">minRatio</span>: <span class="number">0.8</span>, <span class="comment">// 只有压缩好这个比率的资产才能被处理</span></span><br><span class="line">        <span class="attr">deleteOriginalAssets</span>: <span class="literal">false</span> <span class="comment">// 是否删除未压缩的源文件，谨慎设置，如果希望提供非gzip的资源，可不设置或者设置为false（比如删除打包后的gz后还可以加载到原始资源文件）</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p> 启用gzip压缩打包之后，会变成下面这样，自动生成<code>gz</code>包。目前大部分主流浏览器客户端都是支持gzip的，就算小部分非主流浏览器不支持也不用担心，不支持gzip格式文件的会默认访问源文件的，所以不要配置清除源文件。所以这时候打包的总体积会变大， 是因为我们没有删除源文件。是为了防止有些浏览器不支持的时候能返回源文件。</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/10.png" class=""><p>上面<code>test</code>匹配的压缩文件类型， 并没有对图片进行压缩，因为图片压缩并不能实际减少文件大小，反而会导致打包后生成很多同大小的gz文件，得不偿失。</p><p>这种方式是浏览器在请求资源时，服务器返回相应的 <code>.gz</code> 文件。 所以需要在服务器配置一个属性， 期望它能够正常返回我们需要的<code>.gz</code>文件</p><p><code>ginx</code>举例（<code>nginx.conf</code>文件）:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="comment"># ...已省略</span></span><br><span class="line">  <span class="comment"># 静态加载本地的gz文件。</span></span><br><span class="line">  <span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>gzip_static on</code>这个属性是静态加载本地的gz文件</p><p>我们先来看采用这种方法前的请求的<code>chunk-vendors.js</code>的大小：</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/11.png" class=""><p>我们可以看到请求的这个文件大小有 5.4 MB。</p><p>我们采用<code>gzip</code>压缩之后，请求该文件的大小：</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/12.png" class=""><p>可以看出来，请求文件的大小从 5.4MB 变成了 854KB。 而首页的加载时间较少的幅度不是很大， 但也是减少了。</p><p>nginx配置了静态gz加载后，浏览器也返回的是gz文件，这样就会请求小文件而不会导致请求卡线程，并且，因为保留了源文件，所以当我们删除gz后，浏览器会自动去请求原始文件，而不会导致界面出现任何问题</p><p> 静态加载gz文件主要是依托于下面的请求头：</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/13.png" class=""><p>这种优化的主要特点：<code> webpack</code>打包，然后直接使用静态的<code>gz</code>，缺点就是打包后文件体积太大，但是不耗服务器性能。</p><h2 id="Webpack打包体积优化"><a href="#Webpack打包体积优化" class="headerlink" title="Webpack打包体积优化"></a>Webpack打包体积优化</h2><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/14.png" class=""><p>从图上我们发现首屏加载过程中总公发起了149次请求。这显然是不友好的。那我们可以考虑考虑减少首屏加载的请求次数。</p><p>减少首屏加载请求次数可以从下面这个方面入手：</p><ul><li>使用<code>splitChunks</code>分离代码并实现相关模块共享，最终的目的就是减少请求资源的大小和请求次数</li></ul><h3 id="splitChunks"><a href="#splitChunks" class="headerlink" title="splitChunks"></a>splitChunks</h3><p>SplitChunks插件是什么呢，简单的来说就是Webpack中一个提取或分离代码的插件，主要作用是提取公共代码，防止代码被重复打包，拆分过大的js文件，合并零散的js文件。  在Webpack出现前，提取公共代码是人为去处理，而SplitChunks插件的作用就是通过配置让Webpack去帮你提取公共代码</p><p>用SplitChunks插件来控制Webpack打包生成的js文件的内容的精髓就在于，防止模块被重复打包，拆分过大的js文件，合并零散的js文件。 最终的目的就是减少请求资源的大小和请求次数</p><p>我们先来看<code>splitChunks</code>的一下字段说明吧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="comment">// 表示选择哪些 chunks 进行分割，可选值有：async，initial和all, 默认：async</span></span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。</span></span><br><span class="line">      <span class="attr">minSize</span>: <span class="number">3000</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。</span></span><br><span class="line">      <span class="attr">minChunks</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 表示按需加载文件时，并行请求的最大数目。默认为5。</span></span><br><span class="line">      <span class="attr">maxAsyncRequests</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 表示加载入口文件时，并行请求的最大数目。默认为3。</span></span><br><span class="line">      <span class="attr">maxInitialRequests</span>: <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// // 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js</span></span><br><span class="line">      <span class="attr">automaticNameDelimiter</span>: <span class="string">&quot;~&quot;</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// // 设置chunk的文件名。默认为true。当为true时，splitChunks基于chunk和cacheGroups的key自动命名。</span></span><br><span class="line">      <span class="comment">// name: true,</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 缓存组： cacheGroups 的配置项跟 splitChunks是一样的， 但是它自己有几个自己的配置项</span></span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="attr">vender</span>: &#123;</span><br><span class="line">          <span class="comment">// 优先级：数字越大优先级越高，因为默认值为0，所以自定义的一般是负数形式</span></span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">          <span class="comment">// test:可以是一个函数也可以是一个正则，函数的返回值是：boolean RegExp string，通过返回值或者正则来进行匹配。</span></span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="comment">// type: &quot;json&quot;,</span></span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">           <span class="comment">// 这个的作用是当前的chunk如果包含了从main里面分离出来的模块，则重用这个模块，这样的问题是会影响chunk的名称。</span></span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="splitChunks优化"><a href="#splitChunks优化" class="headerlink" title="splitChunks优化"></a>splitChunks优化</h3><p>使用<a href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a> 进行体积分析。该插件可生成依赖包形成可视化分析图谱，帮组开发者分析项目结构</p><p>安装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure><p>将插件添加到<code>webpack</code>中，因为使用的是vue-cli，所以应在<code>vue.config.js</code>中添加配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DEV = process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chainWebpack = <span class="function"><span class="keyword">function</span> <span class="title">chainWebpacks</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (DEV) &#123;</span><br><span class="line">    <span class="comment">// 开发环境使用</span></span><br><span class="line">    config.plugin(<span class="string">&quot;compressionPlugin&quot;</span>)</span><br><span class="line">      .use(<span class="keyword">new</span> BundleAnalyzerPlugin())</span><br><span class="line">      .end();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行<code>npm run build</code>生成分析页面</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/15.png" class=""><p>从分析页面可以看出 <code>chunk-vendor</code>很大。因为这个<code>chunk</code>是项目所有的依赖库，从它是打包了<code>node_modules</code>可以看出，所以很影响性能。从图中发现<code>monaco-editor</code> 在线编辑器占了很大体积。 我们可以把它抽离出来。因为用的地方太多了， 导致很难做成按需加载了的了。</p><p>在<code>vue.config.js</code>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">config.optimization.splitChunks(&#123;</span><br><span class="line">  <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">    <span class="attr">common</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;chunk-common&quot;</span>,</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">      <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">maxInitialRequests</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">minSize</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">priority</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">vendors</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;chunk-vendors&quot;</span>,</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">      chunks: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">      <span class="attr">priority</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">enforce</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 增加一个echarts cacheGroup</span></span><br><span class="line">    <span class="attr">echarts</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;chunk-echarts&quot;</span>,</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]echarts[\\/]/</span>,</span><br><span class="line">      priority: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">      <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">enforce</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 增加一个monacoEditor cacheGroup</span></span><br><span class="line">    <span class="attr">monacoEditor</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;chunk-monaco-editor&quot;</span>,</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]monaco-editor[\\/]/</span>,</span><br><span class="line">      chunks: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">      <span class="attr">priority</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">enforce</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们再来看下分析图：</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/16.png" class=""><p>可以看出<code>monaco-editor</code>和<code>echarts</code>被单独打包了。</p><p>现在我们来看最终的结果：</p><img src="/2021/06/21/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/17.png" class=""><p>请求次数从 149 减到了  115 次。可观的是首页加载耗时减到了 1.74s。 平均值大概 1.5 s。 表示还是可观的。</p><p>注意： <code>SplitChunks</code>插件对代码作更细致的拆分 需要注意的减少请求数必然使得单个文件体积变大,二者是矛盾的,最佳实践是取得一个中庸的值平衡优劣.</p><h1 id="时间轴回放"><a href="#时间轴回放" class="headerlink" title="时间轴回放"></a>时间轴回放</h1><table><thead><tr><th>优化方法</th><th>请求数量</th><th>耗时时间</th></tr></thead><tbody><tr><td>未做任何优化</td><td>149次</td><td>6.86s</td></tr><tr><td>路由懒加载+压缩图片</td><td>149次</td><td>4.26s</td></tr><tr><td>splitChunks分离代码</td><td>115次</td><td>1.74s</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3.0新特性之Composition API</title>
      <link href="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/"/>
      <url>/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/</url>
      
        <content type="html"><![CDATA[<p><code>Vue3.0</code>发布了很多新的特性和一些语法上的变更。其中    <code>Composition API</code>是<code>Vue3.0</code>版本中主要特色语法，这是一个全新的逻辑重用和代码组织的方法。这边文章就带你看看为啥会有<code>Composition API</code>以及如何使用<code>Composition API</code></p> <span id="more"></span><h1 id="Option-API-和-Composition-API-的比较"><a href="#Option-API-和-Composition-API-的比较" class="headerlink" title="Option API 和 Composition API 的比较"></a>Option API 和 Composition API 的比较</h1><p>我们知道<code>Vue2.0</code>（选项）所有数据都定义在<code>data</code>中，方法定义在<code>methods</code>中。所以给组件添加逻辑， 我们可能需要填充（选项）属性<code>data</code>, <code>methods</code>,<code>computed</code>等。但是<code>Vue3.0</code>我们可以不这么写了。具体怎么写， 我们先看看<code>Vue2.0</code>的写法有什么缺陷。</p><h2 id="Option-API"><a href="#Option-API" class="headerlink" title="Option API"></a>Option API</h2><p>使用<code>Vue2.0</code>的<code>option API</code>实现如下功能：</p><iframe height="691" style="width: 100%;" scrolling="no" title="option api" src="https://codepen.io/shuliqi/embed/rNjPvPg?height=691&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/rNjPvPg'>option api</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>我们实现一个加减法，之后数值显示出来，就需要分别在<code>data</code>,<code>computed</code>,<code>methods</code>添加代码，如果还有其他功能，可能还得在生命周期选项等添加代码。那如果需要添加其他的需求。我们的代码结构可能就变成这样了：</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/1.png" class=""><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><p>在<code>Vue3.0</code>中， 我们可以使用<code>Composition API</code>的方式来实现：</p><iframe height="717" style="width: 100%;" scrolling="no" title="vue3.0" src="https://codepen.io/shuliqi/embed/yLgwLwX?height=717&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/yLgwLwX'>vue3.0</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>代码按照逻辑（<code>Composition API</code>的方式来实现）来分割，上面的图变成下面的图（相同业务逻辑的代码颜色），是不是就清晰了？</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/2.png" class=""><p>可以看的出来： <code>Option API</code>相同业务的代码分散在各处，这样后期维护起来就很麻烦。而<code>Composition API</code>就解决了这个问题。那么下面就来讲解<code>Composition API</code>怎么使用。</p><h1 id="Composition-API-的入口及API"><a href="#Composition-API-的入口及API" class="headerlink" title="Composition API 的入口及API"></a>Composition API 的入口及API</h1><p>关于<code>Composition API</code>有哪些<code>API</code>呢？ 先总结一下：</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/3.png" class=""><p>下面根据这些知识点分别来讲解。</p><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p><code>setup</code>功能是新的组件选项，是<code>Composition API</code>使用的入口。</p><h3 id="执行的的时机"><a href="#执行的的时机" class="headerlink" title="执行的的时机"></a>执行的的时机</h3><p><code>setup</code>是在创建<code>vue</code>组件实例并完成<code>props</code>的初始化之后执行（在<code>beforeCreate</code>钩子之前执行）。这就直接限制了在<code>setup</code>中无法使用其他的选项(<code>option</code>)中的数据；如：<code>data</code>,<code>methods</code>，<code>computed</code>等。 但是其他的选项(<code>option</code>)可以使用<code>setup</code>中返回的变量。</p><blockquote><p>由于在执行 <code>setup</code>函数的时候，还没有执行 <code>Created </code>生命周期方法，所以在 <code>setup</code> 函数中，无法使用 <code>data </code>和 <code>methods</code> 的变量和方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  beforeCreate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;------beforeCreate------&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;------created------&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;------setup------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果为：</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/8.png" class=""><h3 id="setup中的上下文"><a href="#setup中的上下文" class="headerlink" title="setup中的上下文"></a>setup中的上下文</h3><p><code>setup</code>中是没有<code>this</code>上下文的.为什么呢？ <code>javascript</code>函数中都是应该有<code>this</code>。但是由于 <strong>执行的的时机</strong>的原因，<code>setup</code>中的<code>this</code> 与<code>Vue2.x</code>中的<code>this</code> 已经不是一个东西了。所以为了防止错误的使用，直接将<code>this</code>改成了 <code>undefined</code>。</p><blockquote><p>由于我们不能在 <code>setup</code>函数中使用<code>data</code>和 <code>methods</code>，所以 Vue 为了避免我们错误的使用，直接将 <code>setup</code>函数中的<code>this</code>修改成了 <code>undefined</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this&quot;</span>, <span class="built_in">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与模板的使用"><a href="#与模板的使用" class="headerlink" title="与模板的使用"></a>与模板的使用</h3><p><code>setup</code>如果返回的是一个对象的话，那么这个对象的所有属性会合并到<code>template</code>的渲染上下文中（也就是说可以在<code>template</code>中使用<code>setup</code>的返回的对象的属性）。</p><iframe height="563" style="width: 100%;" scrolling="no" title="setup 与模板一起使用" src="https://codepen.io/shuliqi/embed/yLgwJZb?height=563&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/yLgwJZb'>setup 与模板一起使用</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>在<code>template</code>中，<code>vue</code>已经帮我们自动获取<code>value</code>属性， 所有我们只需要<code>&#123;&#123; people.name &#125;&#125;</code>,<code>&#123;&#123; people.age &#125;&#125;</code>,<code>&#123;&#123; sex &#125;&#125;</code></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>setup</code>是一个函数，它接受两个参数：<code>props</code>，<code>context</code></p><p>下面我们一个具体的例子项目来讲解。假如我们有这样的项目：</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/4.png" class=""><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p><code>props</code>是父组件传给子组件或者<code>vue-router</code>传给页面的参数。<code>setup</code>中的<code>props</code> 是响应式，当传入新的<code>props</code>，就会被更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props): <span class="comment">// &#123; name, age &#125;</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意： 因为<code>props</code>是响应式的， 所以不能使用<code>ES6</code>解构，如果这样做将会失去响应性。</p></blockquote><p>如果需要<code>ES6</code>解构并且需要数据的响应性的的话， 可以使用<code>toRefs</code>来完成。下面也会讲到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = toRefs(props);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p><code>context</code>是一个<code>javascript</code>对象，它暴露了3 个<code>property</code>：<code>attrs</code>、<code>slot</code> 和<code>emit</code>。分别对应<code>Vue2.x</code>的<code>$attr</code>属性、<code>slot</code>插槽 和<code>$emit</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  &#123;</span><br><span class="line">  <span class="attr">emits</span>: [<span class="string">&quot;updateName&quot;</span>],</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, &#123; emit &#125;</span>)</span> &#123;</span><br><span class="line">   emit(<span class="string">&quot;updateName&quot;</span>, <span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>props</code> 和 <code>context</code>具体的代码如下：</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/5.png" class=""><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><code>ref</code> 函数接受一个值，用于初始化的值，然后返回一个响应式且可修改的<code>ref</code>对象。该对象有一个<code>value</code>属性。<code>valus</code>保存<code>ref</code>对象的值。所以修改变量的话需要修改变量的<code>value</code>值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125;  <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ref 函数返回一个响应式</span></span><br><span class="line">    <span class="keyword">const</span> sex = ref(<span class="string">&quot;女&quot;</span>);    <span class="comment">// &#123; value: &quot;女&quot;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sex&quot;</span>, sex); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isOk = ref(<span class="literal">false</span>);  <span class="comment">// &#123; value:  false &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;isOk&quot;</span>, isOk); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tag = ref(<span class="literal">null</span>);    <span class="comment">// &#123; value: null &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;tag&quot;</span>, tag); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> people = ref(&#123;      <span class="comment">// &#123; value: &#123; name: &quot;shuliqi&quot;, age: 12 &#125;&#125;</span></span><br><span class="line">      <span class="attr">name</span>:  <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;people&quot;</span>, people); </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改变量需要修改对象的value值</span></span><br><span class="line">        people.value.name = <span class="string">&quot;zhangdada&quot;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;更新后的people&quot;</span>, people)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看这段代码打印的结果:</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/6.png" class=""><p>说明:</p><ul><li>使用<code>ref</code>初始化的变量都是一个对象（<code>ref</code> 函数接受一个值，用于初始化的值，然后返回一个响应式且可修改的<code>ref</code>对象）。<code>valus</code>保存<code>ref</code>对象的值。</li><li>在<code>setTimeout</code>时候， 想要修改<code>people</code>这个响应式对象的值，则需要通过赋值操作<code> people.value.name = &quot;zhangdada&quot;</code>来实现。</li></ul><p>再继续看视图页面</p><iframe height="643" style="width: 100%;" scrolling="no" title="ref" src="https://codepen.io/shuliqi/embed/yLgwJZb?height=643&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/yLgwJZb'>ref</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe>## reactive<p><code>reactive</code> 和<code>ref</code> 很相似。 也是一个函数，但是只接受一个对象。并返回一个对这个对象的响应式代理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs &#125;  <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 reactive 初始化一个变量</span></span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">      <span class="attr">sex</span>: <span class="string">&quot;女&quot;</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// reactive 中的变量 的取值和赋值不需要 取其 value 属性</span></span><br><span class="line">        state.name = <span class="string">&quot;更改之后的名字&quot;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;更新后的state的name值&quot;</span>, state.name)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  &#123;</span><br><span class="line">      <span class="comment">// ...state  会失去响应性</span></span><br><span class="line">      ...toRefs(state) <span class="comment">// 会保留响应性</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们看打印的结果：</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/7.png" class=""><p>再看看<code>template</code>中的使用：</p><iframe height="732" style="width: 100%;" scrolling="no" title="reactive" src="https://codepen.io/shuliqi/embed/oNBVaPZ?height=732&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/oNBVaPZ'>reactive</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>最后可得出结论：</p><ul><li><code>reactive</code>函数返回一个对这个对象的响应式代理</li><li><code>reactive</code> 可以将零散的变量聚焦在一个对象</li><li><code>reactive</code>中的变量的取值和赋值不需要取其 <code>value</code>值</li></ul><p><strong>注意的点：</strong>使用<code>reactive</code>时记得使用<code>toRefs</code>保证<code>reactive</code>对象属性保持响应性。</p><h2 id="isRef"><a href="#isRef" class="headerlink" title="isRef"></a>isRef</h2><p><code>isRef</code>用于判断变量是为<code>ref</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive, isRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup ()&#123;</span><br><span class="line">    <span class="keyword">const</span> name = ref(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> people = reactive(&#123;</span><br><span class="line">      <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">      <span class="attr">sex</span>: <span class="string">&quot;女&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(isRef(name)); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(isRef(name) ? name.value : name); <span class="comment">// shuliqi</span></span><br><span class="line">    <span class="built_in">console</span>.log(isRef(people)) <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(isRef(people) ? people.value.age : people.age) <span class="comment">// 12</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h2><p><code>toRefs</code> 用于将一个<code>reactive</code>对象转化为属性为<code>ref</code>对象的普通对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup ()&#123;</span><br><span class="line">    <span class="keyword">const</span> people = reactive(&#123;</span><br><span class="line">      <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">      <span class="attr">sex</span>: <span class="string">&quot;女&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> &#123; age, sex &#125; = toRefs(people);</span><br><span class="line">    <span class="built_in">console</span>.log(isRef(age), isRef(sex)) <span class="comment">// true true</span></span><br><span class="line">    <span class="built_in">console</span>.log(age.value, sex.value) <span class="comment">// 12 shuliqi</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p><code>watch</code>与选项式<code>API</code>（this.$watch/<code>watch</code>选项）完全等效的。<code>watch</code>需要监听特定的<code>data</code>数据源，并且在单独的回调函数中副作用。默认的情况下，是惰性的，也就是说回调函数仅在监听源数据发生变更时才会回调。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch(source, callback, [options])</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>source:</code>要监听的响应式变量。支持<code>String</code>,<code>Object</code>,<code>Function</code>, <code>Array</code>。</li><li><code>callback</code>： 要执行的回调函数。回调函数的第一个参数是监听的数据更新后的值， 第二个参数之前监听的数据之前得值。</li><li><code>options</code>: 支持deep、immediate 和 flush 选项。<ul><li>当我们监听复杂的嵌套数据对象的时候，需要传入第三个参数的<code>deep:true</code>。这个参数的意思是进行深拷贝，目的是为了真正的监听复杂数据对象</li><li>希望<code>watch</code> 不是惰性的（立即执行回调函数）可以设置<code>immediate: true</code></li></ul></li></ul><h3 id="监听ref定义的数据"><a href="#监听ref定义的数据" class="headerlink" title="监听ref定义的数据"></a>监听<code>ref</code>定义的数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> name = ref(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      name.value = <span class="string">&quot;张大大&quot;</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    watch(name, <span class="function">(<span class="params">newName,oldName</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;发生了变化：&quot;</span>, <span class="string">&quot;newName:&quot;</span>, newName, <span class="string">&quot;oldName:&quot;</span>, oldName )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发生了变化： newName: 张大大 oldName: shuliqi</span></span><br></pre></td></tr></table></figure><h3 id="监听reactive定义的数据"><a href="#监听reactive定义的数据" class="headerlink" title="监听reactive定义的数据"></a>监听<code>reactive</code>定义的数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; watch, reactive&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="comment">// 监听`reactive`定义的数据</span></span><br><span class="line">    <span class="keyword">const</span>  obj = reactive(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      obj.name = <span class="string">&quot;张大大&quot;</span></span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">    watch(<span class="function">() =&gt;</span> obj.name, <span class="function">(<span class="params">newName,oldName</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;发生了变化：&quot;</span>, <span class="string">&quot;newName:&quot;</span>, newName, <span class="string">&quot;oldName:&quot;</span>, oldName)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发生了变化： newName: 张大大 oldName: shuliqi</span></span><br></pre></td></tr></table></figure><h3 id="监听多个数据"><a href="#监听多个数据" class="headerlink" title="监听多个数据"></a>监听多个数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="comment">// 监听多个数据源</span></span><br><span class="line">    <span class="keyword">const</span> age = ref(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">const</span> sex = ref(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      sex.value = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    watch([age, sex], <span class="function">(<span class="params">newName,oldName</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;发生了变化：&quot;</span>, <span class="string">&quot;newName&quot;</span>, newName, <span class="string">&quot;oldName&quot;</span>, oldName)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听复杂的嵌套数据"><a href="#监听复杂的嵌套数据" class="headerlink" title="监听复杂的嵌套数据"></a>监听复杂的嵌套数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch, reactive&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="comment">// 监听复杂的嵌套数据</span></span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      <span class="attr">total</span>: <span class="number">12</span>,</span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">titile</span>: <span class="string">&quot;标题&quot;</span>,</span><br><span class="line">        <span class="attr">result</span>: &#123;</span><br><span class="line">          <span class="attr">nane</span>: <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">          <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      state.data.result.name = <span class="string">&quot;张大大&quot;</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">    watch(<span class="function">() =&gt;</span> state.data, <span class="function">(<span class="params">newName,oldName</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;发生了变化：&quot;</span>, <span class="string">&quot;newName:&quot;</span>, newName, <span class="string">&quot;oldName:&quot;</span>, oldName)</span><br><span class="line">    &#125;,  &#123;</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当我们监听复杂的嵌套数据对象的时候，需要传入第三个参数的<code>deep:true</code>。这个参数的意思是进行深拷贝，目的是为了真正的监听复杂数据对象。</p><h3 id="设置watch为立即执行"><a href="#设置watch为立即执行" class="headerlink" title="设置watch为立即执行"></a>设置<code>watch</code>为立即执行</h3><p>设置<code>watch</code>的第三个参数：<code>immediate： true</code>。 则<code>watch</code>不是惰性的，即立即执行回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> &#123; watch, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>; </span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup () &#123;</span><br><span class="line">      <span class="comment">// 设置`watch`为立即执行</span></span><br><span class="line">      <span class="keyword">const</span>  sex = ref(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">      watch(sex, <span class="function">(<span class="params">newName, oldName</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我不是惰性的：&quot;</span>, <span class="string">&quot;newName:&quot;</span>, newName, <span class="string">&quot;oldName:&quot;</span>, oldName)</span><br><span class="line">      &#125;, &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 我不是惰性的： newName: 女 oldName: undefined</span></span><br></pre></td></tr></table></figure><h3 id="停止监听"><a href="#停止监听" class="headerlink" title="停止监听"></a>停止监听</h3><p>组件中创建的<code>watch</code>监听，会在组件被销毁的时候自动停止，如果在组件销毁之前我们想停止某个监听，可以调用<code>watch()</code>函数的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="comment">// 停止监听示例</span></span><br><span class="line">    <span class="keyword">const</span> age = ref(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">const</span> stop = watch(age, <span class="function">(<span class="params">newName, oldName</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;我不是惰性的：&quot;</span>, <span class="string">&quot;newName:&quot;</span>, newName, <span class="string">&quot;oldName:&quot;</span>, oldName)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 停止监听</span></span><br><span class="line">    stop();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      age.value = <span class="number">27</span>;</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果： 不会监听到变化了</p><h3 id="不能监听非响应式的值"><a href="#不能监听非响应式的值" class="headerlink" title="不能监听非响应式的值"></a>不能监听非响应式的值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能监听非响应式的值</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  age++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;改变值&quot;</span>, age);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">watch(<span class="function">() =&gt;</span> age, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;asdas&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 改变值 1</span></span><br></pre></td></tr></table></figure><h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h2><p><code>watchEffect</code>和<code>watch</code>类似，不过<code>watchEffect</code>函数会自动收集依赖。 只需要指定一个回调函数。在组件初始化的时候，会先执行一次手机依赖。然后当收集到的依赖中数据发生变化时，会再次执行回调函数。有以下特点：</p><ul><li><code>watchEffect</code>不需要手动传入依赖（不需要手动传入需要监听的值）；</li><li><code>watchEffect</code>会先执行一次用来自动收集依赖;</li><li><code>watchEffect</code>无法获取到变化前的值，只能获取到变化后的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> name = ref(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> age = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      name.value = <span class="string">&quot;张大大&quot;</span>;</span><br><span class="line">      age.value = <span class="number">20</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;name值：&quot;</span>, name.value, <span class="string">&quot;age值：&quot;</span>, age.value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name值： shuliqi age值： 0</span></span><br><span class="line"><span class="comment">// watchEffect.vue?25bf:15 name值： 张大大 age值： 20</span></span><br></pre></td></tr></table></figure><p>结果可以看出来：组件初始化的时候先执行一次回调函数，收集依赖。1秒之后，依赖发生变化。回调函数会再次被调用。</p><h3 id="停止监听-1"><a href="#停止监听-1" class="headerlink" title="停止监听"></a>停止监听</h3><p>跟<code>watch</code>的停止监听一样。组件中创建的<code>watchEffect</code>监听，会在组件被销毁的时候自动停止，如果在组件销毁之前我们想停止某个监听，可以调用<code>watchEffect()</code>函数的返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> name = ref(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> age = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      name.value = <span class="string">&quot;张大大&quot;</span>;</span><br><span class="line">      age.value = <span class="number">20</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">const</span> stop = watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;name值：&quot;</span>, name.value, <span class="string">&quot;age值：&quot;</span>, age.value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 停止监听</span></span><br><span class="line">    stop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name值： shuliqi age值： 0</span></span><br></pre></td></tr></table></figure><p>回调函数只会在组件初始化的时候回调一次。因为停止了监听<code>stop();</code>所以依赖发生了变化也不会再触发回调了。</p><h3 id="不能监听非响应式的值-1"><a href="#不能监听非响应式的值-1" class="headerlink" title="不能监听非响应式的值"></a>不能监听非响应式的值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 不能监听非响应式的值</span></span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    age++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;改变值&quot;</span>, age);</span><br><span class="line"></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  watchEffect(<span class="function">() =&gt;</span> age, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;asdas&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改变值 1</span></span><br></pre></td></tr></table></figure><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p><code>computed</code>函数与<code>Vue.x</code>的中的<code>computed</code>功能一样。<code>computed</code>接受一个函数并返回一个<code>value</code>值为<code>getter</code>返回值不可改变的响应式<code>ref</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed, isRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> age = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// computed函数的返回值是响应式的ref对象</span></span><br><span class="line">    <span class="keyword">const</span> myComputedAge = computed(<span class="function">() =&gt;</span> age.value + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(isRef(myComputedAge), myComputedAge.value); <span class="comment">// true 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// omputed函数的返回值是不可改变的</span></span><br><span class="line">    myComputedAge.value = <span class="number">3</span>; <span class="comment">//  Write operation failed: computed value is readonly</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h2><p><code>readonly</code>获取一个对象（响应式/纯对象）并返回原始代理的只读代理，只读代理是深层次的：访问的任何嵌套的<code>property</code>也是只读的。返回的代理对象不可改变。但是传入的原始对象改变时，返回的代理对象也会相应的改变。如果传入的是<code>ref</code>对象或者<code>reactive</code>对象。那么返回的代理对象也是响应式的。</p><h3 id="readonly-响应式对象"><a href="#readonly-响应式对象" class="headerlink" title="readonly 响应式对象"></a>readonly 响应式对象</h3><p><strong>ref对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, readonly &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup () &#123;</span><br><span class="line">      <span class="keyword">const</span> name = ref(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> readonlyName = readonly(name);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;读取只读代理的值：&quot;</span>,readonlyName.value );  <span class="comment">// 读取只读代理的值: shuliqi</span></span><br><span class="line">      <span class="comment">// 尝试修改会直接警告</span></span><br><span class="line">      readonlyName.value = <span class="string">&quot;张大大&quot;</span>; <span class="comment">// Set operation on key &quot;value&quot; failed: target is readonly.</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        name.value = <span class="string">&quot;小小舒&quot;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;原始ref对象改变，只读代理的值也会变：&quot;</span>,readonlyName.value); <span class="comment">// 原始ref对象改变，只读代理的值也会变：小小舒</span></span><br><span class="line">      &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>reactive对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readonly, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup () &#123;</span><br><span class="line">      <span class="keyword">const</span> state  = reactive(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;标题&quot;</span>,</span><br><span class="line">        <span class="attr">subTitle</span>: <span class="string">&quot;二级标题&quot;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">const</span> readonlyState = readonly(state);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;读取只读代理的值(reactive)：&quot;</span>,readonlyState.title ); <span class="comment">// 读取只读代理的值(reactive)：标题</span></span><br><span class="line">      <span class="comment">// 尝试修改会直接警告</span></span><br><span class="line">      readonlyState.title = <span class="string">&quot;修改标题&quot;</span>; <span class="comment">// Set operation on key &quot;title&quot; failed: target is readonly</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        state.title = <span class="string">&quot;标题被修改了&quot;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;原始reactive对象改变，只读代理的值也会变(reactive)：&quot;</span>,readonlyState.title); </span><br><span class="line">        <span class="comment">// 原始reactive对象改变，只读代理的值也会变(reactive)：标题被修改了</span></span><br><span class="line">      &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>重要：</strong><code>readonly</code> 响应式对象.只读代理是具有响应性的:</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/9.gif" class=""><h3 id="readonly-普调对象"><a href="#readonly-普调对象" class="headerlink" title="readonly 普调对象"></a>readonly 普调对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readonly &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup () &#123;</span><br><span class="line">      <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="attr">size</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="attr">isNew</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> readonlyObj = readonly(obj);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;读取readonly一个普调对象的只读代理的值：&quot;</span>,readonlyObj );</span><br><span class="line">      <span class="comment">// 读取readonly一个普调对象的只读代理的值:&#123; size: 12, isNew: true &#125;</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//  尝试修改 readonlyObj, 直接警告</span></span><br><span class="line">      readonlyObj.size = <span class="number">100</span>;  <span class="comment">// Set operation on key &quot;size&quot; failed: target is readonly</span></span><br><span class="line">      <span class="comment">//  修改原始数据</span></span><br><span class="line">      obj.size = <span class="number">3000</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;原始数据obj改变， readonlyObj也会改变&quot;</span>,  readonlyObj); </span><br><span class="line">      <span class="comment">// 原始数据obj改变， readonlyObj也会改变 &#123; size: 3000, isNew: true &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="readonly-一个非对象"><a href="#readonly-一个非对象" class="headerlink" title="readonly 一个非对象"></a>readonly 一个非对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readonly &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup () &#123;</span><br><span class="line">      <span class="comment">// readonly 一个非对象: 就不具有只读特性了</span></span><br><span class="line">      <span class="keyword">const</span> str = <span class="string">&quot;oldDate&quot;</span>;</span><br><span class="line">      <span class="keyword">let</span> readonlyStr = readonly(str);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;readonlyStr:&quot;</span>,readonlyStr)</span><br><span class="line">      <span class="comment">// 可以直接修改，说明不具有只读特性</span></span><br><span class="line">      readonlyStr = <span class="string">&quot;newDate&quot;</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;newReadonlyStr:&quot;</span>,readonlyStr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><code>Composition API</code>有人提供了组件生命周期的钩子回调。我们先看<code>vue3.0</code>生命周期图：</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/10.png" class=""><p>我们可以看出，<code>vue3.0</code>增加了<code>setup</code>,然后为了更加语义化将<code>beforeDestroy</code>改成了<code>beforeUnmount</code>；<code>destotredy</code>改成了<code>unmounted</code>。其他<code>Vue2</code>中的生命周期仍然保留。这个图没有显示全部的声声明周期。我们看看全部的生命周期的钩子图示。</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/11.png" class=""><p><code>beforeCreate</code>和<code>created</code>被<code>setup</code>替换了（但是Vue3中你仍然可以使用， 因为Vue3是向下兼容的， 也就是你实际使用的是vue2的）。钩子命名都增加了<code>on</code>; Vue3.x还新增用于调试的钩子函数数<code>onRenderTriggered</code>和<code>onRenderTricked</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; </span><br><span class="line">  onBeforeMount,</span><br><span class="line">  onMounted,</span><br><span class="line">  onBeforeUpdate,</span><br><span class="line">  onUpdated,</span><br><span class="line">  onBeforeUnmount,</span><br><span class="line">  onUnmounted,</span><br><span class="line">  onErrorCaptured, </span><br><span class="line">  onRenderTracked,</span><br><span class="line">  onRenderTriggered</span><br><span class="line">&#125;  <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  beforeCreate () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;beforecreate&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;created&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  setup () &#123;</span><br><span class="line">    onBeforeMount(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Composition API: onBeforeMount&quot;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Composition API: onMounted&quot;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onBeforeUpdate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Composition API: onBeforeUpdate&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>当然关于<code>Composition    API</code>的还有很多的钩子，具体可以看中文官网 <a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html">组合式 API？</a> 英文官网：<a href="https://juejin.cn/post/6844904066103902215#heading-15">Composition API?</a></p><p>最后关于以上的例子的<code>github</code>链接: <a href="https://github.com/shuliqi/vue3.0--Composition-API/tree/master">vue3.0–Composition-API</a></p><p>通过修改<code>src/main.js</code>中的不同的模板来看不同的<code>API 示例</code>。</p><img src="/2021/05/08/Vue3-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BComposition-API/12.png" class="">]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目中遇到的跨域问题</title>
      <link href="/2021/04/15/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2021/04/15/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个全新的<code>Vue</code>前端项目搭建及其开发工作，后端和前端都是分离的，所以避免不了开发环境和生产环境的跨域问题。 开发环境或者是生产环境，前端和后端都是在同一个机器下面部署或者是使用不同的端口号。 当我们的前端资源访问后端服务时得不到数据或没有达到预期的效果。以前也是知道跨域问题的， 但是没有好好总结。那么这篇文章就主要来讲讲遇到的跨域问题。以及如何解决，在 vue 项目中如何解决等。</p> <span id="more"></span><h1 id="跨域的问题"><a href="#跨域的问题" class="headerlink" title="跨域的问题"></a>跨域的问题</h1><p>上面我们也说了， 现在开发项目大部分都是前后端分离的，那么无论是什么环境就肯定会遇到跨域问题。我们举一个例子来说明：</p><h2 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h2><p>我们使用 <code>express</code>来弄一个后端的服务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir serve</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd serve</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch index.js</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express --save</span><br></pre></td></tr></table></figure><p>添加 <code>.gitignore</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure><p><strong>index.js</strong>文件的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/api/getName&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">&quot;舒丽琦&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Example app listening at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码说明：有一个在端口为 8000 的接口 ‘/getName<code>。 接口返回</code>舒丽琦`。</p><p>现在我们启动这个服务：<code>node index.js</code>。 打开浏览器访问：<code>http://localhost:3000/api/getName</code>。可得到：</p><img src="/2021/04/15/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/1.png" class=""><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>我们使用<code>Vue</code>的脚手架<code>vue-cli</code>来构建一个前端的框架：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create web</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd web</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure><p>我们把<code>App.vue</code>代码改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; &lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    // 去请求我们刚才启动的后端得服务的 getName 接口</span><br><span class="line">    axios</span><br><span class="line">      .get(&quot;http://localhost:8000/getName&quot;)</span><br><span class="line">      .then(function(response) &#123;</span><br><span class="line">        console.log(response);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(function(error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>最后启动一下前端服务<code>npm run dev</code>。</p><h2 id="结果及其原因"><a href="#结果及其原因" class="headerlink" title="结果及其原因"></a>结果及其原因</h2><p>这时候我们后端和前端是准备完毕了， 我们来看看结果吧！打开<code>http://localhost:8080/</code>。然后打开控制台，得到的结果如下：</p><img src="/2021/04/15/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/2.png" class=""><p>我们发现是报错了。一看报错信息就知道你产生了跨域的问题。那跨域问题请求到底是什么返回什么呢？</p><p>我们继续 <code>debugger</code></p><img src="/2021/04/15/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/3.png" class=""><p>发现<code>reponse:</code>undefined<code>，提示消息:</code>Network Error`。 那是不是说明请求没有到后端呢？我们来试试。</p><p>我们在后端的接口函数里面打印个<code>log</code>。然后看请求的时候， 看请求是否到了后端：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/getName&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 加个log</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;请求到后端了&quot;</span>);</span><br><span class="line">  res.send(<span class="string">&quot;舒丽琦&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Example app listening at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后我们前端页面请求下，结果是这样的：</p><img src="/2021/04/15/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/4.png" class=""><p>那就说明，<strong>有跨域的时候， 请求是到达了后端的， 并且后端还返回了 数据。只是在浏览器被拦截了。</strong></p><p><a href="https://github.com/shuliqi/crossDomain/tree/master">跨域体现的例子</a></p><h1 id="跨域产生的原因"><a href="#跨域产生的原因" class="headerlink" title="跨域产生的原因"></a>跨域产生的原因</h1><p>经过上面的验证，我们知道跨域是浏览器做了拦截，并且报了错。那为什么浏览器会做拦截呢？</p><p>那当然是为了<strong>安全问题</strong>。比如著名的 CSRF<a href="https://translate.google.com.hk/translate?hl=zh-CN&sl=zh-TW&u=https://zh.wikipedia.org/zh/%25E8%25B7%25A8%25E7%25AB%2599%25E8%25AF%25B7%25E6%25B1%2582%25E4%25BC%25AA%25E9%2580%25A0&prev=search&pto=aue">攻击</a>。XSS 攻击。</p><p>所以浏览器因为安全问题而引入了<strong>同源策略</strong>：</p><img src="/2021/04/15/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/5.png" class=""><p>只有当 协议，域名，端口 三者都相等时，才不会产生跨域问题。就是说是同源，才能读取服务器的响应。</p><table><thead><tr><th>当前的 url</th><th>请求的 url</th><th>是否跨域</th></tr></thead><tbody><tr><td><a href="https://shuliqi.github.io/">https://shuliqi.github.io</a></td><td><a href="http://shuliqi.github.io/">http://shuliqi.github.io</a></td><td>是，协议不同（https/http）</td></tr><tr><td><a href="https://xiaoxiaoshu.github.io/">https://xiaoxiaoshu.github.io</a></td><td><a href="https://shuliqi.github.io/">https://shuliqi.github.io</a></td><td>是，域名不同（xiaoxiaoshu.github.io/shuliqi.github.io）</td></tr><tr><td><a href="https://shuliqi.github.io:3000/">https://shuliqi.github.io:3000</a></td><td><a href="https://shuliqi.github.io:8080/">https://shuliqi.github.io:8080</a></td><td>是，端口不同（3000/8080)</td></tr></tbody></table><p>但是 html 中的 <code>img</code>,<code>script</code>, <code>link</code>, <code>iframe</code>等是允许跨域加载资源的</p><h1 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h1><p>上面例子中，我们由于同源策略的原因（其中域名，端口不相同）产生跨域，导致浏览器拦截并报错。那我们如何解决呢?</p><h2 id="前端-proxy"><a href="#前端-proxy" class="headerlink" title="前端 proxy"></a>前端 proxy</h2><p>浏览器是禁止跨域的，但是服务器不禁止，所以我们前端可以使用<code>webpack</code>给我们的本地起一个服务，作为请求的代理对象。</p><p>由于我们的项目是<code>vue-cli3</code>脚手架搭建的。所以<code>webpack</code>基础配置全部内嵌了，所以我么初始化项目之后<code>Webpack</code>的<code>config</code>初始化的配置不见了。但是<code>Vue-cli3</code>给我们留了一个<code>vue.config.js</code>文件供们对<code>webpack</code>进行自定义配置。</p><p>我们在我们的<code>vue</code>项目的根目录中添加<code>vue.config.js</code>内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 开发环境</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="comment">// 代理的标识， 告诉 node， url 前面是 api的就是需要代理的</span></span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// 目标地址，一般指后端服务器地址</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否允许跨域</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写实 际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替， 因为我们后端接口没有api</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="comment">// 我们请求url为：&#x27;/api/getNmae&#x27;话的，经过http-proxy-middleware的代理服务器时候改成&#x27;/getName&#x27;,然后代理到 target 目标地址</span></span><br><span class="line">          <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的每一步解释已经很清楚了。由于我们做道代理的时候重写了请求 url。所以我们代理服务器最终向目标服务请求的链接是：<code>http://localhost:8080/ /getName</code>。 所以我们后端写的接口也去掉<code>api</code>。</p><p>/serve/index.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"><span class="comment">// 去掉&#x27;api/getName&#x27;中的api，这样前端代理服务器请求过来的才能匹配到</span></span><br><span class="line">app.get(<span class="string">&quot;/getName&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;请求到后端了&quot;</span>);</span><br><span class="line">  res.send(<span class="string">&quot;舒丽琦&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Example app listening at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后我们在请求的时候，需要注意将<code>axios</code>的<code>baseUrl</code>改成 <code>api</code></p><p>App.vue 文件修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;http://localhost:3000/api/getName&#x27;</span>) ---&gt;   axios.get(<span class="string">&#x27;/api/getName&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后前端和后端服务都重启。打开浏览器，结果如下：</p><img src="/2021/04/15/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/6.png" class=""><p>我们可以看到，我们再开发环境成功请求到数据。</p><p><a href="https://github.com/shuliqi/crossDomain/tree/webProxy">本次例子代码</a></p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><h2 id="cors-方式"><a href="#cors-方式" class="headerlink" title="cors 方式"></a>cors 方式</h2><p>=======</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>044ffb97f97af90574daa890024f349cc42d01d3</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="cors-方式-1"><a href="#cors-方式-1" class="headerlink" title="cors 方式"></a>cors 方式</h2><p>上面解决我们在开发环境遇到的跨域问题，但是我们打包上线的话， 我们做的配置是不生效的。自然而然也就产生了跨域。那么这种情况就可以使用<code>cors</code>方式来解决跨域。</p><p><code>cors</code>称: 跨域资源共享（Cross-origin resource sharing）， 是一中 ajax 跨域请求资源的方式。但是这种方式是有兼容性的问题的</p><ul><li>cors 必须 浏览器和服务端同时支持，才能实现跨域</li><li>这种方式几乎所有的浏览器都支持， 但是 IE 需要 IE10 以上才能支持</li><li>IE8，IE9 需要通过<code>XDomainRequest</code>来实现。</li></ul><p>我们知道请求会分为<strong>简单的请求</strong>和<strong>复杂的请求</strong>：</p><p><strong>简单的请求：</strong></p><ul><li><p>请求方式是 GET, POST, HEAD 之一;</p></li><li><p>Content-Type 的值是 <code>text/plain</code>, <code>multipart/form-data</code>, <code>application/x-www-form-urlencoded</code>之一；</p></li></ul><p>那么这次的请求就是简单的请求。</p><p><strong>复杂的请求：</strong></p><ul><li><p>请求方式是下面方式之一：PUT，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT;</span><br><span class="line">DELETE;</span><br><span class="line">CONNECT;</span><br><span class="line">OPTIONS;</span><br><span class="line">TRACE;</span><br><span class="line">PATCH;</span><br></pre></td></tr></table></figure></li><li><p>Content-Type 的值不属于下列之一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">application / x - www - form - urlencoded;</span><br><span class="line">multipart / form - data;</span><br><span class="line">text / plain;</span><br></pre></td></tr></table></figure></li></ul><p>对于简单的请求，对于简单的请求，浏览器会直接发送 cors 请求，具体来说就是在 header 中加入 origin 请求头字段。在响应头回服务器设置相关的 cors 请求,响应头字段为允许跨域请求的源。</p><p>而对于复杂的请求，浏览器会先自动发送一个 <code>options</code>请求浏览器是否支持该请求， 如果不支持，则控制台直接报错， 如果支持， 那么就会发送真正的请求到后端。</p><p>我们继续使用我们上面的产生跨域的例子：</p><p>serve/index.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置跨域访问</span></span><br><span class="line">app.all(<span class="string">&quot;*&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置哪个源可以访问我</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 允许携带哪个头访问我</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Requested-With&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>);</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/api/getName&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;请求到后端了&quot;</span>);</span><br><span class="line">  res.send(<span class="string">&quot;舒丽琦&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Example app listening at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后起我们的前端服务<code>npm run serve</code> 和后端服务<code>node index.js</code>, 打开我们的<code>http://localhost:8080/</code></p><p>可得到结果如下：</p><img src="/2021/04/15/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/7.png" class=""><p><a href="https://github.com/shuliqi/crossDomain/tree/cors">本例子的代码</a>)</p><h2 id="后端代理"><a href="#后端代理" class="headerlink" title="后端代理"></a>后端代理</h2><p>第二种方式简单，但是还是会在一定的程度上有风险的，或者某些浏览器不支持的话。那也是没作用的。那第一种方式我们是前端实现代理， 那后端其实也是可以实现代理的。</p><p>这里我们以 <code>express</code> 为例子. 首先后端安装 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install http-proxy-middleware --save</span><br></pre></td></tr></table></figure><p>新建 serve.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">&quot;http-proxy-middleware&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  <span class="string">&quot;/api&quot;</span>,</span><br><span class="line">  createProxyMiddleware(&#123;</span><br><span class="line">    <span class="comment">// 接受到前端的请求，然后转到3001</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&quot;http://localhost:3001&quot;</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Example app listening at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里我们监听 8000 端口， 当接收到请求前缀是<code>/api</code>， 我们就代理到 3001 端口。</p><p>我们的<code>index.js</code> 改成 <code>api.js</code>， 内容不变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3001</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/api/getName&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;请求到后端了&quot;</span>);</span><br><span class="line">  res.send(<span class="string">&quot;舒丽琦&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Example app listening at http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里我们监听的是 3001 端口。这里才是真正的接口响应的部分。</p><p>我们新建 index.html. 内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;//cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> contextPath = <span class="string">&quot;http://localhost:4000/api/getName&quot;</span>;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">data</span>: <span class="string">&quot;click&quot;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="attr">url</span>: contextPath,</span></span><br><span class="line"><span class="javascript">          <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><p>我们把我们的 html 静态文件放在服务的 8000 端口下面。当请求的时候， 整个过程是这样：</p><p>前端页面发起请求 —&gt; 后端的 8000 服务接收请求，并代理到 3001 端口。—-&gt; 3001 端口处理响应</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>044ffb97f97af90574daa890024f349cc42d01d3</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目配置eslint+husky+lint-staged</title>
      <link href="/2021/04/03/vue%E9%A1%B9%E7%9B%AE%E4%B8%ADeslint-husky-lint-staged%E9%85%8D%E5%90%88%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E6%8F%90%E4%BA%A4/"/>
      <url>/2021/04/03/vue%E9%A1%B9%E7%9B%AE%E4%B8%ADeslint-husky-lint-staged%E9%85%8D%E5%90%88%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<p>最近使用了<code>vue-cli3</code>构建开发一个新的项目， 发现在开发的过程中有很多人会不经意把<code>console.log</code>等提交上去了。于是觉得有必要把<code>eslint</code>加上，因为在多人开发中，每个人的代码风格可能是不一样的。大团队协作时，良好的代码规范显得格外重要，因为这是保障一个团队代码风格相同、避免低级bug的途径之一。为了解决这样的问题！ 我们在每次提交的时候都可以进行一次<code>eslint</code>检查。不符合<code>eslint</code>规范的不给提交。这样就能解决问题了。</p> <span id="more"></span><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>下面讲解的项目范例会使用<code>vue-cli</code>来创建。</p><blockquote><p>具体如何创建一个项目可以看 <a href="https://cli.vuejs.org/zh/guide/">官方的文档</a></p></blockquote><h2 id="安装全局的vue-cli"><a href="#安装全局的vue-cli" class="headerlink" title="安装全局的vue-cli"></a><strong>安装全局的<code>vue-cli</code></strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><h2 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create eslint-example</span><br></pre></td></tr></table></figure><h2 id="选择配置"><a href="#选择配置" class="headerlink" title="选择配置"></a>选择配置</h2><p>弹出的配置中， 我们选择如下的配置：</p><img src="/2021/04/03/vue%E9%A1%B9%E7%9B%AE%E4%B8%ADeslint-husky-lint-staged%E9%85%8D%E5%90%88%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E6%8F%90%E4%BA%A4/1.png" class=""><blockquote><p>当然配置可以根据自己的需要要选择， 我这里只是举个例子</p></blockquote><h1 id="配置ESlint"><a href="#配置ESlint" class="headerlink" title="配置ESlint"></a>配置ESlint</h1><p><code>ESlint</code> 是什么？<code>ESlint</code> 是一个语法规则和代码风格的检查工具。关于一些配置项这里不做过多的讲解。</p><blockquote><p>学习的话可以直接去官网学习：<a href="https://eslint.org/">ESlint英文官网</a>，<a href="https://cn.eslint.org/">ESlint 中文官网</a></p></blockquote><p><code>Eslint</code>如何去使用呢？ 前提肯定是先安装（至于是本地安装还是全局安装，看自己项目的需要）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint --save</span><br></pre></td></tr></table></figure><blockquote><p>本文在创建的时候选择的配置已经把<code>eslint</code>安装上，所以在该项目中就不需要再安装一次了。</p><p>小tips：但是这里创建项目时候选择的<code>eslint</code>版本是有问题， 这个问题下面会暴露， 这里可以先跳过</p></blockquote><h2 id="创建-eslintrc文件"><a href="#创建-eslintrc文件" class="headerlink" title="创建.eslintrc文件"></a>创建.eslintrc文件</h2><p>手动在项目的根目录添加<code>.eslintrc</code>文件。</p><p>安装完之后，不要着急，我们不使用官方提供的<code>eslint --init</code>来生成配置文件而是手动添加。为什么呢？ 因为这样我们需要手动配置很多个的规则。</p><p>那如果不这样？那有没有更好的简便的方法呢？那肯定是有的。网上有一个叫 <a href="https://www.npmjs.com/package/eslint-config-standard">eslint-config-standard</a>的插件，它是标准的<code>ESlint</code>规则， 我们在项目中继承这个标准就可以了。</p><h2 id="安装eslint-config-standard"><a href="#安装eslint-config-standard" class="headerlink" title="安装eslint-config-standard"></a>安装eslint-config-standard</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-config-standard --save</span><br></pre></td></tr></table></figure><p>如<code>eslint-config-standard</code>官网所说：如果我们是需要手动加一些配置的,需要手动安装如下的<code>npm</code>包</p><p>所以我们需要安装如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint-config-standard eslint-plugin-promise eslint-plugin-<span class="keyword">import</span> eslint-plugin-node --save</span><br></pre></td></tr></table></figure><p>因为<code>eslint-config-standard</code>校验规则的时候需要依赖这些<code>plugins</code>去验证。</p><p>然后我们在<code>.eslintrc</code>文件添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;standard&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候校验肯定是校验不了， 因为少安装了一些插件。因为<code>eslint-config-standard</code>校验规则的时候需要依赖这些<code>plugins</code>去验证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint-config-standard eslint-plugin-promise eslint-plugin-<span class="keyword">import</span> eslint-plugin-node --save</span><br></pre></td></tr></table></figure><p>这时候是不是就可以验证了了么？我们执行运行项目看看：<code>npn run serve</code>: 发现抛出错误了。</p><img src="/2021/04/03/vue%E9%A1%B9%E7%9B%AE%E4%B8%ADeslint-husky-lint-staged%E9%85%8D%E5%90%88%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E6%8F%90%E4%BA%A4/2.png" class=""><p>这是因为<code>eslint</code>版本过低。<code>eslint-config-standard</code>插件必须使用<code>7.11.0</code>版本以上的<code>eslint</code>。具体原因可看：<a href="https://github.com/standard/eslint-config-standard/issues/176">https://github.com/standard/eslint-config-standard/issues/176</a></p><blockquote><p>注意：这也就是我们上面说的问题；使用<code>eslint-config-standard</code> 只要需要<code>ESlint：7.11.0</code>版本以上，不然报错，无法校验。</p></blockquote><p>重新安装<code>eslint</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint@<span class="number">7.11</span><span class="number">.0</span> --save</span><br></pre></td></tr></table></figure><p>这时候运行我们的项目就不会报上面的错了。可以进行代码风格校验了。</p><h2 id="安装eslint-plugin-html"><a href="#安装eslint-plugin-html" class="headerlink" title="安装eslint-plugin-html"></a>安装eslint-plugin-html</h2><p>因为<code>vue</code>的项目，<code>.vue</code>文件写的是类似像<code>html</code>这样的格式，它不是标准的<code>Javascript</code>文件。<code>ESlint</code>是无法识别<code>.vue</code>文件的<code>js</code>代码的。所以需要安装另外一个插件 <a href="https://www.npmjs.com/package/eslint-plugin-html">eslint-plugin-html</a>。这个插件的作用是识别一个文件里面的<code>script</code>标签的<code>js</code>代码。</p><blockquote><p><code>.vue</code>文件的<code>js</code>代码就是写在<code>script</code>标签中的。</p></blockquote><p><strong>安装</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint-plugin-html --save</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><p>在<code>.eslintrc</code>添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;standard&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;html&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="package-json-添加命令"><a href="#package-json-添加命令" class="headerlink" title="package.json 添加命令"></a>package.json 添加命令</h2><p>首先先去除<code>package.json</code>里面<code>eslint</code>的配置字段：<code>eslintConfig</code></p><p>上面的步骤完成之后，在项目的<code>packge.json</code>的<code>script</code>字段修改<code>lint</code>命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js --ext .jsx --ext .vue src/&quot;</span>,</span><br><span class="line"><span class="string">&quot;lint-fix&quot;</span>: <span class="string">&quot;eslint --fix --ext .js --ext .jsx --ext .vue src/&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>–ext后面加上我们需要检测文件的后缀，如<code>.js</code>、.<code>jsx</code>、 <code>.vue</code>等，紧接加上检测哪个目录下面的文件的目录，如： 我们要检查<code>src</code>目录下面的文件，就直接写<code>src</code>。</p></blockquote><p>到目前为止，我们可以使用<code>npm run lint</code>来校验了。当然我们可以使用<code>npm run lint-fix</code>来自动修复。</p><h2 id="安装-eslint-plugin-vue"><a href="#安装-eslint-plugin-vue" class="headerlink" title="安装 eslint-plugin-vue"></a>安装 eslint-plugin-vue</h2><p>上面的步骤配置完成之后， 我们试着<code>npm run lint</code>。控制台是能够显示出来那些是有规则问题的，如：</p><img src="/2021/04/03/vue%E9%A1%B9%E7%9B%AE%E4%B8%ADeslint-husky-lint-staged%E9%85%8D%E5%90%88%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E6%8F%90%E4%BA%A4/3.png" class=""><p>我们可以看到，那些代码是有规则问题都被标出来了。</p><p>但是我们进到相应的文件去看，相应有问题的地方却没有被标红（vscode编辑器）这是为什么呢？(之前的项目是可以被标识出来的)</p><p>这是因为：我们使用的是<code>vue-cli3</code>构建的项目，我们使用之前的方案去实现标识是无法识别的。</p><p>想要<code>vscode</code>编辑器对<code>.vue</code>文件的<code>eslint</code>检测时有错误标红出来， 则需要<code>eslint-plugin-vue </code>插件。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint-plugin-vue</span><br></pre></td></tr></table></figure><h3 id="添加plugin说明"><a href="#添加plugin说明" class="headerlink" title="添加plugin说明"></a>添加<code>plugin</code>说明</h3><p><code>.eslintrc</code>文添加<code>plugin</code>说明</p><p><code>.eslintrc</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...其他配置项</span></span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">  <span class="comment">// ...其他plugins</span></span><br><span class="line">  <span class="string">&quot;vue&quot;</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...其他配置项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加extend说明"><a href="#添加extend说明" class="headerlink" title="添加extend说明"></a>添加<code>extend</code>说明</h3><p><code>.eslintrc</code>文添加<code>extend</code>说明</p><p><code>.eslintrc</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line"><span class="comment">// ...其他配置项</span></span><br><span class="line"><span class="attr">extends</span>: [</span><br><span class="line">  <span class="comment">// ... 其他的规则</span></span><br><span class="line">    <span class="string">&#x27;plugin:vue/base&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...其他配置项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用的是<code>base</code>里面的规则。更多的配置可看 <a href="https://eslint.vuejs.org/rules/">官方文档</a></p></blockquote><h3 id="解析器配置"><a href="#解析器配置" class="headerlink" title="解析器配置"></a>解析器配置</h3><p><code>.eslintrc</code>配置解析器</p><p><code>.eslintrc</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...其他配置项</span></span><br><span class="line"><span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">parser</span>: <span class="string">&#x27;babel-eslint&#x27;</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// ...其他配置项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的<code>.eslintrc</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;parser&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;plugin:vue/base&quot;</span></span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;html&quot;</span>, <span class="string">&quot;vue&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在有问题的代码就会标红出来了，如：</p><img src="/2021/04/03/vue%E9%A1%B9%E7%9B%AE%E4%B8%ADeslint-husky-lint-staged%E9%85%8D%E5%90%88%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E6%8F%90%E4%BA%A4/4.png" class=""><p>到目前为止， <code>eslint</code>相关的配置就完成了。</p><h1 id="husy"><a href="#husy" class="headerlink" title="husy"></a>husy</h1><p>有这样的情况：我们试着提交一次有<code>eslint</code>错误的代码:</p><img src="/2021/04/03/vue%E9%A1%B9%E7%9B%AE%E4%B8%ADeslint-husky-lint-staged%E9%85%8D%E5%90%88%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E6%8F%90%E4%BA%A4/5.png" class=""><p>我们发现是可以提交的。并且尝试<code>push</code>到远端的时候，也是可以的。但其实我们是希望在有<code>eslint</code>错误的时候，不能做提交和<code>push</code>这类操作的， 防止有问题的代码托送到远端。那么<code>husky</code>就可以帮助我们。</p><blockquote><p><a href="https://typicode.github.io/husky/#/?id=automatic-recommended">husky官方文档</a></p></blockquote><p><code>husky</code> 是一个<code>npm</code>安装包，安装了之后可以很方便的配置<code>git hook</code>脚本， 以防止不规范代码被<code>commit</code>、<code>push</code>、<code>merge</code>等。</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>由于目前<code>husky</code>已经升级到了 6 版本， 变化还是很大的，网上的很多文章讲解的都是4版本的，  不是很对了。所以我们直接看<a href="https://typicode.github.io/husky/#/?id=automatic-recommended">husky官方文档</a>的安装方式及其使用方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky-init &amp;&amp; npm install </span><br></pre></td></tr></table></figure><p>我们会发现<code>init</code>生成了一个默认的<code>pre-commit</code>钩子：</p><img src="/2021/04/03/vue%E9%A1%B9%E7%9B%AE%E4%B8%ADeslint-husky-lint-staged%E9%85%8D%E5%90%88%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E6%8F%90%E4%BA%A4/6.png" class=""><p>我们把该配置的<code>npm test</code>去掉。</p><h2 id="配置钩子"><a href="#配置钩子" class="headerlink" title="配置钩子"></a>配置钩子</h2><p>修改<code>pre-commit</code>钩子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit <span class="string">&#x27;npm run lint&#x27;</span></span><br></pre></td></tr></table></figure><p>配置<code>pre-push</code>钩子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-push <span class="string">&#x27;npm run lint&#x27;</span></span><br></pre></td></tr></table></figure><p>配置<code>pre-merge</code>钩子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-merge <span class="string">&#x27;npm run lint&#x27;</span></span><br></pre></td></tr></table></figure><p>现在我们试着测试，看是否生效:</p><img src="/2021/04/03/vue%E9%A1%B9%E7%9B%AE%E4%B8%ADeslint-husky-lint-staged%E9%85%8D%E5%90%88%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E6%8F%90%E4%BA%A4/6.png" class=""><p>我们尝试提交了代码不符合规范的代码，确实被阻止了， 生效。</p><h1 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h1><p>我们希望每次<code>commit</code> ,<code>push</code>和<code>merge</code>等这样的操作的时候，只希望校验自己修改的文件代码规范，而不是全局的检验。 这就需要 <a href="https://www.npmjs.com/package/lint-staged"><code>lint-staged</code></a>了。</p><p> <a href="https://www.npmjs.com/package/lint-staged"><code>lint-staged</code></a>的作用是只对<code>git add</code>缓存区的代码进行<code>eslint</code>代码规范检验。这样就能避免全局校验的问题。 符合了我们修改了什么文件，就校验什么文件。其他的的代码不做<code>eslint</code>校验。</p><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev lint-staged</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在 <code>package.json</code>中添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;src/**/*.&#123;js,vue&#125;&quot;</span>: [</span><br><span class="line">     <span class="string">&quot;npm run lint&quot;</span></span><br><span class="line">   ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>src/**/*.&#123;js,vue&#125;</code> 是需要校验的目录， 可以根据目录去修改。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到目前为止，配置就做完了。最后觉得在做一个多人开发的项目的时候， 前期一些代码规范的配置觉得是很有必要的。</p><p>本文中的例子github链接：<a href="https://github.com/shuliqi">shuliqi</a>/<strong><a href="https://github.com/shuliqi/eslint-husky-lint-staged-example">eslint-husky-lint-staged-example</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 工程配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的HTML属性：contenteditable</title>
      <link href="/2021/03/20/webpack%E5%AD%A6%E4%B9%A0-%E4%BC%98%E5%8C%96%EF%BC%88optimization%EF%BC%89/HTML%E7%9A%84ContentEditable-%E5%B1%9E%E6%80%A7/"/>
      <url>/2021/03/20/webpack%E5%AD%A6%E4%B9%A0-%E4%BC%98%E5%8C%96%EF%BC%88optimization%EF%BC%89/HTML%E7%9A%84ContentEditable-%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个需求, 需求中有个这样效果:<strong>有一个输入框，输入框有<code>placeholder</code>提示音输入框的宽度随着内容的长度自适应，并且输入框不可以换行显示，键盘回车就相当于确认值</strong>。刚开始我接到这样的效果，想这还不简单，<code>input</code>不就可以实现吗？但是到我真的进入到开发的时候， 才发现不是很对劲， <code>input</code> 好像实现不了。 那么具体哪里实现不了？ 那么解决的办法是什么呢？有没有什么可以替代的办法呢？我们来一一看一下具体过程。</p><span id="more"></span><h1 id="input-实现"><a href="#input-实现" class="headerlink" title="input 实现"></a>input 实现</h1><p>由于项目是<code>VUE</code>技术栈，那么久直接使用<code>VUE</code>的方式举例子了。</p><p>首先我们来看<code>input</code> 是否能实现：</p><iframe height="411" style="width: 100%;" scrolling="no" title="input自适应宽" src="https://codepen.io/shuliqi/embed/bGgpmrN?height=411&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/bGgpmrN'>input自适应宽</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe>我们页面正常的放入`input`标签，没有给它设置一个固定的宽度值，那么它就会有默认不变的宽度，想让它动态宽度自适应是不可能的。或者我们给它设置一个宽度，那么`input`的宽度也就固定了，也不能动态自适应内容的宽度了。<p>那要是非得要用<code>input </code>标签来实现的话， 能不能实现呢？ 答案是能的， 代码那么神奇，看你自己的思路。 我这里提供一种思路吧!</p><p>既然<code>input</code>标签是有默认宽度的，所以<code>css</code>的宽度就不能不写。我们就直接设置它的宽度为100%，让它跟这父元素的宽度来改变。父元素的宽度我们可以使用<code>span</code>标签撑起来。<code>span</code>标签的内容与<code>input</code>的内容是一样，然后<code>input</code>标签绝对定位，把<code>span</code>盖起来。 大体就是这么个思路。我们来看看例子：</p><iframe height="525" style="width: 100%;" scrolling="no" title="input 标签自适应宽度" src="https://codepen.io/shuliqi/embed/wvgGYbG?height=525&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/wvgGYbG'>input 标签自适应宽度</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>这样就完美实现了。当然也有很多其他的思路， 看自己有么有想出更好的实现方案吧。</p><h1 id="contenteditable-属性实现"><a href="#contenteditable-属性实现" class="headerlink" title="contenteditable  属性实现"></a>contenteditable  属性实现</h1><p>当然除了上面的<code>input</code>方式实现。也还有其他的方式可以实现，这就是我们这篇文章的重点：<code>HTML</code>的<code>ContentEditable</code> 属性。</p><p><code>contenteditable</code> 属性是<code>HTML5</code>的新属性。规定元素的内容是否可编辑。它的属性值有两种：</p><ul><li><strong>true</strong>：规定元素的内容是可编辑的</li><li><strong>false</strong>：规定元素的内容是不可编辑的</li></ul><p>看到这里，大家都会想到<code>textarea</code>。但是<code>contenteditable</code>属性与<code>textarea</code> 是不一样的。</p><ul><li><code>textarea</code>支持多行文本的输入，满足我们很多编辑的需求。但是<code>textarea</code>有一个致命的去诶单，那就是不能像<code>div</code>类似这样的标签宽度，高度自适应。</li><li><code>textarea</code> 只支持文本的输入。但是现在的很多需求需要在编辑区假如图片，链接，视频等。<code>textarea</code> 是做不到的， 但是标签上设置<code>contenteditable</code>为<code>true</code>的话。是可以实现的。</li></ul><p>那我们现在使用 <code>contenteditable</code>属性来实现我们上面说的需求：<strong>有一个输入框，输入框有placeholder提示音，输入框的宽度随着内容的长度自适应，并且输入框不可以换行显示，键盘回车就相当于确认值</strong>;</p><p>具体的实现方式：</p><iframe height="676" style="width: 100%;" scrolling="no" title="qBRqbaz" src="https://codepen.io/shuliqi/embed/qBRqbaz?height=676&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/qBRqbaz'>qBRqbaz</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>下面需要注意的点，我们一一来讲解</p><h3 id="placeholder提示语"><a href="#placeholder提示语" class="headerlink" title="placeholder提示语"></a>placeholder提示语</h3><p><code>input</code> 和 <code>textarea</code>能很轻松的实现<code>placeholder</code>提示语的效果，但是<code>contentediable</code>的元素<code>placeholder</code>不起作用。但是可以通过<code>CSS</code>的<code>:empty</code>解决：</p><p><strong>html：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入标签&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>css:</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* placeholder的设置 */</span></span><br><span class="line"><span class="selector-class">.input</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(placeholder);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>:empty</code> <a href="https://developer.mozilla.org/en-US/docs/Web/CSS">CSS</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes">伪类</a> 代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格）。注释或处理指令都不会产生影响。</p></blockquote><h3 id="自适应宽度"><a href="#自适应宽度" class="headerlink" title="自适应宽度"></a>自适应宽度</h3><p>我们对<code>span</code>标签设置即可，<code>span</code>标签的宽度是内容的宽度撑开的。</p><p>但是这里一点需要注意：需要把 <code>span</code> 设置为<code>display: inline-block</code>。否则标签得到焦点将无法看见光标。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.input</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 重要： 不设置这个光标看不见 */</span></span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为啥设置成 <code>inline-block</code> 就可以看见了呢？</p><blockquote><p><strong>块级元素</strong>：是指当它们显示在浏览器中时，会在自身前后各插入一个空行，而使自身在页面中占据一个相对独立的块状区域的元素 </p><p><strong>行内元素：</strong> 默认是没有宽度的</p><p><strong>答案：</strong>因为行内元素是没有宽度的，光标需要1px 的宽度，所以需要设置成<code>inline-block</code>或者 <code>block</code>就可以显示光标了</p></blockquote><h3 id="内容不可以换行显示"><a href="#内容不可以换行显示" class="headerlink" title="内容不可以换行显示"></a>内容不可以换行显示</h3><p>我们在标签的 <code>keydown</code>事件的时候，判断当前是否是换行 <code>enter</code>键，如果是，那么我们直接阻止浏览器的换行操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.keyCode === <span class="number">13</span>) &#123;</span><br><span class="line">  <span class="comment">// 阻止换行</span></span><br><span class="line">  e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>keyCode:13 就是键盘的 enter 键</p></blockquote><h3 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h3><p>可以通过<code>innerHTML</code>，<code>innerText</code>、<code>textContent</code> 获取输入框的内容，介绍一下区别：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML">innerHTML</a> 返回标签之间的内容，包括标签元素和文本信息，基本上所有浏览器都支持。</li><li><code>innerText/textContent</code>：标签之间的纯文本信息，会将标签过滤掉。</li></ul><p><code>innerText</code>和<code>textContent</code>虽然都是获取标签的内容，但是两者也是存在差异的。具体可看 <a href="https://juejin.cn/post/6844903657935208456">innerText和textContent的区别</a></p><p> 我们这个例子使用的<code>innerText</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="keyword">const</span> newValue = e.target.innerText;</span><br></pre></td></tr></table></figure><p>有些文章说光标在火狐浏览器会有异常，但是看了，其实没问题，应该是浏览器修复bug了吧</p><h1 id="contenteditable-兼容性问题"><a href="#contenteditable-兼容性问题" class="headerlink" title="contenteditable 兼容性问题"></a>contenteditable 兼容性问题</h1><img src="/2021/03/20/webpack%E5%AD%A6%E4%B9%A0-%E4%BC%98%E5%8C%96%EF%BC%88optimization%EF%BC%89/HTML%E7%9A%84ContentEditable-%E5%B1%9E%E6%80%A7/1.png" class=""><p>参考文章</p><p><a href="https://wuxinhua.com/2018/07/05/Contenteditable-The-Good-Part-And-The-Ugly/">contenteditable 踩坑记</a></p><p><a href="https://www.jianshu.com/p/622d9c6e3fdf">contenteditable属性</a></p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript模块化编程总结</title>
      <link href="/2021/03/06/webpack%E5%AD%A6%E4%B9%A0-%E4%BC%98%E5%8C%96%EF%BC%88optimization%EF%BC%89/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2021/03/06/webpack%E5%AD%A6%E4%B9%A0-%E4%BC%98%E5%8C%96%EF%BC%88optimization%EF%BC%89/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章 <a href="https://shuliqi.github.io/shuliqi.github.io/2021/02/03/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Alibrary%EF%BC%8ClibraryTarget%EF%BC%8CauxiliaryComment/">模块化与Webpack属性 library,libraryTarget的关联</a>中提到很多关于模块化的规范。 如什么有些模块需要暴露在<code>module.export</code>上，而有些需要要暴露为<code>define(&#39;XXX&#39;, [], function() =&gt;&#123;&#125;)</code>等等。这些都是因为使用不同的规范导致的。可能会有点混乱，这里就好好来总结模块化的到底有哪些规范。</p><p>目前的模块化的规范：**<code>CommonJs</code><strong>，</strong><code>AMD</code><strong>，</strong><code>CMD</code>** 和 **<code>ES6模块</code>**。</p><span id="more"></span><p>首先先来看一张图片，说明这种模式的整体区别：</p><img src="/2021/03/06/webpack%E5%AD%A6%E4%B9%A0-%E4%BC%98%E5%8C%96%EF%BC%88optimization%EF%BC%89/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/2.png" class=""><p>那么接下来具体讲讲！</p><h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p><code>CommonJS</code>是以在浏览器之外构建 <code>Javascript </code>生态系统为目标而产生的项目，比如在服务器里面。<code>CommonJS</code>的代表：Node应用中的模块，通俗的来说就是<code> npm</code> 安装的模块。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>Node</code> 应用是由模块组成，<code>Node</code>的模块采用<code>CommonJS</code>模块规范；那么它的规范有哪些呢？</p><p><code>CommonJS</code>模块规范：</p><ul><li><p>每一个文件就是一个模块，都有自己的作用域。在一个文件定义的变量，函数，类都是私有的，对其他的文件不可见。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> getName =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个代码表示：变量 <code>x</code> 和函数 <code>getName</code> 是当前 <code>test.js</code>私有的，其他文件是不可见的。如果想在多个文件中分享一个变量的话， 必须定义为 <code>global</code>对象的属性；当然，这种写法是不推荐的。</p></li><li><p>每个模块内部，<code>module</code> 变量代表当前的模块。这个变量是一个对象，它的 <code>exports </code>属性(<code>module.exports</code>)是对对外的接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> getName =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.name = name;</span><br><span class="line"><span class="built_in">module</span>.exports.getName = getName;</span><br></pre></td></tr></table></figure><p>上面的代码通过<code>module.exports</code>将变量<code>name</code>,<code>getName</code>暴露出来。</p></li><li><p><code>Node</code>的每个模块提供一个 <code>exports</code> 变量， 指向 <code>module.exports</code>；这等同于在每个模块头部， 都有这样的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">exports</span>= <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure><p>这个造成的结果是：在对外输出模块接口时，可以向 <code>exports</code>对象添加方法</p><blockquote><p>注意，不能直接将exports变量指向一个值，因为这样等于切断了<code>exports</code>与<code>module.exports</code>的联系。</p></blockquote><blockquote><p>注意：不能直接将<code>exports</code>变量指向一个值, 因为这样就等用于切断了 <code>exports</code> 和<code>module.exports</code>之间的联系；如果 一个模块的对外接口是一个一个单一的值，那么也是不能用 <code>exports</code> 的、建议还是直接使用 <code>module.exports</code>。不用区分那么多</p></blockquote></li><li><p><strong>在服务端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理（这个我们下面的例子会具体来讲）</strong></p></li></ul><p>CommonJS模范定义分为三个部分：</p><ul><li><p>模块定义</p><p>模块定义其实就是暴露模块，可以把模块暴露在<code>module.exports</code>或者<code>exports</code>上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line"><span class="built_in">exports</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把对外开放的接口都暴露在 <code>module.exports</code>对象上。</p></li><li><p>模块标识</p><p>模块标识就是<code>require()</code>函数的参数，规范是这样的</p><ul><li><p>必须是字符串</p></li><li><p>可以是以./, ../开头的相对路径</p></li><li><p>可以是绝对路径</p></li><li><p>可以省略后缀名</p></li></ul><p><code>require</code>命令用于加载模块文件，读入并且执行一个<code>Javascript</code> 文件，然后返回该模块的的 <code>exports</code> 的对象。如果没有指定模块， 会报错。</p></li><li><p>引用模块</p><p>使用 <code>require</code> 加载模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line"><span class="keyword">const</span> name =  <span class="built_in">require</span>(<span class="string">&#x27;shuliqi/study/name.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略了后缀名， 相对路径</span></span><br><span class="line"><span class="keyword">const</span> getName = <span class="built_in">require</span>(<span class="string">&#x27;./getName&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块式第三方模块，直接引用模块名</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="服务端使用"><a href="#服务端使用" class="headerlink" title="服务端使用"></a>服务端使用</h2><p> 首先肯定得下载<a href="https://nodejs.org/en/">NodeJS</a>。到这个页面进行下载哦。</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>然后初始化我们的项目结构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir module-example</span><br><span class="line">$ cd module-example</span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>添加一些文件夹以及文件；最后的基本结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|--src</span><br><span class="line">  |--CommonJS</span><br><span class="line">    |--module1.js</span><br><span class="line">    |--module2.js</span><br><span class="line">    |--index.js</span><br><span class="line">|--package.json</span><br></pre></td></tr></table></figure><h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>module1.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴露（定义）模块：可以直接在写 module.exports 对象上</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;模块1&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module2.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  暴露（定义）模块：也可以直接在写 exports 对象上</span></span><br><span class="line"><span class="built_in">exports</span>.getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;shuliqi&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 引用模块： 通过模块表示 require 来引用；</span></span><br><span class="line"> <span class="comment">// 模块标识 可以省略后缀名， 可以使相对地址</span></span><br><span class="line"><span class="keyword">const</span> module1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(module1.name);</span><br><span class="line">module1.getName(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2.js&#x27;</span>)</span><br><span class="line">module2.getName();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="执行模块"><a href="#执行模块" class="headerlink" title="执行模块"></a>执行模块</h3><p>最后我们执行 <code>index.js</code> 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根目录执行</span></span><br><span class="line">$ node src/commonJS/index.js </span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模块1</span><br><span class="line">模块1</span><br><span class="line">shuliqi</span><br></pre></td></tr></table></figure><h2 id="浏览器端使用"><a href="#浏览器端使用" class="headerlink" title="浏览器端使用"></a>浏览器端使用</h2><p> 添加 index.html 文件</p><p>src/commonJS/index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CommonJS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;./index.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    CommonJS 浏览器端使用</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们浏览器打开 HTML 文件， 发现报错：<code> Uncaught ReferenceError: require is not defined</code>。 </p><p>为什么呢？ 这是因为浏览器缺少Node.Js环境的变量：<code>module</code>,<code>exports</code>,<code>require</code>,<code>global</code>。所以浏览器是无法加载CommonJs模块(npm模块)；</p><p>所以： <code>npm</code> 模块的都是 <code>JavaScript</code> 语言写的，但是浏览器用不了， 当然是因为不支持 <code>CommonJS</code>格式；所以想要浏览器能使用上这些模块， 就要得必须转换格式。</p><p>目前最常用的 <code>CommonJS</code>格式转换的工具是：<a href="http://browserify.org/">Browserify</a>； 那我们接下来的例子(基于上面的例子)就使用<a href="http://browserify.org/">Browserify</a> 来转换的 <code>CommonJS</code>。</p><p>Browserify的作用： 将在HTML 引用的js文件打包编译，是的其能够在浏览器上运行</p><h3 id="安装-Browserify"><a href="#安装-Browserify" class="headerlink" title="安装 Browserify"></a>安装 Browserify</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局安装（本例子采用）</span></span><br><span class="line">npm install browserify -g</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部安装</span></span><br><span class="line">npm install browserify --save-dev</span><br></pre></td></tr></table></figure><h3 id="打包编辑"><a href="#打包编辑" class="headerlink" title="打包编辑"></a>打包编辑</h3><p>在跟目录执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browserify src/commonJS/index.js  -o src/commonJS/bundle.js</span><br></pre></td></tr></table></figure><h3 id="引用编译文件"><a href="#引用编译文件" class="headerlink" title="引用编译文件"></a>引用编译文件</h3><p>src/commonJS/index2.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CommonJS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;./bundle.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    CommonJS 浏览器端使用</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开 HTML。控制台能成功能成功打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模块<span class="number">1</span></span><br><span class="line">模块<span class="number">1</span></span><br><span class="line">shuliqi</span><br></pre></td></tr></table></figure><p>现在最终的文件结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--src</span><br><span class="line">  |--commonJS</span><br><span class="line">    |--module1.js</span><br><span class="line">    |--module2.js</span><br><span class="line">    |--index.js</span><br><span class="line">    |--index.html</span><br><span class="line">    |--index2.html</span><br><span class="line">    |--bundle.js</span><br><span class="line">    |--require.js</span><br><span class="line">|--package.json</span><br><span class="line">|--package-lock.json</span><br></pre></td></tr></table></figure><h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>在 上一节<code>CommonJS</code> 中，我们可以看出 <code>CommonJS</code>的加载是同步的，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> module1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1111&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面的第二行代码必须在 <code> require(&#39;./module1&#39;)</code>之后运行，因此是必须要等 <code>module1.js</code>加载完，也就是说，如果加载的时间很长的， 整个应用是会卡在那里的。</p><p>但是在服务器端，所有的模块都是放在本地磁盘，可以同步加载完成，等待的时间就是硬盘的读取时间。但是对于浏览器来说，等待的时间取决于网速的快慢，可能要等待很长的时间，浏览器处于”假死”状态。</p><p>所以浏览器端的模块不能采用“同步加载”， 只能采用“异步加载”。这就是<code>AMD</code>规范产生的背景</p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>AMD</code>-异步模块加载定义，采用异步方式加载模块， 模块的加载不影响后面语句的运行，所有依赖这个模块的语句都定义在一个回调函数中，等到模块完成之后， 这个回调函数才会运行。</p><h3 id="定义暴露模块"><a href="#定义暴露模块" class="headerlink" title="定义暴露模块"></a>定义暴露模块</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// xxx: 模块</span></span><br><span class="line"><span class="keyword">return</span> xxx</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个没有依赖的模块</span></span><br><span class="line">define([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// xxx: 模块</span></span><br><span class="line"><span class="keyword">return</span> xxx</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="引用模块"><a href="#引用模块" class="headerlink" title="引用模块"></a>引用模块</h3><p>如何引用<code>AMD</code>模块呢？这里先讲讲 <code>RequireJS</code> 和 <code>AMD</code>规范的关系!</p><p>我们知道的大名鼎鼎的 <code>ReuireJS</code>，实际<code>上AMD </code>就是<code>ReuireJS</code> 在推广的过程中对模块定义的规范化产出；</p><p>RequireJS 是一个工具库，主要是用于客户端的模块管理，它可以让客户端的代码分成一个个模块，实现异步加载和动态加载。从而提高代码的性能和可维护性。重要的是它的模块管理遵守 <code>AMD规范</code>。 如果我们是可以使用RequireJS来加载 <code>AMD模块</code></p><p> 先引入<code>require.js</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/require.js&quot;</span> defer <span class="keyword">async</span>=<span class="string">&quot;true&quot;</span> &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>引入<code>require.js</code> 之后加载我们自己的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/require.js&quot;</span> data-main=<span class="string">&quot;js/main&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>data-main属性的作用是：指定网页的主模块。</p></blockquote><p>AMD模块的加载(主模块)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1, module2</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 在回调函数中使用module1/module2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>更详细的引用方式， 我们看下面的例子</p><h2 id="例子🌰"><a href="#例子🌰" class="headerlink" title="例子🌰"></a>例子🌰</h2><p>在基于上一节<code>CommonJS</code>的结构目录， 我们添加新的目录和文件 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|--src</span><br><span class="line">  |--commonJS</span><br><span class="line">    |--module1.js</span><br><span class="line">    |--module2.js</span><br><span class="line">    |--index.js</span><br><span class="line">    |--index.html</span><br><span class="line">    |--index2.html</span><br><span class="line">    |--bundle.js</span><br><span class="line">    |--require.js</span><br><span class="line">  |--AMD</span><br><span class="line">    |--index.html</span><br><span class="line">    |--main.js</span><br><span class="line">    |--module1.js</span><br><span class="line">    |--module2.js</span><br><span class="line">|--package.json</span><br><span class="line">|--package-lock.json</span><br></pre></td></tr></table></figure><h3 id="定义（暴露）模块"><a href="#定义（暴露）模块" class="headerlink" title="定义（暴露）模块"></a>定义（暴露）模块</h3><p>src/AMD/module1.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123;  getName, name &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>src/AMD/module2.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载有依赖的模块</span></span><br><span class="line"><span class="comment">// 依赖module1.js</span></span><br><span class="line">define([<span class="string">&#x27;./module1.js&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">12</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span>,module1.getName(), <span class="string">&#x27;age:&#x27;</span>,  age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; getMsg &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="引用模块-1"><a href="#引用模块-1" class="headerlink" title="引用模块"></a>引用模块</h3><p>可以下载 <a href="http://browserify.org/">require.js</a>,到本地直接引用， 也可以网上的 [require.js链接]<a href="https://requirejs.org/docs/release/2.3.6/minified/require.js">https://requirejs.org/docs/release/2.3.6/minified/require.js</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>  <span class="attr">src</span>=<span class="string">&quot;https://requirejs.org/docs/release/2.3.6/minified/require.js&quot;</span>  <span class="attr">data-main</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>src/AMD/index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>AMD<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>  <span class="attr">src</span>=<span class="string">&quot;https://requirejs.org/docs/release/2.3.6/minified/require.js&quot;</span>  <span class="attr">data-main</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    AMD 浏览器端使用</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主模块main.js 引入我们的<code>module1</code> 和<code> module2</code></p><p>src/AMD/main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;./module1&#x27;</span>, <span class="string">&#x27;./mosule2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1, mosule2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(module1.name);</span><br><span class="line">  mosule2.getMsg();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>打来我们的index,html文件，结果如下：</p><img src="/2021/03/06/webpack%E5%AD%A6%E4%B9%A0-%E4%BC%98%E5%8C%96%EF%BC%88optimization%EF%BC%89/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/1.png" class=""><p> 结果说明：浏览器能使用我们的AMD模块了</p><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p><code>ReuireJS</code>在声明依赖的模块时会在第一时间加载并且执行模块内部的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;./module1&#x27;</span>, <span class="string">&#x27;./mosule2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1, mosule2</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如：即使没有用到模块 module1，但是 module1 还是提前执行了</span></span><br><span class="line">  mosule2.getMsg();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而<code>CMD</code>则是另外一种<code> js</code> 优化方案， 它与<code> AMD</code> 很类似，规范也是专门用于浏览器，模块的加载也是异步的， 但是模块使用的时候才会加载执行。<code>AMD</code> 是推崇依赖前置，提前执行，<code>CMD</code> 推崇依赖就近延迟执行。</p><p><code>CMD</code>是 <code>Sea.js</code>推广过程中的产生的；</p><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义暴露模块-1"><a href="#定义暴露模块-1" class="headerlink" title="定义暴露模块"></a>定义暴露模块</h3><p>在<code>CMD</code>中规范中， 一个模块就是一个文件， 定义暴露模块的格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(factory)</span><br></pre></td></tr></table></figure><p>当<code>factory</code>为函数时，表示是模块的构造方法，执行这个构造方法就可以得到模块向外提供的接口。</p><p><code>factory</code>方法在执行的时候，默认会传入三个参数：<code>require</code>，<code>exports</code>和<code>module</code>。</p><ul><li><p>require 是一个方法，用来获取其他模块提供的接口</p><p><code>require.async</code> 方法用来在模块内部异步加载模块，并在加载完成后执行指定回调。<code>callback</code> 参数可选</p><blockquote><p><strong>注意</strong>：<code>require</code> 是同步往下执行，<code>require.async</code> 则是异步回调执行。<code>require.async</code> 一般用来加载可延迟异步加载的模块。</p></blockquote></li><li><p>exports 是一个对象， 用来向外部提供模块接口</p></li><li><p>module 是一个对象，存储了与当前模块相关联的一些属性和方法</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.xxx = value</span><br><span class="line">  <span class="built_in">module</span>.exports = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 引入依赖模块（同步）</span></span><br><span class="line"><span class="keyword">const</span> module1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 引入依赖模块（异步）</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&#x27;./module2&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">module2</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="引用使用模块"><a href="#引用使用模块" class="headerlink" title="引用使用模块"></a>引用使用模块</h3><p>使用 <code>require</code> 来引用模块。上面代码也写过。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 引入 CMD模块 module1</span></span><br><span class="line">  <span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  <span class="comment">// 引入 CMD模块 module2</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="举例子🌰"><a href="#举例子🌰" class="headerlink" title="举例子🌰"></a>举例子🌰</h2><p><code>CMD</code>是 <code>Sea.js</code>推广过程中的产生的；所有结合 <code>Sea.js</code>来使用。</p><p>在原先的项目结构目录上我们加载<code>CMD</code>目录, 添加文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|--CMD</span><br><span class="line">  |--index.html</span><br><span class="line">  |--module1.js</span><br><span class="line">  |--module2.js</span><br><span class="line">  |--module3.js</span><br><span class="line">  |--main.js</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="引入Sea-js"><a href="#引入Sea-js" class="headerlink" title="引入Sea.js"></a>引入<code>Sea.js</code></h4><ul><li>官网: <a href="http://seajs.org/">seajs.org/</a></li><li>github : <a href="https://github.com/seajs/seajs">github.com/seajs/seajs</a></li></ul><p><a href="https://seajs.github.io/seajs/docs/#downloads">在这里下载</a> 然后将<code>dist</code>目录下面的<code>sea.js</code>导入项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|--CMD</span><br><span class="line">  |--index.html</span><br><span class="line">  |--module1.js</span><br><span class="line">  |--module2.js</span><br><span class="line">  |--module3.js</span><br><span class="line">  |--main.js</span><br><span class="line">  |--sea.js</span><br></pre></td></tr></table></figure><h4 id="定义暴露模块-2"><a href="#定义暴露模块-2" class="headerlink" title="定义暴露模块"></a>定义暴露模块</h4><p>module1.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模块内部变量</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">  <span class="comment">// 模块内部函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露</span></span><br><span class="line">  <span class="built_in">exports</span>.getName = getName;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>module2.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define( <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span> </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模块内部变量</span></span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="comment">// 引入模块（同步）</span></span><br><span class="line">  <span class="keyword">const</span> module1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span>, module1.getName(), <span class="string">&#x27;age: &#x27;</span>, age)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向外暴露模块</span></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;  getMsg &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>module3.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define( <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.sex = <span class="string">&quot;女&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define( <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 引入模块（同步）</span></span><br><span class="line">  <span class="keyword">const</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2&#x27;</span>);</span><br><span class="line">  module2.getMsg();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 引入模块（异步）</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&#x27;./module3&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">module3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是异步加载的：&#x27;</span>, module3.sex)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="浏览器使用模块"><a href="#浏览器使用模块" class="headerlink" title="浏览器使用模块"></a>浏览器使用模块</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CMD<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>  <span class="attr">src</span>=<span class="string">&quot;./sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    CMD模块化 浏览器端使用</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        seajs.use(<span class="string">&#x27;./main.js&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p>控制台能成功打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: shuliqi age:  <span class="number">18</span></span><br><span class="line">我是异步加载的： 女</span><br></pre></td></tr></table></figure><h1 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h1><p>在 <code>ES6</code>之前，最只要是的模块规范是 <code>CommonJS</code> 和<code>AMD</code>,<code>CommonJS</code>主要用于服务端，<code>AMD</code>用于浏览器端；<code>ES6</code>实现了模块功能，完全可以取代 <code>CommonJS</code> 和<code>AMD</code>规范。</p><p> <code>ES6</code> 模块的设计思想是尽量静态化，使得编译时就能确定模块的依赖关系，输入和输出的变量。而<code>CommonJS</code> 和<code>AMD</code>都是只能在运行的时候才能确定这些:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS</span></span><br><span class="line"><span class="keyword">let</span> &#123; start, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>这代码实质是加载<code>fs</code>模块（即加载<code>fs</code>的所有模块）生成一个对象<code>_fs</code>, 然后再从这个对象上读取 3 个方法。 这种加载就称为”运行时加载“， 因为只有运行了才能得到这个对象，导致完全没办法在编译时做”静态化“</p><p>而<code>ES6</code>模块不是对象，而是通过<code>export</code>命令显示的指定输出的代码，再通过<code>import</code>命令输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这代码的实质是从<code>fs</code>模块加载3 个方法，其他方法不加载，这种加载称为”编译时加载“或者”静态加载“，即 ES6可以在编译时就完成模块加载， 效率要比 <code>CommonJS</code>模块的加载方式高。</p><h2 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义暴露模块-3"><a href="#定义暴露模块-3" class="headerlink" title="定义暴露模块"></a>定义暴露模块</h3><p>使用 <code>export</code>命令， <code>export default </code>命令来暴露对外的接口。其中<code>export default </code>命令是为模块指定默认输出</p><blockquote><p>使用 <code>export</code>暴露对外的接口， <code>import</code>引用的时候需要知道所要加载的变量名/函数名，否则无法加载，为了给用户提供方便，让他们不需要阅读文档就能加载模块，就可以使用<code>export default </code>命令来为模块指定默认输出。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴露变量 （export 命令）</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为模块指定默认输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;shuliqi&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴露函数或者类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用模块-2"><a href="#引用模块-2" class="headerlink" title="引用模块"></a>引用模块</h3><p>使用 <code>import</code>命令来加载模块。但是暴露模块的方式，<code>import</code> 的使用会有所不同</p><ul><li><p>如果是使用<code>export</code>命令定义了模块的对外接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export.js</span></span><br><span class="line"><span class="comment">// 暴露变量 （export 命令）</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./export.js&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果使用 <code>export default</code>来加载模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="comment">// 为模块指定默认输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;shuliqi&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default.js&#x27;</span>;</span><br><span class="line">customName()</span><br></pre></td></tr></table></figure></li></ul><h2 id="例子🌰-1"><a href="#例子🌰-1" class="headerlink" title="例子🌰"></a>例子🌰</h2><p>在原来的项目结构上，加载<code>ES6</code>文件夹及其一些文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|--ES6</span><br><span class="line">  |--module1.js</span><br><span class="line">  |--module2.js</span><br><span class="line">  |--main.js</span><br><span class="line">  |--index.js</span><br><span class="line">  |--lib</span><br><span class="line">  |--bundle.js</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="定义暴露模块-4"><a href="#定义暴露模块-4" class="headerlink" title="定义暴露模块"></a>定义暴露模块</h3><p>module1.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 export 暴露模块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">18</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; name, getName &#125;;</span><br></pre></td></tr></table></figure><p>module2.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 export default 为模块指定默认输出</span></span><br><span class="line"><span class="keyword">const</span> sex = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用模块-3"><a href="#引用模块-3" class="headerlink" title="引用模块"></a>引用模块</h3><p>main.js </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, getName &#125; <span class="keyword">from</span> <span class="string">&#x27;./module1.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> getSex <span class="keyword">from</span> <span class="string">&#x27;./module2.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">getName();</span><br><span class="line">getSex();</span><br></pre></td></tr></table></figure><h3 id="安装转换器和编译器"><a href="#安装转换器和编译器" class="headerlink" title="安装转换器和编译器"></a>安装转换器和编译器</h3><p>由于目前各大浏览器对<code>ES6</code>的支持大不相同, 所以通常需要把<code>ES6</code>代码转换成<code>ES5</code>的代码，这就需要转换器，如现在广泛使用的 <a href="https://babeljs.io/">Babel</a> 。转换完之后代码需要再编译一下， 就可以在浏览器使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装babel-cli, babel-preset-es2015和browserify</span></span><br><span class="line">npm install babel-cli browserify -g</span><br><span class="line">npm install babel-preset-es2015 --save-dev</span><br></pre></td></tr></table></figure><p>在跟目录添加 <code>.babelrc</code>文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>:[</span><br><span class="line">      <span class="string">&quot;es2015&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转码我们写的<code>ES6</code>代码和编译我们的转码之后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转码</span></span><br><span class="line">babel src/ES6 -d src/ES6/lib   </span><br><span class="line"><span class="comment">// 编译</span></span><br><span class="line">browserify src/ES6/lib/main.js -o src/ES6/bundle.js</span><br></pre></td></tr></table></figure><p>完成之后我们的ES6文件目录为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|--ES6</span><br><span class="line">  |--module1.js</span><br><span class="line">  |--module2.js</span><br><span class="line">  |--main.js</span><br><span class="line">  |--index.js</span><br><span class="line">  |--lib</span><br><span class="line">       |--module1.js</span><br><span class="line">       |--module2.js</span><br><span class="line">       |--main.js</span><br><span class="line">  |--bundle.js</span><br></pre></td></tr></table></figure><h3 id="html-文件使用"><a href="#html-文件使用" class="headerlink" title="html 文件使用"></a>html 文件使用</h3><p>最后在我们的html文件中加载我们转码和编译之后的代码 <code>bundle.js</code></p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ES6<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ES6 浏览器端使用</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开浏览器，结果： 控制台能正确打印出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shuliqi</span><br><span class="line">18</span><br><span class="line">女</span><br></pre></td></tr></table></figure><p><strong>最后</strong></p><p>最后文章所有的示例可以在<a href="https://github.com/shuliqi/module-example">module-example</a>下载</p><hr><p>参考文章：</p><ul><li><a href="https://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html">浏览器加载 CommonJS 模块的原理与实现</a></li><li><a href="https://javascript.ruanyifeng.com/nodejs/module.html">CommonJS规范</a></li><li><a href="https://juejin.cn/post/6844903744518389768#heading-20">前端模块化详解(完整版)</a></li><li><a href="http://browserify.org/">browserify</a></li></ul><ul><li><a href="https://javascript.ruanyifeng.com/tool/requirejs.html">RequireJS和AMD规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/75980415">前端模块化（AMD、CommonJS、UMD）总结</a></li><li><a href="https://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html">Javascript模块化编程（二）：AMD规范</a></li><li><a href="https://github.com/requirejs/requirejs">github-requirejs</a></li><li><a href="https://ahuigo.github.io/b/ria/js-module-amd#/">JS AMD 模块规范</a></li><li><a href="https://requirejs.org/">requirejs</a></li></ul><ul><li><p><a href="http://jxjweb.top/2017/08/0809.html">jxj-web</a></p></li><li><p><a href="https://github.com/seajs/seajs">seajs</a></p></li><li><p><a href="https://seajs.github.io/seajs/docs/#downloads">seajs官网</a></p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/41231046">JS模块化加载之CommonJS、AMD、CMD、ES6</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1683007">前端模块化：CommonJS,AMD,CMD,ES6</a></p></li><li><p><a href="https://javascript.ruanyifeng.com/tool/browserify.html">Browserify：浏览器加载Node.js模块</a></p></li><li><p><a href="http://browserify.org/">browserify</a></p></li><li><p><a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git提交规范及如何配置</title>
      <link href="/2021/01/15/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/"/>
      <url>/2021/01/15/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p><code>Git</code> 是现在比较流行的版本控制工具，在开发的过程中，<code>Git </code>每次提交代码，都需要写<code>Commit message </code>（即提交说明）。如果没有对 <code>Commit message </code>进行规范，会造成很多的麻烦，比如：</p><ul><li>每个人的 <code>Commit message </code>风格不同，格式凌乱，查看就换个不方便</li><li>有一些commit  没有写 <code>message</code>，事后就很难知道对应修改的作用。</li></ul><p> 所以说规范的 Commit <code>message </code>是很有必要的。也是有很多的好处的，比如：</p><ul><li>可以统一团队的<code>Git commit </code>日志风格</li><li>方便日后查阅， <code>Reviewing Code</code>等</li><li>可以帮助我们写好 <code>Changelog</code></li><li>能提升项目的整体质量</li></ul> <span id="more"></span><p>我们要配置<code>git</code>提交规范的话， 肯定需要知道它的规范是什么？先来看<code>Git Commit</code> 规范 是什么？</p><h1 id="Git-Commit-规范"><a href="#Git-Commit-规范" class="headerlink" title="Git Commit  规范"></a>Git Commit  规范</h1><p>目前规范使用较多的是 <a href="https://www.barretlee.com/blog/2019/10/28/commit-convention/">Angular 团队得规范</a> 我们也叫这种规范做: <strong>Git 约定式提交规范</strong>。</p><p>这种规范提供了一中轻量级的的提交历史编写规则，它的内容十分的简单:</p><p>它包含了三个部分：<code>Heade</code>r，<code>Body</code>，<code>Footer</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意冒号 : 后有空格</span></span><br><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line"><span class="comment">//  空一行</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="comment">// 空一行</span></span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>Header</code> 是必需的，<code>Body</code> 和<code> Footer</code> 可以省略。</p><blockquote><p><strong>注意：</strong> 不管是哪一个部分，任何一行都不得操作72个字符（或者100个字符）。 当然， 这只是避免自动换行影响美观而已。</p></blockquote><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p><code>Header</code> 部分 只有一行，包括三个字段：**<code>type(必填</code>)<strong>，</strong><code>scope(可选)</code><strong>，</strong><code>subject(必填)</code>**</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段用于说明<code> commit</code> 的类别，它允许使用下面的标识</p><ul><li><p><code>feat</code>：新功能（<code>feature</code>）</p></li><li><p><code>fix</code>： 修改<code>bug</code></p></li><li><p><code>docs</code>：文档（<code>documentation</code>）</p></li><li><p><code>style</code>：格式（不影响代码运行的变动）</p></li><li><p><code>refactor</code>：重构（即不是新增功能，也不是修改<code>bug</code>的代码变动）</p></li><li><p><code>test</code>：增加测试</p></li><li><p><code>chore</code>：构建过程或者辅助工具的变动</p></li></ul><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p><code>scope </code>用于说明  <code>commit </code>的影响范围，比如： 数据层，控制层，视图层等等。因具体项目而定。</p><h3 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h3><p><code>subject </code>用于说明 <code>commit</code> 目的的简短描述，最好不要操作50 个字符。我们在写<code>ubject</code>的时候需要注意：</p><ul><li>以动词开头，使用第一人称现在时，比如：<code>change</code>，而不是<code>changed</code> 或者 <code>changes</code></li><li>第一个字母小写</li><li>结尾不加句号</li></ul><h2 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h2><p><code>Body</code> 部分是对本次 <code>commit</code> 的详细描述，可以分成多行。写Body 部分的时候也需要注意：</p><ul><li>使用第一人称现在时候， 比如使用 <code>change</code> 而不是 <code>changed</code> 或 <code>changes</code></li><li>应该说明代码变动的动机，以及与以前行为的对比</li></ul><h2 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h2><p>Footer 部分只用于这两种情况：</p><h3 id="不兼容变动"><a href="#不兼容变动" class="headerlink" title="不兼容变动"></a>不兼容变动</h3><p>如果当前的代码与上一版本不兼容，则<code>Footer</code> 部分以<code> BREAKING CHANGE</code> 开头， 后面是对变动的描述，以及变动的理由和迁移的办法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      <span class="attr">myAttr</span>: <span class="string">&#x27;attribute&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">After</span>:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      <span class="attr">myAttr</span>: <span class="string">&#x27;@&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed <span class="string">`inject`</span> wasn<span class="string">&#x27;t generaly useful for directives so there should be no code using it.</span></span><br></pre></td></tr></table></figure><h3 id="关闭Issue"><a href="#关闭Issue" class="headerlink" title="关闭Issue"></a>关闭Issue</h3><p>如果当前的<code>commit</code> 是针对某个<code> issue</code>。那么在<code>footer</code>部分关闭这个<code>iissue</code>。可以一次性关系多个<code>issue</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closes #<span class="number">123</span>, #<span class="number">245</span>, #<span class="number">992</span></span><br></pre></td></tr></table></figure><h2 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h2><p> 有一种特殊情况， 如果当前的<code>commit</code> 是用于撤销 以前的``commit <code>的，则必须以</code>Revert <code>开头。 后面紧跟着被撤销的</code>Commit<code>的</code>Header`。</p><p><code>Body</code>部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销<code>commit</code>的 <code>SHA</code> 标识符。</p><p>如果当前<code> commit</code> 与被撤销的<code>commit</code>，在同一个发布（<code>release</code>）里面，那么它们都不会出现在 <code>Change log</code> 里面。如果两者在不同的发布，那么当前 <code>commit</code>，会出现在 <code>Change log</code> 的<code>Reverts</code>小标题下面。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我们新建一个文件夹:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir  gitCommit</span><br></pre></td></tr></table></figure><p>然后进入到这个文件夹:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd gitCommit</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>新建一个文件: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch index.js</span><br></pre></td></tr></table></figure><p>执行:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure><p>这时候我们开始写提交的<code>commit message</code>，命令行输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p>这时候会跳出编辑器让我们编写<code> message</code>， 我们则可以写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feat:(*): 添加index.js文件</span><br><span class="line"></span><br><span class="line">在根目录添加了indexjs文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这<code>commit message</code>的 <code>Header</code> 为<code> feat:(*): 添加index.js文件</code>），表示：我们加了一个新功能（<code>type = feat</code>），它的影响范围是*（<code>scope = </code>*）, 它的简短描述(<code>subject</code>)是：添加<code>index.js</code>文件</p><p>这<code>commit message</code> 的<code> Body</code> 为： <code> 在根目录添加了indexjs文件</code>。表示这次的<code>commit</code> 的简单描述是： <code> 在根目录添加了indexjs文件</code></p><p>如果我们要撤销上面的 <code>commit</code> 。 我们这可以 使用 <code>git revert &lt;commitId&gt;</code></p><p>我们可以下先使用 <code>git log</code>, 找出要 revert 的 commitId 0（f6c37576c793b2e2f4e66a87f96c2e825e073d35）</p><p>然后执行：<code>git revert f6c37576c793b2e2f4e66a87f96c2e825e073d35</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Revert <span class="string">&quot;feat:(*): 添加index.js文件&quot;</span></span><br><span class="line"></span><br><span class="line">This reverts commit f6c37576c793b2e2f4e66a87f96c2e825e073d35.</span><br></pre></td></tr></table></figure><p>这是的提交规范是这样的，已经默认帮我们写好了。当然我们也是可以修改的。</p><h1 id="配置-git-提交规范"><a href="#配置-git-提交规范" class="headerlink" title="配置 git 提交规范"></a>配置 git 提交规范</h1><p>当然，在我们的日常开发当中， 需要记住上面的规范， 有点繁琐。我们的目标还是要通过工具生成和约束。 那么我们现在就来配置吧！</p><h2 id="Commitizen"><a href="#Commitizen" class="headerlink" title="Commitizen"></a>Commitizen</h2><p>那么有什么 工具可以 做到生成规范并且约束呢？ <a href="https://github.com/commitizen/cz-cli">Commitizen</a>就是一个很不错的， 很合格的工具，</p><p><code>Commitizen/cz-cli</code>: 是一个格式化 <code>commit message</code> 的工具，可以约束提交者按照制定的规范一步一步的填写 <code>commit message</code>。</p><p><strong>安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commitizen --save</span><br></pre></td></tr></table></figure><p>然后在项目的根目录里， 执行以下的命令，使其支持<code>Angular</code> 的 <code>commit message</code> 格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><p>我们打开<code> packge.json</code>。 可以看到配置为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;config&quot;: &#123;</span><br><span class="line">  &quot;commitizen&quot;: &#123;</span><br><span class="line">    &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，只要是用到 <code>git commit </code>命令，一律改为使用 <code>git cz</code>， 然后就会出现选项， 用来生成符合格式的 <code>commit message</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git cz</span><br><span class="line"></span><br><span class="line">cz-cli@<span class="number">4.2</span><span class="number">.3</span>, cz-conventional-changelog@<span class="number">3.3</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">? Select the type <span class="keyword">of</span> change that you<span class="string">&#x27;re committing: (Use arrow keys)</span></span><br><span class="line"><span class="string">❯ feat:     A new feature </span></span><br><span class="line"><span class="string">  fix:      A bug fix </span></span><br><span class="line"><span class="string">  docs:     Documentation only changes </span></span><br><span class="line"><span class="string">  style:    Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) </span></span><br><span class="line"><span class="string">  refactor: A code change that neither fixes a bug nor adds a feature </span></span><br><span class="line"><span class="string">  perf:     A code change that improves performance </span></span><br><span class="line"><span class="string">  test:     Adding missing tests or correcting existing tests </span></span><br></pre></td></tr></table></figure><h2 id="cz-customizable"><a href="#cz-customizable" class="headerlink" title="cz-customizable"></a>cz-customizable</h2><p>上面是直接使用 <code>cz-conventional-changelog</code> 作为 Adapter。但是如果需要自定义<code> Adapter</code>， 比如：默认提交的<code>types </code>非常多；或者有些使用我们可能只需要其中的某些<code>type</code>。或者自定义一些<code>type</code>，那么就可以通过 <code>cz-customizable</code> 来自定义了。</p><p><strong>安装</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i cz-customizable --save</span><br></pre></td></tr></table></figure><p>将之前符合<code>Angular</code>规范的**<code>cz-conventional-changelog</code><strong>适配器路径改成</strong><code>cz-customizable</code>**适配器路径：  **”<code>path</code>“: “<code>./node_modules/cz-conventional-changelog</code>“ **改成  <strong>“<code>path</code>“: “<code>./node_modules/cz-customizable</code>“</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;path&quot;</span>: <span class="string">&quot;./node_modules/cz-customizable&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><p>在跟目录下新建.<code>cz-config.js</code>。 内容的示例文件如：<a href="https://github.com/leonardoanalista/cz-customizable/blob/master/cz-config-EXAMPLE.js">cz-config-EXAMPLE.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">types</span>: [</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">&#x27;feat&#x27;</span>,     <span class="attr">name</span>: <span class="string">&#x27;feat:     A new feature&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">&#x27;fix&#x27;</span>,      <span class="attr">name</span>: <span class="string">&#x27;fix:      A bug fix&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">&#x27;docs&#x27;</span>,     <span class="attr">name</span>: <span class="string">&#x27;docs:     Documentation only changes&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">&#x27;style&#x27;</span>,    <span class="attr">name</span>: <span class="string">&#x27;style:    Changes that do not affect the meaning of the code\n            (white-space, formatting, missing semi-colons, etc)&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">&#x27;refactor&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;refactor: A code change that neither fixes a bug nor adds a feature&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">&#x27;perf&#x27;</span>,     <span class="attr">name</span>: <span class="string">&#x27;perf:     A code change that improves performance&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">&#x27;test&#x27;</span>,     <span class="attr">name</span>: <span class="string">&#x27;test:     Adding missing tests&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">&#x27;chore&#x27;</span>,    <span class="attr">name</span>: <span class="string">&#x27;chore:    Changes to the build process or auxiliary tools\n            and libraries such as documentation generation&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">&#x27;revert&#x27;</span>,   <span class="attr">name</span>: <span class="string">&#x27;revert:   Revert to a commit&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">value</span>: <span class="string">&#x27;WIP&#x27;</span>,      <span class="attr">name</span>: <span class="string">&#x27;WIP:      Work in progress&#x27;</span>&#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="attr">scopes</span>: [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;accounts&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;admin&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;exampleScope&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;changeMe&#x27;</span>&#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// it needs to match the value for field type. Eg.: &#x27;fix&#x27;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  scopeOverrides: &#123;</span></span><br><span class="line"><span class="comment">    fix: [</span></span><br><span class="line"><span class="comment">      &#123;name: &#x27;merge&#x27;&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: &#x27;style&#x27;&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: &#x27;e2eTest&#x27;&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: &#x27;unitTest&#x27;&#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// override the messages, defaults are as follows</span></span><br><span class="line">  <span class="attr">messages</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;Select the type of change that you\&#x27;re committing:&#x27;</span>,</span><br><span class="line">    <span class="attr">scope</span>: <span class="string">&#x27;\nDenote the SCOPE of this change (optional):&#x27;</span>,</span><br><span class="line">    <span class="comment">// used if allowCustomScopes is true</span></span><br><span class="line">    <span class="attr">customScope</span>: <span class="string">&#x27;Denote the SCOPE of this change:&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;Write a SHORT, IMPERATIVE tense description of the change:\n&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&#x27;Provide a LONGER description of the change (optional). Use &quot;|&quot; to break new line:\n&#x27;</span>,</span><br><span class="line">    <span class="attr">breaking</span>: <span class="string">&#x27;List any BREAKING CHANGES (optional):\n&#x27;</span>,</span><br><span class="line">    <span class="attr">footer</span>: <span class="string">&#x27;List any ISSUES CLOSED by this change (optional). E.g.: #31, #34:\n&#x27;</span>,</span><br><span class="line">    <span class="attr">confirmCommit</span>: <span class="string">&#x27;Are you sure you want to proceed with the commit above?&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">allowCustomScopes</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">allowBreakingChanges</span>: [<span class="string">&#x27;feat&#x27;</span>, <span class="string">&#x27;fix&#x27;</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// limit subject length</span></span><br><span class="line">  <span class="attr">subjectLimit</span>: <span class="number">100</span></span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以对这个配置进行汉化处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// type 类型</span></span><br><span class="line">  <span class="attr">types</span>: [</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;feat&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;feat:     新增产品功能&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;fix&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;fix:      修复 bug&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;docs&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;docs:     文档的变更&#x27;</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;style&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>:</span><br><span class="line">        <span class="string">&#x27;style:    不改变代码功能的变动(如删除空格、格式化、去掉末尾分号等)&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;refactor&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;refactor: 重构代码。不包括 bug 修复、功能新增&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;perf&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;perf:     性能优化&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;test&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;test:     添加、修改测试用例&#x27;</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;build&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;build:    构建流程、外部依赖变更，比如升级 npm 包、修改 webpack 配置&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;ci&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;ci:       修改了 CI 配置、脚本&#x27;</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;chore&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;chore:    对构建过程或辅助工具和库的更改,不影响源文件、测试用例的其他操作&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;revert&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;revert:   回滚 commit&#x27;</span> &#125;,</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scope 类型，针对 React 项目</span></span><br><span class="line">  <span class="attr">scopes</span>: [</span><br><span class="line">    [<span class="string">&#x27;components&#x27;</span>, <span class="string">&#x27;组件相关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;hooks&#x27;</span>, <span class="string">&#x27;hook 相关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;hoc&#x27;</span>, <span class="string">&#x27;HOC&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;utils&#x27;</span>, <span class="string">&#x27;utils 相关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;antd&#x27;</span>, <span class="string">&#x27;对 antd 主题的调整&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;element-ui&#x27;</span>, <span class="string">&#x27;对 element-ui 主题的调整&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;styles&#x27;</span>, <span class="string">&#x27;样式相关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;deps&#x27;</span>, <span class="string">&#x27;项目依赖&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;auth&#x27;</span>, <span class="string">&#x27;对 auth 修改&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;other&#x27;</span>, <span class="string">&#x27;其他修改&#x27;</span>],</span><br><span class="line">    <span class="comment">// 如果选择 custom ,后面会让你再输入一个自定义的 scope , 也可以不设置此项， 把后面的 allowCustomScopes 设置为 true</span></span><br><span class="line">    [<span class="string">&#x27;custom&#x27;</span>, <span class="string">&#x27;以上都不是？我要自定义&#x27;</span>],</span><br><span class="line">  ].map(<span class="function">(<span class="params">[value, description]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">`<span class="subst">$&#123;value.padEnd(<span class="number">30</span>)&#125;</span> (<span class="subst">$&#123;description&#125;</span>)`</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allowTicketNumber: false,</span></span><br><span class="line">  <span class="comment">// isTicketNumberRequired: false,</span></span><br><span class="line">  <span class="comment">// ticketNumberPrefix: &#x27;TICKET-&#x27;,</span></span><br><span class="line">  <span class="comment">// ticketNumberRegExp: &#x27;\\d&#123;1,5&#125;&#x27;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以设置 scope 的类型跟 type 的类型匹配项，例如: &#x27;fix&#x27;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    scopeOverrides: &#123;</span></span><br><span class="line"><span class="comment">      fix: [</span></span><br><span class="line"><span class="comment">        &#123; name: &#x27;merge&#x27; &#125;,</span></span><br><span class="line"><span class="comment">        &#123; name: &#x27;style&#x27; &#125;,</span></span><br><span class="line"><span class="comment">        &#123; name: &#x27;e2eTest&#x27; &#125;,</span></span><br><span class="line"><span class="comment">        &#123; name: &#x27;unitTest&#x27; &#125;</span></span><br><span class="line"><span class="comment">      ]</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 覆写提示的信息</span></span><br><span class="line">  <span class="attr">messages</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;请确保你的提交遵循了原子提交规范！\n选择你要提交的类型:&quot;</span>,</span><br><span class="line">    <span class="attr">scope</span>: <span class="string">&#x27;\n选择一个 scope (可选):&#x27;</span>,</span><br><span class="line">    <span class="comment">// 选择 scope: custom 时会出下面的提示</span></span><br><span class="line">    <span class="attr">customScope</span>: <span class="string">&#x27;请输入自定义的 scope:&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;填写一个简短精炼的描述语句:\n&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&#x27;添加一个更加详细的描述，可以附上新增功能的描述或 bug 链接、截图链接 (可选)。使用 &quot;|&quot; 换行:\n&#x27;</span>,</span><br><span class="line">    <span class="attr">breaking</span>: <span class="string">&#x27;列举非兼容性重大的变更 (可选):\n&#x27;</span>,</span><br><span class="line">    <span class="attr">footer</span>: <span class="string">&#x27;列举出所有变更的 ISSUES CLOSED  (可选)。 例如.: #31, #34:\n&#x27;</span>,</span><br><span class="line">    <span class="attr">confirmCommit</span>: <span class="string">&#x27;确认提交?&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否允许自定义填写 scope ，设置为 true ，会自动添加两个 scope 类型 [&#123; name: &#x27;empty&#x27;, value: false &#125;,&#123; name: &#x27;custom&#x27;, value: &#x27;custom&#x27; &#125;]</span></span><br><span class="line">  <span class="comment">// allowCustomScopes: true,</span></span><br><span class="line">  <span class="attr">allowBreakingChanges</span>: [<span class="string">&#x27;feat&#x27;</span>, <span class="string">&#x27;fix&#x27;</span>],</span><br><span class="line">  <span class="comment">// skip any questions you want</span></span><br><span class="line">  <span class="comment">// skipQuestions: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// subject 限制长度</span></span><br><span class="line">  <span class="attr">subjectLimit</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="comment">// breaklineChar: &#x27;|&#x27;, // 支持 body 和 footer</span></span><br><span class="line">  <span class="comment">// footerPrefix : &#x27;ISSUES CLOSED:&#x27;</span></span><br><span class="line">  <span class="comment">// askForBreakingChangeFirst : true,</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到此， 我们使用 <code>cz-customizable</code>  就自定义配置完了。</p><p>最后我们使用 <code>git cz</code>命令进行提交说明：</p>   <img src="/2021/01/15/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/1.png" class=""><p>上图我们就可以看出此时的提交说明已经汉化， 我们继续写提交说明：</p>   <img src="/2021/01/15/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/2.png" class=""><p>最后我们提交到远端看到效果如下：</p>  <img src="/2021/01/15/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/3.png" class=""><h2 id="Commitizen校验"><a href="#Commitizen校验" class="headerlink" title="Commitizen校验"></a>Commitizen校验</h2><p>我们前面已经约束了一套代码规范提交说明了， 但是还是有人不按照规范提交代码说明怎么呢？， 那么就需要 <a href="https://github.com/marionebl/commitlint">commitlint</a>来校验 commit 了。</p><p><strong>安装commitlint</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @commitlint/cli</span><br></pre></td></tr></table></figure><p><strong>安装@commitlint/config-conventional</strong></p><p>安装符合<code>Abgular</code>风格校验规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @commitlint/config-conventional</span><br></pre></td></tr></table></figure><p>然后在项目中新建 <code>commitlint.config.js</code>文件，并且设置校验规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;@commitlint/config-conventional&#x27;</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>安装安装huksy（git钩子工具）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky --save-dev</span><br></pre></td></tr></table></figure><p>然后在packge.json 中配置 <code>git commit</code>提交时的钩子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;commit-msg&quot;</span>: <span class="string">&quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意</strong>，使用该校验规则不能对<code>.cz-config.js</code>进行不符合<code>Angular</code>规范的定制处理，例如之前的汉化，此时需要将<code>.cz-config.js</code>的文件按照官方示例文件<a href="https://github.com/leonardoanalista/cz-customizable/blob/master/cz-config-EXAMPLE.js">cz-config-EXAMPLE.js</a>进行符合<code>Angular</code>风格的改动。</p><p>最后我们来试一试：</p><p>提交不符合规范的错误提示：</p>  <img src="/2021/01/15/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/4.png" class=""><p>提交符合规范的提示：</p>  <img src="/2021/01/15/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/5.png" class=""><p><strong>需要注意</strong>：如果使用了 <strong>cz-customizable</strong>配器做了破坏<code>Angular</code>风格的提交说明配置，那么不能使用**@commitlint/config-conventional**规则进行提交说明校验，可以使用<a href="https://github.com/whizark/commitlint-config-cz">commitlint-config-cz</a>对定制化提交说明进行校验。</p><p><strong>安装：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commitlint-config-cz --save-dev</span><br></pre></td></tr></table></figure><p>然后加入<code>commitlint</code>校验规则配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;cz&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里推荐使用**@commitlint/config-conventional**校验规则，如果想使用<code>cz-customizable</code>适配器，那么定制化的配置不要破坏Angular规范即可。</p></blockquote><h1 id="git-commit-触发-git-cz"><a href="#git-commit-触发-git-cz" class="headerlink" title="git commit 触发 git cz"></a>git commit 触发 git cz</h1><p>在提交的时候，我们都习惯了 <code>git commit</code> ，虽然换成 <code>git cz</code> 不难，但是如果让开发者在 <code>git commit</code> 时无感知的触发 <code>git cz</code> 肯定是更好的， 而且也能避免不熟悉项目的人直接 <code>git commit</code> 提交一些不符合规范的信息。</p><p>我们可以在<code>husky.config.js</code>中设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;prepare-commit-msg&quot;</span>: <span class="string">&quot;exec &lt; /dev/tty &amp;&amp; git cz --hook || true&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考文档：</strong></p><p><a href="https://juejin.cn/post/6854573220176068615">让你的commit更有价值</a></p><p><a href="https://github.com/leoforfree/cz-customizable">cz-customizable</a></p><p><a href="https://github.com/commitizen/cz-cli">cz-cli</a></p><p><a href="https://www.barretlee.com/blog/2019/10/28/commit-convention/">小胡子哥的个人博客</a></p><p><a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 工程配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS Grid网格布局</title>
      <link href="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"/>
      <url>/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>最近在参加一个小程序比赛，其中在做瀑布流布局的时候，有人拿Grid网格布局来做的，但是我觉得瀑布流并不是个用Grid网格布局来做，因为它每一个项目占多少网格，都需要人工去指定。虽然我觉得Grid网格布局不是个做瀑布流， 但是我觉得它还是非常强大的，甚至觉得比Flex强大。那么这篇文章就是来记录Grid网格布局的一个使用教程的。当翻阅可看。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们web页面开发过程中，我们可以使用css控制页面中元素的位置，主要的布局样式有以下几种：</p><ul><li>正常的布局流</li><li>display 属性</li><li>弹性盒子（<a href="https://shuliqi.github.io/shuliqi.github.io/2018/03/31/Flex%E5%B8%83%E5%B1%80/">FlexBox</a>）</li><li>网格（display：table）</li><li>浮动（float）</li><li>定位（position）</li><li>CSS Grid网格布局</li><li>多列布局（Multi-column layout）</li></ul><h1 id="什么是网格布局（Grid）？"><a href="#什么是网格布局（Grid）？" class="headerlink" title="什么是网格布局（Grid）？"></a>什么是网格布局（Grid）？</h1><p>网格布局（Grid）将网页分成一个个网格，可以任意组合不同的网格，设计出各种各样的的布局。</p><p>网格布局（Grid）将容器划分成“行” 和 “列”， 然后指定“项目所在”的单元格，可以看做是二维布局。Grid 布局远比 Flex 布局强大。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>学习 Grid 布局之前，需要了解一些基本概念。</p><h2 id="容器和项目"><a href="#容器和项目" class="headerlink" title="容器和项目"></a>容器和项目</h2><p>使用网格布局的区域，称为“容器”（container），容器内采用网格定位的子元素，称为“项目”（item）</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们给 class 为 <code>container</code>的元素设置它为 网格布局（Grid）。那么该元素就是容器， 里面的三个class为<code>tem</code>的元素就是项目。</p><p><strong>注意：</strong>项目只能是容器最顶层子元素，不包含项目的子元素。例如上面的<code>span</code>标签就不是项目。Grid布局就对项目生效。</p><h2 id="行，列，单元格，网格线"><a href="#行，列，单元格，网格线" class="headerlink" title="行，列，单元格，网格线"></a>行，列，单元格，网格线</h2><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/3.png" class=""><p><strong>行和列：</strong></p><p>容器里面的水平区域称为”行“（row）；垂直区域称为”列“（column）。 上图中的水平绿色区域就是”行“。垂直的蓝色区域就是”列“。</p><p><strong>单元格：</strong></p><p>行和列的交叉区域称为”单元格“(cell)。如上图显示”单元格“的区域就是其中的一个单元格</p><p><strong>网格线：</strong></p><p>划分为网格的线，称为：”网格线“（grid line）。水平网格线划分出行，垂直网格线划分出列。日上图中就有5个水平网格线 和 10 个垂直网格线。</p><h1 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h1><p>Grid 布局的属性分为两类。一类是定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这里我们先讲容器属性。</p><h2 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h2><p>使用<code>display:grid</code>指定一个容器采用网格布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如：</p><iframe height="400" style="width: 100%;" scrolling="no" title="KKgVeKX" src="https://codepen.io/shuliqi/embed/KKgVeKX?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/KKgVeKX'>KKgVeKX</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe>默认情况下，容器元素都是块级元素，单也可以设置为行内元素。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如：</p><iframe height="400" style="width: 100%;" scrolling="no" title="网格布局inline-grid" src="https://codepen.io/shuliqi/embed/qBabKoB?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/qBabKoB'>网格布局inline-grid</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>上面的这个例子指定了 class 为 <code>grid</code>的 div 为行内元素，该元素内部的项目使用网格布局。</p><p><strong>注意：</strong> 设置网格布局之后，容器项目的 <code>float</code>，<code>display: inline-block</code>,<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置将会失效。</p><h2 id="grid-template-columns属性"><a href="#grid-template-columns属性" class="headerlink" title="grid-template-columns属性"></a>grid-template-columns属性</h2><h2 id="grid-template-rows-属性"><a href="#grid-template-rows-属性" class="headerlink" title="grid-template-rows 属性"></a>grid-template-rows 属性</h2><p>容器指定了网格布局之后，就需要划分行和列。<code>grid-template-columns</code> 属性用来定义每一列的宽度，<code>grid-template-rows</code>属性用来定义每一行的行高。</p><p>例如我们上面两个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上：指定了一个两行两列的网格，列宽和行高都是 <code>100px</code>。</p><p>当然<code>grid-template-columns</code> 和<code>grid-template-rows</code>属性除了可以使用绝对值外，也可以使用百分比的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">  grid-template-rows: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>有时候列宽可能是固定， 到那时我们在指定每一列的列宽时，都需要一一写上。就很麻烦。这时候就可以使用repeat()函数，简化重复的值。</p><p><strong>repeat()：</strong>接受两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。例如上面的代码就可以写成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">50%</span>);</span><br><span class="line">  grid-template-rows: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>repeat()：</strong> 也可以重复某种模式。如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">200px</span>);</span><br><span class="line">  grid-template-rows:  <span class="built_in">repeat</span>(<span class="number">2</span>,  <span class="number">200px</span> <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height="600" style="width: 100%;" scrolling="no" title="grid网格布局repeat()" src="https://codepen.io/shuliqi/embed/LYRGgPv?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/LYRGgPv'>grid网格布局repeat()</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>如上这个例子的代码就表示：第一列和第三列的宽为80px，第二列和第四列的宽为100ox。</p><h4 id="auto-fill-关键字"><a href="#auto-fill-关键字" class="headerlink" title="auto-fill 关键字"></a>auto-fill 关键字</h4><p>有时候单元格的大小是固定的，但是容器的大小是不固定的。如果我们是希望没一行或者每一列能容纳尽可能多的单元格。就可以使用<code>auto-fill</code>关键字了。这个关键字表示自动填充。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height="400" style="width: 100%;" scrolling="no" title="auto-fill" src="https://codepen.io/shuliqi/embed/MWjKPwQ?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/MWjKPwQ'>auto-fill</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>例子代码表示：每列列宽为100px，然后自动填充，直到容器不能放置更多的列。</p><h4 id="fr关键字"><a href="#fr关键字" class="headerlink" title="fr关键字"></a>fr关键字</h4><p>为了方便的表示比列关系，网格布局提供了<code>fr</code> 关键字。如果两列的了宽度分别是 <code>1fr</code> 和 <code>2fr</code> 表示 后者的列宽是前者的两倍。</p><p>如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  grid-template-rows: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表示容器的高度被分为2等份，第一行和第二行的行高都各占了一份。容器的宽被分成2等份，第一列和第二列的列宽都个占了1份。</p><iframe height="400" style="width: 100%;" scrolling="no" title="fr" src="https://codepen.io/shuliqi/embed/OJRMBWW?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/OJRMBWW'>fr</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p> 再如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr <span class="number">3</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示容器的宽被分成了5份等份，第一列的列宽占了2份。第二列的列宽占了一份，第三列的列宽占了3份。</p><iframe height="400" style="width: 100%;" scrolling="no" title="xxEZydN" src="https://codepen.io/shuliqi/embed/xxEZydN?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/xxEZydN'>xxEZydN</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h4 id="minmax"><a href="#minmax" class="headerlink" title="minmax()"></a>minmax()</h4><p><code>minmax()</code>函数产生一个长度范围。它有两个参数，最大值和最小值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="built_in">minmax</span>(<span class="number">100</span>pox, <span class="number">200px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就表示，该项目的宽度不小于100px，不大于200px</p><h4 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h4><p>该关键字表示项目的宽度有浏览器自己决定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.grid &#123;  </span><br><span class="line">  display: grid;  </span><br><span class="line">  grid-template-columns: auto 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示第一个项目的宽度基本是等于该单元格的最大宽度。</p><h4 id="网格线的名称"><a href="#网格线的名称" class="headerlink" title="网格线的名称"></a>网格线的名称</h4><p>使用<code>grid-template-columns</code>属性和 <code>grid-template-rows</code>属性时，可以使用方括号，指定每一根网线的名字。方便之后的引用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;  </span><br><span class="line">  <span class="attribute">display</span>: grid;  </span><br><span class="line">  grid-template-<span class="attribute">columns</span>: [a1] auto [a2] <span class="number">100px</span> [a3];</span><br><span class="line">  grid-template-rows: [b1] <span class="number">100px</span> [b2] <span class="number">100px</span> [b3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上的代码指定的网格布局为两列两行，因此有3根水平网格线和3根垂直网格线。方括号里面依次是这6根网格线的名字。</p><iframe height="400" style="width: 100%;" scrolling="no" title="行间距和列间距" src="https://codepen.io/shuliqi/embed/OJRRaOm?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/OJRRaOm'>行间距和列间距</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p><strong>注意：</strong>网格布局允许同一根线可以有多个名字。如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: [a1 m1] auto [a2] <span class="number">100px</span> [a3];</span><br></pre></td></tr></table></figure><h2 id="grid-row-gap-属性，"><a href="#grid-row-gap-属性，" class="headerlink" title="grid-row-gap 属性，"></a>grid-row-gap 属性，</h2><h2 id="grid-column-gap属性"><a href="#grid-column-gap属性" class="headerlink" title="grid-column-gap属性"></a>grid-column-gap属性</h2><h2 id="grid-gap-属性"><a href="#grid-gap-属性" class="headerlink" title="grid-gap 属性"></a>grid-gap 属性</h2><p><code>grid-row-gap</code>属性设置行与行之间的间隔行间距</p><p><code>grid-column-gap</code> 属性设置列与列之间的间隔（列间距）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="comment">/*   行间距 */</span></span><br><span class="line">  grid-row-gap: <span class="number">20px</span>;</span><br><span class="line">  <span class="comment">/*   列间距 */</span></span><br><span class="line">  grid-<span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grid-gap</code> 属性是 <code>grid-column-gap</code>和 <code>grid-row-gap</code>的合并简写。语法:<code>grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;</code></p><p><strong>注意：</strong>如果<code>grid-gap</code>省略了第二个值。那么浏览器会默认为第二个值等于第一个值</p><p><strong>注意</strong>：根据最新的标准。<code>grid-row-gap</code>，<code>grid-column-gap</code>，<code>grid-gap</code> 这三个属性不用写前缀<code>grid</code>。</p><h2 id="grid-template-areas-属性"><a href="#grid-template-areas-属性" class="headerlink" title="grid-template-areas 属性"></a>grid-template-areas 属性</h2><p>网格布局允许执行“区域”（areas），一个区域有多个单元格组成。那么<code>grid-template-areas</code>属性就是用来定义区域的.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-row-gap: <span class="number">20px</span>;</span><br><span class="line">  grid-<span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="comment">/*   指定区域 */</span></span><br><span class="line">  grid-template-areas: <span class="string">&#x27;a b&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;c d&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height="400" style="width: 100%;" scrolling="no" title="指定区域" src="https://codepen.io/shuliqi/embed/oNzzQaj?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/oNzzQaj'>指定区域</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>上面的这个例子我们审查元素来看看。可以看出区域被分成了4部分 a b c d;</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/4.png" class=""><p><strong>多个单元格合并成一个单元格的写法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&#x27;a a&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;b b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如图：</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/5.png" class=""><p>这样就把把四个单元格分成了 a b  两个区域。</p><p>如果某个区域不需要的话，则使用  .  来表示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&#x27;a .&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;. b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如图：</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/6.png" class=""><p><strong>注意：</strong>区域的命名会影响到网格线，每个区域的起始网格线会自动命名为<code>区域名-start</code>,终止网格线会自动命名为<code>区域名-end</code>.</p><h2 id="grid-auto-flow-属性"><a href="#grid-auto-flow-属性" class="headerlink" title="grid-auto-flow 属性"></a>grid-auto-flow 属性</h2><p><code>grid-auto-flow</code>属性用来设置容器项目的放置顺序。主要有四个值：</p><h3 id="row"><a href="#row" class="headerlink" title="row:"></a><code>row</code>:</h3><p>默认值。表示放置顺序为”先行后列“。 也就是先填满第一行。再放入第二行。</p><blockquote><p>我们上面的所有的例子都是这样的（看元素中的数字可以看出），都是先放满第一行，再放如第二行。</p></blockquote><h3 id="column"><a href="#column" class="headerlink" title="column:"></a><code>column:</code></h3><p>表示”先列后行”。</p><p>如：</p><iframe height="462" style="width: 100%;" scrolling="no" title="先列后行" src="https://codepen.io/shuliqi/embed/MWjjNZw?height=462&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/MWjjNZw'>先列后行</a> by shuliqi    (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>从例子中可以看出来 1，2  在左边；3，  4 在右边。这是因为我们设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*   先列后行 */</span></span><br><span class="line">grid-<span class="attribute">auto</span>-flow: column;</span><br></pre></td></tr></table></figure><h3 id="row-dense"><a href="#row-dense" class="headerlink" title="row dense:"></a><code>row dense:</code></h3><p>表示”先行后列”，每一行尽可能精密填满，尽量不要有空格；</p><p>这个设置的意义在哪里呢？ 我们先来看一个例子：</p><iframe height="537" style="width: 100%;" scrolling="no" title="尽量不要有空格" src="https://codepen.io/shuliqi/embed/VwKKoNQ?height=537&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/VwKKoNQ'>尽量不要有空格</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe>在这个例子中， 我们采用的是”先行后列“的放置顺序；设置第一个项目和第二个项目列宽占两个单元格:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid-column-start: 1;</span><br><span class="line">grid-column-end: 3;</span><br></pre></td></tr></table></figure><p>然后就得到如上的结果，从结果可以看出，第一行空出了一个空白的地方。这是为什么呢？ 这是因为第三个项目默认跟着第二个项目，所以会排在第二个项目之后。</p><p> 但是我们把放置顺序改为：<code>row dense</code>。那么结果就是：</p>  <iframe height="467" style="width: 100%;" scrolling="no" title="QWKGLGb" src="https://codepen.io/shuliqi/embed/QWKGLGb?height=467&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">    See the Pen <a href='https://codepen.io/shuliqi/pen/QWKGLGb'>QWKGLGb</a> by shuliqi    (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.  </iframe><p>这个例子就可以看出来： 先是填满第一行，再填满第二行，并且每一行尽量不要有空格。所以第三个元素会在第一个元素后面</p><h3 id="column-dense"><a href="#column-dense" class="headerlink" title="column dense"></a><code>column dense</code></h3><p>表示 ”先列后行“ 并且每一列尽量不要有空格。</p><p>跟上一个的适用场景一样。 我们将放置顺序改为<code>column dense</code>；那么将得到这样的结果：</p><iframe height="544" style="width: 100%;" scrolling="no" title="GRjNKQb" src="https://codepen.io/shuliqi/embed/GRjNKQb?height=544&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/GRjNKQb'>GRjNKQb</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h2 id="justify-items-属性"><a href="#justify-items-属性" class="headerlink" title="justify-items 属性"></a>justify-items 属性</h2><h2 id="align-items-属性"><a href="#align-items-属性" class="headerlink" title="align-items 属性"></a>align-items 属性</h2><h2 id="place-items-属性"><a href="#place-items-属性" class="headerlink" title="place-items 属性"></a>place-items 属性</h2><p><code>justify-items</code>属性用来设置<strong>单元格内容</strong>的水平位置。<code>align-items</code> 属性用来设置<strong>单元格内容</strong>的垂直位置。这两个都有如下的值：</p><ul><li><code>start：</code> 对齐单元格的起始位置</li><li><code>end：</code>对齐单元格的结束边缘</li><li><code>center:</code>单元格内部居中</li><li><code>stretch </code>:项目大小没有指定时，拉伸占据整个网格容器。</li></ul><p>这里需要注意的是<strong>单元格内容</strong></p><p>例：</p><iframe height="315" style="width: 100%;" scrolling="no" title="jOMBmZg" src="https://codepen.io/shuliqi/embed/jOMBmZg?height=315&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/jOMBmZg'>jOMBmZg</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>如上的代码， 我们让每个单元格里面的内容水平位置居中，垂直位置居中。我们可以通过审查元素来看：</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/7.png" class=""><p>可以看出来，class为 item的元素在第一个单元格的位置都是单元格内部居中（水平位置居中，垂直位置居中）。</p><p>其他值我就不一一举例了。可以直接使用上面的例子，修改 <code> justify-items</code> 和 <code>align-items</code>的值看效果。</p><p><code>place-items 属性</code>是 <code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</span><br></pre></td></tr></table></figure><p>例：</p><iframe height="330" style="width: 100%;" scrolling="no" title="OJRpgJY" src="https://codepen.io/shuliqi/embed/OJRpgJY?height=330&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/OJRpgJY'>OJRpgJY</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe>如上的例子： 我们使用`place-items`设置了 垂直方向是对齐单元格的结束方向。水平方向是居中。我们可以审查元素来看：<img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/8.png" class=""><p>可以看出 来class为 item的元素在第一个单元格的位置是垂直方向是对齐单元格的结束方向。水平方向是居中。</p><p><strong>注意：</strong> <code>place-items</code>属性的第二个参数如果省略的话，则浏览器默认与第一个值相等。</p><h2 id="justify-content-属性"><a href="#justify-content-属性" class="headerlink" title="justify-content 属性"></a>justify-content 属性</h2><h2 id="align-content-属性"><a href="#align-content-属性" class="headerlink" title="align-content 属性"></a>align-content 属性</h2><h2 id="palce-content-属性"><a href="#palce-content-属性" class="headerlink" title="palce-content 属性"></a>palce-content 属性</h2><p><code>justify-content</code> 属性是设置整个内容区域在容器里面的水平位置，<code>align-content</code>属性是设置整个内容区域在容器里面的垂直位置。这两个属性都有如下的值：</p><ul><li><p><strong>start</strong>： 对齐容器的起始边框；</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/9.png" class=""></li><li><p><strong>end</strong>：对齐容器的结束边框;</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/10.png" class=""></li><li><p><strong>center</strong>：容器内部居中；</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/11.png" class=""></li><li><p><strong>stretch</strong> - 项目大小没有指定时，拉伸占据整个网格容器。</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/12.png" class=""></li><li><p><strong>space-around</strong> - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/13.png" class=""></li><li><p><strong>space-between</strong> - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/14.png" class=""></li><li><p><strong>space-evenly</strong> - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/15.png" class=""></li></ul><p><code>place-content</code>属性是 <code>justify-content</code>属性和<code>align-content</code>属性的合并缩写形式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</span><br></pre></td></tr></table></figure><p>如果<code>place-content</code>省略第二个值，那么浏览器就会默认第二个值等于第一个值。</p><h2 id="grid-auto-columns-属性"><a href="#grid-auto-columns-属性" class="headerlink" title="grid-auto-columns 属性"></a>grid-auto-columns 属性</h2><h2 id="grid-auto-rows-属性"><a href="#grid-auto-rows-属性" class="headerlink" title="grid-auto-rows 属性"></a>grid-auto-rows 属性</h2><p>有时候我们的项目的指定在网格的外面，那么浏览器就会自动根据单元格的大小生成多余的网格。</p><p><code>grid-auto-cloumns</code>属性 和 <code>grid-auto-rows</code>属性就是用来设置当浏览器自动创就按多余的网格的列宽和行高。这两个属性的法与<code>grid-template-columns</code>,<code>grid-template-rows</code>是一样的;</p><p>如：</p><iframe height="553" style="width: 100%;" scrolling="no" title="grid-auto-columns" src="https://codepen.io/shuliqi/embed/dypvRMq?height=553&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/dypvRMq'>grid-auto-columns</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>这个例子：第7 个项目超出了当前的网格（使用了<code>grid-row-start</code> 和 <code>grid-column-start</code>下面会有介绍），那么浏览器会自动生成多余的网格，我们设置多余的网格列宽和行高都是50px；</p><h1 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h1><p>定义在项目上的属性。</p><h2 id="grid-column-start-属性"><a href="#grid-column-start-属性" class="headerlink" title="grid-column-start 属性"></a>grid-column-start 属性</h2><h2 id="grid-column-end-属性"><a href="#grid-column-end-属性" class="headerlink" title="grid-column-end 属性"></a>grid-column-end 属性</h2><h2 id="grid-row-start-属性"><a href="#grid-row-start-属性" class="headerlink" title="grid-row-start 属性"></a>grid-row-start 属性</h2><h2 id="grid-row-end-属性"><a href="#grid-row-end-属性" class="headerlink" title="grid-row-end 属性"></a>grid-row-end 属性</h2><p>容器中的项目是可以指定的。使用这四个属性定义项目的边框。这四个属性是定义项目在哪根网格线；</p><ul><li>grid-column-start 属性：项目左边框所在的垂直网格线；</li><li>grid-column-end属性：项目右边框所在的垂直网格线；</li><li>grid-row-start 属性：项目上边框所在的水平网格线；</li><li>grid-row-end 属性：项目下边框所在的水平线网格线；</li></ul><p>我们讲解上个属性的时候也用到了这些属性 <code>grid-row-start</code> 和 <code>grid-column-start</code>。我们可以再举个例子：</p><iframe height="595" style="width: 100%;" scrolling="no" title="grid-auto-columns" src="https://codepen.io/shuliqi/embed/jOMBZWd?height=595&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/jOMBZWd'>grid-auto-columns</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>我们可以通过审查元素看出来第7个元素占的网格线情况：</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/16.png" class=""><p>第七个项目的上边框在水平网格线的第四根，左边框在垂直网格线的第一根。下边框和右边框没有指定，所以会采用默认位置(下边框滴5根网格线。有边框第二根网格线)。</p><p>再看一个例子：</p><iframe height="629" style="width: 100%;" scrolling="no" title="grid-auto-columns" src="https://codepen.io/shuliqi/embed/QWKpQpo?height=629&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/QWKpQpo'>grid-auto-columns</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>我们可以通过审查元素看出来第7个元素占的网格线情况：</p><img src="/2020/12/04/CSS-Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/17.png" class=""><p>我们可以看出第一个项目的左边框在垂直网格线的第二个，右边框在垂直网格线的第四个网格线。上下边框没有指定使用默认位置。除了第一个项目之外，其他项目没有指定位置，由浏览器自动布局。这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会”先行后列”进行排列</p><p><strong>注意1：</strong>这四个属性的值，也可以指定为网格线的名字。</p><iframe height="634" style="width: 100%;" scrolling="no" title="grid-auto-columns" src="https://codepen.io/shuliqi/embed/xxEqYYg?height=634&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/xxEqYYg'>grid-auto-columns</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>第一个项目的左边框指定为a2的网格线，右边框指定为a4的网格线，</p><p><strong>注意2：</strong>这四个属性可以使用 <code>span</code>关键字。表示上下边框（左右边框）之间跨越多少网格。</p><iframe height="634" style="width: 100%;" scrolling="no" title="grid-auto-columns" src="https://codepen.io/shuliqi/embed/xxEqYYg?height=634&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/xxEqYYg'>grid-auto-columns</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>第一个项目的左右边框，上下边框都跨越2个网格（绿色部分）。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结实现瀑布流的三种方式</title>
      <link href="/2020/11/17/%E7%80%91%E5%B8%83%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/11/17/%E7%80%91%E5%B8%83%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>最近在参加一个<a href="http://umapp-docs-dev.lap.qihoo.net/">小程序</a> 比赛， 其中在开发页面的时候，设计图设计是瀑布流的样式。本以为很简单的浮动就能实现的。但是其实并没有那么简单。通过这次写瀑布流。感觉受益颇多。于是通过这篇博客记录一下瀑布流是如何实现的以及每个方法的原理。</p> <span id="more"></span><h1 id="什么是瀑布流？"><a href="#什么是瀑布流？" class="headerlink" title="什么是瀑布流？"></a>什么是瀑布流？</h1><p>瀑布流我们又称瀑布流式布局。这种布局视觉表现为参差不齐的多栏布局，随着页面的滚动条向下滚动，还会不断加载数据块并附加到当前结尾。瀑布流布局即不会出现错乱现象，而且会最大限度显示图片的内容。</p><h1 id="瀑布流的原理"><a href="#瀑布流的原理" class="headerlink" title="瀑布流的原理"></a>瀑布流的原理</h1><p>瀑布流的原理就是页面容器内多个高度不固定的div之间按照一定的间隔参差不齐的无序浮动，数据滚动时不断的在容器内的尾部加载数据，且自动加载到空缺位置。不断循环。瀑布流布局的核心就是基于一个网格的布局，而且每行包含的项目列表的高度(高度)是随机的(随着自己的内容动态变化的高度或者宽度)。</p><h1 id="等宽瀑布流"><a href="#等宽瀑布流" class="headerlink" title="等宽瀑布流"></a>等宽瀑布流</h1><p>根据以上的瀑布流的原理我们也知道，瀑布流可以分为两种形式：等宽瀑布流，等高瀑布流。。我们这篇博文主要讲等宽瀑布流</p><p>等宽瀑布流形式如下：</p><img src="/2020/11/17/%E7%80%91%E5%B8%83%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/2.png" class=""><p>我们可以看出来， 每块的宽度是一定的，但是高度是不一样的，其中高度取决于图片的高度。</p><p>我们来使用具体几种方式来实现：</p><h1 id="css-实现：column-count-方式"><a href="#css-实现：column-count-方式" class="headerlink" title="css 实现：column-count 方式"></a>css 实现：column-count 方式</h1><p><strong>column-count</strong>: 用于定义栏目的的列数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column-count：auto | 整数</span><br></pre></td></tr></table></figure><ul><li>auto: 取计算机值</li><li>整数：有浮点数和单位标识符组成的长度值，不可为负数</li></ul><p><strong>浏览器的兼容：</strong></p><table><thead><tr><th>类型</th><th><img src="https://www.zhangxinxu.com/css3/img/IE.png" alt="IE">Internet Explorer</th><th><img src="https://www.zhangxinxu.com/css3/img/Firefox.png" alt="Firefox">Firefox</th><th><img src="https://www.zhangxinxu.com/css3/img/Chrome.png" alt="Chrome">Chrome</th><th><img src="https://www.zhangxinxu.com/css3/img/Opera.png" alt="Opera">Opera</th><th><img src="https://www.zhangxinxu.com/css3/img/Safari.png" alt="Safari">Safari</th></tr></thead><tbody><tr><td>版本</td><td>(×) IE6</td><td>(×) Firefox 2.0</td><td>(√ )Chrome 1.0.x</td><td>(× )Opera 9.63</td><td>(√)Safari 3.1</td></tr><tr><td>(×)IE7</td><td>(×) Firefox 3.0</td><td>(√) Chrome 2.0.x</td><td></td><td>(√)Safari 4</td><td></td></tr><tr><td>(x)IE8</td><td>(√ )Firefox 3.5</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>可以看出还是有很多浏览器不兼容的。使用的时候还是很需要谨慎。</p><p>所有有些浏览器前缀是必要的：</p><table><thead><tr><th>引擎类型</th><th>Gecko</th><th>Webkit</th><th>Presto</th></tr></thead><tbody><tr><td>column-count</td><td>-moz-column-count</td><td>-webkit-column-count</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>具体的瀑布流的例子：</strong></p><iframe height="800" style="width: 100%;" scrolling="no" title="瀑布流-column" src="https://codepen.io/shuliqi/embed/QWKjYMr?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/QWKjYMr'>瀑布流-column</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>其中例子重要的代码其实也就是如下的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line"><span class="attribute">column-gap</span>: <span class="number">10px</span>;</span><br><span class="line">-webkit-<span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">-webkit-<span class="attribute">column-gap</span>: <span class="number">10px</span>;</span><br><span class="line">-webkit-<span class="attribute">column-gap</span>: <span class="number">10px</span>;</span><br></pre></td></tr></table></figure><p>其中 <strong>column-gap</strong> 属性用来设置元素列之间的间隔大小。</p><p>但是这种方式有一个缺点：数据不是从上到下排列， 而是从左到右边的排列方式。在例子中可以看出来，1，2，3，4 是在左边的一列的。左边的排完了，才到右边的。</p><p>而且这次的<a href="http://umapp-docs-dev.lap.qihoo.net/">360家小程序</a> 。 我们在模拟器上和一些手机上这种方式实现是ok的。但是8p， 5s在我们360家app 上是不支持的。 使用还是需要谨慎。</p><h1 id="css实现：-display-flex-方式"><a href="#css实现：-display-flex-方式" class="headerlink" title="css实现： display: flex 方式"></a>css实现： display: flex 方式</h1><p>如果还不了解弹性布局的可以先看 <a href="https://shuliqi.github.io/shuliqi.github.io/2018/03/31/Flex%E5%B8%83%E5%B1%80/">Flex布局教程</a></p><p>实现原理：</p><ol><li>先使用：<code>  display: flex;</code>, <code>flex-direction: row;</code>将容器的主轴变成垂直方向。</li><li>然后再使用：<code> justify-content: space-between;</code>将主轴的列两端对齐。</li><li>我们需要几列就需要把数据分为几列。</li></ol><p>具体例子：</p><iframe height="800" style="width: 100%;" scrolling="no" title="瀑布流css实现-flex" src="https://codepen.io/shuliqi/embed/BaLogpG?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/BaLogpG'>瀑布流css实现-flex</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>例子的主要代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-direction</span>: row;</span><br><span class="line"><span class="attribute">justify-content</span>: space-between;</span><br></pre></td></tr></table></figure><p>这主要是布局的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载数据， 把数据分成两列</span></span><br><span class="line"> <span class="function"><span class="title">onLoadImg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> colIndex = i % <span class="number">2</span> ; <span class="comment">// 两列</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">`https://shuliqi.github.io/xiaozhan/<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>.jpeg`</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.imgList[colIndex]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.imgList[colIndex].push(url)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$set(<span class="built_in">this</span>.imgList, colIndex, [url])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这主要将数据变成多少列的代码</p><p><strong>缺点：</strong></p><p>当然了这也是有缺点的。就是可能某一列特别长。以为我们在将数据分为几列的时候， 并没有判断图片的高度，而放入不同的列当中。</p><h1 id="JS-计算方式"><a href="#JS-计算方式" class="headerlink" title="JS 计算方式"></a>JS 计算方式</h1><p>js实现的具体步骤：</p><ol><li>确定每行放几张图片， 每行的个数（column）=页面宽度（pageWidth）/（图片盒子宽度+图片间距） </li><li>确定一行多少个之后首先需要将第一行排列好 （绝对定位的方式，使用js排列好）</li><li>找出每一行的最小高度，排列完每一张图片之后更新最小高度</li></ol><p>具体的实现：</p><iframe height="800" style="width: 100%;" scrolling="no" title="瀑布流JS 实现" src="https://codepen.io/shuliqi/embed/wvzMBxW?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/wvzMBxW'>瀑布流JS 实现</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>其中重要的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">waterFall</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> items = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;img-item&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (items.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//定义间隙10像素</span></span><br><span class="line">  <span class="keyword">var</span> gap = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">//首先确定列数 = 页面的宽度 / 图片的宽度</span></span><br><span class="line">  <span class="keyword">var</span> pageWidth = <span class="built_in">this</span>.$refs.waterfall.offsetWidth;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> itemWidth = items[<span class="number">0</span>].offsetWidth;</span><br><span class="line">  <span class="keyword">var</span> columns = <span class="built_in">parseInt</span>(pageWidth / (itemWidth + gap));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> arr = [];<span class="comment">//定义一个数组，用来存储元素的高度</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; items.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; columns) &#123;</span><br><span class="line">          <span class="comment">//满足这个条件则说明在第一行，文章里面有提到</span></span><br><span class="line">          items[i].style.top = <span class="number">0</span>;</span><br><span class="line">          items[i].style.left = (itemWidth + gap) * i + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">          arr.push(items[i].offsetHeight);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//其他行，先找出最小高度列，和索引</span></span><br><span class="line">          <span class="comment">//假设最小高度是第一个元素</span></span><br><span class="line">          <span class="keyword">var</span> minHeight = arr[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++)&#123;<span class="comment">//找出最小高度</span></span><br><span class="line">            <span class="keyword">if</span>(minHeight &gt; arr[j])&#123;</span><br><span class="line">                minHeight = arr[j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125; </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//设置下一行的第一个盒子的位置</span></span><br><span class="line">          <span class="comment">//top值就是最小列的高度+gap</span></span><br><span class="line">          items[i].style.top = arr[index] + gap + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">          items[i].style.left = items[index].offsetLeft + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//修改最小列的高度</span></span><br><span class="line">          <span class="comment">//最小列的高度 = 当前自己的高度 + 拼接过来的高度 + 间隙的高度</span></span><br><span class="line">          arr[index] = arr[index] + items[i].offsetHeight + gap;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>js 实现目前来说是最好的方式， 我们也是采用的这种方式。 但是在使用的过程中也有一些问题，就是在图片还没加载出来的是， 是获取不到每个容器img-item的<code>offsetHeight</code>。 所以有时候会有重叠的时候。</p><p>目前总结的就这三种方式，可以按需使用。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile文件的使用</title>
      <link href="/2020/10/20/Dockerfile%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/10/20/Dockerfile%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章 <a href="https://shuliqi.github.io/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/">Docker的必要性及基础使用</a>，我们知道 Dockerfile 是一个文本文件。这个文件里面包含了一系列的指令，每一条指令构建一层，每一条指令的内容及就是描述该层是如何构建的。</p> <span id="more"></span><h1 id="Dockerfile文件格式"><a href="#Dockerfile文件格式" class="headerlink" title="Dockerfile文件格式"></a>Dockerfile文件格式</h1><p>我们可以上篇文章 <a href="https://shuliqi.github.io/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/">Docker的必要性及基础使用</a>的 <a href="https://github.com/shuliqi/express-for-docker">Demo</a> 的Dockerfile文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12.17</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /shuliqi</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /shuliqi</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span>/tcp</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> node app.js</span></span><br></pre></td></tr></table></figure><p>因此我们知道<code>Dockerfile</code> 文件的格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># comment</span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注释</span><br><span class="line">指令 参数</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code>文件中的指令是不区分大小写的，但是为了更容易区分，约定使用 大写形式</p><p>Docker会依次执行<code>Dockerfile</code>文件中的指令，文件中第一条指令必须是<code>FROM</code>。</p><p>以 <code>#</code>开头的行，Docke会认为是注释，但是 <code># </code>出现在指令参数中，则不是注释。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Comment</span><br><span class="line">RUN echo &#x27;how old are you # my name is shuliqi&#x27;</span><br></pre></td></tr></table></figure><h1 id="Dockerfile-的组成部分"><a href="#Dockerfile-的组成部分" class="headerlink" title="Dockerfile 的组成部分"></a>Dockerfile 的组成部分</h1><p>Dockerfile 文件主要由 四部分组成，分别是：</p><table><thead><tr><th>部分</th><th>指令</th></tr></thead><tbody><tr><td>基础镜像信息</td><td>FROM</td></tr><tr><td>维护者信息</td><td>MAINTAINER</td></tr><tr><td>镜像操作指令</td><td>RUN，COPY，ADD，EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等</td></tr><tr><td>容器启动时执行指令</td><td>CMD、ENTRYPOINT</td></tr></tbody></table><h1 id="Dockerfile中的指令"><a href="#Dockerfile中的指令" class="headerlink" title="Dockerfile中的指令"></a>Dockerfile中的指令</h1><p>接下来我们讲指令的同时结合例子来讲，首先我们先创建一个可以使用的例子。关于怎么创建可以参考上一篇 博文<a href="https://shuliqi.github.io/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84-Docker-%E5%AE%B9">Docker的必要性及基础使用</a>。我创建了项目 **<a href="https://github.com/shuliqi/dockerfile-example">dockerfile-example</a>**。当然项目顺便你怎么弄，直接减一个Dockerfile的文件也算是个。</p><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p><code>FROM</code>指令为后面的指令提供镜像基础。<code>FROM</code>指令必须是<code>Dockerfile文件的</code>首条命令，启动构建流程后，<code>Docker</code>将会基于该镜像构建新镜像，<code>FROM</code>后的命令也是基于这个基础镜像。</p><p><code>FROM</code>的语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;diaest&gt;</span><br></pre></td></tr></table></figure><p>通过 <code>FROM</code>指定的镜像，可以是任何有效的基础镜像，<code>FROM</code>有以下的限制：</p><ul><li><code>FROM</code>必须是 <code>Dockerfile</code>文件的第一条非注释命令</li><li>在一个 <code>Dockerfile</code>文件中创建多个镜像时，<code>FROM</code>是可以多次出现。只需要在每个新命令<code>FROM</code>之前，记录提交上次的镜像ID</li><li><code>tag</code> 和 <code>digest</code>是可选的，如果不使用这两个值的时候，会使用<code>latest</code>版本的基础镜像</li></ul><p>举个🌰：</p><p>在我们当前的项目中， 我们使用node的基础镜像。就可以这么写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br></pre></td></tr></table></figure><p><a href="https://hub.docker.com/search?q=&type=image&image_filter=official">Docker Hub</a>有很多高质量的官方镜像。是可以直接拿来使用的。</p><p>除了选择现有的镜像为基础镜像外。Dcoker 还有一个比较特殊的镜像叫<code>scratch</code>。这个镜像是虚拟的概念。并不实际存在、表示一个空白的镜像。我们也可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br></pre></td></tr></table></figure><p>如果使用了 <code>scratch</code>为基础镜像的话，就说明不以任何的镜像为基础。接下来编写的指令将作为镜像的第一层存在。</p><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p><code>RUN</code>用来在定制镜像（image）时执行命令行命令的，有两种命令执行方式：</p><h4 id="shell-执行"><a href="#shell-执行" class="headerlink" title="shell 执行"></a><code>shell</code> 执行</h4><p>这种方式会在<code>shell</code>中执行命令，就像直接在命令行输入命令一样。</p><p><code>shell</code>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run &lt;命令行命令&gt;</span><br><span class="line"># &lt;命令行命令&gt; 等同于在终端操作的 shell 的命令</span><br></pre></td></tr></table></figure><p>整理了一份 <a href="https://www.jianshu.com/p/3291de46f3ff">命令行命令</a>。可翻阅</p><p>举个🌰：</p><p>我们希望在定制镜像（image）是新建一个名字为 shuliqi.js 的文件。我们就可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN touch shuliqi.js</span><br></pre></td></tr></table></figure><p>然后我们定制镜像（image）文件<code>docker build -t dockerfile-example .</code>然后以该镜像（image）启动一个容器<code>docker run -t dockerfile-example </code>最后我们进入到这个容器看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">0c3ac932b755        dockerfile-example   &quot;/bin/bash&quot;         59 seconds ago      Up 58 seconds                           compassionate_nobel</span><br><span class="line">$ docker exec -t -i 0c3ac932b755 bash</span><br><span class="line">root@0c3ac932b755:/# ls</span><br><span class="line">bin  boot  devetc  home  liblib64  media  mnt  optproc  root  run  sbin  shuliq.js  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><p>进入到容器之后， 我们使用ls 命令行命令，可以看出来，有文件名字为：shuliqi.js</p><h4 id="exec执行"><a href="#exec执行" class="headerlink" title="exec执行"></a><code>exec</code>执行</h4><p><code>exec</code>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;可执行的额文件&quot;,“参数1”, &quot;参数2&quot;]</span><br><span class="line">## 例如：</span><br><span class="line"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></pre></td></tr></table></figure><p><code>RUN</code>可以执行任何命令，然后再当前镜像上创建一个新层并且提交，提交后的结果镜像将会在 <code>Dockerfile</code>文件的下一步。</p><p>通过<code>RUN</code>执行多条命令时，可以通过<code>\</code>换行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN touch shuliqi.js\</span><br><span class="line">touch shuliqi2.js</span><br></pre></td></tr></table></figure><p>也可以在同一行通过分好分隔命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN touch shuliqi.js; RUN touch shuliqi.js; \</span><br></pre></td></tr></table></figure><p><strong>注意:</strong><code>RUN</code>指令创建的中间镜像会被缓存，并且在下次构建中使用。如果不想使用这些缓存镜像，可以在创建时指定<code>--no-cache</code>参数，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ocker build --no-cache .</span><br></pre></td></tr></table></figure><p>例如：</p><p>这样构建镜像的步骤就没有使用缓存，使得每一层的镜像ID都与之前的不同。</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p> <code>CMD</code>用于在指定容器启动时所有执行的命令。<code>CMD</code>有以下三种格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;commond&gt; // shell 格式</span><br><span class="line">CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] // exec格式，推荐格式</span><br><span class="line">CMD [&quot;param1&quot;, &quot;param2&quot;] // 为ENTRYPOINT指令提供参数</span><br></pre></td></tr></table></figure><p>与<code>RUM</code>命令不同的是：</p><p><code>RUM</code>指令在构建镜像时要执行命令。<code>CMD</code>则是用于在指定的容器启动时所要执行的命令。</p><p><code>CMD</code>在 Dockerfile文件中仅可指定一次，指定多次时，会覆盖前面的指令。</p><p><strong>需要注意：</strong>docker  run 命令会覆盖<code>CMD</code>命令。 如果 <code>docker run</code>运行容器时，使用了 <code>Dockerfile</code>中的 <code>CMD</code>命令相同的命令。就会覆盖 <code>Dockerfile</code>的<code>CMD</code>命令。</p><p>我们来举个🌰：</p><p>还是我们之前的项目，我们在 <code>Dockfile</code>文件中使用如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure><p>我们使用<code>docker build -t dockerfile-example .</code>构建一个新的镜像，镜像的名字叫：dockerfile-example，构建完成之后， 我们使用这个镜像运行一个容器，运行效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -t dockerfile-example</span><br><span class="line">root@cfc0384da571:/#</span><br></pre></td></tr></table></figure><p>那么容器终端将会使用 shell 。说明  <code>Dockfile</code>文件中的<code>CMD</code>起作用了。</p><p>但是我们不想使用 <code>Dockfile</code>文件中的<code>CMD</code>指定的命令。我们可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -t dockerfile-example /bin/ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><p>这时，<code>docker run</code>结尾指定的<code>/bin/ps</code>命令覆盖了<code>Dockerfile</code>的<code>CMD</code>中指定的命令。</p><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p><code>ENTRYPOINT</code>与 <code>CMD</code>类似。</p><p><code>ENTRYPOINT</code>有两种模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT &lt;command&gt; (shell模式)</span><br><span class="line">ENTRYPOINT [ &quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ] (exec模式)</span><br></pre></td></tr></table></figure><p>但是<code>ENTRYPOINT</code>不会被 <code>docker run</code>中执行的命令覆盖，并且<code>docker run </code>命令中指定的任何参数都会被当成参数再次传递给 ENTRYPOINT<code>。如果想要覆盖 </code>ENTRYPOINT<code>，则需要在</code>docker run<code>中指定 </code>–entrypoint<code>选项。 </code>Dockerfile<code>中只允许有一个</code>ENTRYPOINT<code>，多指定时会覆盖前端的设置的</code>ENTRYPOINT`指令。 而只执行最后的 ENTRYPOINT指令。</p><p>举个例子：</p><p>我们重写我们的<code>Dockerfile</code>文件。添加 <code>ENTRYPOINT</code>指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version: 0.0.3</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> 何民三 <span class="string">&quot;cn.liuht@gmail.com&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y nginx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;Hello World, 我是个容器&#x27;</span> \ </span></span><br><span class="line">   &gt; /var/www/html/index.html</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>执行 <code>docker image build -t test2:0.0.1 .</code>构建我们的镜像、</p><p>构建完成之后， 启动一个容器：docker run -i -t  test2:0.0.1 -g “daemon off;”  ``</p><p>在运行容器时，我们使用了<code>-g &quot;daemon off;&quot;</code>. 这个参数会传递给 <code>ENTRYPOINT</code>。最终在容器中执行的命令为<code>/usr/sbin/nginx -g &quot;daemon off;&quot;</code></p><h2 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h2><p><code>LABEL</code>用于为镜像添加元数据，元数据以键值对的形式指定：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>LABEL</code>指定元数据时，一条<code>LABEL</code>指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条<code>LABEL</code>指令指定，以免生成过多的中间镜像。</p><p>如，通过<code>LABEL</code>指定一些元数据：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> name=<span class="string">&quot;shuliqi&quot;</span> age=<span class="string">&quot;23&quot;</span></span></span><br></pre></td></tr></table></figure><p>构建容器完后才能之后， 可以使用<code>docker inspect</code>查看</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect test3:<span class="number">0.0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>Dockerfile</code>中还有个 <code>MAINTAINER</code>用来指定镜像的作者。但是``MAINTAINER<code>并不推荐使用，更推荐使用</code>LATER`来指定镜像作者。如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">&quot;itbilu.com&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p><code>EXPOSE</code>用来指定容器在运行的时监听的端口。</p><p>格式如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt; ...]</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span>/tcp</span><br></pre></td></tr></table></figure><p>注意：<code>EXPOSE</code>并不会让容器的端口访问到主机。要使其可以访问， 需要在<code>docker run</code>运行容器时通过 <code>-p</code>来发布这些端口。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -p:8000:3000 express-for-docker:0.0.1</span><br></pre></td></tr></table></figure><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p><code>ENV</code>用于设置环境变量，有以下两种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV SHULIQI_PATH=/home/shuliqi/</span><br></pre></td></tr></table></figure><p>设置完， 这个环境变量在 <code>ENV</code>命令之后都可以使用。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV SHULIQI_PATH=/home/shuliqi/</span><br><span class="line">WORKDIR $SHULIQI_PATH</span><br></pre></td></tr></table></figure><p>这个环境变量不仅可以在构建镜像中使用，使用该镜像创建的容器也可以使用。</p><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p><code>ADD</code>指令用于复制构建环境中的文件/目录到镜像中。</p><p>有两种使用格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure><p>通过<code>ADD</code>复制文件时，需要通过<src>指定源文件位置，并通过<code>&lt;dest&gt;</code>来指定目标位置。<src>可以是一个构建上下文中的文件或目录，也可以是一个<code>URL</code>，但不能访问构建上下文之外的文件或目录。</p><p>如，通过<code>ADD</code>复制一个网络文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD http://wordpress.org/latest.zip $ITBILU_PATH</span><br></pre></td></tr></table></figure><p>在上例中，<code>$ITBILU_PATH</code>是我们使用<code>ENV</code>指定的一个环境变量。</p><p>另外，如果使用的是本地归档文件（<code>gzip</code>、<code>bzip2</code>、<code>xz</code>）时，Docker会自动进行解包操作，类似使用<code>tar -x</code>。</p><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p><code>COPY</code>同样用于复制构建环境中的文件或目录到镜像中。其有以下两种使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure><p><code>COPY</code>指令非常类似于<code>ADD</code>，不同点在于<code>COPY</code>只会复制构建目录下的文件，不能使用<code>URL</code>也不会进行解压操作。</p><h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p><code>VOLUME</code>用于创建挂载点，即向所构建镜像创使的容器添加卷</p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure><p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p><ul><li>卷可以容器间共享和重用</li><li>容器并不一定要和其它容器共享卷</li><li>修改卷后会立即生效</li><li>对卷的修改不会对镜像产生影响</li><li>卷会一直存在，直到没有任何容器在使用它</li></ul><p><code>VOLUME</code>让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</p><p>如，通过<code>VOLUME</code>创建一个挂载点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM node:12.17.0</span><br><span class="line">COPY . /shuliqi</span><br><span class="line">WORKDIR /shuliqi</span><br><span class="line">RUN [&quot;npm&quot;, &quot;install&quot;]</span><br><span class="line">EXPOSE 3000/tcp</span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br><span class="line"># `VOLUME`创建一个挂载点</span><br><span class="line">ENV SHULIQI_PATH /myblog/</span><br><span class="line">VOLUME [$SHULIQI_PATH]</span><br></pre></td></tr></table></figure><p>构建的镜像，并指定镜像名为<code>express-for-docker</code>。构建镜像后，使用新构建的运行一个容器。运行容器时，需<code>-v</code>参将能本地目录绑定到容器的卷（挂载点）上，以使容器可以访问宿主机的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t -v ~/myblog:/myblog/  express-for-docker:0.0.1</span><br><span class="line">root@31b0fac536c4:/# cd /myblog/</span><br><span class="line">root@31b0fac536c4:/myblog# ls</span><br><span class="line">blog</span><br></pre></td></tr></table></figure><p>如上所示，我们已经可以容器的<code>/home/myblog/</code>目录下访问到宿主机`~/myblog目录下的数据了。</p><h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p><code>USER</code>用于指定运行镜像所使用的用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure><p>使用<code>USER</code>指定用户时，可以使用用户名、<code>UID</code>或<code>GID</code>，或是两者的组合。以下都是合法的指定试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure><p>使用<code>USER</code>指定用户后，<code>Dockerfile</code>中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>都将使用该用户。镜像构建完成后，通过<code>docker run</code>运行容器时，可以通过<code>-u</code>参数来覆盖所指定的用户。</p><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p><code>WORKDIR</code>用于在容器内设置一个工作目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure><p>通过<code>WORKDIR</code>设置工作目录后，<code>Dockerfile</code>中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>ADD</code>、<code>COPY</code>等命令都会在该目录下执行。</p><p>如，使用<code>WORKDIR</code>设置工作目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p>在以上示例中，<code>pwd</code>最终将会在<code>/a/b/c</code>目录中执行。</p><p>在使用<code>docker run</code>运行容器时，可以通过<code>-w</code>参数覆盖构建时所设置的工作目录。</p><h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p><code>ARG</code>用于指定传递给构建运行时的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure><p>如，通过<code>ARG</code>指定两个变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG site</span><br><span class="line">ARG build_user=舒丽琦</span><br></pre></td></tr></table></figure><p>以上我们指定了<code>site</code>和<code>build_user</code>两个变量，其中<code>build_user</code>指定了默认值。在使用<code>docker build</code>构建镜像时，可以通过<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>参数来指定或重设置这些变量的值。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --build-<span class="keyword">arg</span> site=shuliqi.github.io -t express-for-docker .</span><br></pre></td></tr></table></figure><p>这样我们构建了 express-for-docker 镜像，其中<code>site</code>会被设置为 shuliqi.github.io，由于没有指定<code>build_user</code>，其值将是默认值<code>舒丽琦</code>。</p><h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><p><code>ONBUILD</code>用于设置镜像触发器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure><p>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。</p><p>如，当镜像被使用时，可能需要做一些处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h2 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h2><p><code>STOPSIGNAL</code>用于设置停止容器所要发送的系统调用信号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure><p>所使用的信号必须是内核系统调用表中的合法的值，如：<code>9</code>、<code>SIGKILL</code>。</p><h2 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h2><p><code>SHELL</code>用于设置执行命令（<code>shell</code>式）所使用的的默认<code>shell</code>类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br></pre></td></tr></table></figure><p><code>SHELL</code>在Windows环境下比较有用，Windows下通常会有<code>cmd</code>和<code>powershell</code>两种<code>shell</code>，可能还会有<code>sh</code>。这时就可以通过<code>SHELL</code>来指定所使用的<code>shell</code>类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;/S&quot;&quot;, &quot;/C&quot;]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的必要性及基础使用</title>
      <link href="/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在阅读我们Docker的 <a href="https://www.docker.com/">官方文档</a>我们知道：</p><ul><li>Docker  是世界领先的软件容器平台。</li><li>使用Docker 可以使开发人员消除一起协作开发遇到的一些问题；如”在我的电脑上可正常运行”。</li></ul> <span id="more"></span><ul><li>使用Docker 可以使运维人员在隔离容器中并行运行和管理应用，获得更好的计算密度。</li><li>使用Docker 企业可以构建敏捷的软件交付管道，以更快的速度，更高的安全性和可靠的信誉为 Linux 和 Wiindows Server 应用发布新功能。</li></ul><p>那么我们为什么需要 Docker 呢？</p><h2 id="环境配置的难题"><a href="#环境配置的难题" class="headerlink" title="环境配置的难题"></a>环境配置的难题</h2><p>我们开发一般在写程序，需要好多个环境，主要的可以分为：</p><ul><li><p><strong>开发环境：</strong>我们自己本地写代码的环境；</p></li><li><p><strong>测试环境：</strong> 提供给测试伙伴测试的环境；</p></li><li><p><strong>生产环境：</strong>测试完成可以上线的环境；</p><p>我们在开发和学习编辑过程中， 好多时间都浪费在环境上：</p></li><li><p>如果重装了系统。我之前的项目，就得弄好多的配置，才能跑起来。比如配置MySQL，配置各种的环境变量等；</p></li><li><p>假如我们在网上学习跟这老师的步骤去写Demo,不知道你们遇到没，反正有些Demo我总有Bug。</p></li><li><p>我们在本地开发环境一切安好， 但是在测试环境上就出错了，或者测试环境是好的，一上线也是各种报错(心累~~);</p></li></ul><p>所以就有“千万不要和程序员说，你的代码有bug”这样的笑话：</p><ul><li>程序员的第一反应是你的环境有问题，第二就是你不会使用吧。</li><li>你要是跟他说“这个程序运行的怎么跟预期的不一样啊，是不是我操作的问题啊？”。</li><li>我们就会第一反应:“这是不是出bug了”</li></ul><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另外一种操作系统，比如我在 Windows 系统里面运行 Linnux 系统。应用程序对此是毫无感知的，，因为虚拟机看上去跟真实系统一摸一样，对于底成系统来说，虚拟机就是一个普通的文件，不需要了就删掉，对其他部分毫无影响。</p><p>虽然我们可以通过虚拟机还原软件的的原始环境，但是这个方案有几点缺点：</p><ul><li><p><strong>资源占用多</strong></p><p>虚拟机会独自占用一部分内存和硬盘空间，它运行的时候其他程序就无法使用这些资源了，哪怕虚拟机里面的应用程序真正使用的内存只有1MB，虚拟机依然会需要几百MB的内存才能运行。</p></li><li><p><strong>繁琐的步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的步骤是无法跳过的，如用户登陆。</p></li><li><p><strong>启动慢</strong></p><p>启动操作系统需要多久的时间，启动虚拟机就需要多久的时间，可能需要等特别长的时间，应用程序才会运行。</p></li></ul><h2 id="Linux容器"><a href="#Linux容器" class="headerlink" title="Linux容器"></a>Linux容器</h2><p>由于虚拟机存在这些缺点，Linux发明出了另外一种虚拟化技术；linux容器(Linux Container)LXC.。</p><p>Linux容器不是模拟一个完整的的操作系统，而是对进程进行隔离。或者说，在正常的进程外面套了一个保护层，对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，所以相比虚拟机有很多的优势：</p><ul><li><p><strong>启动快</strong></p><p>容器里面的应用直接就是底层系统的一个进程，，而不是虚拟机内部的进程，所以启动容器就相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多了。</p></li><li><p><strong>资源占用小</strong></p><p>容器只占用需要的资源，不占用那些不需要额资源；虚拟机由于是完整的操作系统，不可避免的要占用所有的资源，另外，多个容器可以共享资源，虚拟机都是独享资源。</p></li><li><p><strong>体积小</strong></p><p>容器只需要打包用到的组件即可，而虚拟机是整个系统的打包，所以容器文件比虚拟机文件要小很多。</p></li></ul><p>最后说明，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销就小很多。</p><h2 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a>Docker是什么？</h2><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</p><p>它是目前最流行额 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖打包在一个文件里面，运行这个文件，就会生成一个虚容器。程序在这个虚拟容器运行， 就好像在真实的物理机上运行一样。有了 Docker 就不用担心环境问题。</p><p>总体来说，Docker 的接口相当的简单， 用户可以方便的创建和使用容器，把自己的应用放入容器，容器还可以进行版本管理，复制，分享，修改，就像管理普通的代码一样。</p><h2 id="Docker-的用途"><a href="#Docker-的用途" class="headerlink" title="Docker 的用途"></a>Docker 的用途</h2><p>Docker 的主要用途，目前主要有三大类：</p><ul><li><p><strong>提供一次性的环境</strong></p><p>比如：本地测试他人的软件，持续集成的时候提供单元测试和构建环境。</p></li><li><p><strong>提供弹性的云服务</strong></p><p>因为 Docker 容器可以随关随开，，很适合动态扩容和缩容。</p></li><li><p><strong>组建微服务架构</strong></p><p>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构</p></li></ul><h2 id="Docker-的基本概念"><a href="#Docker-的基本概念" class="headerlink" title="Docker 的基本概念"></a>Docker 的基本概念</h2><p>Docker 包含三个基本概念</p><ul><li><p><strong>镜像（image）</strong></p><p>操作系统分为内核和用户空间，就Linux而言，内核启动后，，会挂载<code>root</code>文件系统为其提供用户空间支持。而 Docker镜像，就相当于一个 <code>root</code>文件系统。 Docker镜像就是一个特殊的文件系统，除了提供容器运行时所需的程序，库，资源，配置等文件外，还包含了一些为运行时准备的一些配置参数（如：匿名卷，，环境变量，用户等）。镜像不包含任何的动态数据，，其内容在构建完成之后也不会改变。</p></li><li><p><strong>容器（container）</strong></p><p>镜像（image）和 容器（container）的关系，就像面向对象设计中的 <code>类</code> 和 <code>实例</code> 一样。镜像是静态的定义，，容器是镜像运行时的实体。容器可以被创建，启动通知，删除，暂停等。</p><p>容器的实质就是进程，但是与直接宿主执行的进程不同，容器进程运行于属于自己的独立的 <code>命令空间</code>。因此容器有自己<code>root</code>文件系统，自己的网络配置，自己的进程空间，甚至自己的用户ID空间。</p></li><li><p><strong>仓库（repository）</strong></p><p>镜像构建完成之后，可以很容易的在当前宿主机上运行，但是，如果需要在服务器上使用这个镜像，我们就需要一个集中的存储，分发镜像的服务。Docker 官方提供的 Docker <a href="https://hub.docker.com/">Hub</a>  就是这样的服务，不过这是公共仓库。</p></li></ul><h2 id="Dcoker-的安装"><a href="#Dcoker-的安装" class="headerlink" title="Dcoker 的安装"></a>Dcoker 的安装</h2><p>Docker 有三个更新的频道：<code>stable</code> <code>,</code>test<code>和</code>nightly</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/get-docker/">安装指南</a></p><p>安装完成之后，可以使用一下命令检测 Docker 是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>  如果安装了就会得到关于 docker 的信息</p><img src="/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1.png" class=""><h2 id="hello-world-实例"><a href="#hello-world-实例" class="headerlink" title="hello world 实例"></a>hello world 实例</h2><p>现在我们通过简单的 image 文件 <a href="https://hub.docker.com/_/hello-world">hello world</a> 来感受一下 Docker</p><p>运行下面的命令，将image 文件从 仓库拉取到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure><p>这个代码中的 <code>docker image pull</code>  是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置。·<code>library</code>是 image 文件所在的组<code>hello-world</code>是image文件的名称。</p><p>由于是 Docker 官方提供的image 文件，都放在 <code>library</code>组里面，属于默认组， 所以我们在抓取 Docker 官方 image 文件的时候，可以省略 <code>library</code>·。</p><p>所以上面的命令可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull hello-world</span><br></pre></td></tr></table></figure><p>抓取过程：</p><img src="/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/3.png" class=""><p>抓取成功之后，我们查看本机是否有该 image 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><img src="/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/4.png" class=""><p>我们可以看出本机是有该 image 文件了的、</p><p>接下来，我们运行这个 image 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure><p><code>docker container run</code>命令会从 image 文件 生成一个正在运行的容器。</p><p>注意：<code>docker container run</code>命令具有 自动抓取 image 文件的功能，如果发现本地没有指定的 image 文件，就会从仓库自动抓取。</p><p>如果运行成功，就会在屏幕上得到以下的输出：</p><p>输出这些提示之后就会自动停止运行，容器就会自动终止。</p><p>下面会通过Docker 的三个基本概念来介绍。</p><h2 id="镜像（image文件）"><a href="#镜像（image文件）" class="headerlink" title="镜像（image文件）"></a>镜像（image文件）</h2><p>Docker 把应用程序及其依赖，打包在 image 文件里面。image 是二进制文件。</p><p>只有通过这个文件，才能生成 Docker 容器（container），image文件可以看成是容器的模版。Docker 根据 image 文件生成容器的实例。同一个image文件可以生成多个同时运行的容器实例。</p><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>Docker 运行容器前需要在本地存在对应的镜像（image），如果不存在该镜像，Docker就会从镜像仓库下载该镜像。在<a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上有大量的镜像可以使用。 </p><p>我们可以使用 <code>Docker pull</code>命令获取镜像，命令格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><ul><li><p>其中具体的<code>选项</code>可以通过<code>Docker pull --help</code>查看。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$  Docker pull --help</span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Download all tagged images in the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">      --platform string         Set platform if server is multi-platform capable</span><br><span class="line">  -q, --quiet                   Suppress verbose output</span><br></pre></td></tr></table></figure></li><li><p>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口]</code>。默认的地址是 <a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> </p></li><li><p>仓库名：仓库名是两段式名称，即：<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对弈仓库是 <a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 如果不给出用户名，那么默认为<code>library</code>(官方镜像)。</p></li></ul><p>举个🌰：</p><p>我们从 <a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 仓库上拉取一个 <code>hello-world</code>镜像（image）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ Docker pull hello-world</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">0e03bdcc26d7: Pull complete</span><br><span class="line">Digest: sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line">docker.io/library/hello-world:latest</span><br></pre></td></tr></table></figure><p>这命令明没有给出 Docker 镜像（image）仓库地址，那么将会从<a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 获取镜像（image）。镜像的名字叫做<code>hello-world</code>，因此会获取官方镜像<code>library/hello-world</code>仓库中的最新的版本的镜像(我们没有执行用哪个标签的版本，所以是最新的)。</p><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>可以使用命令`docker image ls 列出已经下载下来的镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                                 TAG                       IMAGE ID            CREATED             SIZE</span><br><span class="line">express-for-docker                         0.0.1                     75b97434d52d        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    b2d9a05ebb31        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    1083c90adc0f        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    914f52bcbe8b        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    7032438fb234        2 days ago          920MB</span><br><span class="line">shuliqi/express-for-docker                 0.0.1                     e46126aa45a5        6 days ago          920MB</span><br><span class="line">r.addops.soft.360.cn/qixiao/backend-test   20200529163234-5ed720bd   a5e1f04e8d6a        4 months ago        2.71GB</span><br><span class="line">node                                       12.17.0                   a37df1a0b8f0        4 months ago        918MB</span><br><span class="line">hello-world                                latest                    bf756fb1ae65        9 months ago        13.3kB</span><br></pre></td></tr></table></figure><p>我们可以看出来，列表包含了 <code>仓库名</code>，<code>标签</code>，<code>镜像ID</code>，<code>创建时间</code>，<code>所占用的空间</code>。其中镜像ID 是镜像的唯一标识、</p><p> image 文件是通用的，一台机器的 image 文件拷贝到另外一台机器，依然是可以使用的。所以一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作，即使自己制作，也应该基于别人 image 文件进行加工，而不是从零制作。</p><p>为了方便共享，inage 文件制作完成之后可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker hub</a> 应该是最常用的。</p><h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>在上面的镜像中， 有一些比较特殊镜像，这些镜像没有仓库名。也没有标签，均为：<code>&lt;none&gt;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;                                     &lt;none&gt;                    b2d9a05ebb31        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    1083c90adc0f        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    914f52bcbe8b        2 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    7032438fb234        2 days ago          920MB</span><br></pre></td></tr></table></figure><p>原因是这样的，这些镜像原先是有镜像和标签的，但是随着这些镜像的官网维护，发布了新版本之后， 重新 <code>Docker     pull</code> 的时候。旧的镜像名被转移到新下载的镜像身上了。而这个旧的镜像上的名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了docker pull<code>可能导致这种情况。</code>docker build`也同样可以导致这种现象。</p><p>由于新旧镜像同名，旧镜像名称被取消。从而出现仓库名，标签均为<code>&lt;none&gt;</code>的镜像。这类镜像就被称为<strong>虚悬镜像（dangling image）</strong></p><p>一般使用<code>docker image ls-f dangling=true</code>来显示这类镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f dangling=<span class="literal">true</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              b2d9a05ebb31        2 days ago          920MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              1083c90adc0f        2 days ago          920MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              914f52bcbe8b        2 days ago          920MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              7032438fb234        3 days ago          920MB</span><br></pre></td></tr></table></figure><p>一般来说，虚悬惊险已经失去了存在的价值，是可以随意删除，可以使用下面的命令删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br><span class="line">WARNING! This will remove all dangling images.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line">Deleted Images:</span><br><span class="line">deleted: sha256:914f52bcbe8b3931a0f28de7f0fdac94718eb679af0eee6056a4339896a2986b</span><br><span class="line">deleted: sha256:8b34628d630ae6f1313ed41ce1539acaa66a2adcc20c5f888475008da5f8f8af</span><br><span class="line">deleted: sha256:107e046f0614e4beb0296e38933989724b232bef66013a83beb5e4a507b15875</span><br><span class="line">deleted: sha256:7adb718c36f311154759d7659bb3a56edc0eef972fe808960a1890a260a344d5</span><br><span class="line">deleted: sha256:49e7e6fadd8e6517ee862d5281a849faa45adf6e097ce280927e5861936731ba</span><br><span class="line">deleted: sha256:b8cfe3d0a0f3c1b19554f9e4cb39978810793399d4c20eb819b7b67205ad58f0</span><br><span class="line">Total reclaimed space: 5.13MB</span><br></pre></td></tr></table></figure><h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加快镜像的构建，重复利用资源，Docker 会利用<strong>中间镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的命令<code>docker image ls</code>只会列出顶层镜像。如果希望现实包含中间层镜像在内的所有镜像的话，需要加<code>-a</code>参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -a</span><br></pre></td></tr></table></figure><p>这样就会看到很多无标签的镜像，与之前的虚悬镜像 不同，这些无标签的镜像很多都是中间层镜像，是其他镜像所依赖的镜像，这些无标签的镜像就不应该删除。否则会导致上层镜像会因为失去依赖而出错。</p><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>如果想要删除本地的镜像，可以使用<code>Docker image rm</code>命令，其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt;...]</span><br></pre></td></tr></table></figure><p>其中<code>镜像</code> 可以是 <code>镜像短ID</code>，<code>镜像长ID</code>,<code>镜像名</code> 或者 <code>镜像摘要</code>.</p><p>举个🌰：</p><p>我们先列出本地的镜像（image）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                                 TAG                       IMAGE ID            CREATED             SIZE</span><br><span class="line">express-for-docker                         0.0.1                     75b97434d52d        3 days ago          920MB</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    b2d9a05ebb31        3 days ago          920MB</span><br><span class="line">r.addops.soft.360.cn/qixiao/backend-test   20200529163234-5ed720bd   a5e1f04e8d6a        4 months ago        2.71GB</span><br></pre></td></tr></table></figure><p>我们可以使用<code>镜像长ID</code>来删除镜像。使用脚本的时候可能会用长ID。但是人工输入的话就会太累了。所以更多的时候是使用<code>短ID</code>来删除镜像、·docker image ls·列出的就是镜像的短ID。</p><p>假如我们要删<code>express-for-docker </code>·镜像，就可以使用短ID执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm 75b97434d52d</span><br><span class="line">Untagged: express-for-docker:0.0.1</span><br><span class="line">Deleted: sha256:75b97434d52d019ad7ee9c1e1d2c903bc6d5e7261a429cb0f97c0302a0323279</span><br><span class="line">Deleted: sha256:4605991534be3e41e1dd0dc142be83617424b94f68feab431ee4cdf88be944f2</span><br><span class="line">Deleted: sha256:b77592ec1b655839244fdaa2bf94f7ebe606e20ae617154aedaed5e6bd04b9dd</span><br><span class="line">Deleted: sha256:15c1b2c7cd44394daa5b22ddae5e66a5a8804bef4a70ef172738f3b8cbf4a8dd</span><br><span class="line">Deleted: sha256:ffa48c079ea207b279b6fffaa41b893e5c66c9c5908fe616e07978e32ed4b341</span><br><span class="line">Deleted: sha256:ffcf86b030c4b1ecba89778455e52e9ce61ecf22fb2ee7fe8e642d52b0f7f82d</span><br><span class="line">Deleted: sha256:e24e7952278d2bde9a56a78ef1887ca732e786a3735f8e3c1cbc315b88edb0b6</span><br><span class="line">Deleted: sha256:60d46f3b1697a276dff10b74fb8199f523c171ece03bd1e372a0b6ce3c6ada23</span><br><span class="line">Deleted: sha256:4e891fdf8b241174de56b22682015358baf52302f4a7a2ddbd0ff417a71d0e2d</span><br></pre></td></tr></table></figure><p>也可以使用镜像名字，即：<code>&lt;仓库名&gt;：&lt;标签&gt;</code>，来删除镜像.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                                 TAG                       IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    b2d9a05ebb31        3 days ago          920MB</span><br><span class="line">r.addops.soft.360.cn/qixiao/backend-test   20200529163234-5ed720bd   a5e1f04e8d6a        4 months ago        2.71GB</span><br><span class="line">hello-world                                latest                    bf756fb1ae65        9 months ago        13.3kB</span><br><span class="line">$ docker image rm  hello-world:latest</span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0</span><br><span class="line">Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b</span><br><span class="line">Deleted: sha256:9c27e219663c25e0f28493790cc0b88bc973ba3b1686355f221c38a36978ac63</span><br><span class="line"> shuliqi@shuliqideMacBook-Pro  ~ </span><br></pre></td></tr></table></figure><p>当然也可以使用 <code>镜像摘要</code>来删除镜像。</p><p>首先我们使用命令<code>docker image ls --digests</code>先列出镜像的摘要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --digests</span><br><span class="line">REPOSITORY                                 TAG                       DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;                                     &lt;none&gt;                    &lt;none&gt;                                                                    b2d9a05ebb31        3 days ago          920MB</span><br><span class="line">r.addops.soft.360.cn/qixiao/backend-test   20200529163234-5ed720bd   sha256:d88b37ff35301dc149c346345cb0609600201b720b14d29f52f7ef232a098e39   a5e1f04e8d6a        4 months ago        2.71GB</span><br><span class="line">hello-world                                latest                    sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0   bf756fb1ae65        9 months ago        13.3kB</span><br></pre></td></tr></table></figure><p>然后使用<code>镜像摘要</code>删除:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0</span><br></pre></td></tr></table></figure><h3 id="使用Dockerfile-定制镜像"><a href="#使用Dockerfile-定制镜像" class="headerlink" title="使用Dockerfile 定制镜像"></a>使用Dockerfile 定制镜像</h3><p>这一部分也是很重要的一个知识点， 我们放在下面的内容 <strong>实例：制作自己的 Docker 容器</strong>来一起讲。</p><h2 id="容器（container-文件）"><a href="#容器（container-文件）" class="headerlink" title="容器（container 文件）"></a>容器（container 文件）</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</p><p>一般来说，一旦容器生成，就会同时存在两个文件： image 文件 和 容器文件，而且关闭容器不会删除容器文件。只是容器停止运行而已。</p><h3 id="列出容器："><a href="#列出容器：" class="headerlink" title="列出容器："></a>列出容器：</h3><p>列出本机容器 可以使用命令 <code>docker container ls</code>。其命令格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls [OPTIONS]</span><br></pre></td></tr></table></figure><p>OPTIONS 的选项很多。具体可以看看 <a href="https://docs.docker.com/engine/reference/commandline/container_ls/">docker container ls</a>的文档。</p><p>列出本机正在运行的容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls </span><br></pre></td></tr></table></figure><p>列出本机所有的容器，包括终止运行的容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                              COMMAND                  CREATED             STATUS                        PORTS               NAMES</span><br><span class="line">d211b923866c        ubuntu                             &quot;/bin/bash&quot;              40 minutes ago      Exited (0) 40 minutes ago                         goofy_feistel</span><br><span class="line">a80be7a20f56        ubuntu                             &quot;/bin/bash&quot;              40 minutes ago      Exited (0) 40 minutes ago                         inspiring_clarke</span><br><span class="line">8d91eaa8f2e1        ubuntu                             &quot;/bin/bash&quot;              3 hours ago         Exited (0) 3 hours ago                            bold_mendel</span><br><span class="line">995f498d0371        ubuntu                             &quot;/bin/bash&quot;              3 hours ago         Exited (0) 3 hours ago                            thirsty_mestorf</span><br><span class="line">33b16714d2b8        shuliqi/express-for-docker:0.0.1   &quot;docker-entrypoint.s…&quot;   3 hours ago         Up 3 hours                    3000/tcp            great_lewin</span><br><span class="line">251d68312383        ubuntu                             &quot;/bin/bash&quot;              3 hours ago         Exited (130) 3 hours ago                          vibrant_banach</span><br><span class="line">1f50021cd2b8        ubuntu                             &quot;/bin/bash&quot;              3 hours ago         Exited (0) 3 hours ago                            gifted_keldysh</span><br></pre></td></tr></table></figure><p>得到的结果之中有容器的ID。这个ID的使用场景就很多，比如终止容器的时候需要提供。</p><h3 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h3><p>启动容器有两个方式：</p><ul><li>一种是基于镜像新建一个容器并启动；</li><li>一种是将终止状态的容器重新启动；</li></ul><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>即第一种启动容器的得方式。启动所需的命令：<code>docker run</code>。其格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTION 选项 具体可以看官方 <a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></p><p>下面的内容会是我们比较常用的参数的例子。</p><p>我们继续以官方的事镜像<code>Hello world</code>来演示。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们拉取我自己上传的一个镜像（image）<code>express-for-docker</code>，再举个特别的🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull shuliqi/express-for-docker:0.0.1</span><br></pre></td></tr></table></figure><p>如果提示没有权限获取，可能没有登录  <a href="https://hub.docker.com/">Docker hub</a> 。需要注册登录一下，下面的内容有讲，可以移步往下面内容看看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i shuliqi/express-for-docker:0.0.1 /bin/bash</span><br><span class="line">root@f6cf67490ae4:/shuliqi<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>上面这个命令启动了一个bash 终端，允许用户进行交互。</p><ul><li><strong>-t：</strong>表示容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器</li><li><strong>-i:</strong>   表示让容器的标准输入保持开启</li><li><strong>/bin/bash:</strong>  容器启动后，内部第一个执行的命令。这里是起订 Bash.保证用户使用 Shell</li></ul><p>我们再试一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run  -t -i -p 8000:3000 shuliqi/express-for-docker:0.0.1 /bin/bash</span><br><span class="line">root@e400118aabd7:/shuliqi<span class="comment"># node app.js</span></span><br><span class="line">111</span><br><span class="line">Example app listening at http://localhost:3000</span><br></pre></td></tr></table></figure><p>然后打开我们浏览器，访问<a href="http://localhost:8000/">http://localhost:8000/</a> 就会看到如下界面：</p><p>其中:</p><ul><li><strong>-p:</strong> 是指将容器的某个端口映射到本机的某个端口。这个例子就是讲 容器的 3000 端口 映射到本机的 8000 端口</li></ul><h4 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h4><p>可以使用<code>docker container start</code>命令来启动一个已终止的容器。其格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTION 的选项具体可以看官方文档：<a href="https://docs.docker.com/engine/reference/commandline/container_start/">docker container start</a></p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container start e400118aabd7</span><br></pre></td></tr></table></figure><p>更多的时候我们是需要Docker 在后台进行而不是直接把执行命令输出的结果输出到当前目录下。那么久可以是用<code>-d</code>来参数来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -t -i -p 8000:300</span><br><span class="line">597e02ae84f497a8ff6ce03b87ecc40cd2c2a44b3eba41ed927e7aa7beded980</span><br></pre></td></tr></table></figure><p>使用·-d· 参数启动后会返回一个唯一的id。</p><p>这时候继续访问 ：<a href="http://localhost:8000/">http://localhost:8000</a> 还是会看到和之前一样的界面。</p><p>如果我们想看容器的输出结果。可以使用<code>docker container logs [containerID or NAMES]:</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs 597e02ae84f497a8ff6ce03b87ecc40cd2c2a44b3eba41ed927e7aa7beded980</span><br><span class="line">111</span><br><span class="line">Example app listening at http://localhost:3000</span><br></pre></td></tr></table></figure><h3 id="终止容器运行"><a href="#终止容器运行" class="headerlink" title="终止容器运行"></a>终止容器运行</h3><p>终止容器可以使用：<code>docker container stop [containerID]</code>命令来终止。其格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop 597e02ae84f4</span><br><span class="line">597e02ae84f4</span><br></pre></td></tr></table></figure><p>上面的命令会导致 containerID 为 597e02ae84f4 的容器停止运行。</p><p>可以通过 <code>docker container ls -a</code>来查看终止状态的容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                              COMMAND                  CREATED             STATUS                        PORTS                                      NAMES</span><br><span class="line">597e02ae84f4        shuliqi/express-for-docker:0.0.1   &quot;docker-entrypoint.s…&quot;   8 minutes ago       Exited (137) 7 seconds ago                                               optimistic_antonelli</span><br></pre></td></tr></table></figure><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在前面我们说过 使用 <code>-d</code>参数时，容器启动后悔进入后台。</p><p>但是有些时候需要进入容器进行一些操作。那么可以使用<code>docker attach</code>或 <code>docker exec</code>来进入容器。但是推荐使用<code>docker exec </code>进入容器。因为使用<code>docker attach</code>进入容器。如果在stdin中exit(退出),是会导致容器停止的。而<code>docker exex</code>则不会。其格式分别为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>使用<code>docker exec</code>的话， 后面可以跟多个参数，可以使用<code>docker exec --help</code>来查看参数。这里主要说名<code>-t</code>，·-i·</p><p>参数。</p><p>如果只使用<code>-i</code>参数的话，由于没有分配伪终端。界面没有我们熟悉的Linux命令符提示器。但是命令执行结果依然可以返回。</p><p>当<code>-i</code>,<code>-t</code>参数一起使用时，则可以看到我们熟悉的Linux命令提示符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -i 33b16714d2b8 bash</span><br><span class="line">ls</span><br><span class="line">Dockerfile</span><br><span class="line">README.md</span><br><span class="line">app.js</span><br><span class="line">node_modules</span><br><span class="line">package-lock.json</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -i -t 33b16714d2b8 bash</span><br><span class="line">root@33b16714d2b8:/shuliqi# ls</span><br><span class="line">Dockerfile  README.md  app.js  node_modules  package-lock.jsonpackage.json</span><br></pre></td></tr></table></figure><h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><p>使用<code>docker export</code>来导出本地的某个容器。其格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>OPTIONS 只有一个选项:</p><ul><li>**–output , -o:**将输入内容写到文件</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                              COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">33b16714d2b8        shuliqi/express-for-docker:0.0.1   &quot;docker-entrypoint.s…&quot;   3 hours ago         Up 3 hours          3000/tcp            great_lewin</span><br><span class="line">$ docker export 33b16714d2b8 &gt; express-docker.tar</span><br><span class="line">$ ls</span><br><span class="line">express-docker.tar</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker export -o=&quot;shuliqi.tar&quot; 33b16714d2b8</span><br><span class="line">$ ls</span><br><span class="line">express-docker.tar shuliqi.tar</span><br></pre></td></tr></table></figure><p>可以使用<code>docker import</code>从容器快照文件中再导入为镜像。其格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTION选项可以查看官方文档  <a href="https://docs.docker.com/engine/reference/commandline/import/">docker import</a></p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat express-docker.tar  | docker import - express-docker.tar</span><br><span class="line"></span><br><span class="line">sha256:d16ef3cbe87943de5c4a7c91f11de88b6b1854f7b8898f64060c7580c2840dda</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                                 TAG                       IMAGE ID            REPOSITORY                                 TAG                       IMAGE ID            CREATED             SIZE</span><br><span class="line">express-docker.tar                         latest                    d16ef3cbe879        45 seconds ago      913MB</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<code>docker container rm</code>命令来删除。其格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>如果删除一个 运行中的容器，可以添加 <code>-f</code> 参数。</p><p>使用<code>docker container ls --a</code>命令，可以查看所有已创建的包括终止状态的容器。如果数量太多的话一个一个删除会很麻烦。<strong>清理所有处于终止状态的容器</strong>可以使用命令 <code>docker container prune</code></p><h2 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h2><p>以上的内容我们学会了如何使用 image 和容器文件，但是如何生成 image 文件呢？</p><p>这就需要 DockerFile 文件，它是一个文本文件，用来配置 image，Docker 根据该文件生成二进制的 image 文件。</p><p>那么我们就通过一个实例，来演示如何编写 DcokerFile 文件吧。</p><h2 id="实例：制作自己的-Docker-容器"><a href="#实例：制作自己的-Docker-容器" class="headerlink" title="实例：制作自己的 Docker 容器"></a>实例：制作自己的 Docker 容器</h2><p>我们先创建一个 express 搭建的项目传到自己的 github。我已经创建完了 <a href="https://github.com/shuliqi/express-for-docker">express-for-docker</a>。怎么创建 express 实例，可以看<a href="https://expressjs.com/zh-cn/starter/hello-world.html">express的官网</a>。</p><p>当然我们上面使用的好多例子也用到了我们上传的 image 文件 <a href="https://hub.docker.com/r/shuliqi/express-for-docker">express-for-docker</a></p><p>接下来我们开始制作自己的 Docker 容器</p><h3 id="编写-Dockerfile-文件"><a href="#编写-Dockerfile-文件" class="headerlink" title="编写 Dockerfile 文件"></a>编写 Dockerfile 文件</h3><p>首先， 我们在项目的根目录下新建一个文本文件 <code>.dockerignore</code>,并写下下面的内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node-modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p>上面的代码表示，这三个路径需要排除，不要打包进 image 文件。如果没有路径需要排除，则这个文件不需要新建。</p><p>然后我们在项目的根目录下新建一个文本文件 <code>Dockerfile</code>,写入下面的内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /shuliqi</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /shuliqi</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span>/tcp</span><br></pre></td></tr></table></figure><p>上面的五行代码分别代表什么意思呢？</p><ul><li><p><strong>FROM node:8.4</strong></p><p>这个 image 文件继承官方的得 node image，冒号表示标签，这里的标签是12.17.0。即12.17.0 版本的node</p></li><li><p><strong>COPY . /app</strong></p><p>将当前目录下的所有文件（除了.dockerignore排除的路径）都拷贝到 image 文件的/app目录下面。</p></li><li><p><strong>WORKDIR /app</strong></p><p>指定接下来的工作路径为/app</p></li><li><p><strong>RUN [“npm”, “install”]</strong></p><p>在/app目录下面，运行 npm install 安装依赖。注意：安装后的所有依赖，都将打包进入  image 文件</p></li><li><p><strong>EXPOSE 3000</strong></p><p>将容器的 3000 端口暴露出来，允许外部连接这个端口。</p></li></ul><p>关于完整的一个 Dockerfile各种命令的使用，我们在下一节讲， 请继续关注哦(* ￣3)(ε￣ *)！！</p><h3 id="创建-image-文件"><a href="#创建-image-文件" class="headerlink" title="创建 image 文件"></a>创建 image 文件</h3><p>有了 .Dockerfile 文件之后， 就可以使用 <code>docker  build</code>命令创建 image 文件。<code>docker build</code> 的具体格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>当然 OPTION 选项也是很多的。具体也可以翻阅官方文档 <a href="https://docs.docker.com/engine/reference/commandline/build/">docker build </a>。</p><p>这里我们讲一个常用到的OPTION 选项：</p><ul><li>**–tag, -t:**镜像的名字以及标签通常 name:tag 格式 或是是 name 格式。</li></ul><p>name继续我们的是咧。我们来构建 image 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker  build -t express=for-docker .</span><br><span class="line">//或者</span><br><span class="line">docker  build -t express=for-docker:0.0.1 .</span><br></pre></td></tr></table></figure><p>这个命令中的 <code>-t</code>参数用来指定 image 文件的名字。后面还可以使用冒号来指定标签。如果不指定的话，默认的标签就是 latest。最后那个表示表示 Dockerfile文件所在的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t express-for-docker .</span><br><span class="line">Sending build context to Docker daemon  2.011MB</span><br><span class="line">Step 1/6 : FROM node:8.4</span><br><span class="line"> ---&gt; 386940f92d24</span><br><span class="line">Step 2/6 : COPY . /shuliqi</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 04a303d12b5f</span><br><span class="line">Step 3/6 : WORKDIR /shuliqi</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; fe2455b89e40</span><br><span class="line">Step 4/6 : RUN [&quot;npm&quot;, &quot;install&quot;]</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 4b9c8652ccc9</span><br><span class="line">Step 5/6 : EXPOSE 3000/tcp</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 11fbd94359f4</span><br><span class="line">Step 6/6 : CMD node app.js</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 1c4d4712b8c0</span><br><span class="line">Successfully built 1c4d4712b8c0</span><br><span class="line">Successfully tagged express-for-docker:latest</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                                 TAG                       IMAGE ID            CREATED              SIZE</span><br><span class="line">express-for-docker                         latest                    1c4d4712b8c0        About a minute ago   674MB</span><br></pre></td></tr></table></figure><p>打包完成后，我们在使用 <code>docker image ls</code>查看所有的image文件，是可以看到我们刚刚打包的image文件（express-for-docker）</p><h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p>使用<code>docker run</code>命令就会从image 文件生成容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -p 8000:3000  express-for-docker:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure><p>上面命令的参数含义如下：</p><ul><li><strong>-p参数：</strong> 容器的 3000 端口 映射到 本机的 8000 端口</li><li><strong>-t 参数：</strong> 容器额 Shell  映射到当前的 Shell，然后在本机窗口输入命令，就会传入容易</li><li><strong>express-for-docker:0.0.1</strong>： image文件的文件名和tag</li><li><strong>/bin/bash：</strong>容器启动后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul><p>执行上面的命令，如果一切正常，那么就会返回命令行提示符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@622773f4bec9:/app#</span><br></pre></td></tr></table></figure><p>这个提示就说明你已经在容器里面了，返回的提示符就是容器里面的 Shell 提示符。</p><p>接下来我们执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@622773f4bec9:/app# node app.js</span><br></pre></td></tr></table></figure><p>这命令就是启动我们这个项目的， 这时打开 <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000</a> 网页显示 “Hello World!”</p><h3 id="CMD-命令"><a href="#CMD-命令" class="headerlink" title="CMD 命令"></a>CMD 命令</h3><p>上面的例子， 容器启动后，我们需要手动的 输入 <code> node app.js</code>来启动项目。其实我们可以吧这个命令写在 Dockerfile 文件里面，这样容器启动后，这个命令就会执行了，不需要我们手动输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:12.17.0</span><br><span class="line">COPY . /shuliqi</span><br><span class="line">WORKDIR /shuliqi</span><br><span class="line">RUN [&quot;npm&quot;, &quot;install&quot;]</span><br><span class="line">EXPOSE 3000/tcp</span><br><span class="line">CMD node app.js</span><br></pre></td></tr></table></figure><p>多出来的这与 一个命令<code>CMD node app.js</code> 它表示容器启动后自动执行  <code>node app.js</code>.。</p><p><strong>CMD 和 RUN 命令的区别：</strong></p><p><code>RUN</code>命令在 image 文件构建阶段执行，执行结果都会打包进入 image 文件</p><p><code>CMD</code>命令则是在容器启动后执行</p><p>一个Dockerfile文件可以包含多个 <code>RUN</code>命令，但是只能有一个<code>CMD</code> 命令</p><h3 id="发布-image-文件"><a href="#发布-image-文件" class="headerlink" title="发布 image 文件"></a>发布 image 文件</h3><p>容器运行成功了之后，就说明 image 文件是有效的。那么我们可以考虑把 image 文件分享到网上， 让其他人也可以使用。</p><p>首先，我们需要去 <a href="https://hub.docker.com/">hub.docker.com</a>注册账号，然后使用如下的命令登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure><p>然后输入注册的用户名和密码。如果成功登录的话，会显示</p><img src="/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/8.png" class=""><p>那么接下来继续我们的发布，我们给本地的 image 标注用户名和版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag [imageName] [userNane]/[repository]:[tag]</span><br></pre></td></tr></table></figure><p>我们给自己的 <code>express-for-docker</code>标注用户名和版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag express-for-docker:0.0.1 shuliqi/express-for-docker:0.0.1</span><br></pre></td></tr></table></figure><p>标注完之后，我们就可以往 <a href="https://hub.docker.com/">hub.docker.com</a>发布我们的image包了。使用如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push express-for-docker:0.0.1</span><br></pre></td></tr></table></figure><p>如发布成功，则会显示：</p><img src="/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/9.png" class=""><p>我们到 <a href="https://hub.docker.com/">hub.docker.com</a> 上就会看到已经上传的 image 文件</p><img src="/2020/09/30/Docker%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/10.png" class=""><p>这样我们就成功发布了一个 image 文件</p><p>文章使用的例子 <a href="https://github.com/shuliqi/express-for-docker">express-for-docker</a></p><p>下一节详细讲 <a href="https://shuliqi.github.io/2020/10/20/Dockerfile%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/">Dockerfile 文件</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://yeasy.gitbook.io/docker_practice/image/list">Docker —— 从入门到实践</a></li><li><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></li><li><a href="https://docs.docker.com/reference/">docker docs</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手封装axios取消重复请求</title>
      <link href="/2020/08/31/%E5%B0%81%E8%A3%85axios%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/"/>
      <url>/2020/08/31/%E5%B0%81%E8%A3%85axios%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>在我们web开发过程中，很多地方需要我们取消重复的请求。但是哪种场合需要我们取消呢？ 我们如何取消呢？带着这些问题我们阅读本文。</p><p>阅读完本文，你将了解以下内容：</p> <span id="more"></span><ul><li>需要取消重复请求的场景</li><li>我们如何取消重复请求</li><li>axios如何取消重复的请求</li><li>封装axios</li><li>如何给开源的项目提供源码</li><li> 如何在本地调试npm包</li></ul><h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><p>最近做的项目中，用的用户经常遇到这样的问题：</p><ul><li>用户频繁切换筛选条件去请求数据，初次的筛选条件数据量大。用的时间比较多。 后面的筛选条件的数据量小。导致后面请求的数据先返回。内容先显示在页面上。但是等一段时间，初次(或者前面)的请求数据返回了， 会覆盖后面的请求的数据。这就导致了筛选条件和内容不一致的情况。</li><li>用户点击了一次提交按钮，接口没有很快响应，导致页面没办法做逻辑语句判断的提示。用户觉得可能没提交上，便会快速又点了按钮几次。如果后端没有去重的判断，就会导致数据中有很多条重复的数据。</li></ul><p>这些问题给用户的体验是很不友好的。那么取消无用的请求是很有必要的。</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>我们用的请求库是axios。那么我们可以在请求的时候拦截请求判断当前的请求是否重复，如果重复我们就取消当前的请求。大致的实现过程如下：</p><p><strong>我们把目前处于pending的请求存储（假如我们放在一个数组）起来。每个请求发送之前我们都要判断当前这个请求是否已经存在于这个数组。如果存在，说明请求重复了，我们就在数组中找到重复的请求并且取消。如果不存在，说明这个请求不是重复的，正常发送并且把这个请求api添加在数据中，等请求结束之后删除数组中的这个api。</strong></p><p>我们这个解决思路有了，但是axios如何取消请求的呢？ 我们先来了解下</p><h1 id="axios-如何取消请求"><a href="#axios-如何取消请求" class="headerlink" title="axios 如何取消请求"></a>axios 如何取消请求</h1><p>查看axios文档发现axios <a href="http://www.axios-js.com/zh-cn/docs/#%E5%8F%96%E6%B6%88">提供了两种取消请求的方法</a></p><ul><li><p>第一种方法</p><p>通过<code>axios.CancelToken.source</code>生成取消令牌<code>token</code>和取消方法<code>cancel</code></p><p>这是官方给的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Request canceled&#x27;</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;new name&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel the request (the message parameter is optional)</span></span><br><span class="line">source.cancel(<span class="string">&#x27;Operation canceled by the user.&#x27;</span>);</span><br></pre></td></tr></table></figure><p>我们自己写个例子：<a href="http://jsfiddle.net/shuliqi/pfj6nsy9/354/">axios取消请求第一种方法</a> </p><iframe width="100%" height="300" src="//jsfiddle.net/shuliqi/pfj6nsy9/356/embedded/js,result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><p>在这个例子中可以通过注释：<code> source.cancel(&#39;手动把请求被取消了&#39;);</code>这段代码来看看</p></li><li><p>第二种方式</p><p>通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建 cancel token;</p><p>官方的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// executor 函数接收一个 cancel 函数作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel the request</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure><p>我们自己来写一个例子看看 [axios取消请求第二种方法]](<a href="http://jsfiddle.net/shuliqi/ucy6vde1/7/">http://jsfiddle.net/shuliqi/ucy6vde1/7/</a>)</p><iframe width="100%" height="300" src="//jsfiddle.net/shuliqi/ucy6vde1/7/embedded/js,result/dark/?bodyColor=1c2128" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe></li></ul><h1 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h1><p>解决取消请求的思路有了，取消请求的办法也有了，那么剩下的就是封装了</p><p>由于同事之前已经封装了axios <a href="https://github.com/verymuch/very-axios">very-axios</a>（基于 axios 进行二次封装，更简单、更统一地使用 axios。）。那么我们就这个基础上提一个pr吧。那么从现在开始我们就一步一步的来实现，这个过程包含了【如何给开源的项目贡献代码】【如何在本地调试npm】如果已经料机的同学可以直接略过。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>由于同事已经封装了axios并且已经开源了。那么我贡献代码的方式主要有两种：</p><ul><li>代码仓库的管理者给我们添加这个仓库的写入权限，如果这样，我们就可以直接提push。</li><li>如果我们没有权限(大多数情况)。我们使用经典的fork &amp; pull request 的方式来提交代码。</li></ul><p>我们采用的第二种方式。 我们去 <a href="https://github.com/verymuch/very-axios">very-axios</a>把代码fork到自己的仓库(如果你还没有自己的github,需要自己注册下哦)。</p><img src="/2020/08/31/%E5%B0%81%E8%A3%85axios%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/1.png" class=""><p>那么你回到自己的github仓库下面就会看有一个一摸一样的项目</p><img src="/2020/08/31/%E5%B0%81%E8%A3%85axios%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/2.png" class=""><p>那么我们现在就可以<code>git clone </code>这个仓库的代码到本地，新建branch进行开发,就比如我新建了一个这样的branch：</p><img src="/2020/08/31/%E5%B0%81%E8%A3%85axios%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/3.png" class=""><p>现在已经有本地的代码了，但是我们调试呢？如何确保我们改的是对的呢？那么就需要我们本地调试本地的npm包了。 那就需要<code>npm link</code> 了 </p><p>首先在我们要修改的npm 包中<code>npm link</code>,,如：</p><img src="/2020/08/31/%E5%B0%81%E8%A3%85axios%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/4.png" class=""><p>之后我们会得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/shuliqi/.nvm/versions/node/v12.17.0/lib/node_modules/very-axios -&gt; /Users/shuliqi/study/axios/very-axios</span><br></pre></td></tr></table></figure><p>这意思就是我们把<code>very-axios</code>链接到全局的<code>node_modules</code></p><p> 然后我们进入我们my-project-of-axios 目录下面执行<code>npm link very-axios  </code> 如图：</p><img src="/2020/08/31/%E5%B0%81%E8%A3%85axios%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/5.png" class=""><p>这意思就是<code>very-axios</code>被安装在<code>my-project-of-axios</code> 下面了。<code>very-axios</code>的修改都会同步到<code>my-project-of-axios</code>。就实现本地测试了。</p><p>我们在<code>my-project-of-axios</code>中的<code>HelloWorld.vue</code>文件中做列子。</p><p>如果这里看的不是很懂的同学可以 看看这两篇文章 <a href="https://github.com/allenGKC/Blog/issues/13">如何在本地调试npm包</a>  <a href="https://juejin.im/post/6844903636863041550">如何使用 GitHub Flow 给开源项目贡献代码</a></p><h2 id="开始封装"><a href="#开始封装" class="headerlink" title="开始封装"></a>开始封装</h2><p>准备工作完成了, 那我们开始封装的事情。根据我们之前的思路。我们采用axios 如何取消请求的第一种方式。</p><p>声明一个Map。用来存储每个请求的 标识 和 取消的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stores the identity and cancellation function for each request</span></span><br><span class="line"><span class="built_in">this</span>.pendingAjax = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><p>自定一个字段来让用户自己决定是否需要取消重复的请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// whether to cancel a duplicated request</span></span><br><span class="line">cancelDuplicated = <span class="literal">false</span>,</span><br></pre></td></tr></table></figure><p>自定一个字段来让用户是否有全局的统一的设置重复标识的函数。如果没有设置全局的统一的函数，则默认是请求的<code>method</code> 和<code> url</code>作为重复的标识</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// how to generate the duplicated key</span></span><br><span class="line">duplicatedKeyFn,</span><br><span class="line"><span class="built_in">this</span>.duplicatedKeyFn = isFunction(duplicatedKeyFn) ? duplicatedKeyFn : <span class="function">(<span class="params">config</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;config.method&#125;</span><span class="subst">$&#123;config.url&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>添加请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add request to pendingAjax</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">config</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">addPendingAjax</span>(<span class="params">config</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// if need cancel duplicated request</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.cancelDuplicated) <span class="keyword">return</span> </span><br><span class="line">  <span class="keyword">const</span> veryConfig = config.veryConfig || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> duplicatedKey = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="attr">duplicatedKey</span>:  veryConfig.duplicatedKey || <span class="built_in">this</span>.duplicatedKeyFn(config), </span><br><span class="line">    <span class="attr">type</span>: REQUEST_TYPE.DUPLICATED_REQUEST,</span><br><span class="line">  &#125;);</span><br><span class="line">  config.cancelToken = config.cancelToken || <span class="keyword">new</span> axios.CancelToken(<span class="function">(<span class="params">cancel</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// if the current request does not exist in pendingAjax, add it</span></span><br><span class="line">    <span class="keyword">if</span> (duplicatedKey &amp;&amp; !<span class="built_in">this</span>.pendingAjax.has(duplicatedKey)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.pendingAjax.set(duplicatedKey, cancel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面我们可以使用<code>duplicatedKey</code>字段来让用户对单一请求自定义重复的标识。或者可以使用一个函数<code>duplicatedKeyFn</code>统一的让用户自定义重复的标识</p><p>删除请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * remove the request in pendingAjax</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">config</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">removePendingAjax</span>(<span class="params">config</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// if need cancel duplicated request</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.cancelDuplicated) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> veryConfig = config.veryConfig || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> duplicatedKey = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="attr">duplicatedKey</span>:  veryConfig.duplicatedKey || <span class="built_in">this</span>.duplicatedKeyFn(config), </span><br><span class="line">    <span class="attr">type</span>: REQUEST_TYPE.DUPLICATED_REQUEST,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// if the current request exists in pendingAjax, cancel the current request and remove it</span></span><br><span class="line">  <span class="keyword">if</span> (duplicatedKey &amp;&amp; <span class="built_in">this</span>.pendingAjax.has(duplicatedKey)) &#123;</span><br><span class="line">    <span class="keyword">const</span> cancel = <span class="built_in">this</span>.pendingAjax.get(duplicatedKey);</span><br><span class="line">    cancel(duplicatedKey);</span><br><span class="line">    <span class="built_in">this</span>.pendingAjax.delete(duplicatedKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装好了， 我们在在哪里使用呢？肯定是在请求开始之前和请求完成之后使用。</p><p>在请求之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intercept response</span></span><br><span class="line"><span class="built_in">this</span>.axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// check the previous request for cancellation before the request starts</span></span><br><span class="line">  <span class="built_in">this</span>.removePendingAjax(config);</span><br><span class="line">  <span class="comment">// add the current request to pendingAjax</span></span><br><span class="line">  <span class="built_in">this</span>.addPendingAjax(config);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在请求完成之后去掉该请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intercept response</span></span><br><span class="line"><span class="built_in">this</span>.axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  removePending(response) </span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>到现在已经完成了该有的功能， 但是取消请求的错误我们不该返回给用户。所以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(err) =&gt; &#123;</span><br><span class="line"><span class="comment">// whether is the type of duplicated request</span></span><br><span class="line"><span class="keyword">let</span> isDuplicatedType;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> errorType = (<span class="built_in">JSON</span>.parse(error.message) || &#123;&#125;).type</span><br><span class="line">  isDuplicatedType = errorType === REQUEST_TYPE.DUPLICATED_REQUEST;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  isDuplicatedType = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isDuplicatedType) <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们在请求完成之后的err里面做一个判断，判断如果当前请求是取消的类型，我们就不返回给用户错误的提示信息。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此 完成了我们的封装。<a href="https://github.com/verymuch/very-axios/pull/1">完成的pr可以点击这里查看</a>   <a href="https://github.com/shuliqi/my-project-of-axios">本文测试npm包的项目</a></p><p>有任何问题可以联系我联系，联系方式：<a href="mailto:&#115;&#104;&#117;&#108;&#105;&#113;&#x69;&#x40;&#111;&#117;&#x74;&#x6c;&#111;&#111;&#x6b;&#x2e;&#99;&#x6f;&#109;">&#115;&#104;&#117;&#108;&#105;&#113;&#x69;&#x40;&#111;&#117;&#x74;&#x6c;&#111;&#111;&#x6b;&#x2e;&#99;&#x6f;&#109;</a>  ，<a href="mailto:&#x73;&#104;&#x75;&#x6c;&#105;&#113;&#105;&#64;&#x33;&#x36;&#48;&#46;&#x63;&#110;">&#x73;&#104;&#x75;&#x6c;&#105;&#113;&#105;&#64;&#x33;&#x36;&#48;&#46;&#x63;&#110;</a> </p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript语言精髓与编程实战》读书笔记-Promised的核心机制</title>
      <link href="/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>最近参部门的读书会，读书会会推荐一些书来供我们学习， 这次的读书会推荐读的书是《JavaScript语言精髓与编程实战》。感觉写的很不错，我这次学习的是【Promise的核心机制】, 虽然之前也看过关于<code>Promise</code>  <a href="https://shuliqi.github.io/2018/03/20/ES6%E5%AD%A6%E4%B9%A0-Promise/">ES6学习笔记-Promise</a>, 但是在看这本书之后，讲的更多关于<code>Promise</code>的原理。还是有值得很深入的点。</p><p>最后感觉跟着大神们学习感觉很不错呀，哈哈嘻😊！</p> <span id="more"></span><h1 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise?"></a>什么是Promise?</h1><p>Promise对象是一个代理对象（代理一个值）。被代理的值在Promise创建的时候可能是未知的。它允许你为异步操作的成功与失败分别绑定相应的处理方法。这让异步可以像同步方法那样返回值，但并不是立即返回最终的执行结果，而是一个能代表未来的出现的结果的promise对象。</p><h1 id="promise的状态"><a href="#promise的状态" class="headerlink" title="promise的状态"></a>promise的状态</h1><p>Promise 一种有三种值的状态： <strong>pending(进行中)</strong>, <strong>fulfiiled(已成功)<strong>，</strong>rejected(已失败)‘</strong></p><h1 id="Promise的特点"><a href="#Promise的特点" class="headerlink" title="Promise的特点"></a>Promise的特点</h1><ul><li><p><strong>对象的状态不受外界的影响</strong></p><p>只有异步的结果可以决定当前是哪一种状态（pending， fulfilled, rejected）。 其他的手段都是无法改变的。</p></li><li><p><strong>一旦状态改变，就不会再变，任何时候都可以拿到这个状态</strong></p><p>Promise的状态只有两种可能：从pending 到 fulfilled， 从peding 到rejected。只要这两种发生了，状态也就凝固了，不会再变了。</p><p>如果在对Promise对象添加回调函数，也会立刻拿到这个结果。</p></li></ul><h1 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h1><p>创建Promise对象，主要有三种方式：</p><ul><li><p>使用 <code>new Promise()</code>来创建一个<code>promise</code>(即<code>new Promise() </code>构造器)</p></li><li><p>使用类方法Promise.xxx()-——<code>Promise.all()</code>，<code>Promise.race()</code>，<code>Promise.allsettled()</code>，<code>Promise.any()</code>，<code>Promise.resolve()</code>，<code>Promise.reject()</code></p></li><li><p>使用原型形方法<code>Promise.prototype.xxx()</code>——<code>promise.then()</code>，<code>promise.catch()</code>，<code>promise.fanally()</code>都将返回一个新的promise</p><blockquote><p>任何方法得到的<code>promise</code>对象都具有<code>.then</code>，<code>.catch</code>等方法，也是<code>Promise.prototype.xxx</code>的原型方法，<code>Javascript</code>调用这些方法将绝对不会抛出异常，所以这就是上面第三种得到一个新的<code>promise</code>对象的方法</p></blockquote></li></ul><p><strong>注意：</strong>任何一种方法都是立即得到<code>promise</code>对象的</p><h1 id="Promise的构造方法"><a href="#Promise的构造方法" class="headerlink" title="Promise的构造方法"></a>Promise的构造方法</h1><p><code>Promise</code>通常使用一个简单的构造器来让用户方便的创建<code>promise</code>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建promise对象的构造器</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要用户声明的执行函数</span></span><br><span class="line"><span class="keyword">const</span> executor = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>executor</code> 是用户声明的执行函数，当<code>JavaScript</code>引擎通过new 运算符来创建<code>promise</code>对象时，它事实上在调用<code>executor()</code>之前就创建好一个新的<code>promise</code>对象的实例，并且得到关联给这个实例的两个置值器：<code>resolve()</code>，<code>reject()</code>函数，然后，它会调用<code>executor()</code>，并且把这两个置值器作为入口参数传入，而<code>executor()</code>函数会被执行直到退出。</p><p><strong>注意：</strong><code>executor()</code>函数并不通过退出时所返回的值来对系统造成影响——该返回值将会被忽略（无论是显式返回结果，还是默认返回值<code>undefined</code>）。<code>executor()</code>中的用户代码可以利用上述的两个置值器，来向<code>promise</code>对象“代理的那个数据”置值。也就是说，为<code>promise</code>绑定值的过程是由用户代码来触发的。这个过程看起来像”让用户代码回调<code>JavaScript</code>引擎”。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户代码通过resolve(或reject）来回调引擎以置值</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>**注意：<code>executor()</code>**函数中的<code>resolve</code>·置值器可以接受任何值（除了当前的promise本身之外）,如果使用自身来置值时，<code>JavaScript</code>会抛出一个异常。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂存resolve置值的变量</span></span><br><span class="line"><span class="keyword">let</span> delayResolve;</span><br><span class="line"> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    delayResolve = resolve;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// 尝试使用自身来置值</span></span><br><span class="line"> delayResolve(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span></span><br></pre></td></tr></table></figure><h1 id="构建Promise对象：没有延迟"><a href="#构建Promise对象：没有延迟" class="headerlink" title="构建Promise对象：没有延迟"></a>构建Promise对象：没有延迟</h1><p>在构建整个<code>Promise</code>对象的过程中， 是没有任何的延迟的。<code>Promise</code>机制中没有延迟， 也没有被延迟的行为，更没有对”时间”这个维度进行控制。因此<code>JavaScript</code>中创建一个<code>promise</code>时，创建过程时立即完成的；使用原型的方法<code>promise.xxx</code>来得到一个新的<code>promise</code>时也是立即完成的。所有<code>promise</code>对象都是在你需要的时候立即就生成的。</p><p>只不过重要的是—-&gt;<strong>这些<code>promise</code>所代理的那个值/数据还没有“就绪”。这个就绪的过程要推迟到“未知的将来”才会发生，而一旦数据就绪，promise.then(fun)中的fun就会被触发了</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&#x27;1&#x27;</span>), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只要我们创建了<code>promise</code> 对象，这个过程是立即的，所以立马输出“shuliqi”。然后过3秒，输出 “1”。</p><h1 id="Then-链"><a href="#Then-链" class="headerlink" title="Then 链"></a>Then 链</h1><p>两个<code>Promise </code>对象之间顺序执行的关系，在<code>JavaScript</code>中称为“Then 链”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Promise 对象P</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;shuliqi&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过p.then()来得到新的promise对象 p2</span></span><br><span class="line"><span class="keyword">const</span> p2 = p.then(foo() =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过调用<code>p.then(</code>)的方式来约定当前的<code>promise </code>对象与下一个<code>promise</code>对象之间的“链”关系，并且这事实上也也代表了它们之前的顺序执行的关系（<strong>所谓的“顺序执行”是指它们的置值逻辑以及触发的行为之间的关系—-&gt; 因为Promise本身是数据的代理所以并不是执行体</strong>）。</p><p>并且then链是Promise机制的基本用法和关键的机制。上面例子中的p.then()代表了对顺序的逻辑的理解， 同时它也隐含的说明：p2 与p1两者所代理的数据之间是有关联的。这个例子的foo()函数是作为p1的成功回调，如下面这个例子的作为onFulfilled参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Promise 对象P</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过p.then()来得到新的promise对象 p2</span></span><br><span class="line"><span class="keyword">const</span> p2 = p.then(onFulfilled, onRejected);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(value); <span class="comment">// shuliqi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前的promise数据就绪时，JavaScript就将根据就绪状态立即出发有p.then()方法所关联的onFulfilled/ onRejected之一，并且这个函数<strong>退出时返回的值</strong>或者<strong>终止执行时的状态</strong>作为值来调用p2</p><p>p.then()实际上是Promise.prototype.then这个原型的方法，它的作用主要是完成三件事：</p><ul><li>创建新的promise2对象</li><li>登记当前promise 与 promise2 之间的关系（顺序执行的关系和代理的数据之间是有关联的）</li><li>将onFulfilled ，onRejected关联给promise2 的resolve置值器，并且确保早promise1的数据就绪时调用onFulfilled， onRejected。</li></ul><h2 id="promise1的置值逻辑"><a href="#promise1的置值逻辑" class="headerlink" title="promise1的置值逻辑"></a>promise1的置值逻辑</h2><p>所以在构建promise的执行器中，可以向resolve/reject 传入任意的JavaScript数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;我显示使用resolve置值器置值&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(<span class="string">&#x27;我显示使用reject 置值器置值&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个例子显式的使用resolve / reject 置值器来置值。</p><p>如果执行器在执行的过程中触发异常，javaScript引擎也将调用reject， 并且把异常作为reason。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// 创建异常，并且抛出，相当于reject(new Error())</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来，如果在它的then 链上有promise2,那么如前所诉：onFulfilled/onRejected将被触发，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;我显示使用resolve置值器置值&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(<span class="string">&#x27;我显示使用reject 置值器置值&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 =p.then(onFulfilled, onRejected);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是resolve置值器置值成功的回调&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是reject置值器置值或者是resolve置值器置值失败的回调&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我是resolve置值器置值成功的回调</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(); <span class="comment">// 创建异常，并且抛出，相当于reject(new Error())</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 =p.then(resolved, rejected);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolved</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是resolve置值器置值成功的回调&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是reject置值器置值或者是resolve置值器置值失败的回调&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我是reject置值器置值或者是resolve置值器置值失败的回调</span></span><br></pre></td></tr></table></figure><p>以上的的 resolved， rejected 都只是 p 的状态，他们只是promise2的置值前提而已， 那么promise2的置值逻辑是啥呢？</p><h2 id="promise2的置值逻辑"><a href="#promise2的置值逻辑" class="headerlink" title="promise2的置值逻辑"></a>promise2的置值逻辑</h2><p>一个Promise可能被置入两种值之一（并且一旦置值将不可改变，称为“终态”），这两种值时指：</p><ul><li>如果promise 被 resolve置值器置值成功，则该值称为有效值（value）</li><li>如果promise 被 reject置值器置值 或者 resolve置值器置值 失败，则该值用于记录原因（reason）。</li></ul><p><strong>无论rejected，rejected函数无论返回何值，都将作为resolve值直接绑定给promise2</strong>(即：resolved, rejected函数会关联在promise2的resolve 值值器上)</p><p>promise2 的置值逻辑伪代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断上一个promise的置值状态</span></span><br><span class="line">    <span class="keyword">if</span> (isRejected(p)) &#123;</span><br><span class="line">        x2 = rejected(result);  <span class="comment">// 执行rejected函数，result为reason（result是p代理的数据）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x2 = resolved(result); <span class="comment">// 执行resolved函数</span></span><br><span class="line">    &#125; </span><br><span class="line">    resolve(x2); <span class="comment">// promise2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvedForP1 = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rejectedForP1 = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reason;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> resolvedForP2 = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是p2 resolved状态,&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rejectedForP2= <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是p2 rejected状态,&#x27;</span>, reason);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 顺便调用p1的resolve置值器，还是reject置值器</span></span><br><span class="line">      <span class="comment">// resolve(&#x27;p1 resolve&#x27;);</span></span><br><span class="line">      reject(<span class="string">&#x27;p1 reject&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(resolvedForP1, rejectedForP1);</span><br><span class="line">p2.then(resolvedForP2, rejectedForP2)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我是p2 resolved状态, p1 reject</span></span><br></pre></td></tr></table></figure><p>这个例子： 无论p1 我调用的是 resolve 置值器还是拍，导致无论调用 resolvedForP1还是 rejectedForP1，返回值都是作为resolve值绑定给p2。</p><p>调用（p1  reject 置值器 —-&gt; 调用rejectedForP1 —-&gt; rejectedForP1 返回值 —-&gt; 通过p2 的resolve置值器直接绑定给p2）。</p><p>注意：<strong>这不是完成的promise2 的置值逻辑</strong>， 完整的请往下看。</p><h2 id="then-链中“产生”-reject值的方法"><a href="#then-链中“产生”-reject值的方法" class="headerlink" title="then 链中“产生” reject值的方法"></a>then 链中“产生” reject值的方法</h2><p>在then 链中“产生” reject值的方法只有两种：</p><ul><li><p>通过抛出异常来使得JavaScript引擎捕获异常对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;我是舒丽琦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方法1: 通过抛出异常来使得JavaScript引擎捕获异常对象</span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;通过抛出异常来使得JavaScript引擎捕获异常对象&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: Error: 通过抛出异常来使得JavaScript引擎捕获异常对象....</span></span><br></pre></td></tr></table></figure></li><li><p>通过显式的调用Promise.reject()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;我是舒丽琦&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方法2: 显式的调用Promise.reject() </span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;显式的调用Promise.reject() &#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: 显式的调用Promise.reject() ...</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Then-链对值的传递"><a href="#Then-链对值的传递" class="headerlink" title="Then 链对值的传递"></a>Then 链对值的传递</h2><p>如果promise2 的resolve 并没有关联有效的resolved，rejected 呢？ 或者 promise2 根本没有resolved， rejected 函数呢？那么还会生成promise2 吗？ 如果生成， 那么它的值时什么呢？</p><p>答案：<strong>如果没有有效的响应函数仍会产生新的promise2, 并且它的resolve 将以then 链中的当前的promise的值为值</strong>，</p><p>因此promise2 的完整的伪置值逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断上一个promise的置值状态</span></span><br><span class="line">    <span class="keyword">if</span> (isRejected(p)) &#123;</span><br><span class="line">       <span class="comment">// rejected 是有效的 ? 执行rejected函数，result为reason : result </span></span><br><span class="line">       <span class="comment">// 其中result是p代理的数据</span></span><br><span class="line">        x2 = isValidHandler(rejected) ? rejected(result) :<span class="keyword">throw</span> result;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// resolved函数是有效的 ？ 执行resolved函数 ： result;</span></span><br><span class="line">        x2 = isValidHandler(resolve) : resolved(result) : result; </span><br><span class="line">    &#125; </span><br><span class="line">    resolve(x2); <span class="comment">// promise2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来举例子检测一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;调用p1的reject置值器置值&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then();</span><br></pre></td></tr></table></figure><img src="/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/1.png" class=""><p>P1代理的值是reject 置值器置值的，在创建p2的时候， rejected 函数不存在(无效), 则抛出异常, 值为当前promise(p1)的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;调用p1的reject置值器置值&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p2 = p1.then();</span><br></pre></td></tr></table></figure><img src="/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/2.png" class=""><p>P1代理的值是resolve置值器置值的，在创建p2的时候， resolved函数不存在(无效), 则直接返回当前promise(p1)的值。</p><h2 id="Then-链-catch-的处理"><a href="#Then-链-catch-的处理" class="headerlink" title="Then 链 catch() 的处理"></a>Then 链 catch() 的处理</h2><p>promise2的置值过程也解释了使用.catch作为then链结尾的原因：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;调用p1的reject置值器置值&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then();</span><br><span class="line"><span class="keyword">const</span> p3 = p2.then();</span><br><span class="line">p3.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// UnhandledPromiseRejectionWarning: 调用p1的reject置值器置值</span></span><br></pre></td></tr></table></figure><p>在任意长的then链中，如果链的前端出现了rejected 值，无论经过多少级.then()响应(只有onFulfilled响应而没有处理)， 最终rejected 值都能够持续向后传递并且被链尾的.catch()响应到。这也就是Promise机制的第一原则：<strong>始于Promise， 终于catch</strong>。</p><h1 id="Promise的类方法"><a href="#Promise的类方法" class="headerlink" title="Promise的类方法"></a>Promise的类方法</h1><p>Promise()类方法Promise.xxx主要作用于获得一个promise</p><p>promise类方法有四个：</p><ul><li><p><strong>Promise.resolve()</strong></p></li><li><p><strong>Promise.reject()</strong></p></li><li><p><strong>Promise.all()</strong></p></li><li><p><strong>Promise.race()</strong></p></li></ul><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>作用：<code>Promise.resolve()</code>将现有的对象转成<code>Promise</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(x)</span><br></pre></td></tr></table></figure><p>x是任意值，如果不指定则是undefined</p><ul><li><p>如果 x 是Promise的一个实例，那么Promise.resolve(x)， 将不会产生新的计算结果，而是直接返回x这个实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;reject&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// p1 与 p2 是相同的promise</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;resolve&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// p1 与 p2 是相同的promise</span></span><br></pre></td></tr></table></figure><p>说明：如果x是一个<code>rejected</code>的<code>promise</code>对象，那么<code>Project.resolve(x)</code>将会是一个<code>rejected</code>状态的<code>promise</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;rejected状态&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(p);</span><br><span class="line">p2.then().catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// rejected状态</span></span><br></pre></td></tr></table></figure><img src="/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/3.png" class=""></li><li><p>如果x是一个thenable</p><p>thenable对象：指任意带有.then()方法的对象。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">   <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;我是thenable对象&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">(<span class="params">reaolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是thenable对象&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">p1 = <span class="built_in">Promise</span>.resolve(obj);</span><br></pre></td></tr></table></figure><img src="/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/4.png" class=""><p><code>x.then()</code>是立即执行了， 但是这个<code>thenable</code>对象与最终的p没有关系，所以目前这个执行过程是没有什么意义的。因为这个t<code>henable</code>对象与最终的<code>p</code>对像之间并没有建立关系。为什么没有建立关系呢？这是因为<code>JavaScript</code>是试图将x.then()作为一个“类似new Promise()中的执行器（executor）”来使用的。<code>Promise.resolve(tenable)</code>导致<code>.then() </code>被执行时，<code>p</code>这个<code>promise</code>对象的<code>resolve</code>与r<code>eject</code>两个置值器被作为<code>.then()</code>的参数传入的，因此(与<code>new Promise</code>类似)，用户代码需要在<code>.then(resolve,reject)</code>调用这两个置值器才能真正的建立thenable与p之间的关系。</p><p>所以下面这个例子，p对象与thenable才真正建立起了关系：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是thenable对象&quot;</span>);</span><br><span class="line">    resolve(<span class="string">&quot;结果&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">p1 = <span class="built_in">Promise</span>.resolve(obj);</span><br></pre></td></tr></table></figure><img src="/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/5.png" class=""></li><li><p>x以上情况都不是，那么将会返回一个新的<code>resolved</code>的<code>promise</code>对像，并且代理的数据与<code>x</code>的相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;111&quot;</span>);</span><br></pre></td></tr></table></figure><img src="/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/6.png" class=""></li></ul><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Pomise</code>类方法<code>Promise.reject()</code>得到一个状态为<code>rejected </code>的<code>promise</code>；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(x)； <span class="comment">// x是任意值，如果不指定则为undefined   </span></span><br></pre></td></tr></table></figure><p><code>Promise.reject(x)</code>与<code>Promise.resolve(x)</code>不同，<code>Promise.reject(x)</code>是将<code>x</code>作为一个普通的对象。这就意味着仍然会得到一个<code>rejected promise</code>，并且它的值时一个（类型为Promise）的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">p2 = <span class="built_in">Promise</span>.reject(p1);</span><br></pre></td></tr></table></figure><img src="/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/7.png" class=""><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>尝试<code>resolve</code>所有元素。当所有的元素都<code>resolved</code>，得到一个将所有结果作为<code>resolved</code> array的<code>promise</code>。当任意一个元素<code>rejected</code>，得到一个该结果 <code>reason</code> 的<code>rejected promise</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(x); <span class="comment">// x 必须是可迭代对象（集合对象，或者是有迭代器的对象）</span></span><br></pre></td></tr></table></figure><p><strong>可迭代的对象</strong>：数组， Map/Set集合，字符串可迭代的对象：数组， Map/Set集合，字符串 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;222&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;333&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;444&quot;</span>);</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">Promise</span>.all([p1,p2,p3,p4]);</span><br></pre></td></tr></table></figure><img src="/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/8.png" class=""><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;222&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">&quot;333&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;444&quot;</span>);</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">Promise</span>.all([p1,p2,p3,p4]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/9.png" class=""><p>Promise.all()会对所有的元素进行预处理（Promise.resolve(x)）所以无论x 是一个普通值还是一个“潜在的promise”， 它都将作为一个resolved promise进入后续的处理，即使x是一个rejected promise， 那么它的状态(Promise.resolve(rejected_promise))依然会影响Promise.all()的最终状态的判断。 一旦发现rejected，则返回rejected的结果。</p><p>promise.all(element)只有element完全resolved时，会在then()中得到一个与原始element 存在映射关系的数组。</p><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p><strong>作用：</strong>作用也是将多个promise实例，包装成一个新的Promise实例。 但是是是要参数实例有任何一个状态变成fulfilled。 包装实例对象就会变成fulfilled状态。如果所有的Promise状态都变成rejected, 包装实例对象才会变成rejecte的状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;1111&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;2222&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">Promise</span>.any([p1,p2]);</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;resolve&quot;</span>, value)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;reject&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 111</span></span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>尝试resolve 所有元素。只要其任一元素resolved 或 rejected，都将以该结果作为结果promise</p><p>注意：所有的其他的元素的状态都是未确定的，并且他们的执行过程与结果不确定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race(x); <span class="comment">// x 必须是可迭代对象（集合对象，或者是有迭代器的对象）</span></span><br></pre></td></tr></table></figure><p>Promise.race()与Promise.all()类似， 都会对所有的元素进行预处理（Promise.resolve(x)）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;1111&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;2222&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">Promise</span>.race([p1,p2]);</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;resolve&quot;</span>, value)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;reject&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// reject 2222</span></span><br></pre></td></tr></table></figure><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p><strong>作用：</strong>作用也是将多个promise实例，包装成一个新的Promise实例.。但是只要这些参数的实例都返回结果，不管是fulfilled还是rejected,包装实例才会结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;1111&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;2222&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">Promise</span>.allSettled([p1,p2]);</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;resolve&quot;</span>, value)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;reject&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve [</span></span><br><span class="line"><span class="comment">//   &#123; status: &#x27;fulfilled&#x27;, value: &#x27;1111&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; status: &#x27;rejected&#x27;, reason: &#x27;2222&#x27; &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h1 id="Promise对象的原型方法"><a href="#Promise对象的原型方法" class="headerlink" title="Promise对象的原型方法"></a>Promise对象的原型方法</h1><p>Promise对象方法Promise.prototype.xxx(p.xxx)主要用于响应一个promise 状态，并且对象方法的响应结果也必然是返回一个新的promise2。除了.then()之外，promise对象最主要的的原型方法—.catch() 和.finally()都是通过通过.then()来间接实现的。</p><h2 id="Promise-Prototype-catch"><a href="#Promise-Prototype-catch" class="headerlink" title="Promise.Prototype.catch()"></a>Promise.Prototype.catch()</h2><p>.catch(onRejected) 与.then(_, onRejected)中的参数一致， 两种用法的效果也近似。</p><p>但是使用.catch()的方法， 尤其是在Then链末端的.catch()是非常必要的和安全的， 因为.then(onFulfilled, onRejected)中的onRejected函数并不能捕获到onFulfilled函数里面的异常(以及其中返回的rejected promise)。 如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onFulfilled = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;我抛出异常，产生rejected promise&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;没有能捕获onFulfilled函数返回的rejected promise&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><p>这个例子中的onRejected 函数并不能响应onFulfilled函数中抛出的异常以及JavaScript为该异常而创建的rejected promise，将会遗漏对rejected Promise的处理，争取的处理应该是遵循“始于promise，终于catch”的原则。如下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onFulfilled = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;我抛出异常，产生rejected promise&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;没有能捕获onFulfilled函数返回的rejected promise&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p.then(onFulfilled, onRejected).catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我来处理onFulfilled产生的异常:&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 我来处理onFulfilled产生的异常： 我抛出异常，产生rejected promise</span></span><br></pre></td></tr></table></figure><h2 id="Promise-Prototype-finally"><a href="#Promise-Prototype-finally" class="headerlink" title="Promise.Prototype.finally()"></a>Promise.Prototype.finally()</h2><p>finally()方法，与try…catch/finally中的finally子句的语法类似；使代码无论.catch()还是.then()调用结束后，总是能得到一次调用.fanally()的机会。</p><p><strong>该方法不接受任何的参数，意思就是最后的Promise代理的值是什么， 是没有办法知道的。finally()方法跟最后的promise的状态是无关的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// finally（）方法的响应函数是无传入参数的</span></span><br><span class="line"><span class="keyword">const</span> onFinally = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;不管promise状态怎么样， 我都会执行, 并且我是无参数参入的哦&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;我抛出错误&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p</span><br><span class="line">.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;发生错误&quot;</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(onFinally);</span><br></pre></td></tr></table></figure><p>上面例子的结果为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">发生错误 <span class="built_in">Error</span>: 我抛出错误</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">6</span>:<span class="number">15</span></span><br><span class="line">    at <span class="keyword">new</span> <span class="built_in">Promise</span> (&lt;anonymous&gt;)</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">5</span>:<span class="number">15</span></span><br><span class="line"><span class="attr">VM134</span>:<span class="number">3</span> 不管promise状态怎么样， 我都会执行, 并且我是无参数参入的哦 <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>这个例子中的onFinally函数中，我们打印value 值，值为undefined。说明.finally()的onFinally函数是不接受任何参数的。</p><p><strong>默认.finally()方法不会改变Then 链上前端所产生的值，也包括其状态。</strong></p><p>JavaScript 不处理在响应函数onFinally中的任何返回值，.finally()方法的结果—只是简单的“得到了”链上的前一个promise对象所代理的数据。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">&quot;我是舒力气&quot;</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(x);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我的年龄是21&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我的值是：&#x27;</span>, value)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 我的值是：我是舒力气</span></span><br></pre></td></tr></table></figure><p>以上例子中.finally()的onFinally中的返回值自动被忽略。所以p2的值是前一个promise对象所代理的值（p1的值）。</p><p>当然，也有例外的时候。如果.finally()的响应函数onFinally()中发生了异常，或者用户代码显式的返回了rejected promise。 那么就会替代了then链上之前的promise对象所代理的值了。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">&quot;我是舒力气&quot;</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(x);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;我在onFinally函数中显式的返回了rejected promise了&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p2.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我的值是：&#x27;</span>, reason)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 我的值是： 我在onFinally函数中显式的返回了rejected promise了</span></span><br></pre></td></tr></table></figure><h2 id="Promise-Prototype-then"><a href="#Promise-Prototype-then" class="headerlink" title="Promise.Prototype.then()"></a>Promise.Prototype.then()</h2><p>其实<code>then</code>方法是最重要的， 在前面我们都是讲过知识点。</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本超出显示省略号的一个完美的方案</title>
      <link href="/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/"/>
      <url>/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>之前做项目需求的时候呢。会经常碰到文本内容超出的问题。通常UI设计师会叫我们超出的话显示省略号。由于之前做这样的需求一直没有整理文本内容超出省略的方案。那么这篇博客就好好整理一下吧。</p><span id="more"></span><p>我们知道CSS3定义了一个文本省略方案<code>text-overflow</code></p><p>MDN上是这么说的：</p><blockquote><p>text-overflow 是一个css 属性，确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号（…）或者显示一个自定义的字符串</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-overflow</span>: ellipsis || clip ||  &lt;string&gt;</span><br></pre></td></tr></table></figure><p><code>clip:</code> 在内容区域的极限处截断文本。因此在字符串的中间可能在中间发生截断</p><p><code>ellipsis:</code>用一个省略号（…）表示被截断的文本。这个省略号被添加在内容区域中。因此会减少显示文本。 如果是空间太少，那么省略号也会被截断。</p><p><code>&lt;string&gt;:</code>用自定义字符串来表示被截断的文本。字符串内容将被添加在内容区域中，所以会减少显示出的文本。如果空间太小到连省略号都容纳不下，那么这个字符串也会被截断。</p><p>但是有一点要非常注意：</p><blockquote><p>这个属性只对那些块级元素溢出的内容有效。但是必须与块级元素内联(inline)方向一致（举一个反例：内容在盒子的下方溢出。此时就不会生效）</p></blockquote><p>这句话简单的理解就是：text-overflow 只管行文本溢出的省略。</p><p>于是文本省略分成了<strong>单行文本省略</strong>和<strong>多行文本省略</strong>。</p><h2 id="单行文本省略"><a href="#单行文本省略" class="headerlink" title="单行文本省略"></a>单行文本省略</h2><p>由以上我们知道<strong>text-overflow</strong> 是可以解决单行文本省略的。但是毕竟是css3出的属性， 我们先看看它的兼容性：</p><img src="/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/1.webp" class=""><p>可以看出它的兼容性是非常好的。所以可以放心愉快的使用吧</p><p>当然了，不是只使用<strong>text-overflow：ellipsis</strong> 就可以实现文本省略的。</p><p>上头我们我们也说过：</p><blockquote><p>这个属性只对那些块级元素溢出的内容有效。但是必须与块级元素内联(inline)方向一致（举一个反例：内容在盒子的下方溢出。此时就不会生效）</p></blockquote><p>文本可能在以下情况下溢出：当其因为某种原因而无法换行(例如：设置了”white-space:nowrap”)，或者一个单词因为太长而不能合理地被安置(fit)。</p><p>因此为了让<strong>text-overflow</strong> 能够生效。我们必须要在元素上添加几个属性和满足一些规则：</p><ul><li>块级元素</li><li>overflow：计算值非visible</li><li>元素的宽度：超出时， 有一个确切的计算值</li><li>white-space：nowrap ||  pre</li></ul><p>解释一下这几个规则：</p><ul><li>overflow确实是非visible， 但是计算值并不是设定值， 因为css有个叫inhert的关键字</li><li>元素宽度： 不是元素的width。max-width，以及flex 布局都是可以的。</li><li>white-space:pre也是可以的， 因为这个属性的设置主要就是为了不折行。</li></ul><p>举个比较普遍的例子：</p><p>html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  我的名字我的名字  我的名字  我的名字  我的名字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.name</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 元素的宽度: 超出时， 有一个确切的计算值 */</span></span><br><span class="line">  <span class="comment">/* 元素宽度： 不只可以是元素的width。max-width，以及flex 布局都是可以的。 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* overflow：计算值非visible */</span></span><br><span class="line">  <span class="comment">/*  overflow确实是非visible， 但是计算值并不是设定值， 因为css有个叫inhert的关键字  */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 不折行:white-space: pre || nowrap */</span></span><br><span class="line">  <span class="comment">/* pre也是可以的， 因为这个属性的设置主要就是为了不折行。  */</span></span><br><span class="line">  <span class="attribute">white-space</span>: pre;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果： </p><img src="/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/2.png" class=""><p><a href="https://codepen.io/shuliqi/pen/WNrjoya"><strong>本例子代码–&gt;可点击查看</strong></a></p><p><strong>flex布局实现</strong></p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ellipsis&quot;</span>&gt;</span></span><br><span class="line">    元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的元素的宽度我使用flex布局也是可行的</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.name</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>：<span class="attribute">flex</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ellipsis</span> &#123;</span><br><span class="line">   <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 元素的宽度: 超出时， 有一个确切的计算值 */</span></span><br><span class="line">  <span class="comment">/* 元素宽度： 不只可以是元素的width。max-width，以及flex 布局都是可以的。 */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* overflow：计算值非visible */</span></span><br><span class="line">  <span class="comment">/*  overflow确实是非visible， 但是计算值并不是设定值， 因为css有个叫inhert的关键字  */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 不折行:white-space: pre || nowrap */</span></span><br><span class="line">  <span class="comment">/* pre也是可以的， 因为这个属性的设置主要就是为了不折行。  */</span></span><br><span class="line">  <span class="attribute">white-space</span>: pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/3.png" class=""><p><a href="https://codepen.io/shuliqi/pen/LYGyWRM"><strong>本例子代码—&gt;可点击查看</strong></a></p><p> <strong>其他的规则：</strong></p><ul><li><a href="https://codepen.io/shuliqi/pen/VwebprJ"><strong>max-width设置元素宽度</strong></a></li><li><a href="https://codepen.io/shuliqi/pen/GRomWxp?editors=1100"><strong>overflow 设置为其他值（auto, scroll等）</strong></a></li><li><a href="https://codepen.io/shuliqi/pen/mdVmWKe"><strong>white-space设置为nowrap</strong></a></li></ul><p>其余的其他设置我就不一一举例验证了。如果验证的时候有问题可以给我留言。</p><h2 id="多行文本省略"><a href="#多行文本省略" class="headerlink" title="多行文本省略"></a>多行文本省略</h2><h4 id="使用-webkit-line-clamp"><a href="#使用-webkit-line-clamp" class="headerlink" title="使用 webkit-line-clamp"></a>使用 webkit-line-clamp</h4><p>多行文本的省略，也有实现方法，但是只是针对<strong>webkit系</strong>浏览器**-webkit-line-clamp**</p><p>MDN上是这么说的：</p><blockquote><p>–webkit-line-clamp： CSS属性 可以把<strong>块容器</strong>中的内容限定为指定的行数</p></blockquote><p><strong>–webkit-line-clamp</strong> 的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-line-clamp: none || integer</span><br></pre></td></tr></table></figure><ul><li>none:表示值显示的内容不会被限制</li><li> integer： 这个值表示内容显示多少行之后会被限制，必须大于0</li></ul><p>这个属性的规则：</p><ul><li>-webkit-line-clamp 只有在 <strong>display</strong> 设置为**-webkit-box** 或者**-webkit-inline-box** 并且设置**-webkit-box-orient** 为<strong>vertical</strong>时才有效果</li><li>在大部分情况下,也需要设置overflow属性为 <code>hidden</code>, 否则,里面的内容不会被裁减,并且在内容显示为指定行数后还会显示省略号(ellipsis ).</li></ul><p>来看个例子：</p><p>html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">  我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* display 设置为-webkit-box 或者-webkit-inline-box */</span></span><br><span class="line">   <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="comment">/* -webkit-box-orient 必须设置为vertical */</span></span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  <span class="comment">/*   -webkit-line-clamp: none || integer */</span></span><br><span class="line">  -webkit-line-clamp: <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/* 在大部分情况下,也需要设置overflow属性为 `hidden`, 否则,里面的内容不会被裁减,并且在内容显示为指定行数后还会显示省略号(ellipsis ). */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/4.png" class=""><p>我们最后来看看 -webkit-line-clamp的兼容性：</p><img src="/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/5.webp" class=""><p>兼容性和上头的 text-overflow 比起来，很惨。都是清一色的Webkit。 而且-wbkit-line-clamp 连 line-clamp 都不是。为什么是<code>-webkit-line-clamp</code>呢？因为</p><ol><li>W3C没规范</li><li>Webkit系自己YY的：所以带-webkit-</li></ol><p>而且由以上的规则我们知道-webkit-line-clamp 依赖与 box 布局，而且是最老的Flex布局方案，已经由最新版的代替flex替代。 如果这个这个属性要进W3C规范，就得改改了。 换一句话来说，现在的写法很有可能在未来不再使用。估计结局是这两种：</p><ul><li>W3C收录规范：规则要改，因为box迟早会被废弃</li><li>W3C自己定义一个新的属性：整个废弃掉</li></ul><p>结论：如果是不是别误选择，还是不建议使用</p><h4 id="大多数网上的方案（css）"><a href="#大多数网上的方案（css）" class="headerlink" title="大多数网上的方案（css）"></a>大多数网上的方案（css）</h4><p>本着一种能使用css 实现的， 就不用js实现的想法。</p><p>在使用其他css 方式之前， 我们来看一下无论单行还是多行实现超出省略的原理：</p><blockquote><p>不管是多行截断还是多行截断，实际上，浏览器并没有把超长的文字删除，而是在渲染的时候在块尾渲染一个”…”覆盖在上面。规则里面的overflow的计算值为非visible， 所以在视觉上是看不到的。</p></blockquote><p>所以我们自己实现的方式的原理也是这样的（<strong>拿个… 盖到上面去</strong>）</p><p>…的方案很简单，可以使用一个特定的元素， 也可以使用::after伪元素。我们可以看一个例子。</p><p>html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">  我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字   我的名字我的名字我的名字我的名字我的名字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.line</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;...&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">42px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/6.png" class=""><p><a href="https://codepen.io/shuliqi/pen/LYGyaom?editors=1100"><strong>此例子的代码–&gt;可点击查看</strong></a></p><p>现在， 一切看都挺不错的。顺便网上一搜， 都是这样的实现方案。</p><p>但是，这个方案存在一个很严重的问题：<strong>默认的认为内容一定会溢出</strong></p><p>网上写这个方案的时候有些也会还有一些提示：计算一下内容会不会溢出。</p><p>额，这提示…还不入不提示。 如果需要 js 计算， 那好不如一开始就使用js的方式实现了呢。为啥还整出 css + js 的方案呢？</p><h4 id="一个完美的方案"><a href="#一个完美的方案" class="headerlink" title="一个完美的方案"></a>一个完美的方案</h4><p>如果我们想实现 <strong>仅仅当内容溢出时， 显示…省略</strong> 这样的方案， 我们该如何做呢？</p><p>我们回想一下我们上头的方案，我们是拿”…“ 盖住了右下角的内容来实现的省略。其实， 同样的道理，我们可以 <strong>拿个东西盖住…</strong></p><p>原理还是那个原理，只是换了谁盖谁，所以我们的实现方案可以是：<strong>当且仅当内容溢出时，不盖住…</strong></p><p>但是， 我们如何使用css 实现这样的效果呢？ 我们怎么知道什么时候内容溢出呢？</p><p>我们抽象理解一下这个方案：</p><ul><li><p>假设我们的内容是用一个数组存储的，我们的内容框只能承载20个字，也就是说，我们的数组length一旦大于20，index &gt;= 20的元素就不能再显示了。</p></li><li><p>现在，我们的数组是空的，我们给它丢个字（假设为：略）进去，使用栈方法，从头往里一直丢字（unshift(‘X’)，X为某个字），那第一次丢进去的“略”字，就会被一直往后推，直到它被推到20的位置，“略”字就“不再显示”了。</p></li></ul><p><strong>原理：</strong></p><p>对<code>...</code>的覆盖，我们也用“推”的方法，想象一下，我们找个<code>东西</code>，把它盖到<code>...</code>上，这就是第一个字“略”，然后，我们一直在这个<code>东西</code>前面添加我们的文本内容，当我们把这个<code>东西</code>推到框外时，就意味着我们的内容溢出了，<code>...</code>需要显示。而在此之前，由于<code>东西</code>一直处在<code>index &lt; 20</code>，所以，它就一直存在，一直盖住<code>...</code>，这就是：内容未溢出，不显示<code>...</code></p><p>原理讲完了， 我们来简单实现一下这个方案，这个原理实现的方案很多， 看自己怎么写。看个例子：</p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line"> 手动添加这里的内容看结果哦 手动添加这里的内容看结果哦 手动添加这里的内容看结果哦 手动添加这里的内容看结果哦</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">90px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 实现省略号 */</span></span><br><span class="line"><span class="selector-class">.line</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;...&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">70px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 盖住...的内容 */</span></span><br><span class="line"><span class="selector-class">.line</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果： 当内容没有超出的时候， 省略号（…）被盖住。当内容超出时。省略号（…）不被盖住</p><img src="/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/7.png" class=""><img src="/2020/06/22/%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88/8.png" class=""><p><a href="https://codepen.io/shuliqi/pen/abdWxEa?editors=1101"><strong>这个例子的代码—&gt; 点击查看</strong></a></p><p>这是我认为的比较完美的纯css 方案了</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Delete`CR`eslint(prettier/prettier) 报错的解决方案</title>
      <link href="/2020/06/06/%E5%85%B3%E4%BA%8EDelete%60CR%60eslint-prettier-prettier-%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/06/06/%E5%85%B3%E4%BA%8EDelete%60CR%60eslint-prettier-prettier-%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>由于之前是一直使用 <code>mac</code> 笔记本开发，突然使用 <code>windows</code> 开发，发现拉完代码之后， 发现在<code>npm run dev</code> 运行代码之后。发现有如下的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Delete <span class="string">`CR`</span>eslint(prettier/prettier)</span><br></pre></td></tr></table></figure> <span id="more"></span><img src="/2020/06/06/%E5%85%B3%E4%BA%8EDelete%60CR%60eslint-prettier-prettier-%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1.png" class=""><h2 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h2><p>出现的问题的原因到底是什么呢？</p><p>根据调查发现出问题 : <strong>windows下和linux下的文本文件的换行符不一致。</strong></p><ul><li><code>Windows</code>在换行的时候，同时使用了回车符<code>CR(carriage-return character)和换行符LF(linefeed character)</code></li><li>而<code>Mac</code>和<code>Linux</code>系统，仅仅使用了换行符<code>LF</code></li><li>老版本的<code>Mac</code>系统使用的是回车符<code>CR</code></li></ul><p>表格解释如下：</p><table><thead><tr><th><strong>Windows</strong></th><th><strong>Linux/Mac</strong></th><th><strong>Old Mac(pre-OSX)</strong></th></tr></thead><tbody><tr><td>CRLF</td><td>LF</td><td>CR</td></tr><tr><td>‘\n\r’</td><td>‘\n’</td><td>‘\r’</td></tr></tbody></table><p>因此，文本文件在不同系统下创建和使用时就会出现不兼容的问题。</p><p>所以出现上面的报错是因为我的同事是在mac环境下提交的代码。文件默认是以LF结尾的。</p><p>当我使用 <code>Windows</code> 电脑<code>git clone</code>代码的时候， 若我的<code>autocrlf</code>(在<code>windows</code>下安装<code>git</code>，该选项默认为<code>true</code>)为true，那么文件每行会被自动转成以CRLF结尾，若对文件不做任何修改，pre-commit执行eslint的时候就会提示你删除CR。</p><h2 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h2><p>下面是上网查到的各种解决办法以及他们的优缺点。</p><h3 id="Crtl-S保存文件"><a href="#Crtl-S保存文件" class="headerlink" title="Crtl+S保存文件"></a>Crtl+S保存文件</h3><p>按Crtl+S保存当前报错文件，eslint错误消失，但是Git暂存区多了个文件改动记录，对比Working tree没发现任何不同。</p><p>缺点：你不可能一一保存所有文件，麻烦，还要commit，多余。</p><h3 id="yarn-run-lint-–fix"><a href="#yarn-run-lint-–fix" class="headerlink" title="yarn run lint –fix"></a>yarn run lint –fix</h3><p>比上面省事，eslint错误消失，但暂存区多了n个文件改动记录，对比Working tree也没发现任何不同。</p><p>缺点：需要commit所有文件，多余。</p><p><a href="https://github.com/prettier/eslint-plugin-prettier/issues/114">参考的资料：”error Delete <code>⏎</code> prettier/prettier” in .vue files</a></p><h3 id="配置-prettierrc-文件"><a href="#配置-prettierrc-文件" class="headerlink" title="配置.prettierrc 文件"></a>配置.prettierrc 文件</h3><p>在项目的根目录的<code>.prettierrc</code>文件中写入即可。其实就是不让prettier检测文件每行结束的格式.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;endOfLine&quot;</span>: <span class="string">&quot;auto&quot;</span></span><br></pre></td></tr></table></figure><p>缺点：不能兼容跨平台开发，从前端工程化上讲没有做到尽善尽美。</p><p><a href="https://stackoverflow.com/questions/53516594/why-do-i-keep-getting-delete-cr-prettier-prettier">参考的资料：Why do I keep getting Delete ‘cr’ [prettier/prettier]?</a></p><h3 id="core-autocrlf配置"><a href="#core-autocrlf配置" class="headerlink" title="core.autocrlf配置"></a>core.autocrlf配置</h3><p>使用git 的一个配置属性： core.autocrlf </p><ul><li><p>Git 可以在你提交的时候自动的把行结束符CRLF转换成LF，而在签出代码时把LF转换成CRLF。用<code>core.autocrlf</code>来打开此项功能。如果是在Windows 系统上，把它设置为true。这样当签出代码时。LF会被转换成CRLF。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --<span class="built_in">global</span> core.autocrlf <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>mac 系统使用LF作为行结束符， 因此你不想Git在签出文件时进行自动的转换；当一个CRLF为行结束符的文件不小心被引入时你想修正，把core.autocrlf 设置为input 来告诉Git 在提交的时候把CRLF 转成LF。签出时不转换；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --<span class="built_in">global</span> core.autocrlf input</span><br></pre></td></tr></table></figure><p>这样会在Windows系统上的签出文件中保留CRLF，会在Mac和Linux系统上，包括仓库中保留LF。</p></li><li><p>如果你是Windows程序员，且正在开发仅运行在Windows上的项目，可以设置false取消此功能，把回车符记录在库中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.autocrlf false</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遇到问题的时候查找了很多的资料。但是结局的办法都不是很尽美 如方法1，方法 2，方法 3，都存在一定的缺点。 最后一个解决办法才是从灵魂上解决了问题。 所以在解决的问题还是追其根源。从根本上解决问题。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas的学习及其使用</title>
      <link href="/2020/05/07/canvas%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/07/canvas%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="canvas的简介"><a href="#canvas的简介" class="headerlink" title="canvas的简介"></a>canvas的简介</h1><p><code>canvas</code>是<code>HTML5</code>新增加的标签，它是一个可以使用脚本（<code>JavaScript</code>）来绘制图形的<code>HTML</code>元素。它可以用来制作图片，动画，甚至可以进行实时视频处理和渲染。</p><p><code>canvas</code>是由<code>HTML</code>代码高度，宽度属性而定义出来的可绘制的区域，<code>JavaScript</code>代码可以可以访问该区域，通过一套完整的绘制函数来动态生成图形。</p><h1 id="canvas-的基本用法"><a href="#canvas-的基本用法" class="headerlink" title="canvas 的基本用法"></a>canvas 的基本用法</h1><h2 id="canvas-元素"><a href="#canvas-元素" class="headerlink" title="canvas 元素"></a>canvas 元素</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>canvas</code> 标签有两个可选的属性<code>height</code>，<code>width</code>。如果没有给<code>canvas</code>设置<code>width</code>，<code>height</code>属性，则<code>height</code>默认150，<code>width</code>默认为 300。单位都是<code>px</code>。当然也可以使用<code>CSS</code>设置宽高，但是如果宽高和初始化的比例不一致，是会出现扭曲的。所以是不建议使用<code>css</code>来设置<code>canvas</code>的宽高的。</p><h2 id="替换的内容"><a href="#替换的内容" class="headerlink" title="替换的内容"></a>替换的内容</h2><p>由于某些比较老的浏览器或者浏览器不支持<code>HTML</code>元素<code>canvas</code>，在这些浏览器上应该要显示替代的内容。</p><p>支持<code>canvas</code>标签的浏览器会只渲染<code>canvas</code>标签，而忽略其中的替代内容。不支持<code>canvas</code>标签的浏览器则会直接渲染替代的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span>  <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">P</span>&gt;</span>你的浏览器不支持canvas标签<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>canvas</code>标签的结束标签是不可省略的。如果省略的话，文档的其余部分会被认为是替代的内容，不会显示出来。</p><h2 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h2><p><code>canvas</code>元素创造了一个固定大小的画布，它公开了一个或多个<strong>渲染上下文（The rendering context）</strong>，它可以用来绘制和处理要展示的内容。</p><p><code>canvas</code>起初是空白的，为了展示，首先脚本需要找到渲染上下文，然后在它的上面绘制。<code>canvas</code>元素有一个叫做<code>getContext()</code>的方法，这个方法用来获得渲染上下文和它的绘画功能。<code>getContext()</code>只有一个参数：上下文的格式。</p><p><strong>绘制2D</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> context = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>绘制3D</strong></p><p><code>HTML5</code>有一个<code>WebGL</code>规范，允许在<code>canvas</code>绘制<code>3D</code>图形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> context = canvas.getContext(<span class="string">&quot;webgl&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="canvas绘制图形"><a href="#canvas绘制图形" class="headerlink" title="canvas绘制图形"></a>canvas绘制图形</h1><h2 id="栅格"><a href="#栅格" class="headerlink" title="栅格"></a>栅格</h2><p>在开始绘图之前， 我们先了解一下画布栅格（<code>canvas grid</code>）以及坐标空间。默认的<code>canvas</code>元素会被网格所盖。如下图：</p><img src="/2020/05/07/canvas%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/1.png" class=""><p>网格中的一个单元相当于<code>canvas</code>元素中的一个像素。网格的左上角坐标为：（0,0）也称原点。 所有元素的位置都相对于原点定位。所以图中蓝色的方形左上角的坐标为距离左边（X轴） x 像素，距离上边（Y轴）y 像素；坐标为（x, y）。</p><h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><p><code>canvas</code>只支持两种形式的图形绘制；<strong>矩形</strong>和<strong>路径（由一系列点连成的线段）</strong>。所有其他类型的图形都是通过一条或者多条路径组合而成。不过我们有很多路径生成的<code>API</code>。</p><ul><li><code>fillRect(x, y, width, height)</code>: 用于绘制一个填充的矩形。</li><li><code>strokeRect(x, y, width,height)</code>: 用于绘制一个矩形的边框。</li><li><code>clearRect(x, y width, height)</code>: 用于清除指定矩形区域，让清除的部分完全透明。</li></ul><p>这三个方法的 <code>x</code>, <code>y</code> 是指在<code>canvas</code>画布上所绘制的矩形的左上角（相对于原点）的坐标，<code>width </code>和 <code>height </code>是设置矩形的尺寸.</p><ul><li><p><code>rect(x, y, width, height)</code>: 绘制一个左上角坐标为（x,y）,宽高为 <code>width</code>和<code>height</code>的矩形。</p><p>这个方法执行的时候， <code>moveTo()</code>方法自动设置坐标参数（0,0）。也就是说当前笔触自动重置回默认坐标。</p></li></ul><p>举个例子:</p><iframe height="577" style="width: 100%;" scrolling="no" title="canvas 绘制矩形" src="https://codepen.io/shuliqi/embed/MWpYMaJ?height=577&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/MWpYMaJ'>canvas 绘制矩形</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>上面例子中<code>fillRect)</code>绘制了一个宽为60px高为70ox的矩形，<code>clearRect()</code> 从距离 x 轴<code>15px</code>， y 轴 <code>50px</code> 的地方开始擦除。</p><p><code>strokeRect</code>绘制了一个距离 x 轴<code>20px</code>， y 轴 <code>30px</code> 的宽为<code>90px</code>，高为<code>90px</code>高为<code>80px</code>的矩形。</p><h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><p>图形的基本元素是路径。 路径是通过不同的颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径都是闭合的。使用路径绘制图形需要一些如下的步骤：</p><ul><li>首先，需要创建路径的起始点。</li><li>然后使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D#paths">画图命令</a>去画出路径。</li><li>之后把路径封闭。</li><li>路径生成之后。就能通过描边或者填充路径来渲染图形。</li></ul><h3 id="绘制路径所用到的函数"><a href="#绘制路径所用到的函数" class="headerlink" title="绘制路径所用到的函数"></a>绘制路径所用到的函数</h3><ul><li><code>beginPath()</code>：新建一条路径，生成之后，图形绘制命令被指令到路径上生成路径。</li><li><code>closePath()</code>：闭合路径。闭合路径之后图形绘制命令又重新回到上下文中。</li><li><code>stroke()</code>：通过线条来绘制图形轮廓。</li><li><code>fill()</code>：通过填充路径的内容区域生成实心的图形。</li></ul><p>生成路径的第一步叫做<code>beginPath()</code>。本质上路径是有很多的子路径构成，这些子路径都是在一个列表中，所有的子路径(线，弧形等等)构成图形。而每次调用这个方法之后，路径列表就会清空，我们就可以绘制新的图形。</p><blockquote><p><strong>注意：</strong>当当前的路径为空(也就是调用<code>beginPath</code>之后或者<code>canvas</code>刚建的时候)。第一条路径构造命令通常是<code>moveTo(x,y)</code>、<code>moveTo(x,y)</code>设置路径的起始位置。无论出自于什么原因，总是要在设置路径之后专门指定路径的起始位置。</p></blockquote><blockquote><p><code>moveTo(x,y)</code>函数下面会讲到。</p></blockquote><p>第二步就是调用函数指定绘制路径。文章之后会讲到。</p><p>第三步就是闭合路径<code>closePath()</code>。但是<code>closePath()</code>不是必须的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是是已经闭合了的(也就是说当前点为开始点)， 那么该函数什么也不做。</p><blockquote><p>注意：当调用<code>fill()</code>函数时，所有没有闭的形状都会自动闭合。所以是不需要使用<code>closePath()</code>函数来闭合形状的。但是<code>stroke()</code>函数是不会自动闭合的。</p></blockquote><p>举个例子：</p><iframe height="378" style="width: 100%;" scrolling="no" title="绘制路径" src="https://codepen.io/shuliqi/embed/jOBPKYo?height=378&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/jOBPKYo'>绘制路径</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h3 id="移动笔触"><a href="#移动笔触" class="headerlink" title="移动笔触"></a>移动笔触</h3><p><strong><code>moveTo(x,y):</code></strong> 将笔触移动到指定的坐标（<code>x</code>，<code>y</code>） 上。</p><p><code>canvas</code>初始化或者<code>beginPath(x,y)</code>调用之后，通常使用<code>mnoveTo(x，y)</code>来设置起点。也可以使用<code>mnoveTo(x，y)</code>来设置一些不连续的路径。</p><h3 id="线"><a href="#线" class="headerlink" title="线"></a>线</h3><p><strong><code>lineTo(x,y):</code></strong> 绘制直线。绘制一条从当前位置到指定 <code>x</code>，<code>y</code>位置的直线</p><p>这个方法有两个参数： <code>x</code>,<code> y</code>；代表坐标系中直线结束的点。开始点和之前的绘制路径有关。开始点也可以通过<code>moveTo()</code>函数改变。</p><p>举个例子：</p><iframe height="426" style="width: 100%;" scrolling="no" title="moveTo" src="https://codepen.io/shuliqi/embed/ExWjpjv?height=426&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/ExWjpjv'>moveTo</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h3 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h3><p>绘制圆弧或者圆，我们使用<code>arc()</code>方法。当然也是可以使用<code>arcTo()</code>， 不过该方法并没有那么可靠。所以这里不做介绍。</p><p><strong><code>arc(x,y,radius, startAngle, endAngle, anticlockwise)</code>：</strong></p><ul><li><code>(x,y)</code>： 圆/圆弧的圆心</li><li><code>radius</code>： 圆的半径</li><li><code>startAngle</code>： 开始的弧度</li><li><code>endAngle</code>： 结束的弧度</li><li><code>anticlockwise</code>： 画圆的防线：<code>true</code>为逆时针，<code>false</code>为顺时针</li></ul><p>画一个以<code>(x,y)</code>为圆心的以<code>radius</code>为半径的圆弧(圆)。从<code>startAngle</code>开始到<code>endAngle</code>结束。按照<code>anticlockwise</code>给定的方向(默认为顺时针)来生成。</p><blockquote><p>注意：<code>arc()</code>函数中表示角的单位是弧度，而不是角度。角度与弧度的换算<code>js</code>表达式：弧度 =角度 * Math.PI / 180； 1弧度等于半径的长度</p></blockquote><p>举个例子：</p><iframe height="563" style="width: 100%;" scrolling="no" title="圆弧" src="https://codepen.io/shuliqi/embed/RwpPOMR?height=563&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/RwpPOMR'>圆弧</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h3 id="贝赛尔曲线"><a href="#贝赛尔曲线" class="headerlink" title="贝赛尔曲线"></a>贝赛尔曲线</h3><p><code>quadraticCurveTo(cplx, cply, x, y):</code>绘制二次贝塞尔曲线，<code>cplx</code>,<code> cply</code>是控制点，<code>x</code>， <code>y</code>为结束点。</p><p><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y):</code>绘制三次贝塞尔曲线。<code>cp1x,cp1y</code>为控制点一，<code>cp2x,cp2y</code>为控制点二，<code>x,y</code>为结束点。</p><p>二次贝塞尔曲线有一个开始点（蓝色）， 一个结束点（蓝色）， 一个控制点（红色）；</p><p>三次贝塞尔曲线有一个开始点（蓝色）， 一个结束点（蓝色），有两个控制点（红色）；</p><p>两个方法中的<code>x,y</code>都是结束坐标。<code>cp1x,cp1y</code>为坐标中的第一个控制点，<code>cp2x,cp2y</code>为坐标中的第二个控制点。</p><p>举个例子：</p><iframe height="393" style="width: 100%;" scrolling="no" title="贝塞尔曲线" src="https://codepen.io/shuliqi/embed/jOBPjoB?height=393&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/jOBPjoB'>贝塞尔曲线</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe># 使用样式和颜色<h2 id="色彩"><a href="#色彩" class="headerlink" title="色彩"></a>色彩</h2><p>到目前为止， 我们只看到过绘制内容的方法，如果想要给图形上色，需要两个重要的属性：</p><ul><li><code>fillStyle = color</code>：设置图形的填充颜色。</li><li><code>strokeStyle = color</code>：设置图形的轮廓颜色。</li></ul><p><code>color</code>值可以是表示<code>CSS</code>颜色字符串，渐变对象，图案对象;默认情况下，线条个填充颜色都是黑色(#0000).</p><blockquote><p><strong>注意：</strong>一旦设置了<code>fillStyle</code>和<code>strokeStyle</code>的值，那么这个新值就会成为新绘制图形的默认值，如果需要给每个不同的图形上不同的颜色值，那么需要重新设置<code>fillStyle</code>，<code>strokeStyle</code>的值。</p></blockquote><p>举个例子：</p><iframe height="714" style="width: 100%;" scrolling="no" title="fillStyle/strokeStyle" src="https://codepen.io/shuliqi/embed/KKWdqeg?height=714&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/KKWdqeg'>fillStyle/strokeStyle</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h2 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h2><p>通过设置<code>globalAlpha</code>属性或者使用一个半透明颜色作为轮廓或填充的样式来绘制半透明的图形。</p><p><code>globalAlpha = transparencyValue </code>：<code>transparencyValue</code>的优先范围为 0.0（完全透明） 到 1.0（完全不透明）</p><blockquote><p><strong>注意：</strong>这个属性会影响到<code>canvas</code>里面所有图形的透明度。所以在绘制大量拥有相同透明度的图形的时候相当有用。不过使用设置<code> strokeStyle</code> 和<code> fillStyle</code>的值为有透明度的更有用。 如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定透明颜色，用于描边和填充样式</span></span><br><span class="line">ctx.strokeStyle = <span class="string">&quot;rgba(255,0,0,0.5)&quot;</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">&quot;rgba(255,0,0,0.5)&quot;</span>;</span><br></pre></td></tr></table></figure></blockquote><p> 举个例子：</p><iframe height="318" style="width: 100%;" scrolling="no" title="透明度" src="https://codepen.io/shuliqi/embed/OJpyQxv?height=318&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/OJpyQxv'>透明度</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe>## 线形<p>可以通过一系列属性来设置线的样式。</p><h3 id="lineWidth"><a href="#lineWidth" class="headerlink" title="lineWidth"></a>lineWidth</h3><p><code>lineWidth = value</code>: 设置线条的宽度。</p><p>举个例子：</p><iframe height="235" style="width: 100%;" scrolling="no" title="lineWidth" src="https://codepen.io/shuliqi/embed/zYZvWOK?height=235&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/zYZvWOK'>lineWidth</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h3 id="lineCap"><a href="#lineCap" class="headerlink" title="lineCap"></a>lineCap</h3><p><code>lineCap = type</code>: 设置末端的样式。</p><p><code>type</code>的类型有：</p><ul><li><code>butt</code>：末端以方形结束</li><li><code>round</code>： 末端以圆形结束</li><li><code>square</code>: 末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域</li></ul><p>举个例子：</p><iframe height="564" style="width: 100%;" scrolling="no" title="lineCap" src="https://codepen.io/shuliqi/embed/BaWorob?height=564&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/BaWorob'>lineCap</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h1 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h1><p> <code>canvas</code> 有两种方式可以绘制文本：</p><ul><li><p><code>fillText(text, x, y [, maxWidth])</code></p><p>在指定的坐标（x，y）填充指定的文本，可以指定最大的宽度。</p></li><li><p><code>strokeText(text,x,y,[,maxWidth])</code></p><p>在指定的坐标上（x,y）绘制指定的文本边框，可以指定最大的宽度。</p></li></ul><p>举个例子：</p><iframe height="296" style="width: 100%;" scrolling="no" title="text" src="https://codepen.io/shuliqi/embed/xxqZgGg?height=296&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/xxqZgGg'>text</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h3 id="文本的样式"><a href="#文本的样式" class="headerlink" title="文本的样式"></a>文本的样式</h3><p>有很多的属性可以改变<code>canvas</code>的显示的文本的样式。</p><ul><li><p><code>font = value</code>:</p><p>当前用来绘制文本的样式，<code>font</code>的使用和<code>CSS</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_text">font</a> 语法是一样的。默认值：”10px sans-serif”</p></li><li><p><code>textAlign = value</code>:</p><p>当前绘制文本的对齐方式，默认值：<code>start</code>；值有：</p><ul><li><code>start</code>：文本对齐界面开始的地方</li><li><code>end</code>：文本对齐界线结束的地方</li><li><code>left：文本左对齐</code></li><li>,<code>right</code>： 文本右对齐</li><li> <code>center</code>: 文本居中</li></ul></li><li><p><code>textBaseline = value</code>:</p><p>当前绘制文本的基线对齐方式，值有：<code>top</code>, <code>hanging</code>, <code>middle</code>, <code>alphabetic</code>, <code>ideographic</code>, <code>bottom</code>。默认值是 <code>alphabetic</code></p></li><li><p><code>direction = value</code>:</p><p>文本方向。默认值是 <code>inherit。值有：</code></p><ul><li><code>ltr</code>： 文本从左到右</li><li><code>rtl</code>：文本从右到左</li><li><code>inherit</code>  根据情况继承</li></ul></li></ul><p>举个例子：</p><iframe height="305" style="width: 100%;" scrolling="no" title="绘制文字的样式" src="https://codepen.io/shuliqi/embed/xxqZgYX?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/xxqZgYX'>绘制文字的样式</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><p>未完待续….学不动了</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MutationObserver 追踪DOM的变化</title>
      <link href="/2020/04/21/MutationObserver-%E7%9B%91%E5%90%ACDOM%E6%A0%91%E5%8F%98%E5%8C%96/"/>
      <url>/2020/04/21/MutationObserver-%E7%9B%91%E5%90%ACDOM%E6%A0%91%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><code>Mutation observer</code>（变动观察器）是监听DOM变动的接口。当DOM对象树发生任何变动时，Mutation observer会得到通知。</p><p>其实<code>Mutation observer</code>代替了<code>Mutation events</code>作为观察DOM树结构发生变化时，作出相应处理的API。为什么要使用<code>Mutation observer</code>去替代 <code>Mutation events</code>呢？ 我们可以先了解一下<code>Mutation events</code></p><span id="more"></span><h1 id="Mutation-events"><a href="#Mutation-events" class="headerlink" title="Mutation events"></a>Mutation events</h1><p><code>Mutation events</code>是在 <a href="https://link.jianshu.com/?t=https://www.w3.org/TR/DOM-Level-3-Events/#events-mutationevents">DOM3中定义</a>，用于监听DOM树结构变化的事件</p><p><code>Mutation events</code>的一个简单的例子**<a href="https://codepen.io/shuliqi/pen/dyYObbo">Demo</a>**</p><p>可知它的简单用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>).addEventListener(<span class="string">&quot;DOMSubtreeModified&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我检测到子元素被修改&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p><strong>Mutation events</strong> 支持的事件列表如下：</p><ol><li><p><strong>DOMAttributeNameChanged</strong>：</p></li><li><p><strong>DOMCharacterDataModified</strong>：在文本节点的值发生变化时触发</p></li><li><p><strong>DOMElementNameChanged</strong></p></li><li><p><strong>DOMNodeInserted</strong>：监听元素子项的增加</p></li><li><p><strong>DOMNodeRemoved</strong>： 监听元素子项的删除</p></li><li><p><strong>DOMNodeInsertedIntoDocument</strong>：在一个节点被直接插入文档或通过子树间接插入到文档之后触发。这个事件在DOMNodeInserted之后触发</p></li><li><p><strong>DOMSubtreeModified</strong>： 监听元素子项的修改(包括删除和新增)</p></li><li><p><strong>DOMAttrModified</strong>： 是监听元素属性的修改，并且能够提供具体的修改动作</p></li></ol><h1 id="Mutation-events-遇到的问题"><a href="#Mutation-events-遇到的问题" class="headerlink" title="Mutation events 遇到的问题"></a>Mutation events 遇到的问题</h1><ol><li><p><strong>浏览器兼容问题</strong></p><ul><li>IE9不支持<code>Mutation events</code></li><li>webkit内核不支持DOMAttrModified特性</li><li>DOMElementNameChanged 和 DOMAttributeNameChanged 在Firefox上不被支持</li></ul></li><li><p><strong>性能问题</strong></p><ul><li><code>Mutation events</code> 是同步执行的，他每次调用，都需要从队列中取出事件，执行，然后从队列中移除，期间需要移动队列元素。如果事件触发的较为频繁的话， 每一次都需要执行上面的步骤，那么浏览器就会被拖慢。</li><li><code>Mutation events</code> 本身是事件， 所以捕获是采用事件冒泡的形式，如果冒泡期间又出发了其他的 <code>Mutation events</code>的话，很有可能会导致阻塞javascript线程，甚至导致浏览器崩溃。</li></ul></li></ol><h1 id="Mutation-Observer"><a href="#Mutation-Observer" class="headerlink" title="Mutation Observer"></a>Mutation Observer</h1><p><code>Mutation Observer</code> 是在DOM4中定义的， 用于替代<code>Mutation events</code>的新的API，它的不同events 的是，<code>Mutation Observer</code> 所有监听操作以及相应处理都是在其他脚本执行完毕之后异步执行的，并且是所有的变动触发之后，将变的记录在数组中，统一进行回调，也就是说，当你使用observer监听多个DOM 变化时， 并且这若干DOM发生变化，那么observer会将变化记录到变化中， 等到一起都结束了，然后一次性的冲变化数组中执行相应饿回调函数。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>只有在全部DOM操作完成之后才会调用callback, 可以看下面的<strong>验证的例子</strong>的<code>callback的回调次数</code>,</li><li>DOM 变动纪录封装成一个数组举行处置惩罚，而不是一条条地一般处置 DOM 变动。</li><li>能够视察发作在 DOM 节点的一切变动，也能够视察某一类变动</li></ol><p>如今，Firefox(14+)、Chrome(26+)、Opera(15+)、IE(11+) 和 Safari(6.1+) 支撑这个 API。 Safari 6.0 和 Chrome 18-25 运用这个 API 的时刻，须要加上 WebKit 前缀（WebKitMutationObserver）。能够运用下面的表达式搜检浏览器是不是支撑这个 API。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MutationObserver =</span><br><span class="line">  <span class="built_in">window</span>.MutationObserver ||</span><br><span class="line">  <span class="built_in">window</span>.WebKitMutationObserver ||</span><br><span class="line">  <span class="built_in">window</span>.MozMutationObserver</span><br><span class="line"><span class="comment">// 监测浏览器是不是支撑</span></span><br><span class="line"><span class="keyword">const</span> observeMutationSupport = !!MutationObserver</span><br></pre></td></tr></table></figure><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>Mutation Observer 的API 调用非常简单， 是一个构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line">  mutations.forEach(<span class="function"><span class="params">mutation</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mutation)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>MutationObserver 构造函数实例化一个观察者对象，其中的一个参数是一个回调函数，它会在指定的DOM节点发生变化之后执行的函数，回调函数会被传入两个参数， 一个是变化记录数组, 另外一个是观察者对象本身。</p><p>实例对象具有三个方法：</p><ol><li><code>observe</code></li><li><code>disconnect</code></li><li><code>takeRecords</code></li></ol><h2 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h2><p>在观察者对象上，注册需要 观察的DOM节点，以及相应的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> observe(Node target, optional MutationObserverInit options)</span><br></pre></td></tr></table></figure><p>其中可选参数 MutationObserverInit的属性如下：</p><ol><li><strong>childLIst</strong>： 观察目标节点的子节点的新增和删除 。</li><li><strong>attributes</strong>： 观察目标节点的属性节点(新增或删除了某个属性,以及某个属性的属性值发生了变化)。</li><li><strong>characterData</strong>： 如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化</li><li><strong>subtree</strong>：观察目标节点的所有后代节点(观察目标节点所包含的整棵DOM树上的上述三种节点变化)</li><li><strong>attributeOldValue</strong>： 已经设为true的前提下,将发生变化characterData节点之前的文本内容记录下来(记录到下面MutationRecord对象的oldValue属性中)</li><li><strong>attributeFilter</strong>： 一个属性名数组(不需要指定命名空间),只有该数组中包含的属性名发生变化时才会被观察到,其他名称的属性发生变化后会被忽略想要设置那些筛选参数的话，</li></ol><p>如果想要使用哪个参数的话， 就将其值设定为true。</p><h2 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h2><p>暂停在观察者对象上设置的节点的变化的监听， 直到重新调用observe 方法。</p><h2 id="takeRecords"><a href="#takeRecords" class="headerlink" title="takeRecords"></a>takeRecords</h2><p>在观察者对象上调用takeRecords 会返回其观察节点上的变化的记录(MutationRecords)数组。</p><p>其中MutationRecords数组也会作为观察者初始化时的回调函数的第一个参数。其中的属性如下：</p><ol><li><strong>type</strong>： 如果是属性发生变化，则返回attribuutes。如果是一个CharacterData节点发生变化，则返回characterData, 如果目标节点的某个字节点发生了变化，则返回childList.</li><li><strong>target</strong>：返回此次变化影响到的节点，具体返回哪种节点类型是根据type值的不同而不同的。如果type为attributes，则返回发生变化的属性节点所在的元素节点。如果type值是characterData，则返回发生变化的这个characterData节点。如果type值是childLiist,则返回发生变化的的子节点的父节点。</li><li><strong>addedNodes</strong>:返回被添加的节点。</li><li><strong>removeNodes</strong>：返回被删除的节点</li><li><strong>previousSibling</strong>: 返回被添加或者删除的节点的前一个兄弟节点。</li><li><strong>nextSibling</strong>: 返回被添加或者删除的节点的后一个兄弟节点。</li><li><strong>attributeName</strong>： 返回变更属性的本地名称。</li><li><strong>oldValue</strong>: 根据type 值的不同， 返回的值也会不同。如果type为attributes,则返回该属性变化之前的属性值.如果type为characterData,则返回该节点变化之前的文本数据.如果type为childList,则返回null</li></ol><h1 id="验证的的例子"><a href="#验证的的例子" class="headerlink" title="验证的的例子"></a>验证的的例子</h1><h2 id="callback的回调次数"><a href="#callback的回调次数" class="headerlink" title="callback的回调次数"></a>callback的回调次数</h2><p><strong>html结构：</strong></p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>打开控制台看看log<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;target&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;block&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;target&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是target的第一个子节点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是target的后代<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>javascri 代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> observe=<span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations,observe</span>) </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我在全部DOM操作完成之后才会调用， 不信你看i的值:&quot;</span>, i) <span class="comment">// </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//设置true，表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</span></span><br><span class="line">  <span class="attr">childList</span>: <span class="literal">true</span>, </span><br><span class="line">&#125;</span><br><span class="line">observe.observe(target, config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加几个TextNode节点</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;我新加的textNode1&#x27;</span>));</span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;我是新加的textNode2&#x27;</span>));</span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;我是新加的textNode3&#x27;</span>));</span><br></pre></td></tr></table></figure><p><strong>控制台打印的结果：</strong></p><p>控制只会打印一条：“ 我在全部DOM操作完成之后才会调用， 不信你看i的值: 1”</p><p><strong>说明</strong></p><p>MutationObserver的callback回调是异步的，只有在所有的DOM操作完成之后才会调用callback。</p><p>**<a href="https://codepen.io/shuliqi/pen/zYvobdB">可以移步看看Demo</a> **</p><h2 id="childList属性"><a href="#childList属性" class="headerlink" title="childList属性"></a>childList属性</h2><p><strong>html结构</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>打开控制台看看log<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;target&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;block&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;target&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是target的第一个子节点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是target的后代<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>javascript代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> observe=<span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations,observe</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(mutations);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">//设置true，表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</span></span><br><span class="line">  <span class="attr">childList</span>: <span class="literal">true</span>, </span><br><span class="line">&#125;</span><br><span class="line">observe.observe(target, config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加几个TextNode节点</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;新增Text节点&#x27;</span>));   <span class="comment">//增加节点，观察到变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点，可以观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].remove();    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于只设置 childList： true, 所以修改字节点以及自子节点后代， 不会被观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].textContent=<span class="string">&#x27;改变子节点的后代&#x27;</span>; </span><br></pre></td></tr></table></figure><p><strong>控制台打印的结果：</strong></p><img src="/2020/04/21/MutationObserver-%E7%9B%91%E5%90%ACDOM%E6%A0%91%E5%8F%98%E5%8C%96/mo1.jpg" class=""><p><strong>说明</strong>：</p><p>从打印的结果得出结论，设置{ <strong>childList: true</strong>}时,表示观察目标子节点的变化,，如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</p><p><strong><a href="https://codepen.io/shuliqi/pen/wvKoZWB">可以移步看看例子</a></strong></p><p>如果想要观察到子节点以及后台的变化需要设置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;childList: <span class="literal">true</span>, subtree: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="https://codepen.io/shuliqi/pen/gOaLyeb">修改后代也能观察到的具体例子可以看看</a></strong></p><h2 id="CharacterData属性"><a href="#CharacterData属性" class="headerlink" title="CharacterData属性"></a>CharacterData属性</h2><p><strong>html结构</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>打开控制台看看log<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;target&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;block&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;target&#x27;</span>&gt;</span></span><br><span class="line">    我是target的text节点</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是target的后代<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>javascript:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> observe=<span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations,observe</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(mutations);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// 观察目标节点的子节点的新增和删除。</span></span><br><span class="line">  <span class="attr">subtree</span>: <span class="literal">true</span>, </span><br><span class="line">  <span class="comment">// 如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化</span></span><br><span class="line">  <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">observe.observe(target, config);</span><br><span class="line"><span class="comment">// target.childNodes[0]：“我是target的第一个子节点”， 是characterData类型节点 所以可以观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].textContent=<span class="string">&#x27;改变Text节点&#x27;</span>;      </span><br><span class="line"></span><br><span class="line"><span class="comment">// arget.childNodes[1]： &lt;p&gt;&lt;span&gt;我是target的后代&lt;/span&gt;&lt;/p&gt;  不是是characterData类型节点， 所以不会观察到</span></span><br><span class="line">target.childNodes[<span class="number">1</span>].textContent=<span class="string">&#x27;改变p元素内容&#x27;</span>; </span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加text节点不会观察到</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;新增Text节点&#x27;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除TEXT节点也不会观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].remove();  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：我们只需要记住只有对CharacterData类型的节点的数据改变才会被characterData为true的选项所观察到。</span></span><br></pre></td></tr></table></figure><p><strong>控制台结果</strong></p><img src="/2020/04/21/MutationObserver-%E7%9B%91%E5%90%ACDOM%E6%A0%91%E5%8F%98%E5%8C%96/mo2.jpg" class=""><p><strong>说明：</strong></p><p>characterData这个选项，它是用来观察CharacterData类型的节点的，只有在改变节点数据时才会观察到，如果你删除或者增加节点都不会进行观察，还有如果对不是CharacterData类型的节点的改变不会观察到。</p><p><strong><a href="https://codepen.io/shuliqi/pen/KKdNYGq?editors=1010">可以移步看看Demo</a></strong></p><h2 id="attributeFilter属性"><a href="#attributeFilter属性" class="headerlink" title="attributeFilter属性"></a>attributeFilter属性</h2><p><strong>html结构</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>打开控制台看看log<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;target&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;block&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;target&#x27;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    我是target的text节点</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是target的后代<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>javascript代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> observe=<span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations,observe</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(mutations); <span class="comment">// 我们可以看到打印的mutations有两个改变的状态</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// 观察目标节点的子节点的新增和删除。</span></span><br><span class="line">  <span class="attr">subtree</span>: <span class="literal">true</span>, </span><br><span class="line">  <span class="comment">// 一个属性名数组(不需要指定命名空间),只有该数组中包含的属性名发生变化时才会被观察到,其他名称的属性发生变化后会被忽略想要设置那些删选参数的话</span></span><br><span class="line">  <span class="attr">attributeFilter</span>: [<span class="string">&quot;style&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line">observe.observe(target, config);</span><br><span class="line"></span><br><span class="line">target.style=<span class="string">&#x27;color:red&#x27;</span>; <span class="comment">//可以观察到</span></span><br><span class="line"></span><br><span class="line">target.removeAttribute(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//删除name属性，无法观察到                          </span></span><br></pre></td></tr></table></figure><p><strong>控制台打印的结果：</strong></p><img src="/2020/04/21/MutationObserver-%E7%9B%91%E5%90%ACDOM%E6%A0%91%E5%8F%98%E5%8C%96/mo3.jpg" class=""><p><strong>说明：</strong></p><p>attributeFilte属性我们只设置了r: [“style”],没有设置name， 说明观察者只会观察style 属性的变化。</p><p>attributeFilte 选项主要是用来筛选要观察的属性</p><p><strong><a href="https://codepen.io/shuliqi/pen/yLYVWNK?editors=1010">可以移步看看例子</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用IntersectionObserver提升性能</title>
      <link href="/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/"/>
      <url>/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="问题引出？"><a href="#问题引出？" class="headerlink" title="问题引出？"></a>问题引出？</h2><p>之前， 我们要做<strong>懒加载</strong>  或者 <strong>无限加载</strong>的时候。通常是这么做的：</p><ol><li><p><strong>懒加载</strong></p> <span id="more"></span><p>图示：</p><img src="/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/lazyLoad.jpg" class=""><p>主要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 浏览器滚动过的高度</span></span><br><span class="line">  <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">  <span class="comment">// 可视区域的高度</span></span><br><span class="line">  <span class="keyword">var</span> winTop = <span class="built_in">window</span>.innerHeight; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; imgs.length;i++)&#123;</span><br><span class="line">    <span class="comment">// 当图片距离页面顶部的距离 &lt; 浏览器滚动过的高度 +  可视区域的高度</span></span><br><span class="line">    <span class="keyword">if</span>(imgs[i].offsetTop &lt; scrollTop + winTop )&#123;</span><br><span class="line">      imgs[i].src = imgs[i].getAttribute(<span class="string">&#x27;data-src&#x27;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>无限滚动</strong></p><p>图例：</p><img src="/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/wuxian.jpg" class=""><p>主要代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> page=<span class="number">1</span>; <span class="comment">//当前页的页码</span></span><br><span class="line"><span class="keyword">var</span> flagNoData = <span class="literal">false</span>; <span class="comment">//false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAjax</span>(<span class="params">page</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...请求数据啥啥的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//真实内容的高度</span></span><br><span class="line">  <span class="keyword">var</span> pageHeight = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollHeight,<span class="built_in">document</span>.body.offsetHeight);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//视窗的高度</span></span><br><span class="line">  <span class="keyword">var</span> viewportHeight = <span class="built_in">window</span>.innerHeight </span><br><span class="line">                   || <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">                   || <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">                   || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//隐藏的高度</span></span><br><span class="line">  <span class="keyword">var</span> scrollHeight = <span class="built_in">window</span>.pageYOffset </span><br><span class="line">                    || <span class="built_in">document</span>.documentElement.scrollTop </span><br><span class="line">                    || <span class="built_in">document</span>.body.scrollTop </span><br><span class="line">                    || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(falgNoData)&#123; <span class="comment">//数据全部加载完了</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pageHeight - viewportHeight - scrollHeight &lt; <span class="number">10</span>)&#123; <span class="comment">//如果满足触发条件，执行    </span></span><br><span class="line">      showAjax(page);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="built_in">window</span>).bind(<span class="string">&quot;scroll&quot;</span>,scrollFn);    <span class="comment">//绑定滚动事件</span></span><br></pre></td></tr></table></figure></li></ol><p>传统的实现方法是，监听到<code>scroll</code>事件后，获取相关元素的坐标来进行判断。这种方法是有缺点的。由于<code>scroll</code>事件密集发生，计算量很大，容易造成性能。</p><p>那么在这样的背景下， 我们有没有更好的办法呢？</p><h2 id="关于IntersectionObserver"><a href="#关于IntersectionObserver" class="headerlink" title="关于IntersectionObserver"></a>关于IntersectionObserver</h2><p><code>IntersectionObserver</code>的出现解决了这个问题。</p><p>MDN上给的官方概念：</p><blockquote><p><code>IntersectionObserver</code>接口 (Intersection Observer API)为开发者提供了一种可以异步监听目标元素与其祖先或者视窗（viewport）交叉状态的手段。祖先元素与视窗(viewport)被称为根(root)。</p></blockquote><p>这概念的重点就是：<strong>监听目标元素与其祖先或视窗交叉状态发生改变的手段</strong> </p><p>图解如下图：</p><img src="/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/2.jpg" class=""><p><strong>目标元素与root元素刚开始交叉</strong>和<strong>目标元素与root元素刚开始不交叉</strong>都能检测到。</p><p><strong>看看小🌰：</strong> </p><iframe height="598" style="width: 100%;" scrolling="no" title="wvKBBWb" src="https://codepen.io/shuliqi/embed/wvKBBWb?height=598&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/wvKBBWb'>wvKBBWb</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h2 id="IntersectionObserver-如何解决？"><a href="#IntersectionObserver-如何解决？" class="headerlink" title="IntersectionObserver 如何解决？"></a>IntersectionObserver 如何解决？</h2><p>IntersectionObserver API 是异步的， 不随着目标元素的滚动同步触发。即只有在线程空闲下来才会执行观察器。这意味着这个观察器的优先级非常的低，只有在其他的任务执行完，浏览器空闲了才会执行。</p><h2 id="IntersectionObserver-API"><a href="#IntersectionObserver-API" class="headerlink" title="IntersectionObserver API"></a>IntersectionObserver API</h2><p>这个API的调用非常的简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, options)</span><br></pre></td></tr></table></figure><p><code>IntersectionObserver</code>支持两个参数：</p><ol><li><code>callback</code> 是当被监听元素的可见性变化时，触发的回调函数</li><li><code>options</code>是一个配置参数对象，可选的， 有默认的属性值</li></ol><p>构造函数的返回值是一个观察实例， 实例的<code>observe</code>方法可以指定观察哪个DOM节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  对元素target添加监听，当target元素变化时，就会触发回调</span></span><br><span class="line">io.observe(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;shuliqi&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除一个监听，移除之后，target元素的交叉状态变化，将不再触发回调函数</span></span><br><span class="line">io.unobserve(element)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止所有的监听</span></span><br><span class="line">io.disconnect();</span><br></pre></td></tr></table></figure><p>上面的<code>observe()</code>的参数是一个DOM节点对象，如果要观察多个节点，就要多次调用这个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.observe(eleA);</span><br><span class="line">io.observe(eleB);</span><br></pre></td></tr></table></figure><h2 id="callback-参数"><a href="#callback-参数" class="headerlink" title="callback 参数"></a>callback 参数</h2><p>目标元素的交叉状态发生改变时，就会调用观察器的回调函数<code>callback</code>。</p><p><code>callback</code>一般会调用两次。一次是目标元素刚刚进入root元素（开始交叉）, 另一次是完全离开root（开始不相交）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(entries);</span><br><span class="line">&#125;)</span><br><span class="line">io.observe($<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>以上的代码， 在chrome控制台进行调试，这里的$0代表我审查元素选中的节点。</p><p>运行的结果如下：</p><img src="/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/3.jpg" class=""><p>由图我们可知callback函数有个参数，它是<code>IntersectionObserverEntry</code>对象数组，举例来说，如果同时有两个被观察的对象的可见性发生变化， 那么entries数组就会有两个成员。</p><p>接下来我们重点讲<code>IntersectionObserverEntry</code></p><h2 id="IntersectionObserverEntry对象"><a href="#IntersectionObserverEntry对象" class="headerlink" title="IntersectionObserverEntry对象"></a>IntersectionObserverEntry对象</h2><p><code>IntersectionObserverEntry</code>对象提供目标元素的信息，</p><p>还是以上的例子：</p><img src="/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/4.jpg" class=""><p>一共有8 个属性：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  time: <span class="number">78463997.025</span>,</span><br><span class="line">  rootBounds: <span class="literal">null</span>,</span><br><span class="line">  boundingClientRect: DOMRectReadOnly &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  intersectionRect: DOMRectReadOnly&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  isIntersecting: <span class="literal">true</span>,</span><br><span class="line">  intersectionRatio: <span class="number">1</span>,</span><br><span class="line">  target: html,</span><br><span class="line">  isVisible: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个属性的含义如下：</p><ol><li><p><strong>time：</strong> </p><p>返回一个记录从<code>IntersectionObserver</code>开始实例化的时间到交叉状态发生改变的时间的时间戳对比时间：实例化的时间。例子：值为1000时，表示在IntersectionObserver实例化的1秒钟之后，目标元素的交叉状态发生改变了</p></li><li><p><strong>rootBounds：</strong> 根元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回<code>null</code></p></li><li><p><strong>boundingClientRect：</strong>  目标元素的矩形信息</p></li><li><p><strong>isIntersecting：</strong>目标元素当前是否可见 Boolean值 可见为true</p></li><li><p><strong>intersectionRect：</strong> 目标元素与视口（或root根元素）的交叉区域的信息</p></li><li><p><strong>intersectionRatio：</strong> 目标元素的可见比例，即<code>intersectionRect</code>占<code>boundingClientRect</code>的比例，完全交叉时为<code>1</code>，完全不交叉时小于等于<code>0</code></p></li><li><p><strong>target：</strong> 被观察的目标元素，是一个 DOM 节点对象</p></li></ol><p><strong>注意：</strong>在Chrome 78版本中会返回<code>isVisible</code>属性，但是不知道是不是Bug，无论元素是否可见，都为<code>false</code>，但是<code>isTntersecting</code>的表现是正常的，所以判断是否可见，可以根据<code>intersectionRatio</code>或者<code>isTntersecting</code>来进行判断。</p><p>上面的矩形信息的关系如下：</p><img src="/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/5.jpg" class=""><h2 id="options参数"><a href="#options参数" class="headerlink" title="options参数"></a>options参数</h2><p><code>IntersectionObserver</code>构造函数的第二参数是一个配置对象， 他可以设置以下属性：</p><ol><li><p><strong>threshold属性</strong></p><p><code>threshold</code>属性 决定了什么时候触发回调函数，它是一个数组， 每一个成员也是一个门槛值，当目标元素和根元素相交的面积占目标元素面积的百分比到达或跨过某些指定的临界值时就会触发回调函数</p><p><code>threshold</code>的默认值是<code>:[0]</code>，即只有在开始进入，或者是完全离开视图区域时，才会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, &#123;</span><br><span class="line"><span class="attr">threshold</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>],</span><br><span class="line">&#125;)</span><br><span class="line">io.observe($<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>用户可以自定义这个属性， [0, 0.5, 1]就表示 0%， 50%，75%， 100%交叉状态发生改变时， 就会触发回调函数。</p><p>   **看看小🌰：  **</p><iframe height="423" style="width: 100%;" scrolling="no" title="dyYoJJJ" src="https://codepen.io/shuliqi/embed/dyYoJJJ?height=423&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/dyYoJJJ'>dyYoJJJ</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe></li><li><p><strong>rootMargin</strong>属性</p><p>用来扩大或者缩小视窗的大小， 使用css的定义方式，    <code>10px 10px 10px 20px</code> 表示top，right,bottom, left的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">threshold</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="attr">rootMargin</span>: <span class="string">&#x27;30px 20px 30px 20px&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图：</p><img src="/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/6.jpg" class=""><p>图上的绿色部分是定义好的root元素， 我们添加了<code>rootMargin</code>属性， 将视窗增大了。</p><p>由此可见，root元素只有在<code>rootMargin</code>为空的时候才是绝对的视窗。</p><p> <strong>看看小🌰：</strong></p><iframe height="628" style="width: 100%;" scrolling="no" title="PoGWJVv" src="https://codepen.io/shuliqi/embed/PoGWJVv?height=628&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/PoGWJVv'>PoGWJVv</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe></li><li><p>**root **属性</p><p><code>root</code>属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。</p></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><p><strong>懒加载（lazy load）</strong></p><p>我们希望某些静态资源（比如图片），只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。这就叫做”惰性加载”。</p><p>有了 IntersectionObserver API，实现起来就很容易了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> IntersectionObserver(callback);</span><br><span class="line">    <span class="keyword">let</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;[data-src]&quot;</span>); <span class="comment">// 将图片的真实url设置为data-src src属性为占位图 元素可见时候替换src</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">entries</span>) </span>&#123;</span><br><span class="line">      entries.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历entries数组</span></span><br><span class="line">        <span class="keyword">if</span> (item.isIntersecting) &#123;</span><br><span class="line">          <span class="comment">// // 当前元素可见</span></span><br><span class="line">          item.target.src = item.target.dataset.src; <span class="comment">// 替换src</span></span><br><span class="line">          io.unobserve(item.target); <span class="comment">// 停止观察当前元素 避免不可见时候再次调用callback函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// io.observe接受一个DOM元素，添加多个监听 使用forEach</span></span><br><span class="line">    imgs.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      io.observe(item);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，只有目标区域可见时，才会将模板内容插入真实 DOM，从而引发静态资源的加载。</p><p><strong>看看小🌰： <a href="https://codepen.io/shuliqi/pen/gOababR">小小例子</a></strong></p><iframe height="570" style="width: 100%;" scrolling="no" title="gOababR" src="https://codepen.io/shuliqi/embed/gOababR?height=570&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/gOababR'>gOababR</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe></li><li><p><strong>无限加载</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> loadData = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      div.className = <span class="string">&quot;unit&quot;</span>;</span><br><span class="line">      div.innerText = <span class="string">`第 <span class="subst">$&#123;sum&#125;</span> 个数据`</span>;</span><br><span class="line">      fragment.appendChild(div);</span><br><span class="line">      sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span></span><br><span class="line">      .getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">   .insertBefore(fragment, <span class="built_in">document</span>.getElementById(<span class="string">&quot;loading&quot;</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="keyword">function</span> (<span class="params">entries</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entries[<span class="number">0</span>].isIntersecting) &#123;</span><br><span class="line">      <span class="comment">// 如果loading元素不可见，就加载数据</span></span><br><span class="line">      loadData();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  io.observe(<span class="built_in">document</span>.getElementById(<span class="string">&quot;loading&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>无限滚动时，最好在页面底部有一个页尾栏（又称<a href="http://www.ruanyifeng.com/blog/2016/11/sentinels">sentinels</a>）。一旦页尾栏可见，就表示用户到达了页面底部，从而加载新的条目放在页尾栏前面。这样做的好处是，不需要再一次调用<code>observe()</code>方法，现有的<code>IntersectionObserver</code>可以保持使用。</p><p>  <strong>看看小🌰： <a href="https://codepen.io/shuliqi/pen/KKdwdNb">小小例子</a></strong></p><iframe height="608" style="width: 100%;" scrolling="no" title="KKdwdNb" src="https://codepen.io/shuliqi/embed/KKdwdNb?height=608&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/KKdwdNb'>KKdwdNb</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe></li></ol><h2 id="疑问的点"><a href="#疑问的点" class="headerlink" title="疑问的点"></a>疑问的点</h2><ol><li><p><strong>一次性到达或跨过的多个临界值中选一个最近的</strong></p><p><strong>问题：</strong>如果一个观察者实例设置了 11 个临界值：[0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]，那么当目标元素和根元素从完全不相交状态滚动到相交率为 1 这一段时间里，回调函数会触发几次？</p><p><strong>答案：</strong> 不确定的。</p><p>如果滚动速度足够慢，每次相交率到达下一个临界值的时间点都发生在了不同的帧里（浏览器至少绘制了 11 次），那么就会有 11 次相交被检测到，回调函数就会被执行 11 次</p><p>如果滚动速度足够快，从不相交到完全相交是发生在同一个帧里的，浏览器只绘制了一次，浏览器虽然知道这一次滚动操作就满足了 11 个指定的临界值（从不相交到 0，从 0 到 0.1，从 0.1 到 0.2 ··· ），但它只会考虑最近的那个临界值，那就是 1，回调函数只触发一次.</p><p> <strong>看看小🌰： <a href="https://codepen.io/shuliqi/pen/zYvGaLL">例子</a></strong></p><p class="codepen" data-height="568" data-theme-id="dark" data-default-tab="js,result" data-user="shuliqi" data-slug-hash="zYvGaLL" style="height: 568px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="zYvGaLL">  <span>See the Pen <a href="https://codepen.io/shuliqi/pen/zYvGaLL">  zYvGaLL</a> by shuliqi (<a href="https://codepen.io/shuliqi">@shuliqi</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script></li><li><p><strong>如何判断当前是否相交？</strong></p><p><strong>问题：</strong> 前面的几个例子， 都使用了isIntersecting 来判断目标元素是否在窗口里面，为什么？难道用entry.intersectionRatio &gt; 0 判断不可以吗？</p><p>如果你滚动页面速度很慢，当目标元素的顶部和视口底部刚好挨上时，浏览器检测到相交了，回调函数触发了，但这时 entry.intersectionRatio 等于 0，会进入 else 分支，继续向下滚，回调函数再不会触发了，提示文字一直停留在不可见状态；但如果你滚动速度很快，当浏览器检测到相交时，已经越过了 0 那个临界值，存在了实际的相交面积，entry.intersectionRatio &gt; 0 也就为 true 了。所以这样写会导致代码执行不稳定，不可行。</p><p><strong>看看小🌰： <a href="https://codepen.io/shuliqi/pen/gOapKZP">例子</a></strong></p><iframe height="444" style="width: 100%;" scrolling="no" title="gOapKZP" src="https://codepen.io/shuliqi/embed/gOapKZP?height=444&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/shuliqi/pen/gOapKZP'>gOapKZP</a> by shuliqi  (<a href='https://codepen.io/shuliqi'>@shuliqi</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe></li><li><p><strong>贴边的情况是特例</strong></p><p>当目标元素从距离根元素很远到和根元素贴边，这时也会触发回调（假如 thresholds 里有 0），但这和工作原理相矛盾啊，离的很远相交率是 0，就算贴边，相交率还是 0，值并没有变，不应该触发回调啊。的确，这和基本工作原理矛盾，但这种情况是特例，目标元素从根元素外部很远的地方移动到和根元素贴边，也会当做是满足了临界值 0，即便 0 等于 0。</p><p>还有一个反过来的特例，就是目标元素从根元素内部的某个地方（相交率已经是 1）移动到和根元素贴边（还是 1），也会触发回调（假如 thresholds 里有 1）</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在当前判断可视性的方法，基本就是监听<code>scroll</code>事件，但是由于其高频的计算频率，会导致浏览器性能的损失，尤其是，如果一个同一个页面中，有多个地方，需要这样的判断，那么就需要绑定多个<code>scroll</code>事件，或者有多个计时器在轮询的话，那么对性能的损失就更为客观了。</p><p>虽然现在的浏览器性能一直在增强，但是也有更多的消耗性能的比较炫的技术在产生，它们依然在占据着浏览器的大量的计算内存，所以，尽量在可以节省性能的时候，就节省一下性能吧。</p><p>而该方法给我们提供了一个更简单直接，性能更好的解决方案，希望以后的浏览器，可以越来越广泛的支持吧。</p><p>最后， 毕竟是一个新兴的<code>API</code>，所以浏览器的支持性并不好，这里可以看看当前浏览器对于<code>IntersectionObserver</code>的支持性：</p><img src="/2020/03/26/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/caniuse.png" class=""><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章的ppt也有哦， <a href="https://shuliqi.github.io/ppt/IntersectionObserver/%E5%85%B3%E4%BA%8EIntersectionObserver.html">请点击这里</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记-Symbol的使用</title>
      <link href="/2020/02/23/ES6%E4%B8%ADSymbol%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/23/ES6%E4%B8%ADSymbol%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>ES6中引入了一种新的基础数据类型：<code>Symbol</code>，不过很多开发者可能都不怎么了解它，或者觉得在实际的开发工作中并没有什么场景应用到它，那么今天我们来讲讲这个数据类型，并看看我们怎么来利用它来改进一下我们的代码。</p><span id="more"></span><h3 id="ES6中的Symbol"><a href="#ES6中的Symbol" class="headerlink" title="ES6中的Symbol"></a>ES6中的Symbol</h3><p><code>Symbol</code>是由ES6规范引入的一项新特性，它的功能类似于一种标识唯一性的ID。通常情况下，我们可以通过调用<code>Symbol()</code>函数来创建一个Symbol实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q1 = <span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure><p>或者，你也可以在调用<code>Symbol()</code>函数时传入一个可选的字符串参数，相当于给你创建的Symbol实例一个描述信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;another symbol&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果用当下比较流行的TypeScript的方式来描述这个<code>Symbol()</code>函数的话，可以表示成：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;any&#125; description 描述信息。可以是任何可以被转型成字符串的值，如：字符串、数字、对象、数组等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Symbol</span>(<span class="params">description?: any</span>): <span class="title">symbol</span></span></span><br></pre></td></tr></table></figure><p>由于<code>Symbol</code>是一种基础数据类型，所以当我们使用<code>typeof</code>去检查它的类型的时候，它会返回一个属于自己的类型<code>symbol</code>，而不是什么<code>string</code>、<code>object</code>之类的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> q1  <span class="comment">// &#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><p>另外，我们需要重点记住的一点是：每个Symbol实例都是唯一的。因此，当你比较两个Symbol实例的时候，将总会返回<code>false</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q1 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> q2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;another symbol&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> q3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;another symbol&#x27;</span>)</span><br><span class="line"></span><br><span class="line">q1 === q2 <span class="comment">// false</span></span><br><span class="line">q2 === q3 <span class="comment">// fals</span></span><br></pre></td></tr></table></figure><h3 id="Symbol的应用场景"><a href="#Symbol的应用场景" class="headerlink" title="Symbol的应用场景"></a>Symbol的应用场景</h3><ul><li><h4 id="使用Symbol来作为对象属性名-key"><a href="#使用Symbol来作为对象属性名-key" class="headerlink" title="使用Symbol来作为对象属性名(key)"></a>使用Symbol来作为对象属性名(key)</h4><p>在这之前，我们通常定义或访问对象的属性时都是使用字符串，比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;shuliqi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">&quot;age&quot;</span>] <span class="comment">// 123</span></span><br><span class="line">obj[<span class="string">&quot;name&quot;</span>] <span class="comment">// &#x27;shuliqi&#x27;</span></span><br></pre></td></tr></table></figure><p>而现在，<code>Symbol</code>可同样用于对象属性的定义和访问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PROP_NAME = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> PROP_AGE = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [PROP_NAME]: <span class="string">&quot;我的代码呀&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[PROP_AGE] = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">obj[PROP_NAME] <span class="comment">// &#x27;我的代码呀&#x27;</span></span><br><span class="line">obj[PROP_AGE] <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用<code>Object.keys()</code>或者<code>for...in</code>来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">   [<span class="built_in">Symbol</span>(<span class="string">&#x27;name&#x27;</span>)]: <span class="string">&#x27;一斤代码&#x27;</span>,</span><br><span class="line">   <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">   <span class="attr">title</span>: <span class="string">&#x27;Engineer&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)   <span class="comment">// [&#x27;age&#x27;, &#x27;title&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(p)   <span class="comment">// 分别会输出：&#x27;age&#x27; 和 &#x27;title&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)   <span class="comment">// [&#x27;age&#x27;, &#x27;title&#x27;]</span></span><br></pre></td></tr></table></figure><p>被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。</p><p>也正因为这样一个特性，当使用<code>JSON.stringify()</code>将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(obj)  <span class="comment">// &#123;&quot;age&quot;:18,&quot;title&quot;:&quot;Engineer&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以利用这一特点来更好的设计我们的数据对象，让“对内操作”和“对外选择性输出”变得更加优雅。</p><p>然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Object的API</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(name)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新增的反射API</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj) <span class="comment">// [Symbol(name), &#x27;age&#x27;, &#x27;title&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><h4 id="使用Symbol来替代常量"><a href="#使用Symbol来替代常量" class="headerlink" title="使用Symbol来替代常量"></a>使用Symbol来替代常量</h4><p>先来看一下下面的代码，是不是在你的代码里经常会出现？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="string">&#x27;AUDIO&#x27;</span></span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="string">&#x27;VIDEO&#x27;</span></span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="string">&#x27;IMAGE&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFileResource</span>(<span class="params">resource</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(resource.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> TYPE_AUDIO:</span><br><span class="line">      playAudio(resource)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> TYPE_VIDEO:</span><br><span class="line">      playVideo(resource)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> TYPE_IMAGE:</span><br><span class="line">      previewImage(resource)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown type of resource&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码中那样，我们经常定义一组常量来代表一种业务逻辑下的几个不同类型，我们通常希望这几个常量之间是唯一的关系，为了保证这一点，我们需要为常量赋一个唯一的值（比如这里的’AUDIO’、’VIDEO’、 ‘IMAGE’），常量少的时候还算好，但是常量一多，你可能还得花点脑子好好为他们取个好点的名字。</p><p>现在有了<code>Symbol</code>，我们大可不必这么麻烦了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure><p>这样定义，直接就保证了三个常量的值是唯一的了！是不是挺方便的呢。</p></li><li><h4 id="使用Symbol定义类的私有属性-方法"><a href="#使用Symbol定义类的私有属性-方法" class="headerlink" title="使用Symbol定义类的私有属性/方法"></a>使用Symbol定义类的私有属性/方法</h4><p>我们知道在JavaScript中，是没有如Java等面向对象语言的访问控制关键字<code>private</code>的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。</p><p>而有了<code>Symbol</code>以及<code>模块化机制</code>，类的私有属性和方法才变成可能。例如：</p><p><strong>在文件 1.js中</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PASSWORD = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">username, password</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.username = username</span><br><span class="line">    <span class="built_in">this</span>[PASSWORD] = password</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">checkPassword</span>(<span class="params">pwd</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>[PASSWORD] === pwd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Login</span><br></pre></td></tr></table></figure><p><strong>2.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="keyword">new</span> Login(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login.checkPassword(<span class="string">&#x27;123456&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">login.PASSWORD  <span class="comment">// oh!no!</span></span><br><span class="line">login[PASSWORD] <span class="comment">// oh!no!</span></span><br><span class="line">login[<span class="string">&quot;PASSWORD&quot;</span>] <span class="comment">// oh!no!</span></span><br></pre></td></tr></table></figure><p>由于Symbol常量<code>PASSWORD</code>被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），因此这个<code>PASSWORD</code>的Symbol只能被限制在a.js内部使用，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。</p></li><li><h4 id="注册和获取全局Symbol"><a href="#注册和获取全局Symbol" class="headerlink" title="注册和获取全局Symbol"></a>注册和获取全局Symbol</h4><p>通常情况下，我们在一个浏览器窗口中（window），使用<code>Symbol()</code>函数来定义和Symbol实例就足够了。但是，如果你的应用涉及到多个window（最典型的就是页面中使用了``），并需要这些window中使用的某些Symbol是同一个，那就不能使用<code>Symbol()</code>函数了，因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol。这种情况下，我们就需要使用另一个API来创建或获取Symbol，那就是<code>Symbol.for()</code>，它可以注册或获取一个window间全局的Symbol实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gs1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;global_symbol_1&#x27;</span>)  <span class="comment">//注册一个全局Symbol</span></span><br><span class="line"><span class="keyword">let</span> gs2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;global_symbol_1&#x27;</span>)  <span class="comment">//获取全局Symbol</span></span><br><span class="line"></span><br><span class="line">gs1 === gs2  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。</p><p>好了，通过以上这些例子，你现在是不是开始对ES6的这个Symbol功能有点了解了呢？Symbol在JS内部也有很多应用，比如迭代器(Iterator)等，大家可以以此为出发点，发掘出更多相关知识点，深入的理解Symbol的用法和使用场景。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端浏览器缓存</title>
      <link href="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
      <url>/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="我们为什么要缓存"><a href="#我们为什么要缓存" class="headerlink" title="我们为什么要缓存"></a>我们为什么要缓存</h2><ul><li><p><strong>缓存可以减少用户的等待时间，提升用户的体验。</strong></p></li><li><p><strong>减少网络带宽消耗</strong></p><p>对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。如果可以使用缓存，只会产生极小的网络流量，这将有效的降低运营成本</p> <span id="more"></span></li><li><p><strong>降低服务器压力。</strong></p><p>给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。此外，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。</p></li></ul><p><strong>注意：</strong>如果缓存数据使用不当，会有“脏数据”。导致用户数据异常。</p><h2 id="前端缓存-后端缓存"><a href="#前端缓存-后端缓存" class="headerlink" title="前端缓存/后端缓存"></a>前端缓存/后端缓存</h2><p>首先我们定义一下：什么是前端缓存？什么是后端缓存？</p><p>基本的网络请求有三个步骤：<code>请求</code>，<code>处理</code>，<code>响应</code>。</p><p>后端缓存主要集中在<code>处理</code>步骤。通过保留数据库的连接，存储结果的处理等方式缩短处理时间。尽快进入“响应”步骤。本文不讲后端缓存。</p><p>前端缓存则可以在剩下的两步：<code>请求</code>和<code>响应</code>中进行。在请求的过程中，浏览器也可以通过存储结果的方式直接使用资源，省去了发送请求。而响应步骤则需要浏览器和服务器共同配合。通过减少响应内容来缩短传输的时间。</p><h2 id="按缓存位置分类"><a href="#按缓存位置分类" class="headerlink" title="按缓存位置分类"></a>按缓存位置分类</h2><p>按缓存位置分类可分为三个部分：<code>service worker</code>,    <code>memory cache</code>,   <code>disk cache</code> 。</p><p>在Chrome 的开发者工具中，Network -&gt; Size 一列看到一个请求最终的处理方式：如果是大小 (多少 K， 多少 M 等) 就表示是网络请求，否则会列出 <code>memory cache</code>,    <code>disk cache</code> 和    <code>ServiceWorker</code> </p><p>如图：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/1.jpg" class=""><p><strong>优先级是：</strong>(由上到下寻找，找到即返回；找不到则继续)</p><ul><li>service worker</li><li>memory cache</li><li>disk cache</li><li>网络请求</li></ul><h4 id="memory-cache"><a href="#memory-cache" class="headerlink" title="memory cache"></a>memory cache</h4><p>memory cache 是内存中的缓存。</p><p>几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。但是因为 <strong>数量很大</strong>，而且<strong>浏览器占的内存不能无限扩大</strong> 这两个原因。memory cache 就只能是个<strong>短期存储</strong>。</p><p>通常的情况下，浏览器的tab 关闭后该浏览器tab的memory cache 就会失效了(为了给其他的tab腾出空间)。</p><p>极端的情况下，如果一个页面的缓存用了超级多的内存，那么可能在它没有关闭前，排在前面的缓存就已经失效了。</p><h4 id="disk-cache-（HTTP-cache）"><a href="#disk-cache-（HTTP-cache）" class="headerlink" title="disk cache （HTTP cache）"></a>disk cache （HTTP cache）</h4><p>disk cache 也叫HTTP cache，是存储在硬盘上的缓存。因此它是持久存储的，是实际存在于文件系统中的。</p><p>disk cache 会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存，哪些资源不可以缓存；哪些资源是仍然可用的，哪些资源是过时需要重新请求的。当命中缓存之后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但比起网络请求还是快了不少的。绝大部分的缓存都来自 disk cache。</p><p>凡是永久性存储都会面临容量增长的问题。disk cache也是一样的。在浏览器自动清理时， 会有神秘的算法去把“最老的”或者“最可能过时的”资源删除。是一个一个删掉的。不过每个浏览器识别“最老的”和“最可能过时的”资源的算法不尽相同，可能也是它们差异性的体现。</p><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>memory cache， disk cache的缓存策略以及缓存/读取/失效的动作都是由浏览器内部判断 &amp; 进行的，我们只能设置响应头的某些字段来告诉浏览器，而不能自己操作。而Service Worker是我们自己能够操作缓存的。</p><p>我们可以从 Chrome 的 F12 中，Application -&gt; Cache Storage 找到这个单独的“小金库”。</p><p><strong>Service Worker 的优点：</strong></p><ul><li>Service Worke 能够直接操作缓存。</li><li>缓存是永久的。即使tab或者浏览器关闭，下次打开依然还在。</li></ul><p>有两种情况会导致这个缓存中的资源被清除：手动调用 API cache.delete(resource) 或者容量超过限制，被浏览器全部清空。</p><h4 id="请求网络"><a href="#请求网络" class="headerlink" title="请求网络"></a>请求网络</h4><p>如果一个请求在上述 3 个位置都没有找到缓存，那么浏览器会正式发送网络请求去获取内容。之后容易想到，为了提升之后请求的缓存命中率，自然要把这个资源添加到缓存中去。</p><h2 id="前端缓存"><a href="#前端缓存" class="headerlink" title="前端缓存"></a>前端缓存</h2><p>前端缓存分类 <strong>HTTP缓存</strong> 和 <strong>浏览器缓存</strong>。</p><p><strong>HTTP缓存：</strong>在HTTP请求传输时用到的缓存，主要在服务器代码上设置（disk cache）。</p><p><strong>浏览器缓存：</strong>前端开发在前端js上进行设置(如：Service Worker )。</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/8.webp" class=""><h2 id="前端缓存的分析过程"><a href="#前端缓存的分析过程" class="headerlink" title="前端缓存的分析过程"></a>前端缓存的分析过程</h2><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。如图：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/9.webp" class=""><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 </p><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，</p><p><strong>强制缓存的情况主要有三种情况：</strong></p><ul><li><p><strong>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求</strong></p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/10.webp" class=""></li><li><p><strong>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存</strong></p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/11.webp" class=""></li><li><p><strong>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</strong></p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/12.webp" class=""></li></ul><p><strong>强制缓存的规则：</strong></p><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应头中和请求结果一起返回给浏览器</p><p><strong>控制强制缓存的字段：</strong> <strong>Expires</strong>，<strong>Cache-Control</strong></p><p><strong>强缓存的直接优点：</strong>直接减少请求数，是提升最大的缓存策略。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>这是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p><p>例子：</p><p>后端的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强缓存---&gt; Expires</span></span><br><span class="line">app.get(<span class="string">&#x27;/1.css&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cssPath = path.join(__dirname, <span class="string">&#x27;./public/stylesheets/1.css&#x27;</span>);</span><br><span class="line">  <span class="comment">// 读取1.css 文件</span></span><br><span class="line">  fs.readFile(cssPath, <span class="function">(<span class="params">err, content</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!err) &#123;</span><br><span class="line">      <span class="comment">// 设置到期时间</span></span><br><span class="line">      res.setHeader(<span class="string">&#x27;Expires&#x27;</span>, <span class="string">&#x27;Thu Dec 05 2019 20:13:08 GMT+0800 (CST)&#x27;</span>);</span><br><span class="line">      <span class="comment">// 发送1.css文件buffer</span></span><br><span class="line">      res.end(content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一次请求1.css 的结果：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/13.png" class=""><p>另打开一个tab再次请求1.css的结果：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/21.png" class=""><p><strong>缺点：</strong></p><ul><li><p>由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑自信修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。</p></li><li><p>写法太复杂了。表示时间的字符串多个空格，少个字母，都会导致非法属性从而设置失效。</p></li></ul><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求</p><p>这两者的区别就是前者是绝对时间，而后者是相对时间</p><p>例子：</p><p>后端的处理逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强缓存---&gt; Cache-Control</span></span><br><span class="line">app.get(<span class="string">&#x27;/2.css&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cssPath = path.join(__dirname, <span class="string">&#x27;./public/stylesheets/2.css&#x27;</span>);</span><br><span class="line">  fs.readFile(cssPath, <span class="function">(<span class="params">err, content</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置到期时间，全部资源， 10秒请求使用本地资源</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;public, max-age=600&#x27;</span>);</span><br><span class="line">    <span class="comment">// 发送2.css文件buffer</span></span><br><span class="line">    res.end(content);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一次请求的结果:</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/22.png" class=""><p>另打开一个tab再次请求的结果：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/23.png" class=""><p><strong>Cache-control 字段常用的值：</strong></p><ul><li>max-age: 即最大有效时间。</li><li>must-revalidate：如果超过了 max-age的时间，浏览器就必须向服务器发送请求，验证资源是否有效。</li><li>no-cache：然字面意思是“不要缓存”，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定。</li><li>no-store: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。</li><li>public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)。</li><li>private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。</li></ul><p>这些值是可以混合使用。</p><p><strong>总结：</strong>自从 HTTP/1.1 开始，Expires 逐渐被 Cache-control 取代。Cache-control 是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且 Cache-control 的可配置性比较强大。</p><p>Cache-control 的优先级高于 Expires，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段我们都会设置。如果两个设置都有效的话， 优先使用Cache-Control。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，</p><p><strong>协商缓存的两种情况：</strong></p><ul><li><p><strong>协商缓存生效，返回304</strong></p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/14.webp" class=""></li><li><p><strong>协商缓存失效，返回200和请求结果结果</strong></p>  <img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/15.webp" class=""></li></ul><p><strong>对比缓存的流程：</strong></p><ol><li>浏览器请求缓存数据库，返回一个缓存标识。</li><li>浏览器拿这个标识和服务器通讯。</li><li>如果缓存未失效，则返回HTTP状态码 304 标识缓存可以继续使用。如果缓存失效，则返回新的数据和缓存规则。浏览器响应数据后，再写入到缓存数据库。</li></ol><p><strong>对比缓存的优点：</strong> 通过减少响应体体积，来缩短网络传输时间。</p><p>虽然请求数和没有缓存是一样的。但是如果是304的话，返回的仅仅是一个状态码而已。但是并没有实际的文件内容，因此在响应体体积上的节省是它优化点。虽然和强制缓存相比提升幅度较小。但总比没有缓存好。</p><p><strong>协商缓存的字段：</strong> <strong>Last-Modified / If-Modified-Since</strong>， <strong>Etag / If-None-Match</strong></p><p>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h4><p>last-Modified是服务器在响应请求时用来说明资源的最后修改时间。与之对应的是<strong>if-Modified-Since</strong>.</p><p>在对比缓存中，浏览器发送HTTP请求中Header中会带上if-Modified-since字段，值为缓存资源的Last-Modified属性的值。</p><p>当服务器端接收到带有 If-Modified-Since 的请求时，则会将 If-Modified-Since 的值与被请求资源的最后修改时间做对比。如果相同，说明资源没有新的修改，则响应 HTTP Status Code 304，浏览器会继续使用缓存资源；如果最后修改时间比较新，则说明资源被修改过，则响应 HTTP Status Code 200，并返回最新的资源。</p><p><strong>例如：</strong></p><p>后端对处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比缓存 [if-modified-since, Last-Modified, ]</span></span><br><span class="line">app.use(<span class="string">&#x27;/1.js&#x27;</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> jsPath = path.join(__dirname, <span class="string">&#x27;./public/javascripts/1.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取文件1.js的信息</span></span><br><span class="line">  fs.stat(jsPath, (err, stat) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取文件内容被修改的时间 modify time</span></span><br><span class="line">    let lastModified = stat.mtime.toUTCString();</span><br><span class="line">   <span class="comment">// 判断 if-modified-since 的时间与资源的最后修改时间是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (req.headers[<span class="string">&#x27;if-modified-since&#x27;</span>] === lastModified) &#123;</span><br><span class="line">      <span class="comment">// 设置响应状态码</span></span><br><span class="line">      res.writeHead(<span class="number">304</span>, <span class="string">&#x27;not modified&#x27;</span>);</span><br><span class="line">      <span class="comment">// 不需要传输响应体</span></span><br><span class="line">      res.end();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 读取文件</span></span><br><span class="line">      fs.readFile(jsPath, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 设置Last-Modified</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Last-Modified&#x27;</span>, lastModified);</span><br><span class="line">        <span class="comment">// 设置响应状态码</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, <span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">        <span class="comment">// 需要传输响应体</span></span><br><span class="line">        res.end(content);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一次请求的结果：第一次请求， 后端设置响应字段 Last-Modified</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/15.png" class=""><p>第二次请求的结果：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/16.png" class=""><p>当我修改1.js文件之后再次访问的结果：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/17.png" class=""><p><strong><code>存在的问题：</code></strong></p><ul><li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内被修改多次的话，它将不能准确标注文件的最后修改时间；</li><li>如果本地打开缓存文件，即使没有对文件进行修改，但 Last-Modified 却改变了，导致文件没法使用缓存</li></ul><h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h4><p>Etag是服务器端在响应请求时用来说明资源在服务器端的唯一标识，与之对应的是 <strong>If-None-Match</strong> 字段。</p><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。</p><p>当服务器端接收到带有 If-None-Match 的请求时，则会将 If-None-Match 的值与被请求资源的唯一标识做对比。如果相同，说明资源没有新的修改，则响应 HTTP Status Code 304，浏览器会继续使用缓存资源；如果不同，则说明资源被修改过，则响应 HTTP Status Code 200，并返回最新的资源。</p><p>例子：</p><p>后端的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 对比缓存 [ Etag, If-None-Match ]</span></span><br><span class="line">app.get(<span class="string">&#x27;/2.js&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> jsPath = path.join(__dirname, <span class="string">&#x27;./public/javascripts/2.js&#x27;</span>);</span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  fs.readFile(jsPath, <span class="function">(<span class="params">err, content</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 对文件内容使用md5加密形成一个唯一的标识</span></span><br><span class="line">    <span class="keyword">let</span> etag = md5(content);</span><br><span class="line">    <span class="comment">// 请求头的唯一标识和当前文件的唯一标识是一致的，标识文件没有被修改过</span></span><br><span class="line">    <span class="keyword">if</span> (req.headers[<span class="string">&#x27;if-none-match&#x27;</span>] === etag) &#123;</span><br><span class="line">      <span class="comment">// 设置响应头 304</span></span><br><span class="line">      res.writeHead(<span class="number">304</span>, <span class="string">&#x27;not modified&#x27;</span>);</span><br><span class="line">      <span class="comment">// 响应体为空，减少传输时间</span></span><br><span class="line">      res.end();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 设置响应头的Etag</span></span><br><span class="line">      res.setHeader(<span class="string">&#x27;Etag&#x27;</span>, etag);</span><br><span class="line">       <span class="comment">// 设置响应头 200</span></span><br><span class="line">      res.writeHead(<span class="number">200</span>, <span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">      <span class="comment">// 需要返回内容</span></span><br><span class="line">      res.end(content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一次请求的结果：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/18.png" class=""><p>再次请求的结果：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/19.png" class=""><p>修改文件2.js 之后再次请求：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/20.png" class=""><p>注意：Last-Modified 是 HTTP 1.0 的字段，而 Etag 是 HTTP 1.1 的字段，<strong>当 Last-Modified 与 Etag 同时存在时，Etag 的优先级要高于 Last-Modified</strong>。Etag 的出现主要是为了解决 Last-Modified 存在的问题。</p><h2 id="用户刷新-访问行为"><a href="#用户刷新-访问行为" class="headerlink" title="用户刷新/访问行为"></a>用户刷新/访问行为</h2><p>强缓存的例子，再次请求有让大家打开另一个tab，为什么呢？为什么不直接刷F5刷新，或者点击工具栏的帅秀楠按钮或者邮件菜单重新加载呢？</p><p>我们把刷新/访问界面的手段分为三类：</p><ul><li><strong>在url输入栏输入然后回车/通过书签访问</strong></li><li><strong>F5/点击工具栏的刷新按钮/右键菜单重新加载</strong></li><li><strong>ctl+F5/硬性重新加载/清空缓存并且硬性重新加载</strong></li></ul><p>对以上三种访问情况进行实践和讨论。</p><p><strong>准备工作：</strong>模拟第一次访问资源。请求头没有任何相关的缓存的信息。而响应体设置了以下头部信息：Cache-Control，Expires，Last-Modified。请求之后，浏览器会对该文件进行缓存。</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/24.png" class=""><p>后端代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刷新/访问行为</span></span><br><span class="line">app.get(<span class="string">&#x27;/1.png&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置到期时间</span></span><br><span class="line">  res.setHeader(<span class="string">&#x27;Expires&#x27;</span>, <span class="string">&#x27;Thu Dec 05 2019 23:51:08 GMT+0800 (CST)&#x27;</span>);</span><br><span class="line">  res.setHeader(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;public, max-age=6000&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> imgPath = path.join(__dirname, <span class="string">&#x27;./public/images/1.png&#x27;</span>);</span><br><span class="line">  <span class="comment">// 获取文件1.png的信息</span></span><br><span class="line">  fs.stat(imgPath, <span class="function">(<span class="params">err, stat</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取文件内容被修改的时间 modify time</span></span><br><span class="line">    <span class="keyword">let</span> lastModified = stat.mtime.toUTCString();</span><br><span class="line">   <span class="comment">// 判断 if-modified-since 的时间与资源的最后修改时间是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (req.headers[<span class="string">&#x27;if-modified-since&#x27;</span>] === lastModified) &#123;</span><br><span class="line">      <span class="comment">// 设置响应状态码</span></span><br><span class="line">      res.writeHead(<span class="number">304</span>, <span class="string">&#x27;not modified&#x27;</span>);</span><br><span class="line">     <span class="comment">// 响应体为空，减少传输时间</span></span><br><span class="line">      res.end();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 读取文件</span></span><br><span class="line">      fs.readFile(jsPath, <span class="function">(<span class="params">err, content</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 设置Last-Modified</span></span><br><span class="line">        res.setHeader(<span class="string">&#x27;Last-Modified&#x27;</span>, lastModified);</span><br><span class="line">        <span class="comment">// 设置响应状态码</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, <span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">        <span class="comment">// 响应体为空，减少传输时间</span></span><br><span class="line">        res.end(content);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>1.在url输入栏输入然后回车</strong></p><p>我们可以看到返回的响应码是<code>200 ok (disk cache)</code>。浏览器发现了该资源以及缓存了而且没有过期(Cache-Control或者Expires)。 没有跟服务器确认，而是直接使用了浏览器缓存的内容，其中响应的内容和上一次的响应内容是一样的。</p><p>如图：</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/25.png" class=""><p><strong>2.F5/点击工具栏的刷新按钮/右键菜单重新加载</strong></p><p><code>F5/点击工具栏的正常刷新按钮/右键菜单重新加载</code> 的作用和<code>在url输入栏输入然后回车</code>的作用是不一样的。前者是无论如何都要发一个HTTP Request 给server。即使先前的响应中有Cache-Control或者Expires。而发送的请求头中，包含了这样的header信息。</p><img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/26.png" class=""><p>其中Cache-Control 是浏览器强制加上的。而If-Modified-Since是因为在获取资源的时候包含了Last-Modified的头部，所以浏览器会使用If-Modified-Since头部信息重新发送改该时间确认资源是否需要重新发送。世纪server 没有改过这个1.png这个文件， 所以返回了<code>304 not modified</code>.</p><p><strong>2.ctl+F5/硬性重新加载/清空缓存并且硬性重新加载</strong></p><p>而<code>ctl+F5/硬性重新加载/清空缓存并且硬性重新加载</code>是彻底的从server拿一份新的资源过来。所以不光耀发送HTTP request给server。而且这个请求里面连If-Modified-Since/If-None-Match都没有。这样就能逼着服务器不能返回304，而是把整个资源原原本本的返回一次。</p><p>为了保证拿到的是从server上获取的。 不只是去掉了f-Modified-Since/If-None-Match， 还添加了一些头部信息，如Cache-control：no-cache。因为cache不光是存在浏览器端，在浏览器端到服务器端的中间节点（如：Proxy）也可能扮演者Cache的角色。所以为了防止从这些节点获取缓存，所以加了Cache-control：no-cache。<img src="/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/27.png" class=""></p><p>最后，附上以上所有例子的代码：<a href="https://github.com/shuliqi/frontCache">https://github.com/shuliqi/frontCache</a></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http1.0，http1.1，http2.0之间的区别</title>
      <link href="/2019/10/17/%20http1.0%EF%BC%8Chttp1.1%EF%BC%8Chttp2.0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/10/17/%20http1.0%EF%BC%8Chttp1.1%EF%BC%8Chttp2.0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-的发展"><a href="#HTTP-的发展" class="headerlink" title="HTTP 的发展"></a>HTTP 的发展</h1><ul><li>1991：http/0.9</li><li>1996: http/1.0</li><li>1999: http/1.1</li><li>2015: http/2</li></ul><h1 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h1><p>HTTP1.0 最大的一个特点就是：<strong>无连接</strong></p><p><code>HTTP1.0</code>浏览器与服务器只保持短暂的连接，每次请求都需要建立一个<code>TCP</code>连接。服务器响应完成，得到客户端的确认之后就立即断开。</p><p><strong>无连接</strong>带来的一个缺点：假如解析<code>HTML</code>文件的时候发现里面嵌入了很多资源文件，如图片，视频，音频等。这时候又需要创建单独的连接。这就导致了一个<code>HTML</code>文件的访问包含了很多的次的请求和响应。这种形式很明显的就造成了性能上的一个缺陷。</p><p><code>HTTP1.0如果需要建立长连接，需要设置非标准的字段</code>Connection：keep-alive`。</p><h1 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h1><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p><code>HTTP1.1</code>默认是长连接<code>（Connection: keep-alive）</code>；即在一个<code>TCP</code>连接上可以传送多个<code>HTTP</code>请求和响应，这样就减少建立和关闭连接的消耗和延迟。</p><p>如果客户端和服务端发现对方一段时间没有活动，就可以主动关闭连接。不过规范的做法是：客户端在请求最后一个请求的时，发送<code>Connection：close</code>，明确服务器关闭<code>TCP</code>连接。</p><h2 id="管道机制（pipelining）"><a href="#管道机制（pipelining）" class="headerlink" title="管道机制（pipelining）"></a>管道机制（pipelining）</h2><p><code>HTTP1.1</code>引入了管道机制；即在同一个<code>TCP</code>连接中，客户端可以同时发送多个请求，这样就增加了效率。只不过服务器还是得按顺序来返回响应，客户端才能区分出来。</p><p>举个例子：客户端需要请求两个资源。以前的做法是，在同一个<code>TCP</code>连接里， 先发送A请求。然后等待服务器的响应，收到响应之后再发出B 请求。而管道机制允许浏览器同时发出这两个请求，但是服务器还是得按照顺序来响应。</p><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p><code>HTTP1.0</code>中主要是使用 <code>header</code>头部的 <code>    Last-Modified/If-Modified-Since</code>， <code>Expires</code>来作为缓存判断的标准，<code>HTTP1.1</code>引入了更多的缓存控制策略，比如：<code>Etag/If-None-Match</code>，<code>If-Unmodified-Since</code> ，<code>If-Match</code>等更多的可供选择的缓存头来控制缓存策略。</p><p>关于 缓存机制可以看这篇文章：<a href="https://shuliqi.github.io/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">前端浏览器缓存</a></p><h2 id="HOST头处理"><a href="#HOST头处理" class="headerlink" title="HOST头处理"></a>HOST头处理</h2><p>在<code>HTTP1.0</code>中认为每台服务器都绑定一个唯一的<code>IP</code>地址，因此请求消息中并没有传递主机名，但是随着虚拟主机技术的发展，在一台物理服务器上可以存在更多的虚拟主机，他们共享这一个<code>IP</code>地址。</p><p>所以<code>HTTP1.1</code>在请求头都加上<code>HOST</code>。 表示<strong>指定请求的服务器的域名和端口号</strong>。如果请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><img src="/2019/10/17/%20http1.0%EF%BC%8Chttp1.1%EF%BC%8Chttp2.0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" class=""><h2 id="引入range"><a href="#引入range" class="headerlink" title="引入range"></a>引入range</h2><p>在<code>HTTP1.0</code>中， 如果客户端值需要某个对象的一部分，但是服务器却将整个对象发送过来了，即不支持断点续传功能，</p><p>在<code>HTTP1.1</code>中请求头部引入了 <code>range</code>头域，允许只请求资源的某个部分。返回状态码为 206。使用的场景： 断点续传。</p><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>从下载断开的位置继续下载，直到下载完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Range: &lt;unit&gt;=&lt;range-start&gt;-</span><br><span class="line">Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;</span><br><span class="line">Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;</span><br><span class="line">Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;</span><br></pre></td></tr></table></figure><ul><li><unit><p>范围所采用的单位，通常是字节（bytes）。</p></li><li><range-start><p>一个整数，表示在特定单位下，范围的起始值。</p></li><li><range-end><p>一个整数，表示在特定单位下，范围的结束值。这个值是可选的，如果不存在，表示此范围一直延伸到文档结束。</p></li></ul><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=200-1000</span><br></pre></td></tr></table></figure><p>表示请求的范围：起始字节为200， 结束字节为1000的内容。</p><p>与范围相关的三种状态：</p><ul><li>请求成功：服务器会返回206（Partial Content）状态码。</li><li>请求范围越界：服务器会返回416（<code>Requested Range Not Satisfiable</code> ）（请求的范围无法满足） 状态码</li><li>不支持范围请求： 服务器返回 200 状态码， 将整个文件对象返回</li></ul><p><strong>Content-range</strong>:用于响应头，描述响应覆盖的一个内容范围和整个实体的长度; </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth] </span><br></pre></td></tr></table></figure><p>举个例子：</p><p>请求下载：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET  /test.rar  HTTP/1.1 </span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span> close </span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span> 116.1.219.219 </span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span> bytes=0-801 //一般请求下载整个文件是bytes=0- 或不用这个头</span><br></pre></td></tr></table></figure><p>一般正常回应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span> 801</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span> application/octet-stream </span><br><span class="line"><span class="attribute">Content-Range</span><span class="punctuation">: </span> bytes  0-800/801 //801:文件总大小</span><br></pre></td></tr></table></figure><h2 id="添加了其他的请求方法："><a href="#添加了其他的请求方法：" class="headerlink" title="添加了其他的请求方法："></a>添加了其他的请求方法：</h2><p><code>PUT</code>,<code>DELETE</code>,<code>OPTIONS</code>,<code>HEADE</code>,<code>PATCHD</code>等</p><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h1><p>2015 年 <code>HTTP/2</code>版本发布，它不叫<code>HTTP/2.0</code>， 因为标准委员会不打算再发布子版本了。下一个新版本将是<code>HTTP/3.0</code>。</p><p>而<code>HTTP/2</code>相比于之前的版本，性能上有很大的提升，添加了很多的特性</p><h2 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h2><p><strong>帧：</strong>是<code>HTTP/2</code>通信的最小单位。</p><p><code>HTTP/2</code>在应用层和传输成职期间加了一个二进制分帧层。将所有传输的信息分割成更小的消息和帧，并对他们采用二进制格式编码，其中<code>HTTP1.x</code>中的头信息会被封装到<code>header</code>帧，<code>body</code>封装到<code>data</code>帧；然后<code>HTTP/2</code>的通信都是在一个<code>TCP</code>连接上完成的（我请求一个页面<a href="http://www.qq.com/">http://www.qq.com</a>。页面上所有的资源请求都是客户端与服务器上的一条TCP上请求和响应的！）。这个连接可以承载任意数量的双向数据流，因此每个数据以消息的形式发送，而消息是由一个或者多个帧组成；这些帧是可以乱序发送的。然后根据每个帧的首部的顺序标识符来重新组装。</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p><code>HTTP/2</code>复用<code>TCP</code>连接，在一个连接里面，客户端和服务端都可以同时发送多个请求或响应。而且不用按照顺序来一一对应。这样就避免了”队头堵塞”。</p><p>多路复用主要用来解决两个问题：</p><ul><li><p>解决第一个问题：在<code>HTTP1.1</code>协议中， 我们传输的<code>request</code>和<code>response</code>都是基于文本格式的，这样就会引发一个问题， 就是所有的数据必须是按着顺序来发送的，比如需要传输：<code>hello world</code>，只能从<code>h</code>到<code>d</code>一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在<code>HTTP1.1</code>是不能实现的。</p><img src="/2019/10/17/%20http1.0%EF%BC%8Chttp1.1%EF%BC%8Chttp2.0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" class=""></li></ul><p><code>HTTP/2</code>引入<code>二进制数据帧</code>和<code>流</code>的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是<code>流</code>所做的事情。</p><img src="/2019/10/17/%20http1.0%EF%BC%8Chttp1.1%EF%BC%8Chttp2.0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/3.png" class=""><ul><li>解决第二个问题：<code>HTTP/2</code>对同一域名下所有请求都是基于<code>流</code>，也就是说同一域名不管访问多少文件，也只<strong>建立一路连接</strong>。同样<code>Apache</code>的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍！</li></ul><p>举例来说：在一个<code>TCP</code>连接中，服务器同时收到A,B请求，于是先处理A请求，结果发现A 请求处理过程非常耗时，于是先发送A请求已经处理好的部分，接着处理B请求，完后才能后，在发送A请求剩下的部分。</p><h2 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h2><p><code>HTTP 2.0</code> 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送;通信期间几乎不会改变的通用键-值对(用户代理、可接受的媒体类型,等等)只 需发送一次。事实上,如果请求中不包含首部(例如对同一资源的轮询请求),那么 首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。</p><p>如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP 2.0 的连接存续期内始终存在,由客户端和服务器共同渐进地更新 。</p><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p><code>HTTP 2.0 </code>引入了服务器推送，允许服务端推送资源给客户端。</p><p>服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源</p><p>免得客户端再次创建连接发送请求到服务器端获取</p><p>这种方式非常合适加载静态资源</p><img src="/2019/10/17/%20http1.0%EF%BC%8Chttp1.1%EF%BC%8Chttp2.0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/4.png" class="">]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git操作整理</title>
      <link href="/2019/09/17/git%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/09/17/git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>获得Git项目的仓库有两种方式：</strong></p><ol><li><p>在现有的目录下面通过导入所有的文件夹来创建Git仓库</p></li><li><p>从已有的仓库克隆一个新新的镜像仓库来使用</p></li></ol></blockquote><span id="more"></span><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>在现有的工作目录中初始化新仓库：</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_init.png" class=""><p>初始化完成后，在当前的目录下面会出现一个名为.git的目录。</p><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>从现有的仓库克隆。</p><p>克隆的命令：<code>git clone [url]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:shuliqi/echarts-vue.git</span><br></pre></td></tr></table></figure><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>检查当前文件的状态。</p><blockquote><p>git的工作目录下的所有文件都不外呼两种状态：已跟踪，未跟踪</p><p><code>已跟踪：</code> 指被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间之后，它们的状态可能是<code>未更新</code>，<code>已修改</code>，<code>已放入暂存入</code></p><p><code>未跟踪：</code>没有上次的更新时的快照，也不在当前的暂存区域（即不是已跟踪文件就是未更新文件）。</p><p>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p></blockquote><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/no_status.png" class=""><p>说明当前的工作目录很干净。所有的跟踪文件在上次提交之后没有更新过。</p><p>我们新建一个文件，1.js。 通过 <code>git status</code> 可看出我们新建的文件在未跟踪的文件列表里面.</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/add-status.png" class=""><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>跟踪一个新文件。</p><p>例如，要跟踪一个新文件1.js, 则可以:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add <span class="number">1.</span>js</span><br></pre></td></tr></table></figure><p>添加跟踪完之后，我们再根据<code>git status</code> 查看状态，可看出该文件已经添加到已追踪列表.</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_new_status.png" class=""><p>只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中</p><p> 当我们在修改1.js 文件。再<code>git status</code>：</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/edit_status.png" class=""><p>文件 1.js  出现在 “Changes not staged for commit”  这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 <code>git add</code> 命令。</p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>有一些文件我们不需要纳入git版本控制。但是我们也不希望它出现在未跟踪的文件列表中。我们可以创建一个名为：.gitignore的文件。里面列出需要忽略的文件的模式。</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/gitignore.png" class=""><p>文件<code>.gitignore</code>的格式如下：</p><ul><li>所有的以<code>#</code>符号开头，所有的空行都会被省略。</li><li>可以使用标准的 glob 模式匹配（指 shell 所使用的简化了的正则表达式）。</li><li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .js 结尾的文件</span><br><span class="line">*.js</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!shuliqi.js</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span><br><span class="line">doc<span class="comment">/**/</span>*.txt</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc<span class="comment">/*.txt</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p><code>git status</code> 显示比较简单，仅仅是列出了修改过的文件。如果要看文件具体修改了哪些地方，可以使用<code>git diff</code></p><p>如果我们修改了文件。再使用<code>git diff</code> 查看：</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_diff_1.png" class=""><p>比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p><p><strong>注意</strong></p><ul><li><p><code>git diff ：</code> 对比工作区(未 git add)和暂存区(git add 之后)</p></li><li><p><code>git diff —cached:</code> 对比暂存区(git add 之后)和版本库(git commit 之后)</p></li><li><p><code>git diff HEAD:</code> 对比工作区(未 git add)和版本库(git commit 之后)</p></li></ul><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>提交更新。</p><p>使用<code>git commit </code> 提交暂存区代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p>这种方式会启动文本编辑器以便输入本次提交的说明。</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_commit.png" class=""><p>还有一种提交的方式，不需要启动文本编辑器来提交本次的说明。</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_commit_m.png" class=""><p>提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添改和删改过。</p><p>虽然使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。</p><p>那么使用 <code>git commit -a -m&quot;跳过暂存区提交&quot;</code></p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_commit_a.png" class=""><p>提交之前不再需要 <code>git add</code> 文件了。</p><p>**<code>git commit --amend</code> ** 此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。</p><p>我们使用<code>git log  -1</code> 查看上一次commit的简要信息</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_commit_amend1.png" class=""><p>撤销上次的commit, 重新编辑提交说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>提交说明改成: “提交新东西(git commit —amend)”</p><p>再<code>git log</code> 查看当前的提交历史</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_commit_amend3.png" class=""><p>从图中看看出，我们的提交说明已经改变了。并且提交历史也没有我们第一次的commit(我们已经改变了)</p><p>如果上次的提交我们有些文件改动没有暂存，我们可以补上暂存操作，然后再<code>git commit --ammend</code>提交。</p><p>例如： 我们提交了一次commit</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_commit_amend3.png" class=""><p>当前的更新历史为：</p><p>补上一个暂存操作，再<code>git commit --ammend</code>，可更改上次的提交了.</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git-commit-amend6.png" class=""><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git-commit-amend7.png" class=""><p>总结：以下的操作只会产生一个commit</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;提交&#x27;</span></span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>移除文件。</p><p>如果想在git 删除某个文件，就必须得从已跟踪（暂存区）的文件清单中移除。然后再提交。使用<code>git rm</code> 移除文件。那么移除的文件就不会出现在未跟踪的清单中了。</p><p>如果手动删除了一个文件，再使用<code>git status</code>查看：</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_rm.png" class=""><p>显示在“Changes not staged for commit”。也就是文件还在跟踪中。</p><p>如果使用<code>git rm</code></p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_rm_2.png" class=""><p>那么最后提交的时候，该文件就不再纳入版本管理了。</p><p>如果我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。则可以使用git rm –cached 文件</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_rm_cached.png" class=""><h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>移除文件（更改文件名）。</p><p>git 无法跟踪文件的移除操作。如果我们改了一个文件名。 Git 并不会体现出这一操作。如果想给一个文件改名，则可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv old_name new_name</span><br></pre></td></tr></table></figure><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_mv.png" class=""><p><code>git mv </code>命令相当于以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ mv old.txt new.txt</span><br><span class="line">➜ git rm old.txt</span><br><span class="line">➜ git add new.txt</span><br></pre></td></tr></table></figure><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>查看提交历史。</p><p>使用<code>git log</code> 查看提交历史.</p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_log.png" class=""><p>如果默认没有参数， 会按提交的时间显示所有的更新。最近的更新排在最上面。每一次的提交都有SHA-1 校验，作者的名字和邮箱，提交的时间， 提交声明。</p><p><code>git log</code>     一些常用的选项:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p <span class="comment">// 展开显示每次提交的内容的差异</span></span><br></pre></td></tr></table></figure><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_log_p.png" class=""><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -&lt;n&gt; <span class="comment">// 加上n &gt; 0 的数字， 显示最近几次的提交</span></span><br></pre></td></tr></table></figure><p>例如：<code>git log -1</code></p><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_log_1.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p --word-diff. // 单词层面的比较</span><br></pre></td></tr></table></figure><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_log_word.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat //显示简要的增改行数统计</span><br></pre></td></tr></table></figure><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_log_stat.png" class=""><p><strong>整理的常用的选项：</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code></td><td>按补丁格式显示每个更新之间的差异。</td></tr><tr><td><code>--word-diff</code></td><td>按 word diff 格式显示差异。</td></tr><tr><td><code>--stat</code></td><td>显示每次更新的文件修改统计信息。</td></tr><tr><td><code>--shortstat</code></td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td><code>--name-only</code></td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td><code>--name-status</code></td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td><code>--abbrev-commit</code></td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td><code>--relative-date</code></td><td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td><code>--graph</code></td><td>显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td><code>--pretty</code></td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr><tr><td><code>--oneline</code></td><td><code>--pretty=oneline --abbrev-commit</code> 的简化用法。</td></tr></tbody></table><p>其他的：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-(n)</code></td><td>仅显示最近的 n 条提交</td></tr><tr><td><code>--since, --after</code></td><td>仅显示指定时间之后的提交。</td></tr><tr><td><code>--until, --before</code></td><td>仅显示指定时间之前的提交。</td></tr><tr><td><code>--author</code></td><td>仅显示指定作者相关的提交。</td></tr><tr><td><code>--committer</code></td><td>仅显示指定提交者相关的提交。</td></tr></tbody></table><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>取消已经暂存的文件。</p><p>假如我们不小心<code>git add</code> 了一个文件加到暂存区。但是我们想撤消该文件加到暂存区。则可以使用<code>git reset</code>进行撤销。</p><blockquote><p>命令不需要我们强制记住，<code>git add</code> 之后我们使用<code>git status</code> 可以看到git 提示我们如何撤消。</p></blockquote><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_reset.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt; // 如何在暂存区撤销一个文件</span><br></pre></td></tr></table></figure><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_reset1.png" class=""><p>即可撤消。</p><h2 id="git-checkout-–-file"><a href="#git-checkout-–-file" class="headerlink" title="git checkout – file"></a>git checkout – file</h2><p>取消对文件的修改。</p><p>如果我们觉得对一个文件的修改没有必要。想要取消修改。则可以使用<code>git checkout -- &lt;file&gt;</code></p><blockquote><p>命令不需要我们强制记住，<code>git add</code> 之后我们使用<code>git status</code> 可以看到git 提示我们如何取消对一个文件的修改。</p></blockquote><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_checkout-file.png" class=""><img src="/2019/09/17/git%E5%91%BD%E4%BB%A4/git_checkout_file1.png" class=""><p>撤消之后，再<code>git status</code>该文件则已经回到没有修改过的状态了。</p><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p>查看远程仓库。</p><p> <code>git remote</code>: 会显示每个远程仓库的简短的名字.如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ git <span class="comment">remoete</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p><code>git remote -v</code>: 显示远程仓库的名字和对应的clone 地址。如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ git <span class="comment">remote -v</span></span><br><span class="line">origingit@github.<span class="keyword">com</span>:shuliqi/rzfx.git (fetch)</span><br><span class="line">origingit@github.<span class="keyword">com</span>:shuliqi/rzfx.git (push)</span><br></pre></td></tr></table></figure><p><code>git remote add [name] [url]</code> 添加远程仓库。如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ git <span class="comment">remote add shuliqi git@github.com:shuliqi/rzfx.git</span></span><br><span class="line">➜ git:(master) git <span class="comment">remote -v</span></span><br><span class="line">origingit@github.<span class="keyword">com</span>:shuliqi/rzfx.git (fetch)</span><br><span class="line">origingit@github.<span class="keyword">com</span>:shuliqi/rzfx.git (push)</span><br><span class="line">shuliqigit@github.<span class="keyword">com</span>:shuliqi/rzfx.git (fetch)</span><br><span class="line">shuliqigit@github.<span class="keyword">com</span>:shuliqi/rzfx.git (push)</span><br></pre></td></tr></table></figure><p>可以通过 <code>git fetch shuliqi</code> 来抓取shuliqi仓库有的但是本地没有的信息。</p><p><code>git remote show [remote-name] </code>: 查看某个远程仓库的相信信息。</p><p>例如：查看克隆的origin的仓库的分支。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜ git <span class="comment">remote show origin</span></span><br><span class="line">* <span class="comment">remote origin</span></span><br><span class="line">  Fetch URL: git@github.<span class="keyword">com</span>:shuliqi/rzfx.git</span><br><span class="line">  Push  URL: git@github.<span class="keyword">com</span>:shuliqi/rzfx.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  <span class="comment">Remote branches:</span></span><br><span class="line">    master     tracked</span><br><span class="line">    shu        tracked</span><br><span class="line">    shu-branch tracked</span><br><span class="line">  Local branch configured <span class="keyword">for</span> <span class="comment">&#x27;git pull&#x27;:</span></span><br><span class="line">    master merges with <span class="comment">remote master</span></span><br><span class="line">  Local refs configured <span class="keyword">for</span> <span class="comment">&#x27;git push&#x27;:</span></span><br><span class="line">    master pushes <span class="keyword">to</span> master (fast-forwardable)</span><br><span class="line">    shu    pushes <span class="keyword">to</span> shu    (up <span class="keyword">to</span> date)</span><br></pre></td></tr></table></figure><p>给出了很多的信息：</p><ul><li><p>仓库的克隆地址</p></li><li><p>提醒你要是在master 可以使用<code>git pull</code>抓取数据。</p></li><li><p>列出了所有的处于跟踪的分支（master, shu, shu-branch ）</p></li></ul><p><code>git remote rename [old-remote-name] [new-remote-name] </code> 命令修改某个远程仓库在本地的简称。</p><p>例如：把本地仓库<code>origin</code>改成成<code>shu</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ git <span class="comment">remote</span></span><br><span class="line">origin</span><br><span class="line">shuliqi</span><br><span class="line">➜  git <span class="comment">remote rename shuliqi shu</span></span><br><span class="line">➜  git <span class="comment">remote</span></span><br><span class="line">origin</span><br><span class="line">shu</span><br></pre></td></tr></table></figure><p>git remote rm [remote-name]` 删除远端仓库。</p><p>例如：删除远程仓库<code>shu</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ git <span class="comment">remote</span></span><br><span class="line">origin</span><br><span class="line">shu</span><br><span class="line">➜  git <span class="comment">remote rm shu</span></span><br><span class="line">➜  git <span class="comment">remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p><code>git fetach &lt;remote-name&gt;</code>会到远程仓库中拉取所有你本地仓库中还没有的数据。</p><p>fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ git fetch origin</span><br></pre></td></tr></table></figure><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>将本地仓库中的数据推送到远程仓库 <code>git push [remote-name] [branch-name]</code> </p><p>例如： 我们新建一个分支<code>shu</code>。对代码做了一些改动。并且推送到远程跟踪的相应的分支。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  git checkout -b shu</span><br><span class="line">Switched <span class="keyword">to</span> a <span class="keyword">new</span> branch <span class="comment">&#x27;shu&#x27;</span></span><br><span class="line">➜  git commit -a -m<span class="string">&quot;将本地数据推送到远程&quot;</span></span><br><span class="line">[shu be180a1] 将本地数据推送到远程</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br><span class="line">➜  git push origin shu</span><br><span class="line">Counting objects: <span class="number">15</span>, done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up <span class="keyword">to</span> <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), <span class="number">1.41</span> KiB | <span class="number">1.41</span> MiB/s, done.</span><br><span class="line">Total <span class="number">15</span> (delta <span class="number">9</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line"><span class="comment">remote: Resolving deltas: 100% (9/9), completed with 4 local objects.</span></span><br><span class="line"><span class="comment">remote:</span></span><br><span class="line"><span class="comment">remote: Create a pull request for &#x27;shu&#x27; on GitHub by visiting:</span></span><br><span class="line"><span class="comment">remote:      https://github.com/shuliqi/rzfx/pull/new/shu</span></span><br><span class="line"><span class="comment">remote:</span></span><br><span class="line"><span class="comment">remote:</span></span><br><span class="line"><span class="comment">remote:</span></span><br><span class="line"><span class="comment">remote: GitHub found 2 vulnerabilities on shuliqi/rzfx&#x27;s default branch (1 high, 1 moderate). To find out more, visit:</span></span><br><span class="line"><span class="comment">remote:      https://github.com/shuliqi/rzfx/network/alerts</span></span><br><span class="line"><span class="comment">remote:</span></span><br><span class="line"><span class="keyword">To</span> github.<span class="keyword">com</span>:shuliqi/rzfx.git</span><br><span class="line"> * [<span class="keyword">new</span> branch]      shu -&gt; shu</span><br></pre></td></tr></table></figure><p>这条命令如期执行的条件：</p><ul><li>在该克隆的服务器上有读写权限。</li><li>在同一时刻，没有其他人提交更新</li></ul><p>如果在推送前，有人已经做了若干更新。 那么你的更新会被驳回。你只能把他们的更新抓到本地。 并且和冰岛自己的项目中。然后进行再次推送才会成功。</p><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><h4 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h4><p>使用<code>git tag</code>    列出所有的标签</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  git tag</span><br><span class="line">v0.<span class="number">0.1</span></span><br><span class="line">v0.<span class="number">0.2</span></span><br><span class="line">v0.<span class="number">0.3</span></span><br></pre></td></tr></table></figure><blockquote><p>Git 使用的标签有两种类型：</p><ul><li>轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</li><li>含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</li></ul></blockquote><h4 id="新建含附注标签"><a href="#新建含附注标签" class="headerlink" title="新建含附注标签"></a>新建含附注标签</h4><p>如命令：<code>git tag -a v0.0.1 -m&quot;新建一个标签，标记0.0.1版本&quot;</code> 可以新建一个含附注标签。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  git tag -a v0.<span class="number">0.1</span> -m<span class="string">&quot;新建一个标签，标记0.0.1版本&quot;</span></span><br><span class="line">➜  git tag</span><br><span class="line">v0.<span class="number">0.1</span></span><br></pre></td></tr></table></figure><p><code>-m</code> 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p><p><code>git show [tag-name]</code>：查看一个标签的的信息。    </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tag v0.<span class="number">0.1</span></span><br><span class="line">Tagger: shuliqi &lt;<span class="number">1169046371</span>@qq.<span class="keyword">com</span>&gt;</span><br><span class="line">Date:   Fri Sep <span class="number">27</span> <span class="number">19</span>:<span class="number">52</span>:<span class="number">56</span> <span class="number">2019</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">新建一个标签，标记<span class="number">0.0</span>.<span class="number">1</span>版本</span><br></pre></td></tr></table></figure><p>可看出：标签名字，标签说明等。</p><h4 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h4><p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 <code>-a</code>，<code>-s</code> 或 <code>-m</code> 选项都不用，直接给出标签名字即可。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  git tag v1.<span class="number">1.6</span></span><br><span class="line">➜  git show v1.<span class="number">1.6</span></span><br><span class="line">commit be180a1be40d9ce2ca8fe3a8c9bb2e9e7322275f (HEAD -&gt; shu, tag: v1.<span class="number">1.6</span>, tag: v0.<span class="number">0.3</span>, tag: v0.<span class="number">0.2</span>, tag: v0.<span class="number">0.1</span>, tag: show, origin/shu)</span><br><span class="line">Author: shuliqi &lt;<span class="number">1169046371</span>@qq.<span class="keyword">com</span>&gt;</span><br><span class="line">Date:   Fri Sep <span class="number">27</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">15</span> <span class="number">2019</span> +<span class="number">0800</span></span><br></pre></td></tr></table></figure><p>可看出轻量级标签就只有相应的提交对象摘要。</p><h4 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h4><p>可以使用<code>git push [remote-name] [tag-name]</code> 命令将某一个tag 推送到远端。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  git push origin v0.<span class="number">0.1</span></span><br><span class="line">Counting objects: <span class="number">1</span>, done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), <span class="number">200</span> bytes | <span class="number">200.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">1</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line"><span class="keyword">To</span> github.<span class="keyword">com</span>:shuliqi/rzfx.git</span><br><span class="line"> * [<span class="keyword">new</span> tag]         v0.<span class="number">0.1</span> -&gt; v0.<span class="number">0.1</span></span><br></pre></td></tr></table></figure><p>可以使用<code>git push origin --tags</code> 命令推送所有的tag 到远端。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  git push origin --tags</span><br><span class="line">Counting objects: <span class="number">2</span>, done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up <span class="keyword">to</span> <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), <span class="number">194</span> bytes | <span class="number">194.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">2</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line"><span class="comment">remote: Resolving deltas: 100% (1/1), done.</span></span><br><span class="line"><span class="keyword">To</span> github.<span class="keyword">com</span>:shuliqi/rzfx.git</span><br><span class="line"> * [<span class="keyword">new</span> tag]         show -&gt; show</span><br><span class="line"> * [<span class="keyword">new</span> tag]         v0.<span class="number">0.2</span> -&gt; v0.<span class="number">0.2</span></span><br><span class="line"> * [<span class="keyword">new</span> tag]         v0.<span class="number">0.3</span> -&gt; v0.<span class="number">0.3</span></span><br><span class="line"> * [<span class="keyword">new</span> tag]         v1.<span class="number">1.6</span> -&gt; v1.<span class="number">1.6</span></span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window.open被浏览器拦截的解决方案</title>
      <link href="/2019/09/04/window-open%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8B%A6%E6%88%AA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/09/04/window-open%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8B%A6%E6%88%AA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="存在的现象"><a href="#存在的现象" class="headerlink" title="存在的现象"></a>存在的现象</h3><p>最近在做一个需求，遇到了使用window.open()跳转到一个新的页面会被浏览器拦截的情况。虽然在开发环境。我们会手动放行。但是对于客户来说，不能要求用户都来通过拦截。而且在出现拦截的时候。很多小白客户根本不知道发生了啥，以为系统出来安全性问题。</p><p>此外，还发现：<strong>当window.open为用户触发事件内部或者加载时，不会被拦截，一旦将弹出代码移动到ajax或者一段异步代码内部，马上就出现被拦截的表现了</strong>。</p><span id="more"></span><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>当浏览器检测到非用户操作产生的新弹出窗口，则会对其进行阻止。因为浏览器认为这不是一个用户希望看到的页面。</p><p><strong>例1：</strong>直接打开一个页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">&#x27;https://app.mokahr.com&#x27;</span>, <span class="string">&#x27;_blank&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在各个浏览器的表现：</p><table><thead><tr><th>浏览器</th><th>ie8</th><th><strong>chrome 40</strong></th><th><strong>firefox 34</strong></th><th><strong>opera 27</strong></th><th><strong>safari 5.1.7</strong></th></tr></thead><tbody><tr><td><strong>是否拦截</strong></td><td><strong>NO</strong></td><td><strong>NO</strong></td><td><strong>YES</strong></td><td><strong>YES</strong></td><td><strong>YES</strong></td></tr></tbody></table><p><strong>例2：</strong>ajax中的使用window.open</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;Webservices/WS_BBS_Login.asmx/GetUserInfo&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;&#123;&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">    <span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.open(result.url, <span class="string">&#x27;_blank&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>也会出现浏览器拦截的情况。</p><p><strong>例3：</strong>但是对于这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">window</span>.open(<span class="string">&#x27;https://app.mokahr.com&#x27;</span>, <span class="string">&#x27;_blank&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所有的浏览器都不会被拦截</p><p><strong>结论：各浏览器对拦截时机的判断不一致，而对于放在ajax回调中的代码，也会被拦截。但是，被浏览器拦截我们代码中要弹出的窗口并不是程序员所希望的。</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li><p><strong>用a标签代替，这样用户点击这个超链接，浏览器会认为它是打开一个新的链接，所以就不会拦截</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;url&quot; target=&quot;_blank&quot; /&gt;</span><br></pre></td></tr></table></figure><p>也可以自己创建一个<code>a</code>标签。</p><p>给出如下函数，将此函数绑定到click的事件回调中，就可以避免大部分浏览器对窗口弹出的拦截。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function newWin(url, id) &#123;</span><br><span class="line">  var a = document.createElement(&#x27;a&#x27;);</span><br><span class="line">  a.setAttribute(&#x27;href&#x27;, url);</span><br><span class="line">  a.setAttribute(&#x27;target&#x27;, &#x27;_blank&#x27;);</span><br><span class="line">  a.setAttribute(&#x27;id&#x27;, id);</span><br><span class="line">  // 防止反复添加</span><br><span class="line">  if(!document.getElementById(id)) document.body.appendChild(a);</span><br><span class="line">  a.click();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用form的submit方法打开一个页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">     &lt;form id=&quot;shu&quot; action=&quot;form_action.asp&quot; method=&quot;get&quot;&gt;&lt;/form&gt; </span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      $(&quot;#shu&quot;).attr(&#x27;target&#x27;, &#x27;_blank&#x27;);</span><br><span class="line">      $(&quot;#shu&quot;).submit();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>通过定时器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var newOpenWindow=window.open();</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">　　newOpenWindow.location=locationurl;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure></li><li><p>终极解决方案–先弹出窗口，然后重定向</p><p><strong>注意：大家注意，以上方法不适合放在ajax的回调函数中，如果放在回调函数中，依然会被浏览器拦截。</strong></p><p>这种方法的核心思想就是：先通过用户点击打开页面，然后再对页面进行重定向。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xx.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 打开页面，此处最好使用提示页面</span></span><br><span class="line">    <span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">&#x27;loading page&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    ajax().done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 重定向到目标页面</span></span><br><span class="line">        newWin.location.href = <span class="string">&#x27;target url&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li></ol><p>此篇文章是参考： <a href="http://zakwu.me/2015/03/03/dan-chu-chuang-kou-bei-liu-lan-qi-lan-jie-de-jie-jue-fang-an/">window.open被浏览器拦截的解决方案</a>， <a href="https://www.cnblogs.com/hss-blog/p/10194830.html">ajax回调中window.open弹出的窗口会被浏览器拦截的解决方法</a>，</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http协议详解</title>
      <link href="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在讲<code>http</code>协议之前， 需要先了解一下基础的计算机网络相关知识。</p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p>计算机网络体系结构是<strong>计算机网络的各层</strong> 和 <strong>其协议</strong>的集合。</p><p>在计算机网络的基本概念中，分层次的体系结构是最基本的。</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>相互通信的两个计算机系统必须高度协调工作才行，而这种<code>协调</code>是相当复杂的。为了设计出这样复杂的计算机网络，最初提出了分层的方法。<strong>分层</strong>可将庞大的而复杂的问题转化为若干较小的局部问题，而这些较小的局部问题比较容易研究和处理。</p><p>计算机网络体系结构有三种体系结构：</p><ul><li><code>OSI体系结构</code>: 概念清楚，理念完整。但是复杂不实用</li><li><code>TCP/IP体系结构</code>：含了一系列构成互联网基础的协议，是<code>Internet</code>的核心协议。被广泛的使用。</li><li><code>五层体系结构</code>：融合了<code>OSL</code> 与<code>TCP/IP</code>的体系结构， 主要的目的是为了学习，讲解计算机原理。</li></ul><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/1.png" class=""><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>在计算机网络中药做到有条不絮的交换数据，就必须遵守一些事先约定好的规则，这些规则明确了所交换的数据的格式以及有关的同步问题。为网络中的数据交换而建立的规则，标准或者约定称为<strong>网络协议</strong>，也可以简称为<strong>协议</strong></p><p><strong>分层</strong>和<strong>协议</strong>就构成了计算机体系结构。</p><h2 id="TCP-IP体系结构"><a href="#TCP-IP体系结构" class="headerlink" title="TCP/IP体系结构"></a>TCP/IP体系结构</h2><p>由于<strong>TCP/IP体系结构</strong>运用广泛，所以我们详细讲解下：</p><table><thead><tr><th>层级</th><th>作用</th><th>具体的协议</th></tr></thead><tbody><tr><td>应用层</td><td>应用层是体系结构中的最高层。<strong>应用层直接为用户的应用进程提供服务</strong>。这里的<strong>进程就是指正在运行的程序</strong>。</td><td>1. http 协议：提供 internet网络浏览服务；<br />2.DNS 协议：负责域名和IP地址的映射<br />3.SMIP协议：提供简单的电子邮件发送服务<br />4.POP 协议：提供对邮箱服务器远程存取邮件的服务。与此功能类似的还有 IMAP 协议<br />5.FIP协议：提供应用级文件传输服务<br />6. SMB协议：提供应用级文件共享服务<br />7.Telnet协议：提供远程登录服务（明文传输）<br />8.SSH协议：提供远程登录服务（加密）</td></tr><tr><td>传输层</td><td>负责向两个主机中进程之间的通信提供服务</td><td>1. TCP协议：提供用户间面向链接，可靠的报文传输服务；<br />2.UDP协议：提供用户间无连接，不可靠的报文传输服务；</td></tr><tr><td>网络层</td><td>负责为分组交换网上的不同主机提供通信服务</td><td>1. IP协议：提供网络结点之前得报文传送服务。<br />2.ARP协议：实现IP呆滞想物理地址的映射<br />3.RARP协议：实现物理地址想IP地址的映射；<br />4.ICMP协议：探测报告传输中产生的错误；<br />5.IGMP协议：管理多波组测成员问题</td></tr><tr><td>网络接口层</td><td>负责与链路（传输媒介）的数据传输工作。</td><td></td></tr></tbody></table><p>关于每一层的工作职责还不是哼清楚的可以看这篇文章： <a href="https://blog.csdn.net/TommyZht/article/details/45966689">网络各层功能职责——计算机网络</a></p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>从上面的内容可以看出<code>http协议</code>是在应用层的。我们先来了解HTTP的基本概念。</p><h2 id="HTTP的基本概念"><a href="#HTTP的基本概念" class="headerlink" title="HTTP的基本概念"></a>HTTP的基本概念</h2><p>HTPP 是超文本传输协议（<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol）。它的名字可以拆解为3个部分：</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/2.png" class=""><h3 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h3><p><strong>文本</strong>：早起的<strong>文本</strong> 指的是普调的文本字符，但是现在的文本的含义已经扩展为图片，水平，压缩包等。在HTTP眼里都是文本。</p><p><strong>超文本</strong>：超越了普调文本的文本，它是图片，文字，视频等的混合体，具有超链接，能从一个超文本跳到另外一个超文本。</p><p>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了</p><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p> 即将数据由A传输到B或者由B传输到A。并且A 与 B 之间可以存放很多第三方；如：A&lt;=&gt;X&lt;=&gt;Y&lt;=&gt;Z&lt;=&gt;B</p><h3 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h3><p> 在计算机网络中有很多的协议，<code>HTTP</code> 也是一个协议</p><p>那么总结来说：<strong>HTTP 是一个在计算机世界里专门在两点之前传输文字，图片， 视频，音频等超文本的数据约定和规定</strong></p><h2 id="HTTP协议的原理"><a href="#HTTP协议的原理" class="headerlink" title="HTTP协议的原理"></a>HTTP协议的原理</h2><p>HTTP协议采用 <strong>请求/响应</strong>的工作方式：</p><ol><li><code>HTTP</code>协议工作于客户端-服务端架构上。浏览器最为<code>HTTP</code>客户端通过<code>url</code>向<code>HTTP</code>服务端（web服务器）发送所有的请求</li><li><code>web</code>服务器：<code>Apache</code>服务器，IIS服务器（Internet Information Services）等。</li><li><code>web</code>服务器根据接收到的请求后， 向客户端发送响应信息。</li><li><code>HTTP</code>服务器默认监听的端口号为80，但是也可以设置为其他端口。</li></ol><h2 id="一次请求流程"><a href="#一次请求流程" class="headerlink" title="一次请求流程"></a>一次请求流程</h2><p>简单的来分析，从输入 <code>URL</code>到回车后发生的行为如下：</p><ul><li>URL解析</li><li>DNS查询</li><li>TCP连接</li><li>HTTP请求</li><li>响应请求</li><li>页面渲染</li><li>TCP关闭</li></ul><h3 id="URL-解析"><a href="#URL-解析" class="headerlink" title="URL 解析"></a>URL 解析</h3><p>首先判断你输入的是不是一个合法的<code>url</code>，并且对你输入的内容进行解析，一个<code>url</code>解析如下：</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/3.png" class=""><h3 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h3><p>浏览器通过<code>URL</code>解析之后的域名，通过DNS解析出目标网页的IP地址。具体的查询如下：</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/4.png" class=""><p>最终得到域名对应的目标服务器的<code>IP</code>地址</p><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>在<code>HTTP</code>开始工作之前，客户端和服务端首先会建立连接（TCP三次握手）</p><h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>当建立<code>TCP</code> 连接连接之后，就可以在这基础上进行通信。浏览器发送<code>HTTP</code>请求到服务器。请求的内容包括：请求行，请求头，请求体。这些知识点我们下面会讲到。</p><h3 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h3><p>当服务器接收到请求之后，会进行逻辑操作，，处理完之后会返回一个<code>HTTP</code>响应消息，内容包括：响应行， 响应头，响应正文。下面我们会讲到。</p><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p>关于页面的渲染可以看这篇文章： <a href="https://shuliqi.github.io/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/">浏览器的渲染流程</a></p><h3 id="TCP关闭"><a href="#TCP关闭" class="headerlink" title="TCP关闭"></a>TCP关闭</h3><p>一旦web服务器想浏览器发送了响应数据。它就要关闭TCP连接。但是如果浏览器或者服务器在其头部加入了这行代码<code>Connection： keep-alive</code>那么TCP连接在发送响应数据之后仍然保持打开状态。</p><h2 id="HTTP报文详解"><a href="#HTTP报文详解" class="headerlink" title="HTTP报文详解"></a>HTTP报文详解</h2><p><code>HTTP</code>在应用层 交互的数据方式 ， 我们叫报文。</p><p><code>HTTP</code>的报文分为：请求报文， 响应报文</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/10.png" class=""><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>请求报文的结构如下：</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/5.png" class=""><p>一个实际的请求报文如下：</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/7.png" class=""><p>请求报文主要由三个部分组成：请求行， 请求头， 请求体；</p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>声明 请求方法，逐级域名，资源路径&amp;协议版</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/6.png" class=""><blockquote><p>注意： 空格是不能省略的</p></blockquote><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>请求方法是定义对请求对象的操作的。请求方法及其解释如下：</p><ol><li><p>GET： 向服务器请求指定URL的资源，请求参数是直接带在链接上，所以没有主体; </p><p>使用场景：如向数据库查询单个或list数据。</p><p>总结来说：告诉服务器我要的东西</p></li><li><p>POST：用于向服务器提交数据。</p><p>使用场景：我新增加一个数据等。</p><p>总结来说：告诉服务器我要给的东西</p></li><li><p>PUT：向服务器请求修改某个已存在的资源。</p><p>使用场景： 我要修改用户名等</p><p>总结的来说：告诉服务器我要更新。</p></li><li><p>HEDA：HEAD 和 GET 是差不多的， 只是HEAD 请求的响应报文不返回响应体，只返回响应头。</p><p>使用场景 ：某个文件是否存在，检查文件是否更新</p></li><li><p>DELETE： 向服务器请求删除某个已存在的文件</p><p>使用场景: 删除 id 为 23 的的数据</p></li><li><p>OPTIONS：返回指定URL资源所能够支持的HTTP请求方式。</p><p>使用场景：获取服务器支持的 http请求的方式，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS#cors_%E4%B8%AD%E7%9A%84%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82">CORS 中的预检请求</a></p><blockquote><p>在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a> 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method"><code>Access-Control-Request-Method</code></a> 首部字段告知服务器实际请求所使用的 HTTP 方法；<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers"><code>Access-Control-Request-Headers</code></a> 首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。</p></blockquote></li><li><p>CONNECT：用于代理用服务器, 具体看这篇文章：<a href="https://www.jianshu.com/p/54357cdd4736">HTTP之connect method</a></p></li><li><p>TRACH: 回显服务器收到的请求</p></li></ol><h5 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h5><p>请求路径就是<code>URL</code>中请求地址的部分. 如：url = <a href="http://www.baidu.com/%EF%BC%9B%E5%88%99%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E4%B8%BA%EF%BC%9A/%EF%BC%9B">http://www.baidu.com/；则请求路径为：/；</a> url = <a href="http://www.baidu.com/20/home%EF%BC%8C%E5%88%99%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E4%B8%BA%EF%BC%9A/20/home%E3%80%82">http://www.baidu.com/20/home，则请求路径为：/20/home。</a></p><blockquote><p>URL: 是统一资源定位符，它的作用就是表示资源的位置，访问资源的方式。它是由：<code>&lt;协议&gt;：// &lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></p></blockquote><h5 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h5><p>定义 HTTP 的版本号。 常用的版本号为：HTTP/1.0， HTTP/1.1，HTTP/2.0,</p><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>声明 客户端，报文的部分信息。所有的请求头如下：</p><table><thead><tr><th align="left">Header</th><th align="left">解释</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">Accept</td><td align="left">指定客户端能够接收的内容类型</td><td align="left">Accept: text/plain, text/html</td></tr><tr><td align="left">Accept-Charset</td><td align="left">浏览器可以接受的字符编码集。</td><td align="left">Accept-Charset: iso-8859-5</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">指定浏览器可以支持的web服务器返回内容压缩编码类型。</td><td align="left">Accept-Encoding: compress, gzip</td></tr><tr><td align="left">Accept-Language</td><td align="left">浏览器可接受的语言</td><td align="left">Accept-Language: en,zh</td></tr><tr><td align="left">Accept-Ranges</td><td align="left">可以请求网页实体的一个或者多个子范围字段</td><td align="left">Accept-Ranges: bytes</td></tr><tr><td align="left">Authorization</td><td align="left">HTTP授权的授权证书</td><td align="left">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td align="left">Cache-Control</td><td align="left">指定请求和响应遵循的缓存机制</td><td align="left">Cache-Control: no-cache</td></tr><tr><td align="left">Connection</td><td align="left">表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td><td align="left">Connection: close</td></tr><tr><td align="left">Cookie</td><td align="left">HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td><td align="left">Cookie: $Version=1; Skin=new;</td></tr><tr><td align="left">Content-Length</td><td align="left">请求的内容长度</td><td align="left">Content-Length: 348</td></tr><tr><td align="left">Content-Type</td><td align="left">请求的与实体对应的MIME信息</td><td align="left">Content-Type: application/x-www-form-urlencoded</td></tr><tr><td align="left">Date</td><td align="left">请求发送的日期和时间</td><td align="left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td align="left">Expect</td><td align="left">请求的特定的服务器行为</td><td align="left">Expect: 100-continue</td></tr><tr><td align="left">From</td><td align="left">发出请求的用户的Email</td><td align="left">From: <a href="mailto:&#117;&#x73;&#101;&#114;&#64;&#101;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;">&#117;&#x73;&#101;&#114;&#64;&#101;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;</a></td></tr><tr><td align="left">Host</td><td align="left">指定请求的服务器的域名和端口号</td><td align="left">Host: <a href="http://www.zcmhi.com/">www.zcmhi.com</a></td></tr><tr><td align="left">If-Match</td><td align="left">只有请求内容与实体相匹配才有效</td><td align="left">If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td align="left">If-Modified-Since</td><td align="left">如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td><td align="left">If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td align="left">If-None-Match</td><td align="left">如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td><td align="left">If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td align="left">If-Range</td><td align="left">如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td><td align="left">If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td align="left">If-Unmodified-Since</td><td align="left">只在实体在指定时间之后未被修改才请求成功</td><td align="left">If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td align="left">Max-Forwards</td><td align="left">限制信息通过代理和网关传送的时间</td><td align="left">Max-Forwards: 10</td></tr><tr><td align="left">Pragma</td><td align="left">用来包含实现特定的指令</td><td align="left">Pragma: no-cache</td></tr><tr><td align="left">Proxy-Authorization</td><td align="left">连接到代理的授权证书</td><td align="left">Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td align="left">Range</td><td align="left">只请求实体的一部分，指定范围</td><td align="left">Range: bytes=500-999</td></tr><tr><td align="left">Referer</td><td align="left">先前网页的地址，当前请求网页紧随其后,即来路</td><td align="left">Referer: <a href="http://www.zcmhi.com/archives/71.html">http://www.zcmhi.com/archives/71.html</a></td></tr><tr><td align="left">TE</td><td align="left">客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td><td align="left">TE: trailers,deflate;q=0.5</td></tr><tr><td align="left">Upgrade</td><td align="left">向服务器指定某种传输协议以便服务器进行转换（如果支持）</td><td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td align="left">User-Agent</td><td align="left">User-Agent的内容包含发出请求的用户信息</td><td align="left">User-Agent: Mozilla/5.0 (Linux; X11)</td></tr><tr><td align="left">Via</td><td align="left">通知中间网关或代理服务器地址，通信协议</td><td align="left">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td></tr><tr><td align="left">Warning</td><td align="left">关于消息实体的警告信息</td><td align="left">Warn: 199 Miscellaneous warning</td></tr></tbody></table><h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p>存放需要发送的信息</p><blockquote><p>可选部分，如 <code>GET请求</code>就无请求数据</p></blockquote><p>它主要有三种使用方式：</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/8.png" class=""><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>响应包问的结构如下：</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/9.png" class=""><p>一个实际的响应报文如下：</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/11.png" class=""><p>HTTP 响应报文包括：状态行，响应头，响应体。</p><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>状态行主要的作用： 声明协议版本，状态码， 状态码描述</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/12.png" class=""><blockquote><p>注意： 空格不能省略</p></blockquote><h5 id="协议版本-1"><a href="#协议版本-1" class="headerlink" title="协议版本"></a>协议版本</h5><p>定义 HTTP 的版本号。 常用的版本号为：HTTP/1.0， HTTP/1.1，HTTP/2.0,</p><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p>表示服务器返回的响应状态代码，分为五大类：</p><ul><li><p>1xx: 表示信息通知；如请求收到了， 但是还没处理</p></li><li><p>2xx: 表示成功。如接受或知道了</p></li><li><p>3xx: 表示重定向。如果要完成请求还需进一步行动</p></li><li><p>4xx: 表示客户端错误，请求包含语法错误导致无法实现</p></li><li><p>5xx: 表示服务器错误，服务器不能实现一种明显无效的请求。</p></li><li><p>常用的状态码如下：</p></li></ul><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td><code>请求成功</code>。一般用于GET与POST请求</td></tr><tr><td>204</td><td>No Content</td><td>无内容。<code>服务器成功处理，但未返回内容</code>。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>206</td><td>Partial Content</td><td><code>是对资源某一部分的请求</code>，服务器成功处理了部分GET请求，响应报文中包含由Content-Range指定范围的实体内容。</td></tr><tr><td></td><td></td><td></td></tr><tr><td>301</td><td>Moved Permanently</td><td><code>永久性重定向</code>。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td><code>临时性重定向</code>。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td><code>查看其它地址</code>。与302类似。使用GET请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>307</td><td>Temporary Redirect</td><td><code>临时重定向</code>。与302类似。使用GET请求重定向，会按照浏览器标准，不会从POST变成GET。</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td><code>客户端请求报文中存在语法错误，服务器无法理解</code>。浏览器会像200 OK一样对待该状态吗</td></tr><tr><td>401</td><td>Unauthorized</td><td><code>请求要求用户的身份认证</code>，通过HTTP认证（BASIC认证，DIGEST认证）的认证信息，若之前已进行过一次请求，则表示用户认证失败</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td><code>服务器理解请求客户端的请求，但是拒绝执行此请求</code></td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面。也可以在服务器拒绝请求且不想说明理由时使用</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td><code>服务器内部错误，无法完成请求</code>，也可能是web应用存在bug或某些临时故障</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>503</td><td>Service Unavailable</td><td><code>由于超载或系统维护，服务器暂时的无法处理客户端的请求</code>。延时的长度可包含在服务器的Retry-After头信息中</td></tr></tbody></table><ul><li>不常用的HTTP状态码列表</li></ul><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h5 id="状态码描述"><a href="#状态码描述" class="headerlink" title="状态码描述"></a>状态码描述</h5><p>当前状态码的解释消息</p><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>响应头的作用：声明服务端的报文的信息</p><p>常用的<code>HTTP响应头</code>：</p><table><thead><tr><th align="left">响应头</th><th align="left">说明</th><th align="left">示例</th><th align="left">状态</th></tr></thead><tbody><tr><td align="left">Access-Control-Allow-Origin</td><td align="left">指定哪些网站可以<code>跨域源资源共享</code></td><td align="left"><code>Access-Control-Allow-Origin: *</code></td><td align="left">临时</td></tr><tr><td align="left">Accept-Patch</td><td align="left">指定服务器所支持的文档补丁格式</td><td align="left">Accept-Patch: text/example;charset=utf-8</td><td align="left">固定</td></tr><tr><td align="left">Accept-Ranges</td><td align="left">服务器所支持的内容范围</td><td align="left"><code>Accept-Ranges: bytes</code></td><td align="left">固定</td></tr><tr><td align="left">Age</td><td align="left">响应对象在代理缓存中存在的时间，以秒为单位</td><td align="left"><code>Age: 12</code></td><td align="left">固定</td></tr><tr><td align="left">Allow</td><td align="left">对于特定资源的有效动作;</td><td align="left"><code>Allow: GET, HEAD</code></td><td align="left">固定</td></tr><tr><td align="left">Cache-Control</td><td align="left">通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td><td align="left"><code>Cache-Control: max-age=3600</code></td><td align="left">固定</td></tr><tr><td align="left">Connection</td><td align="left">针对该连接所预期的选项</td><td align="left"><code>Connection: close</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Disposition</td><td align="left">对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。</td><td align="left">Content-Disposition: attachment; filename=”fname.ext”</td><td align="left">固定</td></tr><tr><td align="left">Content-Encoding</td><td align="left">响应资源所使用的编码类型。</td><td align="left"><code>Content-Encoding: gzip</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Language</td><td align="left">响就内容所使用的语言</td><td align="left"><code>Content-Language: zh-cn</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Length</td><td align="left">响应消息体的长度，用8进制字节表示</td><td align="left"><code>Content-Length: 348</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Location</td><td align="left">所返回的数据的一个候选位置</td><td align="left"><code>Content-Location: /index.htm</code></td><td align="left">固定</td></tr><tr><td align="left">Content-MD5</td><td align="left">响应内容的二进制 MD5 散列值，以 Base64 方式编码</td><td align="left">Content-MD5: IDK0iSsgSW50ZWd0DiJUi==</td><td align="left">已淘汰</td></tr><tr><td align="left">Content-Range</td><td align="left">如果是响应部分消息，表示属于完整消息的哪个部分</td><td align="left">Content-Range: bytes 21010-47021/47022</td><td align="left">固定</td></tr><tr><td align="left">Content-Type</td><td align="left">当前内容的<code>MIME</code>类型</td><td align="left">Content-Type: text/html; charset=utf-8</td><td align="left">固定</td></tr><tr><td align="left">Date</td><td align="left">此条消息被发送时的日期和时间(以<a href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来表示)</td><td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td><td align="left">固定</td></tr><tr><td align="left">ETag</td><td align="left">对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列</td><td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td><td align="left">固定</td></tr><tr><td align="left">Expires</td><td align="left">指定一个日期/时间，超过该时间则认为此回应已经过期</td><td align="left">Expires: Thu, 01 Dec 1994 16:00:00 GMT</td><td align="left">固定: 标准</td></tr><tr><td align="left">Last-Modified</td><td align="left">所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td><td align="left">Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">Link</td><td align="left">用来表示与另一个资源之间的类型关系，此类型关系是在<a href="https://tools.ietf.org/html/rfc5988">RFC 5988</a>中定义</td><td align="left"><code>Link: </code>; rel=”alternate”</td><td align="left">固定</td></tr><tr><td align="left">Location</td><td align="left">用于在进行重定向，或在创建了某个新资源时使用。</td><td align="left">Location: <a href="http://www.itbilu.com/nodejs">http://www.itbilu.com/nodejs</a></td><td align="left">固定</td></tr><tr><td align="left">P3P</td><td align="left">P3P策略相关设置</td><td align="left">P3P: CP=”This is not a P3P policy!</td><td align="left">固定</td></tr><tr><td align="left">Pragma</td><td align="left">与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果</td><td align="left"><code>Pragma: no-cache</code></td><td align="left">固定</td></tr><tr><td align="left">Proxy-Authenticate</td><td align="left">要求在访问代理时提供身份认证信息。</td><td align="left"><code>Proxy-Authenticate: Basic</code></td><td align="left">固定</td></tr><tr><td align="left">Public-Key-Pins</td><td align="left">用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值</td><td align="left">Public-Key-Pins: max-age=2592000; pin-sha256=”……”;</td><td align="left">固定</td></tr><tr><td align="left">Refresh</td><td align="left">用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</td><td align="left">Refresh: 5; url=<a href="http://itbilu.com/">http://itbilu.com</a></td><td align="left"></td></tr><tr><td align="left">Retry-After</td><td align="left">如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。</td><td align="left">示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">Server</td><td align="left">服务器的名称</td><td align="left"><code>Server: nginx/1.6.3</code></td><td align="left">固定</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置<code>HTTP cookie</code></td><td align="left">Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1</td><td align="left">固定: 标准</td></tr><tr><td align="left">Status</td><td align="left">通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。</td><td align="left"><code>Status: 200 OK</code></td><td align="left"></td></tr><tr><td align="left">Trailer</td><td align="left"><code>Trailer</code>用户说明传输中分块编码的编码信息</td><td align="left"><code>Trailer: Max-Forwards</code></td><td align="left">固定</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">用表示实体传输给用户的编码形式。包括：<code>chunked</code>、<code>compress</code>、 <code>deflate</code>、<code>gzip</code>、<code>identity</code>。</td><td align="left">Transfer-Encoding: chunked</td><td align="left">固定</td></tr><tr><td align="left">Upgrade</td><td align="left">要求客户端升级到另一个高版本协议。</td><td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td><td align="left">固定</td></tr><tr><td align="left">Vary</td><td align="left">告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。</td><td align="left"><code>Vary: *</code></td><td align="left">固定</td></tr><tr><td align="left">Via</td><td align="left">告知代理服务器的客户端，当前响应是通过什么途径发送的。</td><td align="left">Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)</td><td align="left">固定</td></tr><tr><td align="left">Warning</td><td align="left">一般性警告，告知在实体内容体中可能存在错误。</td><td align="left">Warning: 199 Miscellaneous warning</td><td align="left">固定</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">表示在请求获取这个实体时应当使用的认证模式。</td><td align="left"><code>WWW-Authenticate: Basic</code></td><td align="left">固定</td></tr></tbody></table><h4 id="响应体："><a href="#响应体：" class="headerlink" title="响应体："></a>响应体：</h4><p>存放需返回给客户端的数据信息。 跟请求体一样同样分为：任意类型的数据交换格式、键值对形式和分部分形式</p><img src="/2019/09/02/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/13.png" class=""><h2 id="HTTP-协议的特点"><a href="#HTTP-协议的特点" class="headerlink" title="HTTP 协议的特点"></a>HTTP 协议的特点</h2><h3 id="支持客户端-服务端模式"><a href="#支持客户端-服务端模式" class="headerlink" title="支持客户端/服务端模式"></a>支持客户端/服务端模式</h3><p>先去请求的就属于客户端，响应相求的就属于服务端。也就是说：客户端用于请求资源，服务端用于提供资源。</p><h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p>​      HTTP 是无连接的，无连接的含义就是限次每一连接只能处理一个请求， 当服务器响应完客户的请求，并且得到客户端的应答之后，就断开连接。采用这种方式可以节省传输时间。</p><p>​     早期这么做的原因是 <code>http</code>协议产生与互联网，因此服务器要同时处理成千上万的客户端网页的访问。但是每个客户端与服务器之前得交换数据的间歇比较大。所以导致大部门的通道是空闲的，五段占用了资源。所以HTTP的设计者就利用这种特点将HTTP设计为<strong>请求时建立连接，请求万释放连接。已尽快将资源释放出来服务其他客户端</strong>。</p><p>​    随着时间的推移，网页变得复杂，如里面可能嵌入了很多的图片，这时候没访问一次图片都需要建立一个<code>TCP</code>连接。就显得很抵消。因此就出现了请求头 <code>Connection： keep-alive</code>。 用来解决这效率低的问题。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>协议对于事物处理没有记忆能力，服务端不知道客户端是什么状态。也就是说我们可以服务器发送<code>HTTP</code>请求之后，服务端会根据请求给我们发送数据过来，但是发送完，不会记录任何的信息。</p><p> <code>HTTP</code>是一个无状态的协议，就意味着每个请求都是独立的， <code>keep-alive </code>也无法改变这个结果。</p><p>协议没有状态带来的后果如：访问系统需要登录后才能访问，由于无状态的特点，每次跳转链接都需要重新登录。这就导致每次请求要发送大量的数据信息给服务器。 </p><p> 由于它的这个特点导致很多的问题， 那么用于保持<code>HTTP 有连接状态的技术就有两种：</code>Cookie<code>, </code>Session`；</p><p>   <code>Cookie：</code>是通过在请求头和响应头中写入 <code>    Cookie</code>来控制客户端的状态的。首次访问服务端的时候，响应头会返回<code>Set-Cookie</code>的首部字段信息，通知客户保存<code>Cookie</code>。当客户下次再向服务端发送请求的时候，客户端会自动在请求头中加入<code>Cookie</code>值发送给服务端。服务端发现客户端发送过来的<code>Cookie</code>后，会去检查究竟是哪个客户端发送过来的请求，然后对比服务器上的记录，最后得到之前得状态信息。</p><p>   <code>Session：</code>是通过服务器来保持状态的。当客户端访问服务器时候，服务器设置<code>Session</code>, 将会话信息保存在服务器上，同时将<code>Session</code>的<code>ID</code>传递给客户端浏览器，浏览器会将这个<code>🆔</code>保存在内存中。之后浏览器每次请求都会带上这个参数值，服务器根据<code>Session</code>的<code>ID</code>，就能取掉客户端的信息。</p><h3 id="简单快速"><a href="#简单快速" class="headerlink" title="简单快速"></a>简单快速</h3><p>客户向服务器请求服务时，只需传送请求方法和路径。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><h3 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h3><p><code>HTTP</code>允许传输任何类型的数据对象。 传输的数据类型由请求头的的<code>Content-type</code>来标记。   </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的css技巧</title>
      <link href="/2019/08/27/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84css%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/08/27/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84css%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="1-用-Of-Type-选择元素"><a href="#1-用-Of-Type-选择元素" class="headerlink" title="1.用 :*-Of-Type 选择元素"></a><strong>1.用 :*-Of-Type 选择元素</strong></h4><blockquote><p>不兼容IE8</p></blockquote><p>假如我们有这样的htm结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>11111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>22222<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>33333<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>44444<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>55555<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure> <span id="more"></span><p>给第一个 p 段落文本变红：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给最后一个 p 加边框:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让偶数列的 p 段落背景设置黑色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(even) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外， 还可以设置其他类型的参数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* only 第三个 */</span></span><br><span class="line"><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每第三个 */</span></span><br><span class="line"><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>n) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每第四加三个，即 3, 7, 11, ... */</span></span><br><span class="line"><span class="selector-pseudo">:nth-of-type</span>(<span class="number">4</span>n+<span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 给第一个 p 段落文本变红： */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-of-type &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 给最后一个 p 加边框 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">border</span>: <span class="number">1px</span> solid green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 让偶数列的 p 段落背景设置黑色： */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(even) &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* only 第三个 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>) &#123;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 每第三个 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>n) &#123;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 每第四加三个，即 3, 7, 11, ... */</span></span></span><br><span class="line"><span class="css">    <span class="selector-pseudo">:nth-of-type</span>(<span class="number">4</span>n+<span class="number">3</span>) &#123;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>11111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>22222<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>33333<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>44444<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>55555<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-用-unset-做-CSS-Reset"><a href="#2-用-unset-做-CSS-Reset" class="headerlink" title="2.用 unset 做 CSS Reset"></a><strong>2.用 unset 做 CSS Reset</strong></h4><blockquote><p>不兼容IE8</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">button</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 取消 item 中 button 的 color 设置 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> <span class="selector-tag">button</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: unset;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮111<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮222<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-使用-empty-区分空元素"><a href="#3-使用-empty-区分空元素" class="headerlink" title="3.使用 :empty 区分空元素"></a>3.使用 :empty 区分空元素</h4><blockquote><p>不兼容IE8</p></blockquote><p>假如我们有以下的HTML结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们希望对空元素和非空元素区别处理。那么有这两种方案。</p><p>使用 <strong>:empty</strong> 选择空元素:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:empty</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用**:not(:empty)** 选择非空元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:empty</span>) &#123;</span><br><span class="line">   <span class="attribute">color</span>: red</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>完成的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>: <span class="number">#ccc</span></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 使用 :empty 选择空元素: */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span><span class="selector-pseudo">:empty</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/*使用:not(:empty) 选择非空元素 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:empty</span>) &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: red</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-每个单词的首字母大写-text-transform"><a href="#4-每个单词的首字母大写-text-transform" class="headerlink" title="4.每个单词的首字母大写 text-transform"></a>4.每个单词的首字母大写 text-transform</h3><blockquote><p> CSS2 中的属性，参数有 capitalize | uppercase | lowercase | none</p></blockquote><p>参数介绍：</p><ol><li>none：默认。定义带有小写字母和大写字母的标准的文本。</li><li>capitalize：文本中的每个单词以大写字母开头。</li><li>uppercase：定义仅有大写字母。</li><li>lowercase：定义无大写字母，仅有小写字母。</li></ol><p>从这个属性我们可以知道全部大写（小写）的需求这个属性也能轻易实现。</p><p>例子：每个单词的首字母大写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>shuliqi is boy<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">   <span class="attribute">text-transform</span>:capitalize;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>例子链接： <a href="http://jsrun.pro/IYWKp/edit">http://jsrun.pro/IYWKp/edit</a></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript运行机制</title>
      <link href="/2019/08/10/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/10/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript运行机制"><a href="#JavaScript运行机制" class="headerlink" title="JavaScript运行机制"></a>JavaScript运行机制</h3><p>我们知道JavaScript执行的时候是单线程的。但是Javascript为什么是单线程的呢， JavaScript为什么需要异步呢，JavaScript又如何靠单线程实现异步的呢？我们又为什么要掌握JavaScript的单线程。</p><span id="more"></span><p>为了回答上面的问题， 我们先看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;我执行了&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这段代码是真的会在1秒后执行吗？答案是不一定的。这就需要我们了解JavaScript的运行机制了。</p><h4 id="Javascript为什么是单线程？"><a href="#Javascript为什么是单线程？" class="headerlink" title="Javascript为什么是单线程？"></a>Javascript为什么是单线程？</h4><p>JavaScript是用在web浏览中。如果JavaScript是多线程的话。那么有两个线程是必然的，如果process1和procees2都操作在同一个DOM。process1要删除这个DOM， process2要编辑这个DOM。这样就会产生矛盾。所以JavaScript还是设计成单线程的。</p><h4 id="JavaScript为什么需要异步？"><a href="#JavaScript为什么需要异步？" class="headerlink" title="JavaScript为什么需要异步？"></a>JavaScript为什么需要异步？</h4><p>如果JavaScript不存在异步， 代码都是自上而下执行，如果上一行代码解析时间过长等原因，那么下面的代码就会被阻塞。这种现象对于用户来说就是“卡死”。用户体验很不好。</p><h4 id="JavaScript单线程如何实现异步呢？"><a href="#JavaScript单线程如何实现异步呢？" class="headerlink" title="JavaScript单线程如何实现异步呢？"></a>JavaScript单线程如何实现异步呢？</h4><p>JavaScript是通过事件循环（event loop）来实现的，事件循环机制也就是今天要说的JavaScript运行机制。</p><h4 id="同步和异步任务"><a href="#同步和异步任务" class="headerlink" title="同步和异步任务"></a>同步和异步任务</h4><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输出结果：1 3  2</p><p>setTimeout需要延迟一段时间爱能去执行。这类代码就是一异步代码。</p><p>根据这个结果。通常我们都这么理解JS的执行原理：</p><ol><li>判断JavaScript是同步的还是异步的。同步的直接进入主线程。异步的则进入Eevent table</li><li>异步任务在Eevent table注册函数，当满足出发条件后，进入event queue（事件队列）。</li><li>同步任务进入主线程后一直执行，直到主线程空闲。才会去event queue中查看是否有可执行的异步任务，如果有就推入主线程。</li></ol><h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><p>但是。按照同步和异步任务来理解JavaScript运行机制并不准确。</p><p>例如看这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>);</span><br></pre></td></tr></table></figure><p>上述的代码按照异步和同步的理解，结果应该是：b  d a c 。按顺序在主线程自上而下的执行。而 a c 是异步。按顺序在主线程有空后自先而后执行</p><p>可是结果并不是这样的， 结果是这样的：b  d  c  a。</p><p>这是为什么呢？ 这就需要了解宏任务和微任务。</p><ol><li><strong>宏任务：</strong> script全部代码，setTimeout，setInterval， I/O， UI Rendering等。</li><li><strong>微任务：</strong>Process.nextTick（Node独有），Promise等。</li></ol><p><img src="/Users/shuliqi/mage/20180924120852420.png"></p><p>根据这个例子我们理解的Javascript是这样的。</p><ol><li>执行宏任务(主线程的同步script代码),如果遇到微任务。就把任务发到微任务的时间队列中。</li><li>当前的宏任务执行完（调用栈是是空的），会去查找微任务的任务队列。将全部的微任务依次执行完毕之后。再去依次执行宏任务事件队列。</li></ol><p>以上的例子promise的then是一微任务，因此它的执行在setTimeout之前。</p><h4 id="JavaScript运行机制-1"><a href="#JavaScript运行机制-1" class="headerlink" title="JavaScript运行机制"></a>JavaScript运行机制</h4><p>通过以上的结论证明， JavaScript运行机制应该是这样的</p><p><strong>同步宏任务→微任务promise→微任务process.nextTick→异步宏任务</strong></p><p>注意的点： 在node环境下，process.nextTick的优先级高于promise。也就是可以简单理解为，在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的promise部分。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后总结开头的例子，我们可以理解为：</p><p>1秒后，setTimeout里的函数会被推入event queue，而event queue（事件队列）里的任务，只有在主线程空闲时才会执行。也就是需要同时满足两个条件（1）1秒后。（2）主线程必须空闲，这样1秒后才会执行该函数。</p><p>下面有几个例子可以看看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>同步宏任务：script start， script end</p><p>异步宏任务：setTimeout</p><p>微任务：promise1， promise2</p><p>根据JavaScript运行机制我们可以得出结果是：script start， script end， promise1， promise2，setTimeout</p><p> 有兴趣的话， 可以再研究研究这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>文章参考出处：<a href="https://blog.csdn.net/qq_41635167/article/details/82827970%EF%BC%8C">https://blog.csdn.net/qq_41635167/article/details/82827970，</a> <a href="https://juejin.im/post/5c3d8956e51d4511dc72c200#heading-12">https://juejin.im/post/5c3d8956e51d4511dc72c200#heading-12</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《javascript设计模式》读书笔记四：对象创建模式</title>
      <link href="/2019/07/07/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/07/07/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 是一种简洁明了的语言，其中并没有在其他语言经常使用的一些特殊语法的特征：命名空间，模块，包，私有属性，以及静态成员等。让我们用JavaScript来实现。</p> <span id="more"></span><h3 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h3><p>命名空间有助于减少程序中所需要的全局变量的数量，并且同时还哟助于避免命名冲突或者过长的名字前缀。</p><p>可以为应用程序或者库创建一个全局对象，然后将所有的功能添加到全局对象中，从而在具有大量函数，对象和其他变量的情况下并不会污染全局范围。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="keyword">var</span> some_var = <span class="string">&quot;shud&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.data = &#123; <span class="attr">a</span>:<span class="string">&#x27;a&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种方式将会导致很多全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line">MYAPP.dd1= &#123;&#125;;</span><br><span class="line">MYAPP.some_var = <span class="string">&quot;shud&quot;</span>;</span><br><span class="line">MYAPP.module = &#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.module.data = &#123; <span class="attr">a</span>:<span class="string">&#x27;a&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>这就避免了代码中的命名冲突。推荐使用这种方式。</p><p><strong>缺点</strong></p><ol><li>需要输入更多的字符，每个变量都需要添加前缀。</li><li>任何闭门的代码都可以修改全局实例。</li><li>长嵌套命名意味着的属性查询时间。</li></ol><h4 id="1-通用命名空间函数"><a href="#1-通用命名空间函数" class="headerlink" title="1.通用命名空间函数"></a>1.通用命名空间函数</h4><p>由于程序的复杂性。上面的做法已经变得不再健全。添加到命名空间中的属性可能已经存在，这将导致覆盖它们。因此在添一个属性或者创建一个命名空间之前，最好先检查它是否已经存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不健全的代码</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的代码风格</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> MYAPP === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者更短的语句</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = MYAPP || &#123;&#125;;</span><br></pre></td></tr></table></figure><p>但是这样每次检查读要针对一个对象或者属性。检查代码量太大。这就需要一个通用命名空间函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用命名空间函数</span></span><br><span class="line">MYAPP.namespace(<span class="string">&#x27;MYAPP.modules.module2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于如下代码</span></span><br><span class="line"><span class="comment">// var MYAPP = &#123;</span></span><br><span class="line"><span class="comment">//  modules: &#123;</span></span><br><span class="line"><span class="comment">//    module2: &#123;&#125;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>一个命名空间函数的实现事例。这个实现是肥破坏性的，也就是说，，如果已经存在一个命名空间， 将不会再重新创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = MYAPP || &#123;&#125;;</span><br><span class="line">MYAPP.namespace = <span class="function"><span class="keyword">function</span>(<span class="params">ns_string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parts = ns_string.splict(<span class="string">&#x27;.&#x27;</span>),</span><br><span class="line">      parent = MYAPP,</span><br><span class="line">      i,</span><br><span class="line">   <span class="comment">// 剥离最前面的多余的全局变量</span></span><br><span class="line">   <span class="keyword">if</span> (parent[<span class="number">0</span>] === <span class="string">&#x27;MYAPP&#x27;</span>) &#123;</span><br><span class="line">     parent = parts.slice(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; parts.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[parts[i]] === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        parent[parts[i]] = &#123;&#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     parent = parent[parts[i]]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明依赖关系"><a href="#声明依赖关系" class="headerlink" title="声明依赖关系"></a>声明依赖关系</h3><p>JavaScript库通常是模块化且根据命名空间组织的，这时我们能够仅包含所需的模块。它有很多优点：</p><ul><li>显式的依赖声明向您代码的用户表明了他们所需要的特定的脚本文件。</li><li>在函数的顶部声明可以很容易的发现和解析依赖。</li><li>解析局部变量的速度要比解析全局变量的速度要快。</li><li>声明依赖在打包之后可以有更小的代码量。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.modules.m1);</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.modules.m2);</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.modules.m3)</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.modules.m4);</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPP.modules.m5);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缩减的test1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> modules = MYAPP.modules</span><br><span class="line">  <span class="built_in">console</span>.log(modules.m1);</span><br><span class="line">  <span class="built_in">console</span>.log(modules.m2);</span><br><span class="line">  <span class="built_in">console</span>.log(modules.m3)</span><br><span class="line">  <span class="built_in">console</span>.log(modules.m4);</span><br><span class="line">  <span class="built_in">console</span>.log(MYAPPmodulesm5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h3><p>JavaScript并没有特殊的语法来表示私有，保护，或者公共属性和方法。在JavaScript中所有对象的成员都是公共的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量的方式构造对象</span></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;shuliqi&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">getNameAndAge</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;1111&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name + <span class="string">&#x27;:&#x27;</span> + myObj.age) <span class="comment">// name 和 age 可以公公访问的</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.getNameAndAge()) <span class="comment">// myobj.getNameAndAge也是可以公公访问的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数创建对象</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">myObj2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line">   <span class="built_in">this</span>.age = <span class="number">20</span>;</span><br><span class="line">   <span class="built_in">this</span>.getNameAndAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;1111&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="keyword">new</span> myObj2();</span><br><span class="line"><span class="built_in">console</span>.log(newObj.name + <span class="string">&#x27;:&#x27;</span> + newObj.age) <span class="comment">// name 和 age 可以公公访问的</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.getNameAndAge()) <span class="comment">// myobj.getNameAndAge也是可以公公访问的</span></span><br></pre></td></tr></table></figure><h4 id="构造函数实现私有成员"><a href="#构造函数实现私有成员" class="headerlink" title="构造函数实现私有成员"></a>构造函数实现私有成员</h4><p>可以使用JavaScript的闭包来实现私有成员的功能。构造函数创建了一个闭包，而在这些闭包范围内部的任意变量都不会暴露给构造函数以外的代码。然而这些私有变量仍然可以用于公共方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 私有成员</span></span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">   <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newMyFun = <span class="keyword">new</span> myFun();</span><br><span class="line"><span class="comment">// name 是私有的</span></span><br><span class="line"><span class="built_in">console</span>.log(newMyFun.name); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// getName 方法是公共的</span></span><br><span class="line"><span class="built_in">console</span>.log(newMyFun.getName()); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>所以只需要在函数中将需要保持为私有属性的数据包装起来，并确保它对函数来说是局部变量就可以实现私有成员。</p><h4 id="构造函数私有性失效"><a href="#构造函数私有性失效" class="headerlink" title="构造函数私有性失效"></a>构造函数私有性失效</h4><p>如果从一个特权方法中返回一个私有变量。且该变量是一个对象或者数组，那么外面的方法仍然可以访问修改该私有变量，因为它是通过引用传递的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&quot;shu&quot;</span>,</span><br><span class="line">     <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">this</span>.getObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> obj;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFun = <span class="keyword">new</span> myFun();</span><br><span class="line"><span class="keyword">var</span> obj = newFun.getObj();</span><br><span class="line">obj.shu = <span class="string">&quot;hahah&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newFun.getObj()); <span class="comment">// &#123;name: &quot;shu&quot;, age: 20, shu: &quot;hahah&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>解决的办法构造函数里面的特权方法不要传递需要有私有性的对象和数组的引用，而是传递克隆的对象或者数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&quot;shu&quot;</span>,</span><br><span class="line">     <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">this</span>.getObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// es6方式克隆</span></span><br><span class="line">      <span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj); </span><br><span class="line">      <span class="keyword">return</span> newObj;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFun = <span class="keyword">new</span> myFun();</span><br><span class="line"><span class="keyword">var</span> obj = newFun.getObj();</span><br><span class="line">obj.shu = <span class="string">&quot;hahah&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newFun.getObj()); <span class="comment">// &#123;name: &quot;shu&quot;, age: 20 &#125; 不可以修改</span></span><br></pre></td></tr></table></figure><h4 id="对象字面量实现私有性"><a href="#对象字面量实现私有性" class="headerlink" title="对象字面量实现私有性"></a>对象字面量实现私有性</h4><p>实现私有性，需要的只是一个能够包装私有数据的函数，因此，在使用对象字面量的情况下，可以使用额外的匿名函数创建闭包来实现私有性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 私有成员</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">  <span class="comment">// 实现公共部分</span></span><br><span class="line">  <span class="comment">// 注意这里没有使用var字符</span></span><br><span class="line">  obj = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// &#x27;undefined&#x27; name 是私有的</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()) <span class="comment">// &#x27;shuliqi&#x27;  特权方法是公共的</span></span><br></pre></td></tr></table></figure><p>另外的一种写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 私有成员</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// &#x27;undefined&#x27; name 是私有的</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()) <span class="comment">// &#x27;shuliqi&#x27;  特权方法是公共的</span></span><br></pre></td></tr></table></figure><h4 id="原型和私有性"><a href="#原型和私有性" class="headerlink" title="原型和私有性"></a>原型和私有性</h4><p>当私有成员与构造函数一起使用时，其中的一个缺点就是每次调用构造函数以创建对象时，这些私有成员都会被重新创建。构造函数中任何添加到this的任何成员都会有这种情况。为了避免这样重复的工作。可以把常用的方法和属性添加到构造函数的prototype属性中。这样就可以通过一个构造函数创建的多个实例共享常见的的部分数据。还可以在多个实例中共享隐藏的私有成员。即构造函数中的私有属性和对象字面量的私有属性。由于prototype仅仅是一个对象。所以可以使用对象字面量来创建它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 私有属性</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line"><span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.prototype = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 私有成员</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="keyword">new</span> myObj()</span><br><span class="line"><span class="built_in">console</span>.log(newObj.getName()) <span class="comment">// &#x27;shuliqi&#x27;  自身的特权方法</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.getAge())  <span class="comment">// 12 原型的特权方法</span></span><br></pre></td></tr></table></figure><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>由于我们Javascript是没有包的语法的。模块模式提供了一种创建自包含非耦合代码片段的有力工具，可以将它视为黑盒功能，并且可以根据自己所需添加，替换或者删除这些模块。</p><p>模块模式是有下面这几种组合的组合。</p><ul><li>命名空间</li><li>即使函数</li><li>私有和特权成员</li><li>声明依赖</li></ul><p><strong>第一步：</strong>定义一个命名空间：例如我们之前介绍的namespace()函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYAPP.namespace(<span class="string">&#x27;MYAPP.utilities.array&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>第二步：</strong>定义该模块，对于需要保持私有性的情况，本模式可以提供就要有私有作用域的即使函数。该即时函数返回一个对象，即具有公共接口的实际模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MYAPP.utilities.array = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ... todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p><strong>第三步：</strong>向公共接口添加一些方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MYAPP.utilities.array = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="attr">isArray</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p><strong>最后：</strong>通过即使函数提供的私有作用域，可以根据需要声明一些私有属性和方法。在即时函数的顶部，正好也是声明模块可能有任何依赖的位置。在声明变量后，可以任意的放置有助于建立该模块的任何一性的初始化代码。最后结果是一个由即时函数返回的对象，其中该对象包含了自己模块需要的公共API。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MYAPP.namespace(<span class="string">&#x27;MYAPP.utilities.array&#x27;</span>);</span><br><span class="line">MYAPP.utilities.array = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 依赖</span></span><br><span class="line">   <span class="keyword">var</span> uobj = MYAPP.utilities.object,</span><br><span class="line">       ulang = MYAPP.utilities.ulang,</span><br><span class="line">       <span class="comment">// 私有属性</span></span><br><span class="line">       name = <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">       age =  <span class="number">12</span>,</span><br><span class="line">       <span class="comment">// 私有方法</span></span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       <span class="comment">// var 变量定义结束</span></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">   <span class="comment">// 可选的一次性初始化过程</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 公共API</span></span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="attr">isArray</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">name</span>: name,</span><br><span class="line">     <span class="comment">// ... 更多的属性和方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就是模块模式的基本创建方式。</p><h3 id="揭示模式"><a href="#揭示模式" class="headerlink" title="揭示模式"></a>揭示模式</h3><p>在模块模式里面，公共API:公共属性和方法都是写在对象字面量中， 如果想在闭包内部调用公有属性和方法，就需要通过暴露在全局变量中的对象名称去调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var MYAPP = (function() &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">       // 公有属性</span><br><span class="line">       firstName: &#x27;Peppa&#x27;,</span><br><span class="line">       // 公有属性</span><br><span class="line">       lastName: &#x27;Pig&#x27;,</span><br><span class="line">       getFullName: function() &#123;</span><br><span class="line">          return MYAPP.firstName + &#x27; &#x27; +  MYAPP.lastName;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;());</span><br><span class="line">console.log(MYAPP.getFullName()) // Peppa Pig</span><br></pre></td></tr></table></figure><p>就像上面实例中展示的，<code>getFullName</code> 方法中需要访问公有属性 <code>firstName</code> 和 <code>lastName</code>，就必须通过 <code>nameSpace</code> 对象名去调用。这样的确很别扭，如果想要给 <code>nameSpace</code> 换个对象名，就需要考虑闭包内部的调用</p><p>那么使用揭示模式就可以解决这个问题了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Peppa&#x27;</span></span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Pig&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">firstName</span>: firstName,</span><br><span class="line"><span class="attr">lastName</span>: lastName,</span><br><span class="line"><span class="attr">getFullName</span>: getFullName</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">MYAPP.getFullName() <span class="comment">// &quot;Peppa Pig&quot;</span></span><br></pre></td></tr></table></figure><p>优化后的代码，我们将公有的变量和方法在返回前就做了处理，而返回的对象更加纯粹，增强了可读性。这也是揭示模块模式的<strong>优点</strong></p><h3 id="创建构造函数的的模块"><a href="#创建构造函数的的模块" class="headerlink" title="创建构造函数的的模块"></a>创建构造函数的的模块</h3><p>有时候使用构造函数创建对象更为方便。当然，仍然可以使用模块模式来执行创建对象的操作。区别就是在于包装了模块的即时函数最终将会返回一个函数，而不是一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">MYAPP.namespace(<span class="string">&#x27;MYAPP.utilities.array&#x27;</span>);</span><br><span class="line">MYAPP.utilities.array = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 依赖</span></span><br><span class="line">   <span class="keyword">var</span> uobj = MYAPP.utilities.object,</span><br><span class="line">       ulang = MYAPP.utilities.ulang,</span><br><span class="line">       <span class="comment">// 私有属性</span></span><br><span class="line">       name = <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">       age =  <span class="number">12</span>,</span><br><span class="line">       constr;</span><br><span class="line">       <span class="comment">// 私有方法</span></span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       <span class="comment">// var 变量定义结束</span></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">   <span class="comment">// 可选的一次性初始化过程</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="comment">// 公共API-----构造函数</span></span><br><span class="line">   constr = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.elements = <span class="built_in">this</span>.toArray(o);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 公共API-----原型</span></span><br><span class="line">   constr.prototype = &#123;</span><br><span class="line">     <span class="attr">constructor</span>: MYAPP.utilities.array,</span><br><span class="line">     <span class="attr">toArray</span>: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新构造函数的方法</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MYAPP.utilities.array(obj);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《javascript设计模式》读书笔记三：函数</title>
      <link href="/2019/06/15/%20%E3%80%8Ajavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2019/06/15/%20%E3%80%8Ajavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一-函数的特点"><a href="#一-函数的特点" class="headerlink" title="一. 函数的特点"></a>一. 函数的特点</h3><h4 id="函数是第一类对象"><a href="#函数是第一类对象" class="headerlink" title="函数是第一类对象"></a>函数是第一类对象</h4><p>函数就是对象，其表现是：</p><ul><li><p>函数可以在运行时动态创建，也可以在程序执行过程中创建</p></li><li><p>函数可以分配给变量，可以将它们的引用复制到其他变量，可以被扩展，此外，除了极少数特殊情况外，函数也可以被删除。</p> <span id="more"></span></li><li><p>可以作为参数传递给他们函数，并且还可以被其他函数返回。</p></li><li><p>函数可以有自己的属性和方法。</p></li></ul><h4 id="函数提供了作用域"><a href="#函数提供了作用域" class="headerlink" title="函数提供了作用域"></a>函数提供了作用域</h4><p>在JavaScript中没有花括号{}语法以定义局变量，也就是说， 块并不创建作用域。JavaScript仅存在函数作用域。在函数内以var关键词定义的任何变量都是局部变量。对于函数外是不可见的。</p><h3 id="二-函数声明和函数表达式"><a href="#二-函数声明和函数表达式" class="headerlink" title="二. 函数声明和函数表达式"></a>二. 函数声明和函数表达式</h3><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>命名函数表达式是函数表达式的一种特殊情况。</p><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数声明与函数表示式的区别"><a href="#函数声明与函数表示式的区别" class="headerlink" title="函数声明与函数表示式的区别"></a>函数声明与函数表示式的区别</h4><ul><li><p>函数表达式中需要分号结尾，并且总应该用分号。函数声明不需要分号。</p></li><li><p>使用函数声明时，不仅仅函数定定义被提升，函数体也被提升了。使用函数表达式时， 只有函数定义提升，函数体不提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;global foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;global bar&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">host</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo);  <span class="comment">// &quot;function&quot;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line">  foo(); <span class="comment">// local foo</span></span><br><span class="line">  bar(); <span class="comment">// bar is not a function</span></span><br><span class="line">  <span class="comment">// 函数声明，函数定义和函数体一起被提升到函数host顶部</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;local foo&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 函数表达式，只有函数定义被提升到函数host顶部</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;local bar&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="三-函数有关的有用的模式"><a href="#三-函数有关的有用的模式" class="headerlink" title="三. 函数有关的有用的模式"></a>三. 函数有关的有用的模式</h3><h4 id="API模式"><a href="#API模式" class="headerlink" title="API模式"></a>API模式</h4><ul><li><p>配置对象：有助于保持受到控制的函数的参数数量</p><p>如果函数的参数列表很长（超过3个），一个更好的办法是仅使用一个参数对象来替代所有的参数，然后实际的参数在这个对象里面配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addPerson = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> &#123; age, name &#125; = config;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line"><span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">addPerson(config)</span><br></pre></td></tr></table></figure><p>该方法的优点：</p><ul><li>不需要记住总众多的参数和参数的顺序。</li><li>可以安全的忽略可选参数。</li><li>更加易于阅读和维护。</li><li>更加易于添加参数和删除参数。</li></ul><p>配置对象的不足：</p><ul><li>需要记住参数名称</li><li>属性名称无法被压缩</li></ul></li></ul><h4 id="初始化模式"><a href="#初始化模式" class="headerlink" title="初始化模式"></a>初始化模式</h4><ul><li><p>即时函数：是一种支持在定义函数后立即执行该函数的语法</p><p><strong>语法：</strong></p><ul><li>可以使用函数表达式定义一个函数（函数声明则无法达到这个效果）</li><li>在末尾添加一组括号，这将导致该函数立即执行</li><li>将整个函数包装在括号中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p><strong>好处：</strong>可以包装需要想要执行的任务，且不会在后台留下任何全局变量，定义的所有变量将会是用于自身调用函数的局部变量，并且不会担心全局空间呗临时的变量所污染。</p></li><li><p>即时对象初始化：跟即时函数类似，可以保护全局作用域不收污染。</p><p>这种模式使用带有init()方法的对象。该方法在创建对象之后将会立即执行。init()函数需要负责所有的初始化任务。</p><p><strong>语法：</strong></p><ul><li>使用对象字面量创建一个普通的对象。</li><li>将字面量包括到括号中。</li><li>在括号结束之后，可以立即调init()方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line"><span class="attr">width</span>: <span class="number">600</span>,</span><br><span class="line"><span class="attr">height</span>: <span class="number">300</span>,</span><br><span class="line"><span class="attr">getMax</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.width + <span class="built_in">this</span>.height;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.getMax());</span><br><span class="line">&#125;</span><br><span class="line">&#125;).init();</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>于即时函数的优点相同</li><li>如果初始化任务更加复杂，它将会使得整个初始化过程更加有结构化。</li></ul></li><li><p>初始化时分支：也称加载时分支，是一种优化模式。</p><p>帮助分支代码在初始化代码执行过程中仅检测一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">var</span> utils = &#123;</span><br><span class="line"><span class="attr">addListenner</span>: <span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.addEventListener === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">el.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span>.attachEvent === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">el.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">el[<span class="string">&#x27;on&#x27;</span> + type] = fn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">removeListenner</span>: <span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 几乎一样的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式效率比较低下，每次调用utils.addListenner 和utils.addListenner时，都会重复的执行相同的检查。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> utils = &#123;</span><br><span class="line"> <span class="attr">addListenner</span>: <span class="literal">null</span>,</span><br><span class="line"> <span class="attr">removeListenner</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.addEventListener === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">utils.removeListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">el.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">utils.removeListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">el.removeListenner(type, fn, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">document</span>.attachEvent === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">utils.addListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">el.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn)</span><br><span class="line">&#125;</span><br><span class="line">utils.removeListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">el.detachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">utils.addListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">el[<span class="string">&#x27;on&#x27;</span> + type] = fn;</span><br><span class="line">&#125;</span><br><span class="line">utils.removeListenner =<span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">el[<span class="string">&#x27;on&#x27;</span> + type] = fn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式就是只会检测一次了。</p></li></ul><h4 id="性能模式"><a href="#性能模式" class="headerlink" title="性能模式"></a>性能模式</h4><ul><li><p>备忘录模式：使用函数属性以便使的计算过的值无需在此计算</p><p>以为函数是对象，所以有属性和方法。例如：无论以什么方式创建了对象，都会自动获得一个length属性，包含了该函数期望的参数的数量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun.length)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>所以可以在任何时候将自定义属性添加到函数中，其中的一个作用就是缓存函数结果（返回值）。因此在下一次调用的时候就不用重复做潜在的繁重计算功能。缓存函数结果被称：备忘</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFun = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="built_in">arguments</span>.callee;</span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line"><span class="keyword">if</span> (!f.cache) &#123;</span><br><span class="line">result = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line"><span class="comment">// ...开销很大的操作</span></span><br><span class="line">myFun.cache = result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f.cache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存存储</span></span><br><span class="line">myFun.cache = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>自定义模式（惰性函数定义）： 以新的主体重写本身。使的在第二次或者以后调用时仅需要执行更少的工作</p><p>函数可以被动态定义，也可以分配给变量。如果创建了一个新的函数并且把它分配给了另外一个函数的的同一个变量。那么就是以新函数覆盖了就函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">myFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2222&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">myFun(); <span class="comment">// &#x27;111&#x27;</span></span><br><span class="line">myFun(); <span class="comment">// &#x27;2222&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(myFun.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果函数有一些初始化的准备工作要做。并且只需要执行一次。那么这种模式就很有用。</p><p><strong>缺点</strong></p><ul><li><p>如果改函数使用了不同的名称（比如分配给不同的变量或者以对象的方式来使用）那么重定义就不会发生，并且会执行原始函数体。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">myFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2222&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值给另一个不同名称的变量</span></span><br><span class="line"><span class="keyword">var</span> newMyFun = myFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个方法被调用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> <span class="attr">fun</span>: newMyFun,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newMyFun() <span class="comment">// &#x27;111&#x27;</span></span><br><span class="line">newMyFun() <span class="comment">// &#x27;111&#x27;</span></span><br><span class="line"></span><br><span class="line">obj.fun() <span class="comment">// &#x27;111&#x27;</span></span><br><span class="line">obj.fun() <span class="comment">// &#x27;111&#x27;</span></span><br><span class="line"></span><br><span class="line">myFun() <span class="comment">// &#x27;2222&#x27;</span></span><br><span class="line">myFun() <span class="comment">// &#x27;2222&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些调用不断的重写全局myFun()指针。以至于它最终被调用时，它才第一次更新函数主体。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中如何检测数组的变化?</title>
      <link href="/2019/06/03/Vue%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96/"/>
      <url>/2019/06/03/Vue%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>之前学习了关于<code>Vue</code>的响应式数据的原理： <a href="https://shuliqi.github.io/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/">Vue 的双向绑定原理及手把手实现</a>。它的原理其实就是通过<code>Object.defineProperty</code>控制    <code>getter</code>和<code>setter</code>结合发布订阅者模式完成响应式设计的，</p><p><strong>1. 但是这种数据劫持对数组有什么影响呢？</strong></p><p>这种递归方式无论对于数组还是对象都进行了观测。但是我们的数组有成千上万个元素，每一个元素下标都添加<code>get</code> 和<code>set</code>.这样对于性能来说代价太大了。那么<code>Object.property</code>只用来劫持对象。</p><p><strong>2. Object.property这种劫持方式有什么缺点呢？</strong></p><p>对于新增的或者删除的属性是无法被检测到的，只有对象本身存在的属性才会被劫持。</p><p>对于数组来说也是一样，新增加的元素和删除的元素无法对他们的下表进行劫持。</p> <span id="more"></span><p>根据以上两点可以得出这就是为什么<code>Vue</code>官方说如下的话：</p><blockquote><p>由于<code>JavaScript</code>的限制，<code>Vue</code>无法检测到以下数组的变动：</p><ul><li>当你使用索引设置一项时；如：<code>vm.items[indexOfItem] = newValue</code></li><li>当修改数组的长度时；如：vm.items.length =  newLength</li></ul></blockquote><p>我们举个例子：</p><p>之前的文章  <a href="https://shuliqi.github.io/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/">Vue 的双向绑定原理及手把手实现</a>写好了<code>Observer</code>。 我们来做一个实验：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/observer.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/compile.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/watcher.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> MyVue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;舒丽琦&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">list</span>: [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置普调对象的值</span></span></span><br><span class="line"><span class="javascript">    vm.name = <span class="string">&quot; 小小舒&quot;</span> </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取普调对象的值</span></span></span><br><span class="line"><span class="javascript">    vm.name;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置数组的值</span></span></span><br><span class="line"><span class="javascript">    vm.list.push(<span class="string">&quot;4&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取数组的值</span></span></span><br><span class="line"><span class="javascript">    vm.list[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(vm.list);</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>关上面的代码的代码可到  <a href="https://shuliqi.github.io/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/">Vue 的双向绑定原理及手把手实现</a>找到</p></blockquote><p>我们看看实验的结果：</p><img src="/2019/06/03/Vue%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96/1.png" class=""><p>从结果可以看出：<code>data</code> 中的 <code>name</code>,<code> list</code> 均发生了变化; <code>name</code>发生了变化能检测到，但是是<code>list</code>发生变化无法检测到。这是为什么呢？</p><p>原来操作数组的方法是在 <code>Array.prototype</code>上的； 挂在在<code>Array.prototype</code>上的方法并不能触发属性的<code>getter</code>和<code>setter</code>。</p><h1 id="Vue-检测数组变化-重写数组"><a href="#Vue-检测数组变化-重写数组" class="headerlink" title="Vue 检测数组变化-重写数组"></a>Vue 检测数组变化-重写数组</h1><p>那解决这个问题的办法是什么呢？<code>Vue2.x</code>使用的是将数组常用的方法进行重写。</p><p>基本的思路是之前我们调用数组的常用的方法的时候（如<code>push</code>·）；我们是从 <code>Array.prototype</code>上面寻找这个方法，现在我们改成一个空对象 {} 继承  <code>Array.prototype</code>，然后给 空对象添加 <code>push</code>方法；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  push： <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 其他常用的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们调用常用的办法，实际上就是在调用 这个空对象的方法。因为常用的方法使我们自己重写的，肯定就知道当前操作是什么，新数据是什么等等，就可以做到检测数组的变化了。</p><p>既然是这样， 那么我们的<code>observer</code>是需要区分当前需要监听的数据是对象还是数组，如果是数组，则改变数组的原型链，只有改变了原型链才能改变调用数组常用的方法如<code>push</code>方法时，是调用我们自己的设置的常用的方法的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 如果数据不存在，或者 data 不是一个对象的话， 则不处理</span></span><br><span class="line">  <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">    data.__proto__ = arrayMethods;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 监听不是数组的数据</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">      defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>arrayMethods</code>就是我们所说的空对象。它里面添加数组常用的方法如：<code>push</code>等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 老的数组的原型</span></span><br><span class="line"><span class="keyword">const</span> oldArrayProperty = <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的空对象，但是会继承原数组的一些方法，因为当使用我们没有重写的方法的时候，能使用到</span></span><br><span class="line"><span class="keyword">const</span> arrayMethodObj = <span class="built_in">Object</span>.create(oldArrayProperty);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要重写的数组</span></span><br><span class="line"><span class="keyword">const</span> arrayMethods =  [<span class="string">&quot;push&quot;</span>, <span class="string">&quot;shift&quot;</span>, <span class="string">&quot;unshift&quot;</span>, <span class="string">&quot;pop&quot;</span>,<span class="string">&quot;reverse&quot;</span>, <span class="string">&quot;sort&quot;</span>, <span class="string">&quot;splice&quot;</span>];</span><br><span class="line">arrayMethods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arrayMethodObj[method] = <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 执行老的数组的方法，得到结果</span></span><br><span class="line">    <span class="keyword">const</span> result = oldArrayProperty[method].apply(<span class="built_in">this</span>, arg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`数组有变化了，方法：<span class="subst">$&#123;method&#125;</span>, 新增加的值为: <span class="subst">$&#123;inserted&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们实现对新增属性的监听。基本的思路：</p><ul><li>获取到新的属性</li><li>对新的属性进行监听</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 老的数组的原型</span></span><br><span class="line"><span class="keyword">const</span> oldArrayProperty = <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的空对象，但是会继承原数组的一些方法，因为当使用我们没有重写的方法的时候，能使用到</span></span><br><span class="line"><span class="keyword">const</span> arrayMethodObj = <span class="built_in">Object</span>.create(oldArrayProperty);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要重写的数组</span></span><br><span class="line"><span class="keyword">const</span> arrayMethods =  [<span class="string">&quot;push&quot;</span>, <span class="string">&quot;shift&quot;</span>, <span class="string">&quot;unshift&quot;</span>, <span class="string">&quot;pop&quot;</span>,<span class="string">&quot;reverse&quot;</span>, <span class="string">&quot;sort&quot;</span>, <span class="string">&quot;splice&quot;</span>];</span><br><span class="line">arrayMethods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arrayMethodObj[method] = <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 执行老的数组的方法，得到结果</span></span><br><span class="line">    <span class="keyword">const</span> result = oldArrayProperty[method].apply(<span class="built_in">this</span>, arg);</span><br><span class="line">    <span class="comment">// 进行监听： 1.找到增加的元素； 2.实现监听</span></span><br><span class="line">    <span class="comment">// 1.找到新增加的元素</span></span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;unshift&quot;</span>:</span><br><span class="line">        inserted = arg;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;splice&quot;</span>:</span><br><span class="line">         <span class="comment">// vm.list.splice(3, 0,&quot;哈哈哈&quot;, &quot;怎么着&quot;) ---&gt; arg = [3, 0, &quot;哈哈哈&quot;, &quot;怎么着&quot;]</span></span><br><span class="line">        inserted = arg.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">      <span class="comment">// 2.实现对新增加元素的监听：当然是新增的元素是数组的话才会去监听，observer函数有处理</span></span><br><span class="line">      observerArray(inserted);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`数组有变化了，方法：<span class="subst">$&#123;method&#125;</span>, 新增加的值为: <span class="subst">$&#123;inserted&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 剩下的就需要通知订阅者去更新视图了</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中有一个 <code>observeArray</code>方法去监听新增加的数组的元素。我们看看 <code>observeArray</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 劫持数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observeArray</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  循环监听每一个新增的属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observer(items[i]); <span class="comment">// 注意这里是observer 不是 Observer</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>observeArray</code>方法中对<code>inserted</code>进行遍历，对每一项进行监听。为什么要遍历呢？因为<code>inserted</code>不一定是一个值。也有可能是多个如：[].splice(0,0,”1”, “2”, “3”)；[].push(1,2,3)等。</p><p>我们来看 <code>observer</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果数据不存在，或者data 不是一个对象的话， 则不处理</span></span><br><span class="line">  <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有很重要的一点：<code>value</code>不是一个对象的话， 我们是不做任何处理的。就比如：<code>  observer(items[i]); // 注意这里是observer 不是 Observer</code>这一句，这里的<code>items[i]</code>有可能就只是一个数据，而不是对象或者数组， 我们就是不处理的。不然跟对数组的所有下表监听的有啥区别。</p><p>目前实现对了数组方法的拦截。但是还有一个问题，就是我们在初始化的时候，data可能就是数组，因此要把这个数组也进行监听。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">    data.__proto__ = arrayMethodObj;</span><br><span class="line">    observerArray(data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      defineObserver(data, key, data[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们是实现了对数据的监听，不过这里还是有个问题没解决，也就是<code>Vue2.x</code>还没有解决的问题：并没有实现对数组的每一项进行监听：如下面这样的就不会被监听到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> MyVue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;舒丽琦&quot;</span>,</span><br><span class="line">    <span class="attr">list</span>: [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.list[<span class="number">0</span>] = <span class="string">&quot;我改变了&quot;</span></span><br></pre></td></tr></table></figure><p>这是因为我们数据劫持的时候没有对数组的下标进行监听。因为性能的代价太高了。除此之外，改变数组的长度也是无限监听的 <code>vm.list.length = 9</code>。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>最后我们演示一下结果</p><p>我们的<code>html</code>代码为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/observer.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/compile.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/watcher.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> MyVue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;舒丽琦&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">list</span>: [<span class="string">&quot;舒&quot;</span>, <span class="string">&quot;丽&quot;</span>, <span class="string">&quot;琦&quot;</span>]</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 给数组添加一个元素， 这个元素是一个数组</span></span></span><br><span class="line"><span class="javascript">    vm.list.push([<span class="string">&quot;小小舒&quot;</span>, <span class="string">&quot;sha&quot;</span>]);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 对新增的元素（新增的是一个数组：[&quot;小小舒&quot;, &quot;sha&quot;]）再添加元素</span></span></span><br><span class="line"><span class="javascript">    vm.list[<span class="number">3</span>].push(<span class="string">&quot;哈哈哈&quot;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加数组</span></span></span><br><span class="line"><span class="javascript">    vm.list.splice(<span class="number">3</span>, <span class="number">0</span>,<span class="string">&quot;哈哈哈&quot;</span>, <span class="string">&quot;怎么着&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(vm.list);</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>observer.js</code>完整的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 老的数组的原型</span></span><br><span class="line"><span class="keyword">const</span> oldArrayProperty = <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的空对象，但是会继承原数组的一些方法，因为当使用我们没有重写的方法的时候，能使用到</span></span><br><span class="line"><span class="keyword">const</span> arrayMethodObj = <span class="built_in">Object</span>.create(oldArrayProperty);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要重写的数组</span></span><br><span class="line"><span class="keyword">const</span> arrayMethods =  [<span class="string">&quot;push&quot;</span>, <span class="string">&quot;shift&quot;</span>, <span class="string">&quot;unshift&quot;</span>, <span class="string">&quot;pop&quot;</span>,<span class="string">&quot;reverse&quot;</span>, <span class="string">&quot;sort&quot;</span>, <span class="string">&quot;splice&quot;</span>];</span><br><span class="line">arrayMethods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arrayMethodObj[method] = <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 执行老的数组的方法，得到结果</span></span><br><span class="line">    <span class="keyword">const</span> result = oldArrayProperty[method].apply(<span class="built_in">this</span>, arg);</span><br><span class="line">    <span class="comment">// 进行监听： 1.找到增加的元素； 2.实现监听</span></span><br><span class="line">    <span class="comment">// 1.找到新增加的元素</span></span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;unshift&quot;</span>:</span><br><span class="line">        inserted = arg;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;splice&quot;</span>:</span><br><span class="line">         <span class="comment">// vm.list.splice(3, 0,&quot;哈哈哈&quot;, &quot;怎么着&quot;) ---&gt; arg = [3, 0, &quot;哈哈哈&quot;, &quot;怎么着&quot;]</span></span><br><span class="line">        inserted = arg.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">      <span class="comment">// 2.实现对新增加元素的监听：当然是新增的元素是数组的话才会去监听，observer函数有处理</span></span><br><span class="line">      observerArray(inserted);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`数组有变化了，方法：<span class="subst">$&#123;method&#125;</span>, 新增加的值为: <span class="subst">$&#123;inserted&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 剩下的就需要通知订阅者去更新视图了</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">    data.__proto__ = arrayMethodObj;</span><br><span class="line">    observerArray(data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      defineObserver(data, key, data[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observerArray</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    observer(items[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果数据不存在，或者data 不是一个对象的话， 则不处理</span></span><br><span class="line">  <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineObserver</span>(<span class="params">data, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 监听子元素</span></span><br><span class="line">  observer(value);</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 把订阅者添加到容器里面，统一管理</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value !== newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;监听对象属性到变化了，新的值为：&quot;</span>, newValue)</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="comment">// 通知收集的容器的 notify，notify 去更新每一个订阅者的 update 方法去更新视图</span></span><br><span class="line">        dep.notify();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理每一个订阅者的容器:</span></span><br><span class="line"><span class="comment">// 该容器维护一个数组，用来收集订阅者。</span></span><br><span class="line"><span class="comment">// 该容器有一个 notify 方法 去触发订阅者的 update 去更新视图。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  <span class="attr">addSub</span>: <span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">notify</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2019/06/03/Vue%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96/2.png" class=""><p>上面例子的代码： <a href="https://github.com/shuliqi/MyVue/tree/array_methids">vue检测数组-重写数组常用的方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《javascript设计模式》读书笔记二：字面量和构造函数</title>
      <link href="/2019/05/23/%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/05/23/%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="一-对象"><a href="#一-对象" class="headerlink" title="一.对象"></a>一.对象</h3><p>对象由下面这三种方式创建：</p><ul><li><strong>对象字面量</strong></li><li><strong>来自构造函数的对象</strong></li><li><strong>来自自定义构造函数的对象</strong></li></ul> <span id="more"></span><h5 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h5><p>在大括号里面写上键值对，键和值之间以分号分割，不同的键值对以逗号分隔。这种方式就是字面量。值可以是任意类型对象，除值是函数外我们都称为属性。值是函数我们称为方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 像对象添加一个属性name</span></span><br><span class="line">obj.name = <span class="string">&quot;shu&quot;</span>  </span><br><span class="line"><span class="comment">// 向对象添加一个方法fun</span></span><br><span class="line">obj.fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> obj.age&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="来自构造函数的对象"><a href="#来自构造函数的对象" class="headerlink" title="来自构造函数的对象"></a>来自构造函数的对象</h5><p>可以使用类似 Object(), Date(), String()的内置构造函数来创建对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>但是这种方式是不推荐的， 原因：</p><ul><li><p>在构造时，解析器需要从调用Object()的位置开始一直向上查询作用域链，直到发现全局的object函数（可能以同样的命名创建了一个局部构造函数）—&gt;但字面量并没哟作用域解析。</p></li><li><p>使用内置构造函数来创建对象。对于不同的内置函数会有自己的特征。例如：Object()构造函数会接受一个参数。并且以来传递进来的参数，导致Object()会委托其他的内置函数来创建对象，并且返回一个并非期望的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor === <span class="built_in">Object</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor === <span class="built_in">Number</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.toFixed(<span class="number">2</span>)) <span class="comment">// 1.00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&#x27;tss&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor === <span class="built_in">String</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o.substring())  <span class="comment">//Object并没有substring方法。但是字符串是由的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor === <span class="built_in">Boolean</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="自定义构造函数创建的对象"><a href="#自定义构造函数创建的对象" class="headerlink" title="自定义构造函数创建的对象"></a>自定义构造函数创建的对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newPerson = <span class="keyword">new</span> Person(<span class="string">&quot;shuliqi&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newPerson.name)  <span class="comment">// shuliqi</span></span><br><span class="line">newPerson.getName()  <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>使用new 操作符调用构造函数（自定义+内置）时。函数内部发生的事：</p><ul><li>创建一个空对象.</li><li>this指向该空对象.并且继承函数的原型。</li><li>属性和方法被加入到this引用的对象中</li><li>新对象由this值引用，并且最后隐式的返回（如果没有显示的返回值）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">this</span> = &#123;&#125;;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return this; 隐式的返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用new操作符创建对象时，构造函数总会返回一个对象。默认情况下返回的是this所引用的对象。如果在构造函数中不向this添加任何属性和方法，将会返回一个空对象（这里的”空”，实际上并不空，它已经从构造函函数的原型继承了很多成员）。</p><p>当然构造函数你可以返回你想要的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> that = &#123;&#125;</span><br><span class="line">  that.name = name;</span><br><span class="line">  <span class="keyword">return</span> that;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newPerson = <span class="keyword">new</span> Person(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newPerson.name) <span class="comment">// shuliqi</span></span><br><span class="line">newPerson.getName  <span class="comment">// 报错： newPerson.getName is not a function</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在用new操作符创建对象时，构造函数总会返回一个对象。默认情况下返回的时this所引用的对象。如果在构造函数中没有向this添加任何属性和方法。那么将返回一个空对象（除了从构造函数的原型继承的成员）</p><p>构造函数将隐式的返回this。甚至在函数中没有显式的加入return语句。但是可以根据需要返回任意其他对象。</p><h5 id="强制使用new的模式"><a href="#强制使用new的模式" class="headerlink" title="强制使用new的模式"></a>强制使用new的模式</h5><hr><p>构造函数也是函数，只不过它却以new的方式调用。如果在调用构造函数时忘记添加new操作符会发生？这虽然不会导致语法和运行时的错误。但是可能导致逻辑错误和意外的行为发生。忘记加new操作符。导致构造函数的this指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name =<span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新对象</span></span><br><span class="line"><span class="keyword">var</span> newPerson = <span class="keyword">new</span> person();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> newPerson)  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(newPerson.name) <span class="comment">// &quot;shuliqi&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 忘记使用&quot;new&quot;模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newPerson1 = person();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> newPerson1) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)  <span class="comment">//  &quot;shuliqi&quot;</span></span><br></pre></td></tr></table></figure><p><strong>解决的办法</strong></p><ul><li><p>命名约定。使构造函数的函数名首字母是大写的。有助于在一定程度上能避免忘记new操作符。</p></li><li><p>构造函数不使用this。构造函数中并不用将方法和属性添加到this。而是添加到一个自定义的变量，最后返回。甚至不需要一个这样的局部变量。直接返回一个对象即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="keyword">new</span> name();</span><br><span class="line"><span class="keyword">var</span> secondtName = name();</span><br><span class="line"><span class="built_in">console</span>.log(firstName.name) <span class="comment">// &quot;shuliqi&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(secondtName.name) <span class="comment">// &quot;shuliqi&quot;</span></span><br></pre></td></tr></table></figure><p>但是这种方式的缺点是会丢失到原型的链接。构造函数的原型属性都是不可用的。</p></li><li><p>自调用构造函数</p><p>为了使得构造函数的属性在实例对象中也能使用。可以在构造函数中检查this是否为构造函数的实例。如果为否。可以再次调用自身。并且在这次调用中正确的使用了new操作符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!(<span class="built_in">this</span> <span class="keyword">instanceof</span> name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">name.prototype.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newName = name();</span><br><span class="line"><span class="built_in">console</span>.log(newName.name,newName.age) <span class="comment">// &quot;shuliqi&quot;, 12</span></span><br></pre></td></tr></table></figure><p>另一种检测实例对象的方法是使用arguments.callee进行比较。callen属性指向被调用的函数。这样就不用在编码的时候硬编构造函数的名字了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!(<span class="built_in">this</span> <span class="keyword">instanceof</span> <span class="built_in">arguments</span>.callee)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">name.prototype.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newName = name();</span><br><span class="line"><span class="built_in">console</span>.log(newName.name,newName.age) <span class="comment">// &quot;shuliqi&quot;, 12</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="二-数组"><a href="#二-数组" class="headerlink" title="二.数组"></a>二.数组</h3><p> 数组对象可以通过下面这三种方式创建：</p><ul><li><p>数组字面量</p></li><li><p>数组构造函数</p><h5 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h5></li></ul><p>数组字面量表示法：逗号分隔的元素列表。并且元素列表包装在一个方括号中。可以给元素指定任意类型的值。包括对象或者其他数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]</span><br></pre></td></tr></table></figure><h5 id="数组构造函数"><a href="#数组构造函数" class="headerlink" title="数组构造函数"></a>数组构造函数</h5><p>可以通过内置的构造函数Arrry()来创建数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>最好不要使用构造函数来创建数组。因为当向构造函数传递单个数字时，它并不会成为数组的第一个元素的值。而是设置了数组的长度。但是数组中并没有实际的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length, arr[<span class="number">0</span>])  <span class="comment">// 1, 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr2.length, arr2[<span class="number">0</span>])  <span class="comment">// 3, undefined</span></span><br></pre></td></tr></table></figure><p>如果传入的是浮点数将会更糟糕</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3.14</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length, arr[<span class="number">0</span>])  <span class="comment">// 1, 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3.14</span>)  <span class="comment">// Uncaught RangeError: Invalid array length（不合法的数组长度）</span></span><br></pre></td></tr></table></figure><p>因此坚决使用字面量将使程序更加安全。</p><h5 id="检查数组的性质"><a href="#检查数组的性质" class="headerlink" title="检查数组的性质"></a>检查数组的性质</h5><p>因为以数组为操作数的并且使用typeof操作符。结果都会返回”object”。</p><p>检查一个对象是否是数组的办法：</p><ul><li><p>可以检查对象是否存在数组的一些属性(length)和方如slice()，split()等。以此来确定该值是否具有”数组性质”。</p><p><strong>缺点</strong>：不能保证任何其他非数组对象不能具有相同名称的属性和方法。</p></li><li><p>instance Array进行检查</p><p><strong>缺点：</strong>在某些浏览器版本中的不同框架运行并不正确。</p></li><li><p>ES5中的Array.isAarray()方法。该函数在参数为数组的时候返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([])) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试以一个类似数组的对象欺骗检查</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(&#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">slice</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;))   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果无法使用rray.isAarray()方法， 可以通过调用Object.prototype.toString()方法进行检查。如果在数组上，详细问调用toString()的call()方法，它应该返回”[object Array]”。如果是上下文是对象，则它应该返回字符串”[object object]”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.isArray === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">&quot;[object Array]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON是一种轻量级的数据交换格式。是一个数组和对象字面量表示方法的结合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&#x27;shu&#x27;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>, <span class="string">&quot;some&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br></pre></td></tr></table></figure><h5 id="JSON文字对象之间的区别"><a href="#JSON文字对象之间的区别" class="headerlink" title="JSON文字对象之间的区别"></a>JSON文字对象之间的区别</h5><p>在JSON中，属性名称需要在包装在引号才能成为合法的JSON。</p><p>在对象字面量中。仅当属性名称不是有效的标识符的时候菜会需要使用引号。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;first name&quot;</span>: <span class="string">&quot;jsdhs&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>注意： 在JSON中不能使用正则表达式字面量和函数。</p><h5 id="使用JSON"><a href="#使用JSON" class="headerlink" title="使用JSON"></a>使用JSON</h5><p>使用JSON.parse()解析字符串。</p><p>使用JSON.stringify()将基本数据类型序列化成为一个JSON数组。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式也是对象，可以通过两种方式创建正则表达式：</p><ul><li>使用正则表达式字面量</li><li>使用new RegExp()</li></ul><h5 id="使用正则表达式字面量"><a href="#使用正则表达式字面量" class="headerlink" title="使用正则表达式字面量"></a>使用正则表达式字面量</h5><p>正则表达式字面量表示法使用了些刚（”/“）来包装用于匹配的正则表达式模式。在第二个斜杆之后，可以将该模式修改为不加引号的字母形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /shuliqi/gm</span><br></pre></td></tr></table></figure><h5 id="使用new-RegExp"><a href="#使用new-RegExp" class="headerlink" title="使用new RegExp()"></a>使用new RegExp()</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;shuliqi&quot;</span>, <span class="string">&quot;i&quot;</span>)</span><br></pre></td></tr></table></figure><p>能使用久使用字面量。</p><h3 id="基本值类型包装器"><a href="#基本值类型包装器" class="headerlink" title="基本值类型包装器"></a>基本值类型包装器</h3><p>javascript中的基本数据类型：number，string， boolean，null， undefined。除了null和undefined，其他三个具有所谓的基本包装对象。可以使用内置构造函数Number()，String()和Boolean()创建包装对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个基本数值</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n); <span class="comment">// &quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> nObj);<span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>基本值只要调用包装对象的方法，就可以在后台杯临时转换为一个对象，并且表现得犹如一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来作为对象的基本字符串</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;shu&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.toUpperCase()); <span class="comment">// &#x27;SHU&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值本身可以作为一个对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;mokey&quot;</span>.slice(<span class="number">3</span>,<span class="number">6</span>)); <span class="comment">// &quot;key&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此可看出：基本值也可以充当对象，只要需要他们这么做。但是通常没有理由去使用更长的包装构造函数。</p><p>通常使用包装对象的原因之一是有扩充值及持久保存状态的需要。这是由于基本类型不是对象，他们不可能扩充属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本字符串</span></span><br><span class="line"><span class="keyword">var</span> greet = <span class="string">&quot;shu&quot;</span>;</span><br><span class="line"><span class="comment">// 为了使用slice()方法，基本数据类型杯转换成对象</span></span><br><span class="line"><span class="built_in">console</span>.log(greet.slice(<span class="string">&#x27;&#x27;</span>)[<span class="number">0</span>]); <span class="comment">//  &quot;s&quot;</span></span><br><span class="line"><span class="comment">// 试图添加一个原始数据类型并不会导致错误</span></span><br><span class="line">greet.smile = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 但它并不是实际运行</span></span><br><span class="line"><span class="built_in">console</span>.log(greet.smile) <span class="comment">//&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《javascript设计模式》读书笔记一：编写可维护的代码</title>
      <link href="/2019/05/14/%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%88%E5%9F%BA%E7%A1%80%E6%8A%80%E5%B7%A7%EF%BC%89/"/>
      <url>/2019/05/14/%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%88%E5%9F%BA%E7%A1%80%E6%8A%80%E5%B7%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-尽量少用全局变量"><a href="#一-尽量少用全局变量" class="headerlink" title="一. 尽量少用全局变量"></a>一. 尽量少用全局变量</h3><p>Javascript 使用的是函数作用域，在函数内声明的变量，只有在函数内有效，不能在函数外使用。全局变量则是在函数外部声明，在函数内无需声明就可以使用。</p> <span id="more"></span><p>每一个javascript环境都有一个全局对象，在函数外部使用this进行访问。创建的全局变量都归全局对象所有。</p><p>在浏览器中，使用window表示全局变量本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myName = <span class="string">&quot;haha&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(myName)  <span class="comment">//haha</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.myName) <span class="comment">//haha</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>[<span class="string">&quot;myName&quot;</span>]) <span class="comment">//haha</span></span><br></pre></td></tr></table></figure><h5 id="全局变量的产生"><a href="#全局变量的产生" class="headerlink" title="全局变量的产生"></a>全局变量的产生</h5><p>javascript的两个特性总让我们在不知不觉中就创建了全局变量</p><ol><li><p><strong>可直接使用变量。甚至无需声明</strong></p></li><li><p><strong>javascript有个隐含全局变量。即任何变量，如果未经声明，就为全局对象所有</strong></p><p>例1:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">result = x + y;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong>例子中result未经声明， 归全局对象所有，在一般情况下可以正常使用， 但是在相同的全局命名空间使用了另外的result 变量， 就会有问题。</p><p>带有var声明的链式赋值有可能导致隐含全局变量</p><p>面的例子中你估计想要的结果？</p><p>例2:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = b = <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：a是局部变量，b是全局变量</p><p><strong>原因</strong>：从右到左的操作符优先级。首先是优先级较高的表达式b=0,此时b未经声明(归全局对象所有)。表达式的返回值是0， 被赋给了var声明的局部变量a。</p></li></ol><h5 id="全局变量的问题"><a href="#全局变量的问题" class="headerlink" title="全局变量的问题"></a>全局变量的问题</h5><ol><li><p>全局变量存在于同一个全局命名空间内，很有可能发生命名冲突</p></li><li><p>变量释放时的副作用</p><p>隐含全局变量与明确定义的全局变量有细微的不同。</p><ul><li><p>使用var创建的全局变量（这类变量在函数外部创建），不可以使用delete操作符撤销变量</p></li><li><p>不使用var创建的隐含全局变量（即使它是在函数内部创建），也可以使用delete操作符撤销变量</p><p>例3:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">c = <span class="number">3</span>;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// 企图删除</span></span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">delete</span> b; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> c; <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 测试删除情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a, <span class="keyword">typeof</span> b, <span class="keyword">typeof</span> c)</span><br><span class="line"><span class="comment">// &quot;number&quot;, &quot;undefined&quot;, &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>这说明隐含全局变量不是真正的变量。而是只是全局对象的属性，属性是可以通过delete操作符删除的，但是变量不可以</p><h5 id="如何最小化全局变量的数量"><a href="#如何最小化全局变量的数量" class="headerlink" title="如何最小化全局变量的数量"></a>如何最小化全局变量的数量</h5><ol><li>命名空间模式</li><li>即时函数</li><li>使用var声明变量</li></ol><p>最重要的方式还是使用var声明。上面的例子改造如下：</p><p>例1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = x + y; <span class="comment">// result 就不会变成全局变量。</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a, b；</span><br><span class="line">a = b = <span class="number">0</span>; <span class="comment">//都是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-变量声明提升-凌散变量-的问题"><a href="#二-变量声明提升-凌散变量-的问题" class="headerlink" title="二. 变量声明提升(凌散变量)的问题"></a>二. 变量声明提升(凌散变量)的问题</h3><p>javascript允许在任何地方声明变量，无论在哪里声明，效果都等同于在函数顶部进行声明。这就是<strong>变量声明提升</strong>。注意：提升的只是声明部分，赋值部分不提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;shu&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a) </span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;liqi&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></figure><p><strong>结果：</strong>‘undefined’，’ liqi’</p><p><strong>原因：</strong>在函数getName作用域内，a被看做函数作用域内的变量。函数中所有的变量声明都会被提升的函数的最顶成，但是赋值部分位置不变。所以导致log出：’undefined’， liqi。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;shu&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="built_in">console</span>.log(name) </span><br><span class="line">name = <span class="string">&quot;liqi&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></figure><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>为了避免的这样的混乱， 我们最好在开始就声明要用的变量。</p><h3 id="三-for循环"><a href="#三-for循环" class="headerlink" title="三. for循环"></a>三. for循环</h3><p>for循环常用在数组或者类数组对象（伪数组）上面。类对象数组例如：arguments，HTML DOM对象:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByName()</span><br><span class="line">document.getElementsByClassName()</span><br><span class="line">document.getElementsByTagName()</span><br></pre></td></tr></table></figure><h5 id="通常的for循环使用："><a href="#通常的for循环使用：" class="headerlink" title="通常的for循环使用："></a>通常的for循环使用：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法在于每次循环都需要访问数组的长度。这样会使代码变慢。特别当arr不是数组，是HTML DOM</p><p>对象的时候。更耗时。</p><h5 id="第一种改进的方案："><a href="#第一种改进的方案：" class="headerlink" title="第一种改进的方案："></a>第一种改进的方案：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i) <span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式下， 对长度的值只提取一次。但是可以应用的整个循环。</p><h5 id="第二种改进的方案："><a href="#第二种改进的方案：" class="headerlink" title="第二种改进的方案："></a>第二种改进的方案：</h5><p>逐步减到0，因为同0比较比同数组的长度比较（同非0数组）比较更有效率</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = arr.length; i--;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="两种方式的比较："><a href="#两种方式的比较：" class="headerlink" title="两种方式的比较："></a>两种方式的比较：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;同长度比较&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line"><span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;同长度比较&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;同0比较&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = arr.length; i--;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line"><span class="comment">// 处理arr[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;同0比较&#x27;</span>)</span><br></pre></td></tr></table></figure><p>但是也存在一些缺点，就是处理的顺序倒过来了。</p><h3 id="四-for-in循环"><a href="#四-for-in循环" class="headerlink" title="四. for-in循环"></a>四. for-in循环</h3><p>for-in是用来循环非数组对象的。当遍历对象属性时遇到原型链的属性时，使用hasOwnProperty()方法来过滤是非常重要的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;shu&quot;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将一个方法clone添加到对象上</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype.clone === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免在枚举的时候出现clone()。 需要调用hasOwnproperty()方法来过滤原型链属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(key,<span class="string">&#x27;:&#x27;</span>, obj[key] )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong> name : shu， age : 12</p><h3 id="五-避免使用隐式类型转换"><a href="#五-避免使用隐式类型转换" class="headerlink" title="五.避免使用隐式类型转换"></a>五.避免使用隐式类型转换</h3><p>#####1.字符串连接符与算术运算符（+ - * / %）隐式转换规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="string">&#x27;true&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>结果会是什么样的？</p><p><strong>转换规则：</strong></p><p>​    1.字符串连接符(“+”两边有一边是字符串)：会把其他数据类型调用String()方法然后拼接。</p><p>​    2.运算操作符(除了不是字符串连接符的”+”就都是是运算操作符)：会把其他数据类型调用Number()方法转成数字然后做运算。</p><p>所以例子的结果是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;+“ 是字符串连接符：String(1) + &#x27;true&#x27; = &#x27;1true&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="string">&#x27;true&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;+“ 是算术运算符： 1 + Number(true) = 1 + 1 = 2</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">true</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;+“ 是算术运算符： 1 + Number(undefined) = 1 + NaN = NaN</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> + <span class="literal">undefined</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;+“ 是算数运算符： 1 + Number(null) = 1 + 0 = 1</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span>+ <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h5 id="2-关系运算符-gt-lt-gt-lt-：会把其他数据类型转换成number之后再比较关系"><a href="#2-关系运算符-gt-lt-gt-lt-：会把其他数据类型转换成number之后再比较关系" class="headerlink" title="2.关系运算符( &gt; &lt; &gt;= &lt;= == != === !==)：会把其他数据类型转换成number之后再比较关系"></a>2.关系运算符( &gt; &lt; &gt;= &lt;= == != === !==)：会把其他数据类型转换成number之后再比较关系</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &gt; <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &gt; <span class="string">&#x27;10&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;aad&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> ==  <span class="literal">NaN</span>)</span><br></pre></td></tr></table></figure><p>结果会是什么样的呢？</p><p><strong>转换规则：</strong></p><p>1.关系运算符两边有一边是字符串，会将其使用Number()转成数字，然后比较关系。</p><p>2.关系运算符两边都是字符串，两边按照字符串对应的unicode编码（可以使用charCodeAt()查看）转成数字，然后比较。</p><p>3.当有多个字符串进行比较，依次从左到右比较。</p><p>4.如果数据类型是null，undefined 不是严格比较两者都是相等的。</p><p>5.NaN 类型与任何数据类型比较都是NaN</p><p>所以例子的结果是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false  Number(2) &gt; 10 = 2 &gt; 10 = false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true  &#x27;2&#x27;.charCodeAt() &gt; &#x27;10&#x27;.charCodeAt() = 50 &gt; 49 = true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &gt; <span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>.charCodeAt()); <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>.charCodeAt()); <span class="comment">// 49</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false 先比较a和b：  &#x27;a&#x27;.charCodeAt() &gt; &#x27;b&#x27;.charCodeAt() = 97 &gt; 98 = false,直接得出结果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>.charCodeAt()); <span class="comment">// 97</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>.charCodeAt()); <span class="comment">// 98</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//true 先比较 a和a, 两者相等。则比较b和a：&#x27;b&#x27;.charCodeAt() &gt; &#x27;a&#x27;.charCodeAt() = 98 &gt; 97 = true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span> &gt; <span class="string">&#x27;aad&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true 特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// false 严格比较</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ===  <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true 特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> ==  <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true  特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> ==  <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// false 特殊情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> ==  <span class="literal">NaN</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> ===  <span class="literal">NaN</span>)</span><br></pre></td></tr></table></figure><h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>JavaScript在语句比较时会执行隐式类型转换(除了严格比较)。 有时候自己理不清。最好避免使用。使用就最好使用严格比较如：===,   !==。</p><h3 id="六-避免使用eval"><a href="#六-避免使用eval" class="headerlink" title="六. 避免使用eval()"></a>六. 避免使用eval()</h3><p><strong>eval函数的作用</strong>:  在当前作用域中执行一段JavaScript代码字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> one = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&#x27;one = 3&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="不推荐使用使用eval-的原因"><a href="#不推荐使用使用eval-的原因" class="headerlink" title="不推荐使用使用eval()的原因"></a>不推荐使用使用eval()的原因</h4><h5 id="1-eval-可以访问和修改它外部作用域的变量"><a href="#1-eval-可以访问和修改它外部作用域的变量" class="headerlink" title="1. eval()可以访问和修改它外部作用域的变量"></a>1. eval()可以访问和修改它外部作用域的变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunOne</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> local = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;local = 3; console.log(&quot;eval:&quot;, local)&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(local) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line">myFunOne();</span><br></pre></td></tr></table></figure><h5 id="2-eval-只在被直接调用并且调用函数就是-eval-本身时，才在当前作用域中执行，-否则就是在全局作用域执行"><a href="#2-eval-只在被直接调用并且调用函数就是-eval-本身时，才在当前作用域中执行，-否则就是在全局作用域执行" class="headerlink" title="2.eval() 只在被直接调用并且调用函数就是 eval ()本身时，才在当前作用域中执行， 否则就是在全局作用域执行"></a>2.eval() 只在被直接调用并且调用函数就是 eval ()本身时，才在当前作用域中执行， 否则就是在全局作用域执行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> one = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">eval</span>; <span class="comment">//这里将a变量指向了eval函数的引用</span></span><br><span class="line">    a(<span class="string">&#x27;one = 3&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(one); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这段代码等价于在全局作用域中调用 eval。</p><h5 id="3-安全问题"><a href="#3-安全问题" class="headerlink" title="3.安全问题"></a>3.安全问题</h5><p>eval 也存在安全问题，因为它会执行任意传给它的代码字符串， 在代码字符串未知或者是来自一个不信任的源时就会有安全问题。</p><h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><p>​        绝对不要使用 eval，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。 如果一些情况必        须使用到 eval 才能正常工作，首先它的设计会受到质疑，这不应该是首选的解决方案。</p><h4 id="eval-的替代方式"><a href="#eval-的替代方式" class="headerlink" title="eval() 的替代方式"></a>eval() 的替代方式</h4><p>new Fuction()构造函数和eval()比较类似。如果一定需要使用eval()，那么可以考虑使用new Fuction()来代替eval()。这样的好处是：<strong>new Function()中的代码将在局部函数空间中运行， 因此代码中的任何采用var定义的变量不会自定成为全局变量</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> one); <span class="comment">// &quot;undefine&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> two); <span class="comment">// &quot;undefine&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var one = 1; console.log(one);&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;var two = 2; console.log(two);&#x27;</span>)() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> one); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> two); <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>setInterval(),setTimeout,function()等构造函数来传递参数。在特殊情况下，会导致类似eval()的隐患。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1111&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 认为 &quot;myFun()&quot; 是可执行的代码  不建议这么写</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;myFun()&quot;</span>, <span class="number">1000</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 认为 &quot;myFun(1,2,3)&quot; 是可执行的代码 不建议这么写</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;myFun(1,2,3)&quot;</span>, <span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐这种方式: 函数的引用</span></span><br><span class="line"><span class="built_in">setInterval</span>(myFun, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">myFun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// myFun是对函数的直接调用，也就是说当setInterval还没有开始函数func就执行了, 果这个函数没有返回值或者返回值不是可执行的函数或者其他的代码的话，就以上代码而言只会打印一次。</span></span><br><span class="line"><span class="built_in">setInterval</span>(myFun(), <span class="number">1000</span> ) </span><br></pre></td></tr></table></figure><h3 id="七-不要增加内置的原型"><a href="#七-不要增加内置的原型" class="headerlink" title="七. 不要增加内置的原型"></a>七. 不要增加内置的原型</h3><p>增加内置构造函数（Object(),Array(),Fuction()等）的原型，但是这可能会严重影响可维护性。因为这种做法使得代码更加不可预测。其他开发者在使用你的代码的时候可能期望的内置的Javascript方法，而不是期望有一些你自己添加的方法。</p><p>并且，给原型添加属性在没有使用hasOwnproperpty()时可能会在循环中出现。这会导致一些混乱。</p><h3 id="八-switch模式："><a href="#八-switch模式：" class="headerlink" title="八. switch模式："></a>八. switch模式：</h3><p>可以使用一下switch模式来提高代码的的可读性和健壮性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">result = <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：每一个case 需要有一个明确的break语句</p><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 的双向绑定原理及手把手实现</title>
      <link href="/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>最近在学习<code>Vue</code>，之前一直对<code>Vue</code>的双向数据绑定只算是了解。经过这几天的深入学习。对它的原理有了更加深刻的认识。虽然<code>Vue</code>并没有有完全遵循<code>MVVM模型</code>， 但是它的设计也是受到了<code>MVVM模型</code>的启发。所以它也是能实现双向数据绑定的， 那我们来看<code>mvvm模型</code>的双向数据绑定是什么？其实双向数据绑定实现的效果就是指：模型(<code>model</code>)<code>javaScript</code>中定义的对象，它改变了会同步视图(view)。修改视图()view)也会同步修改数据层；</p><blockquote><p>为什么说 <code>Vue</code> 没有完全遵循 <code>MVVM</code> 吗？ 是以为<code>Vue</code> 提供了<code>ref</code>属性， 通过<code> ref</code> 能够得到dom对象， 通过<code>ref</code> 直接去操作视图，这一点违背了 <code>MVVM</code></p></blockquote> <span id="more"></span><p>演示如下：</p><img src="/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/6.gif" class=""><h1 id="什么是双向数据绑定"><a href="#什么是双向数据绑定" class="headerlink" title="什么是双向数据绑定"></a>什么是双向数据绑定</h1><p>双向数据绑定就是 <code>view </code>层 和 <code>model </code>层 可以互相影响， <code>view</code> 层改变了， 会同步更新<code>mode</code>， <code>model</code> 改变了， 会同步更新 <code>view</code>。</p><h1 id="Vue-双向数据绑定的原理"><a href="#Vue-双向数据绑定的原理" class="headerlink" title="Vue 双向数据绑定的原理"></a>Vue 双向数据绑定的原理</h1><p>我们知道 <code>vue</code> 是双向数据绑定， 它主要是由三个重要部分构成：</p><ul><li>Model(数据层): 应用中的数据或者业务逻辑</li><li>View(视图层): 应用的展示效果，各类的UI组件</li><li>ViewModel(数据视图层):  框架封装的核心，负责将 <code>View</code> 和 <code>Model</code>连接起来</li></ul><h3 id="ViewModel的理解"><a href="#ViewModel的理解" class="headerlink" title="ViewModel的理解"></a>ViewModel的理解</h3><ul><li> 数据变化更新视图</li><li>视图变化更新数据</li></ul><p>它是由两个主要部分组成：</p><ul><li>监听器（Observer）： 对所有的的数据进行监听</li><li>解析器（Compiler）：对每个节点进行扫描和解析，根据指令模板替换内容，以及绑定相应的更新函数</li></ul><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>从开发者的角度去看，视图到<code>data</code>的的改动只需要监听<code>DOM</code>的变化再同步赋值给<code>JavaScript</code>变量即可；如：<code>&lt;input&gt;</code>标签添加<code>change</code>或者<code>input</code>监听事件并在事件处理函数中给变量赋值。其实这也是<code>Vue</code>中<code>v-model</code>指令做的很重要事情。另外数据到视图关键是监听数据的变化，再去更新相应的<code>DOM</code>。那么监听数据的变化有哪些方式呢？。 </p><p>我们知道常见架构模式有<code>MVC</code>, <code>MVP</code>,<code>MVVM</code>模式，目前前端框架基本上都是采用<code>MVVMM</code>实现双向数据绑定。<code>Vue</code>也不例外。各个框架实现双向数据板绑定的方法有有所不同，目前大概有以为这三种：</p><ul><li>发布订阅模式</li><li>数据劫持</li><li><a href="https://www.jianshu.com/p/2b61cd0bcbce">Angular 的脏查机制</a></li></ul><p>而<code>Vue</code>采用的是<strong>数据劫持</strong>和<strong>发布订阅者模式</strong>相结合的方式来实现双向数据绑定。而<strong>数据劫持</strong>主要是通过<code>Object.defineProperty</code>来实现。</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>关于Object.defineProperty 可以看我之前写的一篇文章： <a href="https://shuliqi.github.io/2018/02/19/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Object-defineProperty/">Object.defineProperty</a>。let ，我们主要看它的<code>get</code> 和<code>set</code>能帮我们实现什么？</p><p>我们对一个<code>Javacript</code>变量进行设置值和获取值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">labelName</span>: <span class="string">&quot;标签&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.labelName = <span class="string">&quot;更新标签名字&quot;</span></span><br><span class="line">obj.labelName;</span><br></pre></td></tr></table></figure><p>我们对一个<code>Javacript</code>变量进行设置值和获取值， 除了设置成功和获取成功， 我们是没办法看到其他的变化了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> labelName;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;labelName&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;获取标签名字&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> labelName;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;设置新的标签名&quot;</span>);</span><br><span class="line">    labelName = newValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.labelName = <span class="string">&quot;标签&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.labelName);</span><br></pre></td></tr></table></figure><p>具体的效果如下：</p><img src="/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/2.gif" class=""><p>从上面的例子可以看出，我们在访问<code>JavaScript</code>变<strong>量的时候会自动执</strong>行<code>get</code>函数。设置值得时候会自动执行<code>set</code>函数。</p><h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h2><p>根据上面的两点我们知道<code>Vue</code>是通过数据劫持结合发布订阅模式来实现双向数据绑定，所以实现双向数据绑定就必须实现以下几点：</p><ul><li>实现一个监听器 <code>Observer</code>能够对数据对象的所有属性进行监听；<code>Observer</code>监听器里面使用<code>Object.defineProperty</code>来监听。当属性有变动拿到最新的值和通知订阅者。</li><li>实现一个指令解析器<code>Compile</code>。对每个元素的节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</li><li>实现一个订阅者<code>Watcher</code>，能够订阅并收到每个属性的变动的通知，执行指令绑定的相应的回调函数，从而更新视图；</li><li>由于<code>data</code>的某个<code>key</code>在⼀个视图中可能出现多次，所以每个<code>key</code>都需要⼀个管家<code>Dep</code>来管理多个<code>Watcher</code></li><li>实现入口函数，整合以上三者。</li></ul><p>上面的流程如下图：</p><img src="/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/3.png" class=""><h1 id="监听器Oberver"><a href="#监听器Oberver" class="headerlink" title="监听器Oberver"></a>监听器Oberver</h1><p>监听器的作用是去监听数据的每一个属性，使用上面我们讲的<code>Object.defineProperty</code>来监听属性的变动。我们需要对<code>Observer</code>的数据对象进行递归遍历。使得子属性对象的属性都加上<code>get</code> 和 <code>set</code>函数。这样就能监听到数据的变化了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果数据不存在，或者data 不是一个对象的话， 则不处理</span></span><br><span class="line">  <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    defineObserver(data, key, data[key]);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineObserver</span>(<span class="params">data, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 监听子元素</span></span><br><span class="line">  Observer(data[key]);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value !== newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;监听到变化了&quot;</span>, newValue)</span><br><span class="line">        value = newValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们监听的属性发生变化之后我们需要去通知订阅者<code>Wtcher</code>去执行更新函数更新视图。这个过程中会有很多的订阅者（一个属性就是一个订阅者<code>Watcher</code>）， 所以我们创建一个容器<code>Dep</code>去做一个统一的管理。这个容器维护一个数组，用来收集订阅者。当数据变动触发<code>notify</code>， 然后容器（订阅器）触发订阅者的<code>update</code>方法。最终的的<code>Observer</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Observer</span><span class="params">(data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果数据不存在，或者data 不是一个对象的话， 则不处理</span></span><br><span class="line">  <span class="keyword">if</span> (!data || typeof data !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(data).forEach((key) =&gt; &#123;</span><br><span class="line">    defineObserver(data, key, data[key]);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">defineObserver</span><span class="params">(data, key, value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 监听子元素</span></span><br><span class="line">  Observer(data[key]);</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  Object.defineProperty(data, key, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      <span class="comment">// 把订阅者添加到容器里面，统一管理</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(newValue) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value !== newValue) &#123;</span><br><span class="line">        console.log(<span class="string">&quot;监听到变化了&quot;</span>, newValue)</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="comment">// 通知收集的容器的 notify，notify 去更新每一个订阅者的 update 方法去更新视图</span></span><br><span class="line">        dep.notify();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理每一个订阅者的容器:</span></span><br><span class="line"><span class="comment">// 该容器维护一个数组，用来收集订阅者。</span></span><br><span class="line"><span class="comment">// 该容器有一个 notify 方法 去触发订阅者的 update 去更新视图。</span></span><br><span class="line"><span class="function">function <span class="title">Dep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub: function(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">  &#125;,</span><br><span class="line">  notify: function() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach((sub) =&gt; &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dep.target = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>大家可能对下面这段代码可能不是很理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把订阅者添加到容器里面，统一管理</span></span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    dep.addSub(Dep.target)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码的目的是为了后面写的<code>Watcher</code>. 到哪里我会解释的。</p><p>那么到目前为止，就实现了一个<code>Observer</code>了。已经有监听数据变化和通知订阅者的功能了。</p><h1 id="Compile解析器"><a href="#Compile解析器" class="headerlink" title="Compile解析器"></a>Compile解析器</h1><p><code>Compile</code>主要做的事情就两点:</p><ul><li>解析模板的指令，将模板中的变量替换成数据，然后初始化渲染页面。</li><li>对每个指令对应的节点绑定订阅者（添加更新视图的函数uodate）</li></ul><p>如下图：</p><img src="/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/4.png" class=""><p>因为在解析<code>DOM</code>加点的过程中我们会频繁的操作<code>DOM</code>所以我们利用好文档片段[DocumentFragment]](<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment</a>) 来帮助我们解析`DOM。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.vm = vm;</span><br><span class="line">  <span class="built_in">this</span>.el = vm.$el;</span><br><span class="line">  <span class="built_in">this</span>.fragment = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">  <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 文档片段</span></span><br><span class="line">    <span class="built_in">this</span>.fragment = <span class="built_in">this</span>.nodeFragment(<span class="built_in">this</span>.el);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析DOM元素</span></span><br><span class="line">    <span class="built_in">this</span>.compileNode(<span class="built_in">this</span>.fragment);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析完成添加到元素中去</span></span><br><span class="line">    <span class="built_in">this</span>.el.appendChild(<span class="built_in">this</span>.fragment); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取当前 el 下面的所有元素 放到 文档片段 fragment 里面去</span></span><br><span class="line">  <span class="attr">nodeFragment</span>: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空白的文档片段</span></span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把页面 el 下面的所有 子节点都放到文档片段里面去</span></span><br><span class="line">    <span class="comment">// appendChild:Node.appendChild() 方法将一个节点附加到指定父节点的子节点列表的末尾处。</span></span><br><span class="line">    <span class="comment">// 如果将被插入的节点已经存在于当前文档的文档树中，那么 appendChild() 只会将它从原先的位置移动到新的位置</span></span><br><span class="line">    <span class="comment">//（不需要事先移除要移动的节点）。</span></span><br><span class="line">    <span class="keyword">let</span> child = el.firstChild;</span><br><span class="line">    <span class="keyword">while</span>(child) &#123;</span><br><span class="line">      fragment.appendChild(child);</span><br><span class="line">      child = el.firstChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 解析节点： 也就是替换 &#123;&#123;&#125;&#125;</span></span><br><span class="line">  <span class="attr">compileNode</span>: <span class="function"><span class="keyword">function</span>(<span class="params">fragment</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Node.childNodes 返回包含指定节点的子节点的集合</span></span><br><span class="line">    <span class="keyword">const</span> childNodes = fragment.childNodes;</span><br><span class="line">    [...childNodes].forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isElementNode(node)) &#123;</span><br><span class="line">        <span class="comment">//如果是元素节点</span></span><br><span class="line">        <span class="built_in">this</span>.compile(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文本元素的内容</span></span><br><span class="line">        <span class="comment">// textContent 属性表示一个节点及其后代的文本内容。</span></span><br><span class="line">        <span class="keyword">const</span> text = node.textContent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配插槽如： &#123;&#123; name &#125;&#125;</span></span><br><span class="line">        <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。</span></span><br><span class="line">        <span class="keyword">if</span>(reg.test(text)) &#123;</span><br><span class="line">          <span class="comment">// exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null</span></span><br><span class="line">          <span class="keyword">const</span> prop = reg.exec(text)[<span class="number">1</span>].trim();</span><br><span class="line">          <span class="built_in">this</span>.compileText(node, prop);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.compileNode(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">compile</span>: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Element.attributes 属性返回该元素所有属性节点的一个实时集合。该集合是一个 NamedNodeMap 对象</span></span><br><span class="line">    <span class="keyword">let</span> nodeAttrs = node.attributes;</span><br><span class="line">    [...nodeAttrs].forEach(<span class="function">(<span class="params">attr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = attr.name;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isDirective(name)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="string">&quot;v-model&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> value = attr.value;</span><br><span class="line">          <span class="built_in">this</span>.compileModel(node, value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">compileModel</span>: <span class="function"><span class="keyword">function</span>(<span class="params">node, prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="built_in">this</span>.vm.$data[prop];</span><br><span class="line">    <span class="comment">// 更新 model 类型的 value 值</span></span><br><span class="line">    <span class="built_in">this</span>.updateModel(node, val);</span><br><span class="line">    <span class="comment">// 给 input 框添加 input事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加订阅者</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, prop, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.updateModel(node, newValue);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    node.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newValue = e.target.value;</span><br><span class="line">      <span class="keyword">if</span> (newValue === val) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置新值</span></span><br><span class="line">      <span class="built_in">this</span>.vm.$data[prop] = newValue;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">compileText</span>: <span class="function"><span class="keyword">function</span>(<span class="params">node, prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="built_in">this</span>.vm.$data[prop];</span><br><span class="line">    <span class="built_in">this</span>.updateView(node, val);</span><br><span class="line">    <span class="comment">// 添加订阅者</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, prop, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.updateView(node, newValue);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">updateView</span>: <span class="function"><span class="keyword">function</span>(<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">    node.textContent = value == <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&quot;&quot;</span> : value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">updateModel</span>: <span class="function"><span class="keyword">function</span>(<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">    node.value = <span class="keyword">typeof</span> value == <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&quot;&quot;</span> : value;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否是一个指令</span></span><br><span class="line">  <span class="attr">isDirective</span>: <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> attr.indexOf(<span class="string">&#x27;v-&#x27;</span>) !== -<span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">isElementNode</span>: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// nodeType 属性返回节点类型。</span></span><br><span class="line">    <span class="comment">// 如果节点是一个元素节点，nodeType 属性返回 1。</span></span><br><span class="line">    <span class="comment">// 如果节点是属性节点, nodeType 属性返回 2。</span></span><br><span class="line">    <span class="comment">// 如果节点是一个文本节点，nodeType 属性返回 3。</span></span><br><span class="line">    <span class="comment">// 如果节点是一个注释节点，nodeType 属性返回 8。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素节点：构成了DOM的基础。文档结构中，&lt;html&gt;是根元素，代表整个文档，其他的还有&lt;head&gt;,&lt;body&gt;,&lt;p&gt;,&lt;span&gt;等等。元素节点之间可以相互包含(当然遵循一定的规则)</span></span><br><span class="line">    <span class="comment">// 文本节点：包含在元素节点中。</span></span><br><span class="line">    <span class="comment">// 属性节点：元素都可以包含一些属性，属性的作用是对元素做出更具体的描述，比如id,name之类的。</span></span><br><span class="line">     <span class="keyword">return</span> node.nodeType === <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写<code>Compile</code>时候对下面这段代码比较疑惑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nodeFragment: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空白的文档片段</span></span><br><span class="line">  <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">let</span> child = el.firstChild;</span><br><span class="line">  <span class="keyword">while</span>(child) &#123;</span><br><span class="line">    fragment.appendChild(child);</span><br><span class="line">    child = el.firstChild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>while</code>为啥一直是<code> child = el.firstChild;</code>呢？那岂不是一直都一个元素节点？，其实不是的，这是因为：</p><blockquote><p>appendChild:Node.appendChild() 方法将一个节点附加到指定父节点的子节点列表的末尾处。如果将被插入的节点已经存在于当前文档的文档树中，那么 appendChild() 只会将它从原先的位置移动到新的位置.</p></blockquote><p>哈哈， 豁然开朗！！！</p><p>这里一个<code>Compile</code>就完成了。</p><h1 id="Watcher-订阅者"><a href="#Watcher-订阅者" class="headerlink" title="Watcher 订阅者"></a>Watcher 订阅者</h1><p><code>Watcher</code> 订阅器主要做的事情就两件:</p><ul><li>在自身实例化的时候网订阅器（<code>Dep</code> 容器）添加自己。</li><li>必须有一个<code>uodate</code>方法，目的是为了调用每个订阅者的更新视图的函数（即：接收到通知，执行更新函数）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, prop, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.vm = vm;</span><br><span class="line">  <span class="built_in">this</span>.prop = prop;</span><br><span class="line">  <span class="built_in">this</span>.callback = callback;</span><br><span class="line">  <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  <span class="attr">update</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.vm.$data[<span class="built_in">this</span>.prop];</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value !== oldValue) &#123;</span><br><span class="line">      <span class="built_in">this</span>.callback(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Dep.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 这一步很关键：因为属性被监听，这一步会执行监听器的 get 方法</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.vm.$data[<span class="built_in">this</span>.prop];</span><br><span class="line">    Dep.target = <span class="literal">null</span>; <span class="comment">// 清空订阅器，因为上一步订阅器已经被加上了</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的这段代码很关键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="built_in">this</span>.vm.$data[<span class="built_in">this</span>.prop];</span><br></pre></td></tr></table></figure><p>注意这里是获取<code>属性</code>。在实现<code>Observer</code>监听了所有属性的获取，监听属性的时候我们在<code>get</code>方法有如下的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把订阅者添加到容器里面，统一管理</span></span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    dep.addSub(Dep.target)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里这么写的时候就是跟<code>Watcher</code>的<code> const value = this.vm.$data[this.prop];</code>相呼应的。我们的订阅者就是在这时候添加到容器<code>Dep</code>里面去的。</p><h1 id="实现的入口函数"><a href="#实现的入口函数" class="headerlink" title="实现的入口函数"></a>实现的入口函数</h1><p>上面三个重要的点实现完了。最后就只需要一个入口函数来整合了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyVue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el);</span><br><span class="line">  <span class="built_in">this</span>.$data = options.data;</span><br><span class="line">  <span class="comment">// 监听数据</span></span><br><span class="line">  <span class="keyword">new</span> Observer(<span class="built_in">this</span>.$data);</span><br><span class="line">  <span class="comment">// 解析指令</span></span><br><span class="line">  <span class="keyword">new</span> Compile(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们尝试去修改数据，也完全没问题；</p><img src="/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/5.gif" class=""><p>但是有个问题就是我们修改数据时时通过 <code>vm.$data.name</code> 去修改数据，而不是想 Vue 中直接用 <code>vm.name</code> 就可以去修改，那这个是怎么做到的呢？其实很简单，Vue 做了一步数据代理操作。最新代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js ---&gt; 入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyVue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el);</span><br><span class="line">  <span class="built_in">this</span>.$data = options.data;</span><br><span class="line">  <span class="comment">//数据代理</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.$data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.proxyData(key);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line">MyVue.prototype = &#123;</span><br><span class="line">  <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(<span class="built_in">this</span>.$data);</span><br><span class="line">    <span class="keyword">new</span> Compile(<span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">proxyData</span>: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 代理第一层即可</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, key, &#123;</span><br><span class="line">      <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$data[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果如下：</p><img src="/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/6.gif" class=""><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>最后实现的相关如下：</p><img src="/2019/04/20/Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0/7.gif" class=""><p>如果需要代码的可点击 <a href="https://github.com/shuliqi/MyVue/tree/master">MyVue</a>。最后一点感触， 原理性的东西看懂了原理，还是需要手写一遍， 其中会发现很多意想不到的情况。收获颇多。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的闭包</title>
      <link href="/2018/10/23/JavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
      <url>/2018/10/23/JavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>对于使用过<code>JavaScript</code>的人来说，理解闭包的概念是需要付出非常多的努力和牺牲的。其实很多人在没有理解必闭包之前也已经使用了闭包，但是我们应该根据自己的意愿来正确的识别和使用闭包，这边文章主要是在我看了《你不知道的JavaScript》之后整理的。供自己以后方便查阅。</p><p>在理解闭包之前首先得先理解一下<strong>词法作用域</strong></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域简单的可以说： 作用域的本质是一套规则，规定了变量的生命周期和可使用范围。</p><p>《你不知道的JavaScript上卷》上是这么说的：</p><blockquote><p>作用域就是一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量</p></blockquote><p>作用域的解析方式有两种： </p><ul><li>词法作用域</li><li>动态作用域</li></ul><p>而<code>JavaScript</code>使用的是词法作用域。下面我们来讲词法作用域</p><h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><p>词法作用域也叫静态作用域， 它的作用域在词法分析阶段的时候就已经确定了。是不会再改变了。词法作用域是由你在写代码的时候将变量和代码写在哪里来决定的。这样词法分析器在处理代码的时候就会保持作用域不变。</p><p>而作用域根据代码层次分层，子域可以访问到父作用域，通常沿着链式作用域查找，而父作用域是不能访问子作用域的。</p><p>我们看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>在词法作用域下：</p><ul><li>全局作用域有两个标识:  a,  foo</li><li>foo函数作用域下有一个标识： a</li></ul><p>执行<code>foo()</code>的时候， <code>console.log(a)</code>是在 foo函数作用域下的，并且里面有 a 变量的标识， 所以输出的是 20 而不是 10</p><p>我们举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">    getA();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>在词法作用域下：</p><ul><li>全局作用域两个标识：a，getA,  foo,</li><li>在 foo 函数这个作用域下有一个标识： a</li></ul><p>执行 <code>foo </code>函数的时候，<code>getA()</code> 被执行。但是<code>getA()</code>是定义在全局作用域下的，所以获取到的值是10， 而不是20</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>我们先看闭包的定义，要先掌握它才能更加理解是识别闭包：</p><blockquote><p>当函数可以记住和访问当前的词法作用域时，就产生了闭包。即使这个函数是在当前的词法作用域之外执行的。</p></blockquote><p>我们来看一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>在词法作用域中：</p><ul><li>全局作用域有1一个标识: foo</li><li>在函数 foo 中有两个标识： a, bar</li></ul><p>执行函数<code> foo</code> 的时候， 会去执行<code>bar</code>函数，而bar函数在 <code>foo </code>函数创建的作用域中，并且 <code>foo </code>函数创建的作用域中有 a 变量。所以输出了2。</p><p>上面代码中的 <code>bar</code>函数是闭包吗？ 答案： 这不是闭包， 但是它是闭包中很重要的一部分：根据词法作用域的查找规则，它能够访问外部作用域。</p><p> 我们再看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz(); <span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p>这段代码中的 <code>baz</code>就是一个闭包。<code>bar</code>的词法作用域能够访问<code>foo</code>函数创建的作用域，然后把<code>bar</code>这个函数本身当做返回值，然后在调用<code>foo</code>的时候把 <code>bar</code>的引用复赋值给<code>baz</code>(其实两个标识引用同一个函数)， 所以能够访问<code>foo</code>的作作用域。</p><p>这段代码就验证了前面所讲的定义：即使函数式在当前词法作用域之外执行。</p><p>其实按照正常情况下，引擎有卡机回收机器会释放不在使用的内存空间，如上面的代码中foo执行完之后就会将其回收。但是闭包的神奇之处就在于它可以阻止这件事的发生。</p><p>由于<code>bar</code>声明位置的原因（也就是定义在<code>foo</code>函数创建的作用域中，并且是在<code>a</code> 变量下面），它涵盖了内部作用域的闭包，使得该作用域一直存活，以供<code>bar</code>在之后任何时间进行引用。<code>bar</code>依然有对该作用域的引用，而这个引用就叫做闭包。</p><p>当然，形成闭包的方式不只是有上面这种<strong>在一个函数中return 一个函数的</strong> 的方式。</p><p>如： 无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包的存在：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getValue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(a);</span><br><span class="line">   &#125;</span><br><span class="line">   bar(getValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面这种情况，<code>fn</code> 也是闭包。 把函数<code>foo</code>内部的函数<code> getValue</code> 传递给<code>bar</code>。 当调用<code> foo</code>时会执行<code>bar</code>函数，<code>bar</code>函数里面执行传递进来的函数<code>getValue</code>的引用。所以它是能够访问<code>foo</code>内的作用域的。</p><p>传递函数也可以使间接的， 只要在词法作用域之外调用的是词法作用域内的函数的引用就能够形成闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getValue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(a);</span><br><span class="line">   &#125;</span><br><span class="line">   fn = getValue;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">fn(); <span class="comment">// 1 --&gt;  这也是闭包</span></span><br></pre></td></tr></table></figure><p>所以得到的结论为：</p><blockquote><p>无论通过何种方式将内部函数的引用传递到所在词法作用域之外，它都会保持有对原始定义的作用域的引用，无论在何处执行都会使用闭包。</p></blockquote><h1 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h1><p>闭包是无处不在的，我们不妨来看看几个常用的片段，看看闭包妙在哪里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="string">&quot;舒丽琦&quot;</span>)</span><br></pre></td></tr></table></figure><p>将内部函数<code>timer</code>作为参数传递给 <code>setTimeout</code>。而<code>timer</code>能够访问<code>wait</code>的内部作用域。</p><p>使用过<code>jQuery</code>的人对下面的代码应该知道：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupBot</span>(<span class="params">name,selector</span>)</span>&#123;</span><br><span class="line">    $(selector).click(<span class="function"><span class="keyword">function</span> <span class="title">activator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;message:&quot;</span> + name);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">setupBot(<span class="string">&quot;舒丽琦1&quot;</span>,<span class="string">&quot;#btn_1&quot;</span>);</span><br><span class="line">setupBot(<span class="string">&quot;舒丽琦2&quot;</span>,<span class="string">&quot;#btn_2&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面这个两个例子可以得到结论：</p><blockquote><p>无论何时何地，如果将函数（访问他们各自的词法作用域）当前值类型到处传递，就会看到闭包在这些函数中的应用。在定时器，时间监听，Ajax请求异步或者同步的任务中， 只要有回调函数，实际上就是在使用闭包。</p></blockquote><p> 我们看一个经典的面试题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，我们对这段代码行为的预期是每秒一次输出1~5。</p><p>但实际上，这段代码在运行时会以每秒一次的频率输出五次6。</p><p>这是为什么呢？ 这是因为<code> var</code> 定义了一个全部的变量 i。 当<code>i = 6</code>的时候， 结束了循环。根据词法作用域的原理， 这几个定时器共享同一个全局作用域。定时器执行的时候，全局变量<code> i</code> 已经变成6 了。</p><p>那怎么解决呢？ 我们看下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">      &#125;,j*<span class="number">1000</span>);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用一个立即执行函数把当前 i传递进去，这个立即执行函数有自己的作用域。而我们将一个函数传递给定时器，传递给定时器的函数就会保持对原有的作用域的引用。所有立即函数的作用域不会被回收。所以代码能够符合我们预期的小运行。</p><p>除了这个办法还有别的办法吗？ 有的， 那就是 <code>ES6</code>新出的<code>let</code>就可以解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果按照我们的预期输出。这是为什么呢？</p><ul><li><code>for</code> 有自己的块作用域（（）是父级作用域，{} 是子级作用域）。</li><li><code>let </code>定义的变量只能在自己所在的代码块中有效。</li></ul><p>那么上面可以这个理解：在父级作用域（（））中定义了一个变量 i。 在子级中有一个内部函数，该内部函数使用了 i 这个变量。并且这个函数被当作值传递了出去。所有它持有对原始作用域的引用。</p><p> 上面我们都是识别闭包， 那我们能用闭包来做什么呢？</p><p>我们看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = &#123;</span><br><span class="line">    <span class="attr">age</span> : <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">box.age =  <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(box.age); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>上面的代码中，对象的<code>age</code>属性可以随意的被修改。但是如果我们使用闭包的话，就可以实现私有化，将<code>age</code>属性保护起来，只做允许的修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">addAge</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      ++age;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(age)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">bar.addAge();</span><br><span class="line">bar.getAge();</span><br></pre></td></tr></table></figure><p>这样就能够实现 <code>age </code>属性的私有化了，只允许<code> age</code> 进行加操作。</p><h1 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h1><p>所以我们可以想到的闭包的用途：</p><ul><li>可以获取函数内部的变量</li><li>让变量的值始终保存在内存中， 不会被垃圾回收机制回收</li><li>可以实现私有化</li></ul><p>当然也是有缺点的：</p><ul><li><p>由于使用闭包使得变量始终保存在内存中，内存消耗很大，所以不能滥用，否则会造成网页的性能。</p><p>解决办法： 在退出函数之后将不使用的变量全部删除）</p></li><li><p>闭包会在父函数外面改变内部内部变量的值。</p><p>所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p></li></ul><h1 id="闭包的释放"><a href="#闭包的释放" class="headerlink" title="闭包的释放"></a>闭包的释放</h1><p>上面讲过闭包的会值得变量的值用于保存在内存当中。这样是有可能造成我们网页的性能问题的。那我们该如何去释放闭包呢？</p><p>上面是将内部的引用传递出去， 那么我们把函数的引用改了， 是不是就释放了？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = add(); <span class="comment">// 得到内部函数bar的引用</span></span><br><span class="line">fn(); <span class="comment">// 1</span></span><br><span class="line">fn(); <span class="comment">// 2</span></span><br><span class="line">fn(); <span class="comment">// 3</span></span><br><span class="line">fn = <span class="literal">null</span>; <span class="comment">// 手动释放 bar 的引用</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// bar 的引用 fn 被释放了，现在 f 的作用域也被释放了。num再次归零了。</span></span><br><span class="line">fn = add();</span><br><span class="line">fn(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>手动修改 内部函数的引用， 就释放了当前作用域的了。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>最后来一个面试中经常问到的题目：实现 sum(1)(2)(3) 返回结果是 1,2,3 之和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y + z</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>如果有很多的回调呢？ 怎么办？</p><p>这就需要封装一个 柯里化的函数了， 具体可移步 <a href="https://shuliqi.github.io/2018/10/05/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/">什么是函数柯里化</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是函数柯里化</title>
      <link href="/2018/10/05/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2018/10/05/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是“函数柯里化”"><a href="#什么是“函数柯里化”" class="headerlink" title="什么是“函数柯里化”"></a>什么是“函数柯里化”</h2><blockquote><p>curry的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p></blockquote> <span id="more"></span><p>先看一个简单的例子,add函数接受两个参数，addcurry函数接受一个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCurry</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(addCurry(<span class="number">1</span>)(<span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>由例子可以看出，所谓的“<strong>柯里化</strong>“就是<strong>将一个多参数的函数，转化成单参数的函数</strong>。</p><h2 id="函数柯里化的优点"><a href="#函数柯里化的优点" class="headerlink" title="函数柯里化的优点"></a>函数柯里化的优点</h2><ul><li><p>参数复用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt);</span><br><span class="line">&#125;</span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;test&#x27;</span>)       <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">&#x27;test&#x27;</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCurry</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> hasNumber = checkCurry(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="keyword">const</span> hasLetter = checkCurry(<span class="regexp">/[a-z]+/g</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hasNumber(<span class="string">&#x27;shuliqi11&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(hasNumber(<span class="string">&#x27;shuliqi&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(hasLetter(<span class="string">&#x27;1231231&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便</p></li><li><p>延迟运行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像我们js中经常使用的bind，实现的机制就是Curry</p></li></ul><h2 id="如何实现柯里化"><a href="#如何实现柯里化" class="headerlink" title="如何实现柯里化"></a>如何实现柯里化</h2><p>我们先看一个例子：这里使用了(ramda， 自行安装)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&quot;ramda&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a, b, c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curry_add = _.curry(add);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(curry_add(<span class="number">1</span>)); <span class="comment">// 输出函数</span></span><br><span class="line"><span class="built_in">console</span>.log(curry_add(<span class="number">1</span>)(<span class="number">2</span>)); <span class="comment">// 输出函数</span></span><br><span class="line"><span class="built_in">console</span>.log(curry_add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出结果</span></span><br></pre></td></tr></table></figure><p>栗子中我们对 add 进行了柯里化，从结果上可以看到当参数为 1 个时返回的是个函数，当参数为 2 个的时候返回函数，当参数为 3 个的时候返回<code>函数执行结果</code>。</p><p>根据上述的小栗子，可以得到，<code>柯里化后的函数</code>如果接受到全部参数则返回<code>函数执行结果</code>，否则返回<code>一个柯里化函数</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 假如我们柯里化的函数叫 curry_fn</span></span><br><span class="line"><span class="comment">// if curry_fn接收到的参数等于fn接受</span></span><br><span class="line"><span class="comment">// else return &quot;一个柯里化函数&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述伪代码是不是很像递归？</p><ul><li>递归出口：curry_fn接受到的参数数量等于fn接受参数的数量</li><li>重复逻辑：return “一个柯里化函数”</li></ul><p>于是有了以下简单实现柯里化的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> rest = [...args, ...arguments];</span><br><span class="line">        <span class="keyword">if</span> (rest.length &lt; fn.length) &#123;</span><br><span class="line">            <span class="comment">// 如果传入的参数的个数没有等于 fn 函数的参数的个数，则递归返回</span></span><br><span class="line">            <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn,  rest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行fn</span></span><br><span class="line">            <span class="keyword">return</span> fn.apply(fn, rest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curryAdd = curry(add);</span><br><span class="line"><span class="built_in">console</span>.log(curryAdd(<span class="number">1</span>)(<span class="number">1</span>)(<span class="number">1</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件之间的通讯方式</title>
      <link href="/2018/07/18/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/07/18/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Vue.js 中最强大的功能之一就是组件。而组件实例之间是相互独立的。也就说明了不同的组件之前得数据是不相通的。我们可以先来看看组件之间都存在哪几种关系：</p><img src="/2018/07/18/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/1.png" class=""><p>如上图所示。A 和 B，B 和 C，B 和 D 都是父子关系，C 和 D 是兄弟关系。A 和 C，A 和 D都是隔代关系（这里只是隔了一代，但其实业务场景中，可能隔很多代）</p><p>那针对不同的使用场景。怎么选择有效的通信方式呢？</p><h1 id="方式一：props-emit"><a href="#方式一：props-emit" class="headerlink" title="方式一：props / $emit"></a>方式一：props / $emit</h1><p>这种方式适合父子关系的的组件。可能也是我们在写代码中最常用到的传递数据的方式了吧。<strong>父级组件通过<code>props</code>向子组件传递。而子组件通过<code>$emit</code>来向父组件通信</strong></p><p>举个例子：</p><p><strong>parent.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父级组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childen</span> <span class="attr">:name</span>=<span class="string">&quot;name&quot;</span></span></span><br><span class="line"><span class="tag">             @<span class="attr">onUpdateName</span>=<span class="string">&quot;onUpdateName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">childen</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> children <span class="keyword">from</span> <span class="string">&quot;./children&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      children</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      onUpdateName (newName) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.name = newName;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>children.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    姓名：&#123;&#123; name &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;onUpdate&quot;</span>&gt;</span>点击更新名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">name</span>: <span class="built_in">String</span> <span class="comment">// 父组件传下来的值</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      onUpdate () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 子组件向父组件传值：</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 子组件通过 event 给父组件发送消息</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;onUpdateName&quot;</span>, <span class="string">&quot;新的名字&quot;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>父组件传值给子组件：通过<code>props</code>向下传递数据给子组件</p></li><li><p>子组件传值给父组件：通过<code>events</code>给父组件发送消息。也就是将自己的数据发送给父组件。</p></li></ul><blockquote><p><strong>注意：</strong>在子组件中无法修改父组件传递下来的值（单向数据流）</p></blockquote><h1 id="方式二：-parent-children"><a href="#方式二：-parent-children" class="headerlink" title="方式二：$parent/$children"></a>方式二：$parent/$children</h1><p>这种方式是个父子组件。我们直接看<code>vue</code>的官方是怎么解释的；</p><img src="/2018/07/18/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/2.png" class=""><p>由上面的解释，我们可以知道：通过<code>$parent</code> 和 <code>$children</code>就可以访问组件的实例。拿到实例就可以访问组件的所有方法和<code>data</code>。</p><p>我们看看例子：</p><p><strong>parent.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;isShowChildrenName&quot;</span>&gt;</span> 姓名：&#123;&#123; this.$children[0].name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">&quot;onUpdateChildren&quot;</span>&gt;</span>点击更新子组件名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">children</span> <span class="attr">:parentName</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> children <span class="keyword">from</span> <span class="string">&quot;./children&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      children</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">     <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;父组件的名字&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">isShowChildrenName</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">     &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.isShowChildrenName = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 修改自身的name</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">uodateName</span>(<span class="params">newName</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.name = newName;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 修改子组件的name</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">onUpdateChildren</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$children[<span class="number">0</span>]);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//  this.$children[0].name = &quot;新的子组件的名字&quot;; //  直接修改子组件 data 的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$children[<span class="number">0</span>].updateName(<span class="string">&quot;新的子组件的名字&quot;</span>); <span class="comment">// 调用父组件的方法</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>children.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：&#123;&#123; parentName &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;onUpdateParent&quot;</span>&gt;</span>点击更新父组件名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">parentName</span>: <span class="built_in">String</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;子组件的名字&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 修改父组件的name</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">onUpdateParent</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$parent.name = <span class="string">&quot;新的父组件的名字&quot;</span>; <span class="comment">// 直接修改父组件 data 的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.$parent.uodateName(&quot;新的父级的组件的名字&quot;); // 调用父组件的方法</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 修改自身的name</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">updateName</span>(<span class="params">newName</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.name = newName;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在父组件中， 我们可以通过<code>this.$children</code> 拿到所有的子实例（注意：<code>this.$children</code>是一个数组，所有子实例的集合）。拿到实例之后可以访问实例的方法和代码。</p><p>在子组件中，我们可以通过<code>this.$parent</code>来访问父实例。拿到实例之后就可以访问父实例的方法和<code>data</code>。</p><blockquote><p>注意：在 ·#app·上拿到的<code>$parent</code>得到的是 <code>new Vue()</code>实例。在这实例拿到的<code>$parent</code>是<code>undefined</code>；而在最低层拿到的<code>$children</code> 是空数组。也要注意得到<code>$parent</code>和<code>$children</code>的值不一样，<code>$children</code> 的值是数组，而<code>$parent</code>是个对象</p></blockquote><h1 id="方式三：ref-refs"><a href="#方式三：ref-refs" class="headerlink" title="方式三：ref/$refs"></a>方式三：ref/$refs</h1><p><code>ref</code>如果是在普通的元素上使用，引用指向的是<code>DOM</code>元素；如果是用在组件上，引用指向的是组件的实例，可以通过实例直接使用组件上的方法或者访问数据。<code>$refs</code>是所有<code>ref</code>的集合。可通过<code>this.$refs[&lt;ref设置的名字&gt;]</code>来取到相应的实例或者元素。</p><p><strong>parent.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">P</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;isShowChildrenName&quot;</span>&gt;</span>名字：&#123;&#123;this.$refs.childrenRef.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">&quot;onUpdateChildren&quot;</span>&gt;</span>点击更新子组件名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">children</span> <span class="attr">ref</span>=<span class="string">&quot;childrenRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> children <span class="keyword">from</span> <span class="string">&quot;./children&quot;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    children</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">isShowChildrenName</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.isShowChildrenName = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">onUpdateChildren</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$refs.childrenRef.updateName(&quot;新的组件的名字&quot;); // 调用子组件的方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$refs.childrenRef.name = <span class="string">&quot;新的组件的名字&quot;</span>; <span class="comment">// 调用子组件的data</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>children.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">P</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">name</span>:<span class="string">&quot;子组件的名字&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">updateName</span>(<span class="params">newName</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.name = newName;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="方式四：provide-inject"><a href="#方式四：provide-inject" class="headerlink" title="方式四：provide/ inject"></a>方式四：provide/ inject</h1><p>这是<code>Vue2.2.0</code>增加的<code>api</code>。在父组件通过<code>provide</code>来提供变量。子组件通过<code>inject</code>来注入变量。这里不论子组件的嵌套有多深，只要父组件调用了<code>provide</code>，无论在多深嵌套的子组件中都可以<code>inject</code>数据。</p><ul><li><strong>provide</strong>：一个对象或者一个返回一个对象的函数。改对象包含可注入子孙的属性</li><li><strong>inject</strong>：一个字符串/数组/对象</li></ul><p>例子1：</p><p><strong>A.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是最上层组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">B</span>&gt;</span><span class="tag">&lt;/<span class="name">B</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">&quot;./B&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    B</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">provide</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">name</span>: <span class="string">&quot;父组件的名字&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>B.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是中间层组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">C</span>&gt;</span><span class="tag">&lt;/<span class="name">C</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> C <span class="keyword">from</span> <span class="string">&quot;./C&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    C</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>C.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是最底层组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>最上层组件的name值：&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">inject</span>: [<span class="string">&quot;name&quot;</span>]</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后我们页面是这样的：</p><img src="/2018/07/18/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/3.png" class=""><p>我们可以看出来，在父组件<code>provide</code>一个<code>name</code>属性。在<code>C.vue</code>组件是可以<code>inject</code>到的。</p><p>但是现在有个问题： 我们父组件<code>provide</code>的<code>name</code>是固定的一个字符串。但是想要<code>provide</code>的属性是响应式的，这能做到的吗？我们看官方的解释：</p><blockquote><p><code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</p></blockquote><p>那我们父组件改成这样是不是就可以了？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是最上层组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">B</span>&gt;</span><span class="tag">&lt;/<span class="name">B</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;onUpdateParent&quot;</span>&gt;</span>点击最上层组件名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">&quot;./B&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    B</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">name</span>: <span class="string">&quot;父组件的名字&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">name</span>: <span class="built_in">this</span>.name</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">onUpdateParent</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.name = <span class="string">&quot;最上层组件的新的名字呀&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>经过验证，子组件页面都没办法实现响应更新<code>this.name</code>值。可能是我们对官方的解释有点误解；</p><p><strong>如果把函数赋值给<code>provide</code>的一个属性，这个函数返回父组件动态的数据，然后在子组件调用函数。是不是就可以了？</strong></p><p>答案是可以的<strong>因为这种方式的函数是保存了父组件的实例的引用，这样子组件每次拿到的数据就是最新的了</strong></p><p>最终需要修改的组件代码如下：</p><p><code>A.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是最上层组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">B</span>&gt;</span><span class="tag">&lt;/<span class="name">B</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;onUpdateParent&quot;</span>&gt;</span>点击最上层组件名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">&quot;./B&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    B</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">name</span>: <span class="string">&quot;父组件的名字&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">getName</span>: <span class="function">() =&gt;</span> <span class="built_in">this</span>.name</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">onUpdateParent</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.name = <span class="string">&quot;最上层组件的新的名字呀&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>C.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是最底层组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>最上层组件的name值：&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">inject</span>: [<span class="string">&quot;getName&quot;</span>],</span></span><br><span class="line"><span class="javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">    name () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">this</span>.getName();</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果:</p><img src="/2018/07/18/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/4.gif" class=""><p>可以看出来，子组件得到响应的数据了。</p><h1 id="方案五：eventBus"><a href="#方案五：eventBus" class="headerlink" title="方案五：eventBus"></a>方案五：eventBus</h1><p><code>eventBus</code>又称为事件总线，在<code>Vue</code>中可以使用它来作为沟通桥梁的概念，就像是所有组件公用相同的事件中心，可以向该中心注册发送事件/接受事件，组件也可以通知其他组件。</p><p><strong>缺点：</strong>当项目比较大的时候，就容易造成难以维护的灾难。</p><p>这种方式既适合父子组件也适合兄弟组件以及嵌套很深的组件，本例子是拿的兄弟组件来说明</p><p>那么如何使用<code>eventBus</code>呢？具体的来说可以有以下这几个步骤：</p><p><strong>初始化</strong></p><p>首先创建一个事件总线并将其导出，以便于其他模块可以使用或者监听它。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 初始化事件总线，并将其导出</span><br><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">export default new Vue();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>发送和接受事件</strong></p><p><strong>A.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">B</span>&gt;</span><span class="tag">&lt;/<span class="name">B</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">C</span>&gt;</span><span class="tag">&lt;/<span class="name">C</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">&quot;./B&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> C <span class="keyword">from</span> <span class="string">&quot;./C&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      B,</span></span><br><span class="line"><span class="javascript">      C</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>A组件引入了B,C组件，为兄弟组件</p><p><strong>B.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">P</span>&gt;</span>B组件名字：&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">&quot;onUpdateNameOfC&quot;</span>&gt;</span>修改兄弟组件C组件的名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&quot;./eventBus&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;我是B组件的名字&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">onUpdateNameOfC</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 发送事件</span></span></span><br><span class="line"><span class="javascript">        eventBus.$emit(<span class="string">&quot;updateNameByB&quot;</span>, <span class="string">&quot;我的 B组件，触发 C组件 的事件去修改name&quot;</span>);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 接收事件</span></span></span><br><span class="line"><span class="javascript">      eventBus.$on(<span class="string">&quot;updateNameByC&quot;</span>, <span class="function">(<span class="params">newName</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.name = newName;</span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>B组件发送了<code>updateNameByB</code>事件和接收(监听)了<code>updateNameByC</code>组件</p><p><code>C.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">P</span>&gt;</span>C组件的名字： &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">&quot;onUpdateNameOfB&quot;</span>&gt;</span>修改兄弟组件B组件的名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&quot;./eventBus&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;我是C组件的名字&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">onUpdateNameOfB</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 发送事件</span></span></span><br><span class="line"><span class="javascript">        eventBus.$emit(<span class="string">&quot;updateNameByC&quot;</span>, <span class="string">&quot;我的 C组件，触发 B组件 的事件去修改name&quot;</span>);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 接收事件</span></span></span><br><span class="line"><span class="javascript">      eventBus.$on(<span class="string">&quot;updateNameByB&quot;</span>, <span class="function">(<span class="params">newName</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.name = newName;</span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>C组件发送了<code>updateNameByC</code>事件和接收(监听)了<code>updateNameByB</code>组件</p><p>我们来看着例子的最终结果：</p><img src="/2018/07/18/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/5.gif" class=""><h1 id="方式六：-attrs-listeners"><a href="#方式六：-attrs-listeners" class="headerlink" title="方式六：$attrs/$listeners"></a>方式六：$attrs/$listeners</h1><p>在<code>Vue2.4</code>中引入了<code>$attrs</code>和<code>$listeners</code>。父作用域中不作为<code>prop</code>被识别（且获取）的特定绑定（除了 <code>class</code>和<code>style</code>），将会”回退“且作为普调的<code>HTML</code>特性应用在子组件的根元素上。</p><p><strong>A.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">B</span>  <span class="attr">:name</span>=<span class="string">&quot;name&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:age</span>=<span class="string">&quot;age&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:sex</span>=<span class="string">&quot;sex&quot;</span> </span></span><br><span class="line"><span class="tag">        @<span class="attr">updateName</span>=<span class="string">&quot;updateName&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:class</span>=<span class="string">&quot;isActive&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:style</span>=<span class="string">&quot;isStyle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">B</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">&quot;./B&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      B,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>:<span class="number">18</span>, </span></span><br><span class="line"><span class="javascript">        <span class="attr">sex</span>: <span class="string">&quot;女&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">isActive</span>: <span class="string">&quot;isActive&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">isStyle</span>: <span class="string">&quot;color: red&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">updateName</span>(<span class="params">name</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.name = name;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>B.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">C</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">C</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> C <span class="keyword">from</span> <span class="string">&quot;./C&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      C</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">age</span>: <span class="built_in">Number</span> <span class="comment">// 父级传进来的 age 值， 我们使用props接受了， 那么$attrs将不会再把这个值向下传递</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>C.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">&quot;onUpdateName&quot;</span>&gt;</span>点击更新最上层的name值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      name,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;this.$attrs:&quot;</span>,<span class="built_in">this</span>.$attrs);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;this.$listeners:&quot;</span>,<span class="built_in">this</span>.$listeners);</span></span><br><span class="line"><span class="javascript">      </span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">onUpdateName</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$listeners.updateName(<span class="string">&quot;新的名字&quot;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面这个例子中：</p><ul><li><p>A组件向B组件传递了<code>name</code>，<code>age</code>，<code>sex</code>。绑定<code>class</code>值为<code>isActive</code>的值，绑定的<code>style</code>值为``isStyle`的值。</p></li><li><p>B组件中使用<code>v-bind=&quot;$attrs 将父级传下来的值传给C 组件（不包含class。style和在组件中使用</code>props接收的值<code>）</code>props<code>接收了</code>age<code>值，说明</code>VM.$attrs`将不包含这个值。</p></li><li><p>C组件使用<code>props</code>接收<code>name</code>值，说明<code>VM.$attrs</code>将不包含这个值。在生命周期打印<code>$attrs)</code>和<code>$listeners</code>。</p><p>最后有一个更新按钮去触发<code>this.$listeners.updateName(&quot;新的名字&quot;)</code>A组件的事件去修改<code>name</code>值</p></li></ul><p>最后我们来看结果：</p><img src="/2018/07/18/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%89%8D%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/6.gif" class=""><p>结果是符合我们预期的，这种方式的通信还是挺好的</p><p>最后 以上的例子柯点击：<a href="https://github.com/shuliqi">shuliqi</a>/**<a href="https://github.com/shuliqi/vue-communication">vue-communication</a>**。查看的时候，可以通过切换<code>App.vue</code>不同的通讯方式的文件来体验：</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于this的指向问题</title>
      <link href="/2018/07/02/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/02/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>this关键字是<code>JavaScript</code>中最复杂的机制之一，是一个特别的关键字，被自动定义在所有函数的作用域中，但是相信很多<code>JavaScript</code>开发者并不是非常清楚它究竟指向的是什么。听说你很懂this,是真的吗？</p> <span id="more"></span><h2 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h2><p><strong>函数的<code>this</code>指向在函数定义的时候是不能确定的。只有在函数执行的时候才能确定函数的<code>this</code>指向谁</strong></p><p>总结普通函数的绑定规则主要分为以下这几种：</p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>默认绑定是在不能应用其他绑定规则的时候使用的默认规则， 通常是独立函数调用。</p><p>例子1:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line">getName(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>在调用<code>getName</code>的时候，使用了默认绑定，<code>this</code>指向了全局对象。严格模式下，<code>this</code>指向<code>undefined</code>，``undefined`上没有this对象，会抛出错误。</p><p>这里例子是<code>window</code>调用了独立的函数，<code>this</code>就是指向<code>window</code>（非严格模式就是<code>windom </code>）</p><p>这里的例子可以这么看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line"><span class="built_in">window</span>.getName(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>函数的调用时在某个对象上触发的。即调用位置上存在上下文对象。典型的形式为<code> XXX.fun()</code>。</p><p>例子2:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;shuliqi2222&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: getName,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;shuliqi11111&#x27;</span>;</span><br><span class="line">person.getName(); <span class="comment">// shuliqi2222</span></span><br></pre></td></tr></table></figure><p>是对象<code>person</code>调用函数<code>logName</code>， 所以<code>this</code>指向<code>person</code>。</p><p><code>getName</code>函数在外部声明， 严格来说并不属于<code>person</code>，但是在调用<code>getName</code>时,调用位置会使用<code>person</code>的上下文来引用函数，隐式绑定会把函数调用中的<code>this</code>(即此例<code>getName</code>函数中的this)绑定到这个上下文对象（即此例中的<code>person</code>）.</p><p>注意：<strong>对象属性链中只有最后一层会影响到调用位置</strong></p><p>例子3:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;shuliqi11111&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: getName,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;shuliqi2222&#x27;</span>,</span><br><span class="line">    <span class="attr">person</span>: person1,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line">person2.person.getName(); <span class="comment">// shuliqi11111</span></span><br></pre></td></tr></table></figure><p>因为只有最后一层会确定<code>this</code>指向的是什么，不管有多少层，在判断this的时候，我们只关注最后一层，即此处的<code>person</code>。</p><p><strong>隐式绑定</strong>有一个很大的缺陷，就是很容易丢失（即容易给我们造成误导，我们以为<code>this</code>指向的是什么，但是实际上并非如此）</p><p>例子4:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;shuliqi11111&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: getName,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;shuliqi2222&#x27;</span>,</span><br><span class="line">    <span class="attr">person</span>: person1,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> logName = person2.person.getName;</span><br><span class="line">logName(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>为什么结果是 <code>shuliqi</code>？</p><p>这是因为l<code>ogName</code> 直接指向了<code>getName</code>的引用， 跟<code>person</code>没关系。针对此类问题，我建议大家只需牢牢继续这个格式:<code>XXX.fn();fn()</code>前如果什么都没有，那么肯定不是隐式绑定。</p><p>除了上面这种丢失之外，隐式绑定的丢失是发生在回调函数中(事件回调也是其中一种)，我们来看下面一个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;YvetteLau&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,&#x27;</span>,<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Christina&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">&#x27;Wiliam&#x27;</span>;</span><br><span class="line">person1.sayHi();</span><br><span class="line"><span class="built_in">setTimeout</span>(person2.sayHi,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    person2.sayHi();</span><br><span class="line">&#125;,<span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, Wiliam</span><br><span class="line">Hello, Wiliam</span><br><span class="line">Hello, Christina</span><br></pre></td></tr></table></figure><ul><li><p>第一条输出很容易理解，<code>setTimeout</code>的回调函数中，<code>this</code>使用的是默认绑定，非严格模式下，执行的是全局对象</p></li><li><p>第二条输出是不是有点迷惑了？说好<code>XXX.fun()</code>的时候，<code>fun</code>中的<code>this</code>指向的是<code>XXX</code>呢，为什么这次却不是这样了！<code>Why</code>?</p><p>其实这里我们可以这样理解: <code>setTimeout(fn,delay)&#123; fn(); &#125;</code>,相当于是将<code>person2.sayHi</code>赋值给了一个变量，最后执行了变量，这个时候，<code>sayHi</code>中的<code>this</code>显然和<code>person2</code>就没有关系了。</p></li><li><p>第三条虽然也是在<code>setTimeout</code>的回调中，但是我们可以看出，这是执行的是<code>person2.sayHi()</code>使用的是隐式绑定，因此这是<code>this</code>指向的是<code>person2</code>，跟当前的作用域没有任何关系。</p></li></ul><h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><p>显示绑定就是通过<code>apply</code>，<code>call</code>，<code>bind</code>的方法， 显示的指定<code>this</code>所指的对象。</p><p><code>apply</code>，<code>call</code>，<code>bind</code>的第一个参数都是该函数this所指的对象。 <code>call</code>，<code>apply</code> 是一样的， 都会立即执行，只是传参方式不同。<code>call</code>和<code>apply</code>都会执行对应的函数，而<code>bind</code>方法不会。<code>apply</code>的第二个参数是一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;YvetteLau&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Wiliam&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = person.sayHi;</span><br><span class="line">Hi.call(person); <span class="comment">//Hi.apply(person)</span></span><br></pre></td></tr></table></figure><p>结果：<code>Hello, YvetteLau</code>。因为明确将<code>this</code>绑定在了<code>person</code>上</p><p>那么，使用了硬绑定，是不是意味着不会出现隐式绑定所遇到的绑定丢失呢？显然不是这样的，不信，继续往下看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;YvetteLau&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Wiliam&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi); </span><br></pre></td></tr></table></figure><p>输出的结果是 H<code>ello, Wiliam.</code> 原因很简单，<code>Hi.call(person, person.sayHi)</code>的确是将<code>this</code>绑定到Hi中的<code>this</code>了。但是在执行<code>fn</code>的时候，相当于直接调用了<code>sayHi</code>方法(记住<code>: person.sayH</code>i已经被赋值给<code>fn</code>了，隐式绑定也丢了)，没有指定<code>this</code>的值，对应的是默认绑定。</p><p>如果我们现在希望绑定不要丢失， 我们该怎么做？ 很简单， 在调用<code>fn</code>的时候也是用显示绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;YvetteLau&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Wiliam&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure><p>此时，输出的结果为<code>: Hello, YvetteLau</code>，因为<code>person</code>被绑定到<code>H</code>i函数中的<code>this</code>上，fn又将这个对象绑定给了<code>sayHi</code>的函数。这时，<code>sayHi</code>中的<code>this</code>指向的就是<code>person</code>对象。</p><p>如果我们将<code>null</code>或者是<code>undefined</code>作为<code>this</code>的绑定对象传入<code>call</code>、<code>apply</code>或者是<code>bind</code>,这些值在调用时会被忽略，实际应用的是默认绑定规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;shuliqi11111&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: getName,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;shuliqi&#x27;</span></span><br><span class="line">hi.call(<span class="literal">null</span>, person.getName);  <span class="comment">//  shuliqi</span></span><br></pre></td></tr></table></figure><h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><p><code>new</code>的原理：</p><ul><li>创建一个空对象</li><li>将空对象的原型指向构造函数的原型属性，从而继承构造原型上的方法（<code>newObj.__proto__ === Fn.prototype</code>）</li><li> 将构造函数的<code>this</code>指向新建的对象，并且执行构造函数的代码，从而获得构造函数的私有属性</li><li>最后看构造函数是否是返回一个对象，如果是直接返回该对象，如果不是， 则返回我们新建对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;shuliqi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFn = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(newFn.name); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>这里<code>newFn</code>对象子所以可以点<code>name</code>出来，是因为<code>new</code>关键字可以改变<code>this</code>指向。</p><p><strong>实现new:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyNew</span>(<span class="params">Fn, ...args</span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建一个空对象</span></span><br><span class="line">  <span class="comment">// 2. 将空对象的原型指向构造函数的原型属性，从继承构造函数原型的方法（obj.__proto__ === Fn.prototype）</span></span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Fn.prototype);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 将构造函数的thia，指向新建的对象，并且执行构造函数，从而获得私有属性</span></span><br><span class="line">  <span class="keyword">const</span> result = Fn.apply(obj, args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.如果构造函数返回的是对象， 我们就返回此对象，不然返回新建的对象</span></span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span>  ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> MyPeople  = MyNew(People, <span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(MyPeople); <span class="comment">// People &#123; name: &#x27;shuliqi&#x27; &#125;</span></span><br><span class="line">MyPeople.getName(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><h3 id="普通函数的绑定优先级"><a href="#普通函数的绑定优先级" class="headerlink" title="普通函数的绑定优先级"></a>普通函数的绑定优先级</h3><p>我们知道了this有四种绑定规则，但是如果同时应用了多种规则，怎么办？</p><p>显然，我们需要了解哪一种绑定方式的优先级更高，这四种绑定的优先级为:</p><p><code>new</code>绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><strong>箭头函数<code>this</code>的定义： 箭头函数的<code>this</code>在定义的时候绑定。而不是在执行的时候绑定。它的<code>this</code>指向在定义的时候继承自外层第一个普通函数的<code>this</code>。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;shuliqi11111&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> logName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">        logName();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">person.getName(); <span class="comment">// shuliqi11111</span></span><br></pre></td></tr></table></figure><p>内层箭头函数<code>logName</code>本身并没有<code>this</code>对象。它的<code>this</code>对象来自于外层作用域。<code>logName</code>函数的外层函数<code>getName</code>是一个普通的函数。 它是有<code>this</code>值的指向<code>person</code>对象。所以<code>logName</code>函数的<code>this</code>指向<code>person</code>对象。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的原型链</title>
      <link href="/2018/06/01/JavaScript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/06/01/JavaScript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>对于<code>JavaScript</code>中的原型链，一直很疑惑，看不懂，最近读到一篇文章，觉得豁然开朗。记录一下。关于<code>javaScript</code>为什么会有原型链，可以点击 <a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">Javascript继承机制的设计思想</a>讲得非常清楚</p><h1 id="普通对象和函数对象"><a href="#普通对象和函数对象" class="headerlink" title="普通对象和函数对象"></a>普通对象和函数对象</h1><p>在 <code>JavaScript</code>中除了基本数据类型之外（引用数据类型），都是对象，但是对象也分为<strong>普调对象</strong> 和 <strong>函数对象</strong>。<code>Object</code>和<code>Function</code> 是自带的函数对象。</p><p><code>typeof</code>能判断引用数据类型是什么类型的对象，所以我们使用<code>typeof </code>来判断一下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1= &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2= <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">const</span> obj3 = <span class="keyword">new</span> f1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj1); <span class="comment">// object --&gt; 普通对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj2); <span class="comment">// object --&gt; 普通对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj3)  <span class="comment">// object --&gt; 普通对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>);   <span class="comment">// function --&gt; 函数对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">// function --&gt; 函数对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1); <span class="comment">// function --&gt; 函数对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f2); <span class="comment">// function --&gt; 函数对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f3); <span class="comment">// function --&gt; 函数对象</span></span><br></pre></td></tr></table></figure><p>上面中 <code>obj1</code>,<code>obj2</code>,<code>obj3</code>都是普通对象，内置的 <code>Function</code>，<code>Object</code>都是函数对象，<code>f1</code>,<code>f2</code>,<code>f3</code>都是函数对象。</p><p>它们之前的区分是什么？ </p><blockquote><p>凡是通过<code>new Function()</code>创建的对象都是函数对象，其他的都是普通对象。</p></blockquote><p>F3 通过 <code>new Function </code>创建的，所以是函数对象，<code>Object</code>和<code>Function</code> 是自带的函数对象。<code>f1</code>,<code> f2</code>归根到底通过<code>new Function</code> 创建的。可能会觉得<code>f1</code>,<code> f2</code>会觉得有点疑惑。 我们验证一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//  true</span></span><br><span class="line"><span class="built_in">console</span>.log(f2 <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//  true</span></span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> MyPerson(<span class="string">&quot;舒丽琦&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> MyPerson(<span class="string">&quot;shuliqi&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor === MyPerson); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor === MyPerson); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这个例子中 <code>MyPerson</code> 我们叫构造函数， <code>person1</code> 和<code> person2</code> 是构造函数  <code>MyPerson</code> 的实例<code>person1</code> 和<code> person2</code> 这两个实例都有一个 <code>constructor </code>属性，这个属性是一个指针，指向构造函数<code> MyPerson</code></p><h1 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h1><p>在<code>JavaScript</code>中， 每当定义一个对象（函数也是对象）的时候， 对象中都会有一些预定义的属性。其中每个<strong>函数对象</strong>都会有<code>prototype</code>属性。这个属性指向个对象的<strong>原型对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个对象 MyPerson</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义的这个对象的有一个prototype， 指向对象的原型</span></span><br><span class="line">MyPerson.prototype = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;人类&quot;</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&quot;高高高级开发&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> MyPerson(<span class="string">&quot;舒丽琦&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> MyPerson(<span class="string">&quot;shuliqi&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// 舒丽琦</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName()); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>上面代码中， 我们定义了一个对象（<code>MyPerson</code>），因为是定义的函数对象，所以有<code>prototype</code>属性。这个属性指向对象原型（<code>MyPerson.prototype</code>的就是原型对象 ）。</p><p> 很容易看出原型对象就是一个普通的对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPerson</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> MyPerson.prototype ); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>而普通对象是由构造器 <code>Object</code>构造的， 下面会讲到构造器。</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><blockquote><p>默认情况下，所有的原型对象都会自动获得一个<code> constructor</code> 属性（构造函数属性），这个属性是一个指针，指向<code>prototype</code> 属性所在的函数（<code>MyPerson</code>）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个对象 MyPerson</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象 MyPerson 的原型的 constructor 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(MyPerson.prototype.constructor === MyPerson); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在上面的小节中，我们实例的<code>constructor</code>（构造函数属性）指向构造函数<code>person1.constructor === MyPerson</code>。 这两个指向是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个对象 MyPerson</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyPerson 的实例 person1</span></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> MyPerson(<span class="string">&quot;舒丽琦&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 MyPerson 的原型的 constructor 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(MyPerson.prototype.constructor === MyPerson); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例的 constructor 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor === MyPerson); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>person1</code>为什么会有<code> constructor</code> 属性？ 那是因为<code>person1</code>是<code>MyPerson </code>的实例。</p><p>但是<code>MyPerson</code>的原型对象（<code>MyPerson.prototype</code>）为什么有 <code>constructor</code> 属性？ 同理，<code>MyPerson.prototype</code> 应该就是 MyPerson 的一个实例。</p><p>也就是说明在定义一个函数对象的时候， 创建了一个它自己的实例对象，并且赋值给它的原型对象。类似如下的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> A = <span class="keyword">new</span> Person();</span><br><span class="line"> Person.prototype = A;</span><br><span class="line"><span class="comment">// 注：上面两行代码只是帮助理解，并不能正常运行</span></span><br></pre></td></tr></table></figure><p>那么我们可以得到这样结论：</p><blockquote><p>原型对象是构造函数的一个实例</p></blockquote><p><strong>注意：</strong>如果我们改写了 对象原型，那么原型的<code>constructor</code>就不是<code>MyPerson</code>了， 已经被改写了</p><h2 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h2><p>以上我们可以知道，原型对象是一个普通的对象，但是 <code>Function.prototype</code>是一个例外，它不是普通对象而是函数对象？ 并且它没有<code>prototype</code>属性（前面讲过：函数对象都有<code>prototype</code>属性）为什么？ </p><p>根据上面<code>constructor</code>这个小节可知：原型对象是构造函数的一个实例。那么<code>Function.prototype</code>就是 <code>Function</code>的一个实例。类似下面这样的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">new</span> <span class="built_in">Function</span> ();</span><br><span class="line"><span class="built_in">Function</span>.prototype = A;</span><br></pre></td></tr></table></figure><p>而上面我们提到<strong>凡是通过 new Function() 产生的对象都是函数对象</strong>。上面的<code>A</code>是函数对象，所以<code>Function.prototype</code>是一个函数对象。</p><h2 id="原型的作用"><a href="#原型的作用" class="headerlink" title="原型的作用"></a>原型的作用</h2><p>那原型对象是用来最什么的呢？ 它的主要做作用是是继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name; <span class="comment">// 这个this 指的是 new 出来的实例</span></span><br><span class="line">  <span class="built_in">this</span>.age = age; <span class="comment">// 这个this 指的是 new 出来的实例</span></span><br><span class="line">&#125;</span><br><span class="line">MyPerson.prototype = &#123;</span><br><span class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> MyPerson(<span class="string">&quot;舒丽琦&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName()); <span class="comment">// 舒丽琦</span></span><br></pre></td></tr></table></figure><p>上面代码中， 我们改了 <code>MyPerson</code>的原型，使其有一个 <code>getName</code>方法。<code>person1</code>是<code>MyPerson</code>的一个实例。这个实例继承了对象原型的方法。</p><p>关于是如何继承， 我们就需要讲到下面的原型链了。</p><h1 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a>_<em>proto</em>_</h1><p><code>JavaScript</code>在创建对象的时候（不论是函数对象还是普通对象），都有一个叫做<code>__proto__</code>属性。这属性指向创建它的构造函数的原型对象。</p><p>那根据以上全部我们可以得到 一个实例与它构造函数，构造函数的原型对象之间的关系如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个对象 MyPerson</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MyPerson 的实例 person1</span></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> MyPerson(<span class="string">&quot;舒丽琦&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === MyPerson.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor === MyPerson); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(MyPerson.prototype.constructor === MyPerson); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以得出很重要的一点：<strong>实例与构造原型对象之间是通过<code>__proto__</code>来进行链接</strong></p><h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><p>我们创建一个对象的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>它等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p><code>obj </code>是构造函数 <code>Object</code> 的一个实例； 所以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.constructor === <span class="built_in">Object</span></span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p>新对象<code>obj</code>是使用<code>new</code>操作符后跟一个构造函数来创建的。构造函数<code>Object</code> 本身就是一个函数对象。它和我们之前的构造函数<code>MyPerson</code>是差不多的。只不多这个函数是出自于创建新对象的目的而定义的。</p><p>同理，可以创建对象的构造器不仅仅有<code>Object</code>还有其他的构造器如：<code>Array</code>，<code>Date</code>，<code>Function</code>等。</p><p>用不同的构造器来创建不同的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor === <span class="built_in">Array</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === <span class="built_in">Array</span>.prototype);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s.constructor === <span class="built_in">String</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s.__proto__ === <span class="built_in">String</span>.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(d.constructor === <span class="built_in">Date</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(d.__proto__ === <span class="built_in">Date</span>.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">console</span>.log(f.constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f.__proto__ === <span class="built_in">Function</span>.prototype);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line"><span class="built_in">console</span>.log(n.constructor === <span class="built_in">Number</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(n.__proto__ === <span class="built_in">Number</span>.prototype);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br><span class="line"><span class="built_in">console</span>.log(b.constructor === <span class="built_in">Boolean</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__ === <span class="built_in">Boolean</span>.prototype);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>而这些构造器都是函数对象：</p><img src="/2018/06/01/JavaScript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/1.png" class=""><p>所以我们自己写构造函数（ MyPerson）和构造器都会有<code>Function</code>构造的。</p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>总结一下全部的知识点</p><ul><li><p>每个函数对象都有<code>prototype</code>属性，指向自己的原型、</p></li><li><p>每个对象都有<code>__proto__</code>属性， 指向自构造自己的构造函数的的原型。</p></li><li><p>构造函数和构造器一样都是函数对象，是由<code>Function</code>构造的。所以构造函数的原型的<code>__proto__</code>属性指向<code>Function.prototype</code>。</p></li><li><p>而构造函数的原型也是对象， 也有<code>__proto__</code>属性，构造函数的原型都是普通对象。所以指向 <code>Object.prototype</code></p></li><li><p>而<code>Function.prototype</code>也是一个对象，也有<code>__proto__</code>属性。在<code>JavaScript</code>中万物皆对象。所以<code>Function.prototype</code>是由<code>Object</code>构造的。所以<code>Function.prototype</code>的<code>__proto__</code>属性指向 <code>Object</code>的原型。prototype`。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.prototype</code>也是一个对象，也有<code>__proto__</code>属性。但是它指向 <code>null</code>， 指原型链的终点。</p></li></ul><p>​                                                                                                                   </p><p>而上面的对象也原型之前是通过<code>__proto__</code>来进行链接。这样就构成了原型链。</p><p>根据以上内容，我们来做做下面的测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPeople</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> MyPeople();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><code>person1.__proto__ === ?</code></li><li><code>MyPeople.__proto__ === ?</code></li><li><code>Person.prototype.__proto__ === ?</code></li><li><code>Object.__proto__ === ?</code></li><li><code>Function.prototype === ?</code></li><li><code>Object.prototype.__proto__  === ?</code></li></ol><ul><li><p><code>person1.__proto__ === ?</code>:</p><p>每个对象都有<code>__proto__</code>属性，指向当前对象的构造函数的原型，<code>person1</code>的构造函数是<code>MyPeople</code>。所以：<code>person1.__proto__ === MyPeople.prototype</code></p></li><li><p><code>MyPeople.__proto__ === ?</code>:</p><p><code>Person</code> 也是一个对象, 所以它也有<code>__proto__</code>属性， 指向当前对象的构造函数的原型。我们自己写的构造函数和自带的构造器是一样的都是函数对象，所以<code>MyPeople</code>的构造函数是<code>Function</code>。所以：<code>MyPeople.__proto__ === Function.prototype</code>。</p></li><li><p><code>Person.prototype.__proto__ === ？</code>:</p><p>构造函数的原型也是一个对象，也有<code>__proto__</code>属性。构造函数的原型都是普调对象。普通对象的话那就是由构造器<code>Object</code> 构造的。 所以：<code>Person.prototype.__proto__</code> === Object.prototype </p></li><li><p><code>Object.__proto__ === ?</code></p><p>构造器<code>Object</code>也是一个对象，也有<code>__proto__</code>属性。 构造器跟我们自己写的构造函数一样， 都是函数对象，所以<code>Object</code>是由<code>Function</code>构造的。 所以：<code>Object.__proto__ === Function.prototype</code>。</p></li><li><p><code>Function.prototype === ?</code></p><p><code>Function.prototype</code>也是一个对象。但是它比较特，他是函数对象（前面讲过构造函数的原型就是一个普通函数）。并且它没有<code>prototype</code>属性。在<code>JavaScript</code>中万物皆对象。所以<code>Function.prototype</code>是由<code>Object</code>构造的。所以<code>Function.prototype__proto__ === Object.prototype</code>。</p></li><li><p><code>Object.prototype.__proto__  === ?</code></p><p><code>Object.prototype</code>也是一个对象，也有<code>__proto__</code>属性。但是它比较特殊，它为<code>null</code>,<code>null</code>为原型链的顶端。</p></li></ul><p>测试结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPeople</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> MyPeople();</span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === MyPeople.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(MyPeople.__proto__ === <span class="built_in">Function</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(MyPeople.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ ===  <span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以现在来看这个原型链图应该明白很多：</p><img src="/2018/06/01/JavaScript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/3.png" class=""><p>也可以对比网上的图</p><img src="/2018/06/01/JavaScript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/4.png" class=""><p>参考文章：</p><ul><li><p><a href="https://www.jianshu.com/p/dee9f8b14771">https://www.jianshu.com/p/dee9f8b14771</a></p></li><li><p><a href="https://www.jianshu.com/p/652991a67186">https://www.jianshu.com/p/652991a67186</a></p></li><li><p><a href="https://www.jianshu.com/p/a4e1e7b6f4f8">https://www.jianshu.com/p/a4e1e7b6f4f8</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x的生命周期详解</title>
      <link href="/2018/04/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/04/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>使用<code>Vue</code>开发已经有一段时间了。但发现自己对<code>vue</code>的理解还是不深刻。于是想着从观看<code>Vue</code>文档开始。在阅读文档之前，觉得需要先了解整个<code>Vue</code>的生命周期，清楚的认识到<code>Vue</code>在每个阶段的钩子函数没这样才能更好的让我们去使用<code>Vue</code>。</p><p>我们先来看一张图，上面解释每个步骤是做什么的。可以只看这一张图就可以明白Vue实例的整个流程。</p><img src="/2018/04/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/3.png" class=""><p>每个<code>Vue</code>实例在被创建之前都要经历过一系列的初始化过程，这个过程就是<code>Vue</code>的生命周期。浅显的来说，生命周期的钩子函数就是回调函数，在不同的阶段有不同的回调函数供用户处理自定义的事件。也可以说生命周期是一套流程，而这套流程里面的方法会有先后顺序的执行（调用就执行，不调用就不执行）。</p><h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p>从上面的图中会看到生个<code>vue</code>的生命周期钩子：</p><ul><li><p>beforeCreate</p></li><li><p>created</p></li><li><p>beforeMount</p></li><li><p>mounted</p></li><li><p>beforeUpdate</p></li><li><p>updated</p></li><li><p>beforeDestroy</p></li><li><p>destroyed</p></li></ul><p>当然除了实例的生命周期，还有其他的：</p><ul><li>activated： keep-alive 缓存组件激活时使用</li><li>deactivated： keep-alice 缓存组件停用时使用</li><li>errorCaptured： 捕获一个来自子孙组件的错误时调用</li></ul><h2 id="beforeCreate-之前"><a href="#beforeCreate-之前" class="headerlink" title="beforeCreate 之前"></a>beforeCreate 之前</h2><p>在<code>beforeCreate</code>生命周期之前。首先是使用<code>new Vue</code>来开始创建一个<code>Vue</code>实例、接下来会初始化这个实例的生命周期事件。如下图：</p><img src="/2018/04/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/1.png" class=""><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue2.x生命周期学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">     <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;舒丽琦&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">getMessage</span>(<span class="params"></span>)</span> &#123; </span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="string">`方法返回：<span class="subst">$&#123;<span class="built_in">this</span>.message&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">      beforeCreate () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;------beforeCreate------&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;el:&quot;</span>, <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;data:&quot;</span>, <span class="built_in">this</span>.$data);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;methods:&quot;</span>, <span class="built_in">this</span>.getMessage);</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">   &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------beforeCreate------</span><br><span class="line">el: undefined</span><br><span class="line">data: undefined</span><br><span class="line">methods: undefined</span><br></pre></td></tr></table></figure><h2 id="beforeCreate-和-created-之间"><a href="#beforeCreate-和-created-之间" class="headerlink" title="beforeCreate 和 created 之间"></a>beforeCreate 和 created 之间</h2><p>在这个生命周期之前，会初始化当前实例上的<code>data</code> 和<code>methods</code>。说明<code>created</code>的时候数据已经绑定，是可以访问到了。在这里可以做<code>ajax</code>请求了。</p><p><strong>注意：</strong>这里还没有 <code>el</code> 选项。</p><img src="/2018/04/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/2.png" class=""><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue2.x生命周期学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;舒丽琦&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">getMessage</span>(<span class="params"></span>)</span> &#123; </span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="string">`方法返回：<span class="subst">$&#123;<span class="built_in">this</span>.message&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">      beforeCreate () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;------beforeCreate------&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;el:&quot;</span>, <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;data:&quot;</span>, <span class="built_in">this</span>.$data);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;methods:&quot;</span>, <span class="built_in">this</span>.getMessage);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">      created () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;------created------&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;el:&quot;</span>, <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;data:&quot;</span>, <span class="built_in">this</span>.$data.message);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;methods:&quot;</span>, <span class="built_in">this</span>.getMessage());</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">   &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">------beforeCreate------</span><br><span class="line">el: undefined</span><br><span class="line">data: undefined</span><br><span class="line">methods: undefined</span><br><span class="line">------created------</span><br><span class="line">el: undefined</span><br><span class="line">data: 舒丽琦</span><br><span class="line">methods: 方法返回：舒丽琦</span><br></pre></td></tr></table></figure><p>可以看出，<code>created</code>可以获取<code>data</code>和<code>methods</code></p><h2 id="created-和-beforeMount-之间的生命周期"><a href="#created-和-beforeMount-之间的生命周期" class="headerlink" title="created 和 beforeMount 之间的生命周期"></a>created 和 beforeMount 之间的生命周期</h2><img src="/2018/04/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/5.png" class=""><p>这阶段里面首先会判断是否有<code>el</code>选项。如果有的话，那么继续往下编译，如果没有<code>el</code>选项。则停止编辑。也就意味停止了生命周期。直到该<code>Vue</code>实例上调用了<code>Vm.$mount(el)</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue2.x生命周期学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// el: &#x27;#app&#x27;, // 被注释掉了</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;舒丽琦&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">getMessage</span>(<span class="params"></span>)</span> &#123; </span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="string">`方法返回：<span class="subst">$&#123;<span class="built_in">this</span>.message&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;------created--------&quot;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;------beforeMount------&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;el:&quot;</span>, <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;data:&quot;</span>, <span class="built_in">this</span>.$data.message)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;methods:&quot;</span>, <span class="built_in">this</span>.getMessage());</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">   &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">------created--------</span><br></pre></td></tr></table></figure><p>手动调用实例的<code>Vm。$mount(#app)</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue2.x生命周期学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// el: &#x27;#app&#x27;, // 被注释掉了</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;舒丽琦&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">getMessage</span>(<span class="params"></span>)</span> &#123; </span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="string">`方法返回：<span class="subst">$&#123;<span class="built_in">this</span>.message&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;------created--------&quot;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;------beforeMount------&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;el:&quot;</span>, <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;data:&quot;</span>, <span class="built_in">this</span>.$data.message)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;methods:&quot;</span>, <span class="built_in">this</span>.getMessage());</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">   &#125;)</span></span><br><span class="line"><span class="javascript">   vm.$mount(<span class="string">&quot;#app&quot;</span>); <span class="comment">// 手动调用了 Vm.$mount(el)</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果打印：</p><p>然后会判断是否有<code>template</code>。有没有<code>template</code>对生命周期没有影响。</p><ul><li>如果有<code>template</code>则直接作为模板编译成render函数；</li><li>如果没有<code>template</code>则直接将外部的<code>html</code>作为模板编译；</li></ul><p><strong>注意：</strong><code>template</code>模板的优先级要高于外部<code>html</code>的优先级。</p><p>如下的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue2.x生命周期学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是外部的html模板:&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;舒丽琦&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">template</span>: <span class="string">&quot;&lt;span&gt;这是内部的模板：&#123;&#123;message&#125;&#125;&lt;/span&gt;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">getMessage</span>(<span class="params"></span>)</span> &#123; </span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="string">`方法返回：<span class="subst">$&#123;<span class="built_in">this</span>.message&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">   &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开之后，我们看到的页面文案是：”这是内部的模板：舒丽琦”</p><p>如果我们把<code>template</code> 删除掉那么就会显示：”这是外部的html模板:舒丽琦”6</p><h2 id="beforeMount-和-mounted之前的生命周期"><a href="#beforeMount-和-mounted之前的生命周期" class="headerlink" title="beforeMount 和 mounted之前的生命周期"></a>beforeMount 和 mounted之前的生命周期</h2><img src="/2018/04/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/6.png" class=""><p>这期间<code>Vue</code>实例对象添加<code>$el</code>。把内存中渲染好的html 替换到页面上。覆盖<code>$el</code>指定的页面。因为在这之前的<code>beforeCreate</code>生命周期打印的<code>el</code>还是<code>undefined</code>。</p><h2 id="mounted生命周期"><a href="#mounted生命周期" class="headerlink" title="mounted生命周期"></a>mounted生命周期</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue2.x生命周期学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是外部的html模板:&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;舒丽琦&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">template</span>: <span class="string">&quot;&lt;span&gt;这是内部的模板：&#123;&#123;message&#125;&#125;&lt;/span&gt;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">getMessage</span>(<span class="params"></span>)</span> &#123; </span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="string">`方法返回：<span class="subst">$&#123;<span class="built_in">this</span>.message&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;--------mounted--------&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;el:&quot;</span>, <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">   &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------mounted--------</span><br><span class="line">el: &lt;span&gt;​这是内部的模板：舒丽琦​&lt;/span&gt;​</span><br></pre></td></tr></table></figure><p>在这之前的<code>span</code>标签的名字是  占位的。这是<code>JavaScript</code>中的虚拟<code>DOM</code>形式存在的。在<code>mounted</code>之后就可以看到了内容发生了变化。</p><h2 id="beforeUpdate-和-updated-之间的生命周期"><a href="#beforeUpdate-和-updated-之间的生命周期" class="headerlink" title="beforeUpdate 和 updated 之间的生命周期"></a>beforeUpdate 和 updated 之间的生命周期</h2><img src="/2018/04/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/7.png" class=""><p>从图中可以看出来， 当<code>data</code>的数据发生了变化，先会触发<code>beforeUpdate</code>钩子。注意这时候页面的视图还没更新。然后才重新渲染组件。最后调用<code>updated</code>。调用完之后。视图和<code>data</code>都是最新的。</p><p>我们看下面的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue2.x生命周期学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是外部的html模板:&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;老的数据&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">beforeUpdate</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;--------beforeUpdate--------&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;el:&quot;</span>, <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;--------updated--------&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;el:&quot;</span>, <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">   &#125;)</span></span><br><span class="line"><span class="javascript">   vm.message = <span class="string">&quot;新的数据&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><img src="/2018/04/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/8.png" class=""><p>当数据<code>data</code>有改变的（ vm.message = “新的数据”）。就会分别触发<code>beforeUpdate</code> 和 <code>updated</code>。</p><h2 id="beforeDestroy-和-destroyed-之间的生命周期"><a href="#beforeDestroy-和-destroyed-之间的生命周期" class="headerlink" title="beforeDestroy 和 destroyed 之间的生命周期"></a>beforeDestroy 和 destroyed 之间的生命周期</h2><img src="/2018/04/17/Vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/9.png" class=""><p><strong>beforeDestroy</strong> 生命周期是在实例被销毁之前调用。在这一步，实例仍然是可用的。</p><p><strong>destroyed</strong>生命周期是在实例销毁之后调用。调用后。<code>Vue</code>实例所指的所有东西都会被解除绑定。所有的事件也会被移除。所有的子实例也会被销毁。</p><h2 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h2><p><code>keep-alive</code> 缓存组件激活的时候使用</p><h2 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h2><p> <code>keep-alive</code> 缓存组件停用时使用</p><h2 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h2><p>捕获子孙组件的错误时调用</p><h2 id="数据请求在created和mouted的区别"><a href="#数据请求在created和mouted的区别" class="headerlink" title="数据请求在created和mouted的区别"></a>数据请求在created和mouted的区别</h2><p><code>created</code>是在组件实例一旦创建完成的时候立刻调用，这时候页面<code>dom</code>节点并未生成，<code>mounted</code>是在页面<code>dom</code>节点渲染完毕之后就立刻执行的，触发时机上<code>created</code>是比<code>mounted</code>要更早的：两者相同点：都能拿到实例对象的属性和方法；讨论这个问题本质就是触发的时机，放在<code>mounted</code>请求有可能导致页面闪动（页面<code>dom</code>结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在<code>create</code>生命周期当中</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debounce和Throttle的原理及实现</title>
      <link href="/2018/04/16/Debounce%E5%92%8CThrottle%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/04/16/Debounce%E5%92%8CThrottle%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h1><p>在处理诸如<code>resize</code>,<code>scroll</code>,<code>mousemove</code> 和 <code>keydown</code>, <code>keyup</code>,<code>keypress</code>等事件的时候， 我们通常不希望这些事件太过频繁的触发。尤其是监听程序中涉及到大量的计算或者是非常耗资源的操作。</p> <span id="more"></span><p>有多频繁呢？ 我们以<code>mousemove</code>为例，根据 <a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-type-mousemove">DOM Level 3</a> 的规定,。</p><blockquote><p>A <a href="https://www.w3.org/TR/DOM-Level-3-Events/#user-agent">user agent</a> MUST dispatch this event when a pointing device is moved while it is over an element. The frequency rate of events while the pointing device is moved is implementation-, device-, and platform-specific, but multiple consecutive <a href="https://www.w3.org/TR/DOM-Level-3-Events/#mousemove"><code>mousemove</code></a> events SHOULD be fired for sustained pointer-device movement, rather than a single event for each instance of mouse movement. Implementations are encouraged to determine the optimal frequency rate to balance responsiveness with performance.</p></blockquote><p>大概的意思就是：<strong>如果鼠标连续的移动，那么浏览器就应该触发多个连续的<code>mousemove</code>事件。</strong></p><p>这就说明了浏览器在其内部计时器允许的情况下，根据用户鼠标的速度来触发<code>mousemove</code>事件。(当然了， 如果移动鼠标足够快，比如“刷”的一下扫过去，浏览器是不会触发的这个事件的），<code>resize</code>,<code>scroll</code> 和<code>key*</code>等事件于此类似。</p><p>具体的可以看例子体会下 <a href="https://codepen.io/shuliqi/pen/NWGNXWv?editors=1010">鼠标滑动 </a></p><h1 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h1><p> DOM事件里的<code>debounce</code>概念其实是从机械开关和继电器的“去弹跳(debounce)”衍生出来的，基本的思路就是把多个信号的合并为一个信号。</p><p>在Javascript中， <code>debounce</code>函数所做的事情就是：强制某一个函数在某个连续的时间段内只执行一次，哪怕它本来会被调用很多次。即我们希望用户在停止某个操作一段时间之后才执行相应的舰艇函数，而不是在用户操作的过程中，浏览器触发多少次事件，就执行多少次舰艇函数。</p><p>比如，在某个5s的时间段内连续移动了鼠标，浏览器就可能会触发几十个（甚至几百个）<code>mousemove</code> 事件， 不使用<code>debounce</code>的话，监听函数就要执行这么多次；如果对监听函数使用1000ms的“去弹跳”。 那么浏览器就只会<strong>执行一次</strong>这个监听函数， 而且是在第6s的时候执行的。</p><p>那如何实现一个<code>ddebunce</code> 函数呢？</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们<code>debunce</code>函数接受三个参数， 第一个参数是要“去弹跳”的回调函数<strong>func</strong>, 第二个参数是延迟的时间<strong>wait</strong>，第三个参数<strong>immediate</strong>表示在wait 这个时间区间内做开始执行(<strong>immediate = true</strong>)还是最后执行(<strong>immediate = false</strong>)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* debounce函数， 返回函数连续调用时， 空闲时间必须大于或者等于wait, func 才会执行</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>func 回调函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>wait 回调函数延迟调用的时间</span></span><br><span class="line"><span class="comment">* param &#123;booleam&#125; 是否为立即调用</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;function&#125;</span> </span>返回客户调用函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate = <span class="literal">true</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, args;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 延迟执行函数</span></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 延迟执行函数执行完毕，  需要清除定时器序号</span></span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 首次进入， 没有延迟函数，创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = later();</span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        <span class="comment">// 如果立即执行， 则调用函数</span></span><br><span class="line">        func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存调用函数时的上下文和参数</span></span><br><span class="line">        context = <span class="built_in">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果已经存在延迟函数，清除，再重新设定</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>其实原理很简单，<code>debounce</code>返回了一个闭包， 这个闭包依然会被连续的频繁的调用。但是在闭包的内部， 却限制了原始函数<strong>func</strong>的执行， 强制<strong>func</strong>只能在连续操作停止后只执行一次。</p><h3 id="调用及例子"><a href="#调用及例子" class="headerlink" title="调用及例子"></a>调用及例子</h3><p>调用方式如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wwindow.addEventListener(<span class="string">&#x27;resize&#x27;</span>, debounce(handle, <span class="number">1000</span>, <span class="literal">false</span>))</span><br></pre></td></tr></table></figure><p><strong><a href="https://codepen.io/shuliqi/pen/vYNGeZR">一个小小的keydown例子</a></strong></p><h1 id="Throttle"><a href="#Throttle" class="headerlink" title="Throttle"></a>Throttle</h1><p><code>throttle</code>理解起来更容易，就是<code>固定函数执行的速率</code> 即所谓的<code>节流</code>。举个例子，正常的情况下，<code>mousemove</code>的监听函数可能会20ms(假设)执行一， 如果设置200ms的”节流“。那么它就会<strong>每200ms</strong>执行一次。 比如在1s的时间段内，正常的监听函数可能会执行50（1000/20）次。”节流”的就会执行5（1000/200）次。</p><p>我们来看个例子：**<a href="https://codepen.io/shuliqi/pen/WNQGQbV">例子</a>**无论我鼠标移动的有多快， 我的count 都是匀速（每隔1s）增加。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>与<code>debounce</code>类似， 我们<code>throttle</code>    也接收<code>func</code>（一个实际要执行的函数），<code>wait</code>一个执行时间间隔值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>func &#123;Function&#125;   实际要执行的函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>wait &#123;Number&#125;  执行间隔，单位是毫秒（ms）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;Function&#125;</span>     </span>返回一个“节流”函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context, args;</span><br><span class="line">  <span class="comment">// 设置前一个函数调用的时间戳</span></span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">if</span> (!previous) &#123;</span><br><span class="line">      <span class="comment">// 首次进入</span></span><br><span class="line">      previous = now;</span><br><span class="line">     </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      context = <span class="built_in">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="keyword">let</span> remaining = wait - (now - previous);</span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        previous = now;</span><br><span class="line">        context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用及例子-1"><a href="#调用及例子-1" class="headerlink" title="调用及例子"></a>调用及例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, throttle(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><p><code>throttle</code>常用的场景是限制<code>resize</code>和<code>scroll</code>的触发频率。我们以scroll 为例子**<a href="https://codepen.io/shuliqi/pen/NWGRGQr">scroll例子</a> <a href="https://codepen.io/shuliqi/pen/ExVKwEW">resize例子</a> ** </p><h1 id="可视化解释"><a href="#可视化解释" class="headerlink" title="可视化解释"></a>可视化解释</h1><p>如果还是不能完全体会<code>debounce</code>和<code>throttle</code>的差异， 可以看这个例子 <strong><a href="http://demo.nimius.net/debounce_throttle/">可视化例子</a></strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>debounce</code>强制函数在某段时间内只执行一次，<code>throttle</code>强制函数以固定的速率执行，在处理一些高频率触发的DOM 事件的时候， 它们都能极大提高用户体验。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记-Class</title>
      <link href="/2018/04/10/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Class/"/>
      <url>/2018/04/10/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Class/</url>
      
        <content type="html"><![CDATA[<p><code>ES6</code>的<code>Class</code>很多大部分的功能，<code>ES5</code>都是可以实现的， 但是为什么还有出<code>Class</code>呢? 这是因为<code>ES5</code>中生成实例对象的方法是通过构造函数生成的。 这与我们所接触的很多语言（C++）差异很大。于是<code>ES6</code>就提供了跟传统语言的写法。可以说<code>Class</code>是一个语法糖。</p><span id="more"></span><h1 id="类与ES5"><a href="#类与ES5" class="headerlink" title="类与ES5"></a>类与ES5</h1><p><code>ES6</code>的<code>Class</code>与<code>ES5</code>的构造函数有什么不一样呢？</p><p>我们先看<code>ES5</code>如何生成实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 父类实例对象属性：name</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">   <span class="comment">// 父类实例对象属性：age</span></span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型方法</span></span><br><span class="line">People.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型方法</span></span><br><span class="line">People.prototype.getNane = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new 操作符生成实例对象people</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;shuliqi&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(people)</span><br><span class="line">people.getAge();  <span class="comment">// 18</span></span><br><span class="line">people.getNane(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>上面代码我们有一个构造函数<code>People</code> ；<code>this</code>关键字代表实例对象，实例对象上有两个属性（<code>name</code>, <code>age</code> ） 在原型有两个方法（<code>getName</code>, <code>getAge</code>）。通过<code>new</code>的方式生成实例对象<code>people</code>；</p><p>我们把上面的代码改成用<code>class</code>来写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改成class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">     <span class="comment">// 父类实例对象属性：name</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">     <span class="comment">// 父类实例对象属性：age</span></span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法</span></span><br><span class="line">  <span class="function"><span class="title">getNane</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法</span></span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new 操作符生成实例对象people</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;shuliqi&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">people.getAge();  <span class="comment">// 18</span></span><br><span class="line">people.getNane(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>上面代码我们定义来看一个 类叫<code>People</code>；里面的<code>constructor</code>方法就是构造方法、<code>this</code>表示实例对象(也就是<code>new People</code>返回的对象)的本身。<code>People</code>类里有 <code>getName</code>,<code>getAge</code>原型方法。<strong>类里面的方法都是在类的原型上创建的</strong>我们在<strong>类里面写方法的时候是不需要写<code>function</code>关键字</strong>；并且<strong>方法与方法之间是不需要逗号分隔的，加了反而会报错</strong></p><p>总归来说， <code>ES6</code>的类就是构造函数的另外一种写法。为什么这么说呢？我们对比一下<code>ES5</code>:</p><ul><li><p><strong>类的数据类型就是函数。类本身就指向构造函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> People); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(People.prototype.constructor === People); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> People); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(People.prototype.constructor === People); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用类的时候都是直接通过<code>new</code>的命令来使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure></li><li><p><strong><code>ES6</code>的类也有在<code>prototype</code>属性。类中定义的所有方法都是定义在类的<code>prototype</code>属性上面</strong>；</p><p>首先我们先来了解<code>ES5</code>的一些概念：</p><p><strong>构造函数：</strong></p><p>js规定，每个构造函数都有一个<code>prototype</code>属性，指向另外一个对象（我们也叫原型对象或者<code>prototype对象</code>），这个对象的所有属性和方法都会被构造函数所拥有，我们通常把不变的方法方法定义在<code>prototype对象</code>上，这样构造函数生成的实例对象就可以共享这些方法。</p><p><strong>实例对象：</strong></p><p>构造函数生成的实例对象有一个属性<code>__proto__</code>，指向构造函数的原型对象；所有构造函数生成的实例对象的<code>__proto__</code>与构造函数的<code>prototype</code>是等价的；</p><p>实例对象方法和属性的查找规则：先在对象自己身上找，没有再去构造函数的原型对象上查找，还是没有就继续沿着原型链查找。</p><p>回到正题：我们<code>ES6</code>的<code>类</code>也是有如<code>ES5</code>这么一套逻辑的(即有自己的prototype属性)。类中定义的方法都是定义在类的<code>prototype对象上 </code>的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line">People.prototype.constructor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">People.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">People.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>因此我们类生成的实例上调用的方法其实都是调用<code>prototype</code>对象上的方法。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line"><span class="built_in">console</span>.log(people.constructor === People.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(people.getName === People.prototype.getName);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(people.getAge === People.prototype.getAge);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p>但是<code>ES6</code>的类与<code>ES5</code>的构造函数还是有不一样的地方的，我们看</p><ul><li><p><strong>类中定义的方法都是不可枚举的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(People.prototype); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(People.prototype); <span class="comment">// [ &#x27;constructor&#x27;, &#x27;getName&#x27;, &#x27;getAge&#x27; ]</span></span><br></pre></td></tr></table></figure><p>可以看出不可枚举。但是<code>ES5</code>写的构造函数定义的方法是可以枚举的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(People.prototype); <span class="comment">// [ &#x27;getName&#x27;, &#x27;getAge&#x27; ]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(People.prototype); <span class="comment">// [ &#x27;constructor&#x27;, &#x27;getName&#x27;, &#x27;getAge&#x27; ]</span></span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>我们在定义类的时候， 必须有<code>constructor</code>方法，<code>constructor</code>方法是默认方法，如果没有显式的定义，一个空的<code>constructor</code>方法会默认添加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中我们定义了一个空类 <code>People</code>，js引擎会自动给它添加<code>constructor</code>方法。</p><p>使用<code>new</code>生成对象的时候， 会自动调用该方法。<code>constructor</code>方法默认返回实例对象(即<code>this</code>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;使用new命令生成实例的时候， 会被自动调用&#x27;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line"><span class="comment">// 使用new命令生成实例的时候， 会被自动调用</span></span><br></pre></td></tr></table></figure><p>我们使用<code>new</code>命令生成实例的时候，<code>constructor</code>方法会被调用。</p><p>类使用的时候必须使用<strong>new 调用，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;使用new命令生成实例的时候， 会被自动调用&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people =  People();</span><br><span class="line"><span class="comment">// TypeError: Class constructor People cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure><p>但是普通构造函数式可以不用<code>new</code>的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;调用&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">People(); <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure><h1 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h1><p>生成一个类的实例，也是使用一个<code>new</code>命令。如果不用，将会报错（上一节说过）；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Class constructor People cannot be invoked without &#x27;new&#x27;</span></span><br><span class="line"><span class="keyword">const</span> people = People(<span class="string">&#x27;shuliqi&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment">// 生成类 People 的实例people</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;shuliqi&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>在一个类中， 属性除非是定义在本身(即定义在this对象上)。否则都是定义在原型上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;shuliqi&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(  people.getAge()  ); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(  people.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)  ) <span class="comment">//  true</span></span><br><span class="line"><span class="built_in">console</span>.log(  people.hasOwnProperty(<span class="string">&#x27;age&#x27;</span>)  ) <span class="comment">//  true</span></span><br><span class="line"><span class="built_in">console</span>.log(  people.hasOwnProperty(<span class="string">&#x27;getName&#x27;</span>)  ) <span class="comment">//  false</span></span><br><span class="line"><span class="built_in">console</span>.log(  people.hasOwnProperty(<span class="string">&#x27;getAge&#x27;</span>)  ) <span class="comment">//  false</span></span><br><span class="line"><span class="built_in">console</span>.log(  people.__proto__.hasOwnProperty(<span class="string">&#x27;getAge&#x27;</span>)  ) <span class="comment">//  true</span></span><br></pre></td></tr></table></figure><p>这代码我们定义了一个类叫<code>People</code>，属性<code>name</code>,<code>age</code>实例对象<code>people</code>的自身属性(因为定义在<code>this</code> 上), 所有<code>hasOwnProperty()</code>方法返回了<code>true</code>。而<code>getName</code>,<code>getAge</code>是原型对象的属性（因为定义在类上）。所以<code>hasOwnProperty()</code>返回<code>false</code>。</p><p>跟上面讲过的一样，类的实例共享一个原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> People(<span class="string">&#x27;shuliqi&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> People(<span class="string">&#x27;shulina&#x27;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log( p1.__proto__ === p2.__proto__ ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h1><p>类的属性名可以采用表达式，和<code>ES5</code>也是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法名变量(表达式)</span></span><br><span class="line"><span class="keyword">const</span> getName = <span class="string">&#x27;getName&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  [getName]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;shuliqi&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(  people.getName()  ); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>People</code>类的方法名<code>getName</code>，是从表达式得到的。</p><h2 id="取值函数-getter-和存值函数-setter"><a href="#取值函数-getter-和存值函数-setter" class="headerlink" title="取值函数(getter)和存值函数(setter)"></a>取值函数(getter)和存值函数(setter)</h2><p>在类的内部可以使用<code>get</code>,<code>set</code>关键字。对一个属性进行设置值和取值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(people.name); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 我们存取值函数的函数名和里面的变量名不能一致。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(people.name); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>这样写是会报错的。这是因为，在构造函数中执行<code>this.name=name</code>的时候，就会去调用<code>set name</code>，在set name方法中，我们又执行<code>this.name = name</code>，进行无限递归，最后导致栈溢出(RangeError)。</p><h2 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h2><p>类也可以使用表达式的方式定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> People = <span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// MyPeople 只能在类的内部使用</span></span><br><span class="line">    MyPeople.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在外部只能使用类的引用名：People</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;shuliqi&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如上，我们使用表达式的方式定义了一个类。这个类的名字是<code>MyPeople</code>。但是<code>MyPeople</code>只能在类的内部使用，指向的是当前类。在类的外部只能使用<code>People</code>引用。</p><p>当然， 如果内部不用， 可以省略类名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> People = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在外部只能使用类的引用名：People</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;shuliqi&#x27;</span>)</span><br></pre></td></tr></table></figure><p>采用表达式定义类， 可以写出立即执行的<code>Class</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;shuliqi&#x27;</span>)</span><br><span class="line">people.getName();</span><br><span class="line"><span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><h1 id="Class-注意的点"><a href="#Class-注意的点" class="headerlink" title="Class 注意的点"></a>Class 注意的点</h1><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>类和模块的内部默认就是严格模式，所以我们不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类和模块当中。就只有严格模式可以使用。</p><h2 id="不存在提升"><a href="#不存在提升" class="headerlink" title="不存在提升"></a>不存在提升</h2><p>类是不存在提升的（这和<code>ES5</code>完全是不一样的）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在声明提升， 在一个类定义好之前使用，直接报错</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// ReferenceError: Cannot access &#x27;People&#x27; before initialization</span></span><br></pre></td></tr></table></figure><p>上面的代码 <code>People</code>类使用在前，定义在后，这样使用是会报错的。因为<code>ES6</code> 不会把类的声明提升到代码块的顶部的。那为什么有这样的规定呢？ 这是有原因：这和继承有关，必须保证子类在父类之后定义；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> People = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的代码不会出错，因为<code>Mypeople</code>在继承<code>People</code>的时候，<code>People</code>已经定义了。但是如果存在类的声明提升，上面的代码就会出错了，这是因为<code>class</code> 会被提升到代码块的顶部， 但是<code>let</code>不会提升，就会导致<code>Mypeople</code>在继承<code>People</code>的时候。<code>People</code>没有定义。</p><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">People</span> </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(People.name); <span class="comment">// People</span></span><br></pre></td></tr></table></figure><h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p>类的达内部如果有<code>this</code>，它默认指向类的实例，但是单独使用该方法的时候，就可能会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line">people.getName();  <span class="comment">// shuliqi</span></span><br><span class="line"><span class="keyword">const</span> &#123; getName &#125; = people;</span><br><span class="line">getName(); <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>类<code>People</code>的方法<code>getName</code>中的<code>this</code>默认指向<code>People</code>的实例。但是这个方法提取出来单独调用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到name属性而报错。</p><p>解决的办法可以使用箭头函数。如下这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line">people.getName();  <span class="comment">// shuliqi</span></span><br><span class="line"><span class="keyword">const</span> &#123; getName &#125; = people;</span><br><span class="line">getName(); <span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>箭头函数内部的<code>this</code>在定义的时候就确定好了，箭头函数的<code>this</code>总是指向外层第一个普通函数的<code>this</code>。上面代码中，箭头函数构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象。关于this指向的问题可以看这篇文章</p><p><a href="https://shuliqi.github.io/shuliqi.github.io/2018/07/02/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/">关于this的指向问题</a></p><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><p>类相当于实例的原型，所有在类中定义的方法，都会被继承，如果我们不想让一个方法被继承，可以在方法名前加<code>static</code>关键字，该方法就就不会被实例继承，只能通过类直接调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态方法 getName</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">People.getName(); <span class="comment">// shuliqi</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.getName(); <span class="comment">// people.getName is not a function</span></span><br></pre></td></tr></table></figure><p>上面定义了一个类<code>People</code>, 类<code>People</code>里面定义了一个静态方法<code>getName</code>, 该方法只能类<code>People直接调用</code>，实例<code>people</code>调用的话直接报错（该方法不存在）</p><p><strong>注意：</strong> 如果在静态方法中有<code>this</code>关键字，这个<code>this</code>指向类，而不是实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">19</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法，只能类调用，实例不能调用</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法中的this 指向 类，而不是实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类属性</span></span><br><span class="line">People.age = <span class="number">900</span>;</span><br><span class="line">People.getAge(); <span class="comment">// 900</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态方法可以与非静态方法重名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通方法</span></span><br><span class="line">  <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure><p>父类的静态方法是可以被子类继承的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;子类可以继承父类的静态方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;&#125;</span><br><span class="line">MyPeople.getAge(); <span class="comment">// 子类可以继承父类的静态方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h1><p>实例属性除了可以定义在<code>constructor</code>方法中的<code>this</code>上，也可以直接定义在类的最顶层。这样的写法看上去比较整齐</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,  <span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.get(); <span class="comment">// shuliqi 10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h1><p>静态属性是指 <code>Class</code> 本身的属性.即<code>Class.propName</code>，而不是定义在对象（<code>this</code>）的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">People.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(People.age); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.getAge(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这表示给类<code>People</code>添加了静态属性<code>age</code>。只能<code>People.age</code>调用。 在<code>this</code> 是取不到的（<code>people.getAge(); // undefined</code>）</p><p>第二种方式，在实例属性前面添加<code>static</code>关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> name = <span class="string">&#x27;shuliqi&#x27;</span>;</span><br><span class="line"> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">People.name = <span class="string">&#x27;shulina&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(People.name); <span class="comment">// shulina</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People();</span><br><span class="line">people.getName(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><p>类可以通过<code>extends</code>关键字实现继承。比ES5 那么多继承方式方便的多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,  <span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople(<span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line"><span class="comment">// ReferenceError:: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码定义了一个类 <code>MyPeople</code>, 通过关键字<code>extends</code>继承了 <code>People</code>类的所有属性和方法。我们看到``MyPeople<code>的构造函数和</code>getName<code>使用了</code>super<code>。那</code>super`这代表什么呢? 我们之后下面有讲到。</p><p>需要注意： 在子类的<code>construtor</code>中必须是用<code>super</code>方法。否则在新建实例的时候会报错。为什么呢？这是因为子类的<code>this</code>对象必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法。如果不调用<code>super</code>方法的话，子类就将得不到<code>this</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,  <span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="comment">// super(...arguments)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople(<span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line"><span class="comment">// ReferenceError:: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这代码中，子类<code>MyPeople</code>继承了父类<code>People</code>, 但是在它的构造函数中没有调用<code>super</code>方法，导致在新建实例的时候报错。</p><p><strong>必须先调用super方法的原因：</strong></p><p>ES5的继承方式：先创造子类的实例对象的<code>this</code>。然后再把父类的属性和方法加到this上面来。</p><p>ES6的继承方式：先将父类实例的属性和方法加到this上面来(所以必须先调用super方法)。然后再用子类的构造函数修改<code>this</code></p><p> 跟定义类一样，如果子类没有定义construtor方法，那么这个方法就会被默认加上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类的构造函数中， 只有调用了<code> super</code> 方法之后，才可以使用this关键字，不然就会报错。这是因为子类的实例的创建基于父类实例，只有`super方法才能调用父类实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,  <span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在调用super()之前使用this</span></span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">super</span>(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople(<span class="string">&#x27;shuliqi&#x27;</span>);</span><br><span class="line"><span class="comment">// ReferenceError: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br></pre></td></tr></table></figure><p>上面的代码在子类<code>MyPeople</code>的<code>constructor</code>方法中在使用<code>super()</code>之前是用了<code>this</code>。结果在创建实例的时候报错。</p><p>上面有讲过父类的静态方法也会被子类继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父类的静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;shuliqi&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age, sex</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用super方法</span></span><br><span class="line">    <span class="built_in">super</span>(name, age);</span><br><span class="line">    <span class="built_in">this</span>.sex = sex; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类继承了父类的静态方法，所以可以调用父类的静态方法</span></span><br><span class="line">MyPeople.getName(); <span class="comment">//  shuliqi</span></span><br></pre></td></tr></table></figure><h1 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h1><p><code>Object.getPrototypeOf()</code>该方法用于从子类获取父类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,  <span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在调用super()之前使用this</span></span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">super</span>(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(MyPeople) === People) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h1 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h1><p>super关键字可以当函数使用，也可以当对象使用。这里可以分成下面这几类来：</p><h2 id="super作为函数使用"><a href="#super作为函数使用" class="headerlink" title="super作为函数使用"></a>super作为函数使用</h2><p><code>super</code>作为函数使用时，代表父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;父类的构造函数&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// super作为函数使用时，代表父类的构造函数</span></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line"><span class="comment">// 父类的构造函数</span></span><br></pre></td></tr></table></figure><p>这段代码子类<code>MyPeople</code>的<code>constructor</code>函数中，**<code>super</code>作为函数调用，代表父类的构造函数**。</p><p><strong>注意：</strong>作为函数使用， 只能在子类的构造函数中使用，在其他地方使用的话是会报错的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;父类的构造函数&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// super当函数使用时，代表父类的构造函数</span></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// super作为函数调用时，只能在constructor中使用</span></span><br><span class="line">    <span class="comment">// 在其他地方使用报错</span></span><br><span class="line">    <span class="built_in">super</span>(); <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="super作为对象在普通方法中使用是指向父类的原型对象"><a href="#super作为对象在普通方法中使用是指向父类的原型对象" class="headerlink" title="super作为对象在普通方法中使用是指向父类的原型对象"></a>super作为对象在普通方法中使用是指向父类的原型对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 父类实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;父类实例属性&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;父类原型方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类原型普通方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// super在子类作为对象使用，并且在普通方法中，那么super指向父类的原型对象</span></span><br><span class="line">    <span class="built_in">super</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line">people.getName(); <span class="comment">// 父类原型方法</span></span><br></pre></td></tr></table></figure><p><code>super</code>作为对象在普通方法中使用是指向父类的原型对象（<code>prototype</code>对象）。</p><p><strong>注意：</strong>由于这种情况，<code>super</code>指向父类的原型对象，所以定义在父类实例上的属或者方法是没有办法通过<code>super</code>调用的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 父类实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;父类实例属性&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;父类原型方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类原型普通方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// super在子类作为对象使用，并且在普通方法中，那么super指向父类的原型对象</span></span><br><span class="line">    <span class="comment">// 所以定义在父类实例上的属性或者方法是不能通过super调用的</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line">people.getName(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>调用<code>super.name</code>返回<code>undefined</code>。</p><p>如果是定义在父类的原型上就可以取到了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 父类实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;父类实例属性&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;父类原型方法&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型对象属性</span></span><br><span class="line">People.prototype.name = <span class="string">&#x27;父类原型对象属性&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类原型普通方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// super在子类作为对象使用，并且在普通方法中，那么super指向父类的原型对象</span></span><br><span class="line">    <span class="comment">// 如果name定义在父类原型对象上，那么久可以取到</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line">people.getName(); <span class="comment">// 父类原型对象属性</span></span><br></pre></td></tr></table></figure><h2 id="super作为对象在普通方法中调用父类原型的方法，该方法内部的this指向子类的实例-this"><a href="#super作为对象在普通方法中调用父类原型的方法，该方法内部的this指向子类的实例-this" class="headerlink" title="super作为对象在普通方法中调用父类原型的方法，该方法内部的this指向子类的实例(this)"></a>super作为对象在普通方法中调用父类原型的方法，该方法内部的this指向子类的实例(this)</h2><p>这句话看着好大，但是我们可以分析简单理解下。父类的方法都是定义在原型对象上面，而super作为对象在普通方法中使用时指向父类的原型，所以不用说的那么复杂，可以说成<strong>super作为对象在普通函数中调用方法，改方法内部的this指向子类的实例(即this)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 父类实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;父类实例属性&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类原型方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型对象属性</span></span><br><span class="line">People.prototype.name = <span class="string">&#x27;父类原型对象属性&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;子类实例属性&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类原型普通方法（类的的所有方法都是在类的原型上）</span></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// super在子类作为对象使用，并且在普通方法中，调用方法，那么改方法中的this指向子类的实例（this）</span></span><br><span class="line">    <span class="built_in">super</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line">people.getName(); <span class="comment">// 子类实例属性</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>  super.getName();</code>虽然调用的是<code>People.prototype.getName()</code>。 但是<code>People.prototype.getName()</code>中的<code>this</code> 指向的是子类<code>MyPeople</code>的实例。 导致输出的是”子类实例属性” 而不是“父类实例属性”</p><h2 id="super作为对象在静态方法中是指向父类。"><a href="#super作为对象在静态方法中是指向父类。" class="headerlink" title="super作为对象在静态方法中是指向父类。"></a>super作为对象在静态方法中是指向父类。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.age = <span class="string">&#x27;父类实例属性&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类静态方法（只能 People.getName()调用）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;父类静态方法&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.age = <span class="string">&#x27;父类原型属性&#x27;</span></span><br><span class="line">People.age = <span class="string">&#x27;父类属性&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类静态方法（只能MyPeople.getName()调用）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 作为对象在子类静态方法中使用，super指向父类(People)，而不是父类的原型(Pepple.prototype)</span></span><br><span class="line">    <span class="built_in">super</span>.getName();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.age);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPeople.getName(); </span><br><span class="line"><span class="comment">// 父类静态方法</span></span><br><span class="line"><span class="comment">// 父类属性</span></span><br></pre></td></tr></table></figure><p>super作为对象在子类的静态方法使用，super指向父类(People)，而不是父类的原型(People.prototype)。</p><h2 id="super作为对象在静态方法中调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。"><a href="#super作为对象在静态方法中调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。" class="headerlink" title="super作为对象在静态方法中调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。"></a>super作为对象在静态方法中调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.age = <span class="string">&#x27;父类实例属性&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父类静态方法（只能 People.getName()调用）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="string">&#x27;子类实例属性&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类静态方法（只能MyPeople.getName()调用）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 作为对象在子类静态方法中使用，super指向父类(People)，而不是父类的原型(Pepple.prototype)</span></span><br><span class="line">    <span class="comment">// 调用父类方法，方法中的this指向子类(MyPeople)，而不是子类的原型(MyPeople.prototype)</span></span><br><span class="line">    <span class="built_in">super</span>.getName();</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPeople.prototype.age = <span class="string">&#x27;子类原型属性&#x27;</span>;</span><br><span class="line">MyPeople.age = <span class="string">&#x27;子类属性&#x27;</span>;</span><br><span class="line">MyPeople.getName();  <span class="comment">// 子类属性</span></span><br></pre></td></tr></table></figure><p>super作为对象在子类的静态方法调用（<code> super.getName();</code>）这里的<code>super.getName() === People.getName()</code>。虽然调用的是<code>People.getName()</code>但是方法中的this指向的是子类(<code>MyPeople</code>).所以<code>this.age === MyPeople.age </code>  结果为：“子类属性”</p><h2 id="使用super设置属性的话，那么super就是当前的this。"><a href="#使用super设置属性的话，那么super就是当前的this。" class="headerlink" title="使用super设置属性的话，那么super就是当前的this。"></a>使用super设置属性的话，那么super就是当前的this。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 父类实例的属性</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">38</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类的属性</span></span><br><span class="line">People.sex = <span class="number">30</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPeople</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用super设置属性，就是当前的this，所有给当前的实例的属性age设置值为20</span></span><br><span class="line">    <span class="built_in">super</span>.age = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 普通方法中，super作为对象的话，指向父类的原型；</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.age); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> MyPeople();</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined ---&gt; 父类的原型没有age属性</span></span><br><span class="line"><span class="comment">// 20 ---&gt;使用super设置属性，就是当前的this，所有给当前的实例的属性age设置值为20</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习都是来自[<a href="https://es6.ruanyifeng.com/#docs/class">ECMAScript 6 入门–Class</a>。</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局教程</title>
      <link href="/2018/03/31/Flex%E5%B8%83%E5%B1%80/"/>
      <url>/2018/03/31/Flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Flex-布局的概念"><a href="#Flex-布局的概念" class="headerlink" title="Flex 布局的概念"></a>Flex 布局的概念</h2><p>Flex 是 Flexible Box 的缩写，意思就是“弹性布局”。它的作用就是为盒状模型提供最大的灵活性。</p><p>任何容器都可以指定为Flex 布局.</p><span id="more"></span><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用flex 布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">dispaly: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 设置为Flex布局之后， 子元素的·<code>float</code>，<code>claer</code>，<code>vertical-align</code> 将会失效。</p><h2 id="Flex的基本概念"><a href="#Flex的基本概念" class="headerlink" title="Flex的基本概念"></a>Flex的基本概念</h2><p>使用了Flex布局的元素， 称为：Flex容器， 简称：“容器”。 容器内的所有元素自动成为容器成员。称为：Flex项目， 简称“项目“。</p><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/1.png" class=""><p>容器默认存在两根轴，水平的主轴（main axis）和垂直的交叉轴（cross axis），主轴的开始位置（与边框的交叉点）叫<code>main start</code>, 结束位置叫<code>main end</code>交叉轴的开始位置叫<code>cross start</code>, 结束位置叫<code>cross start</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫<code>main size</code>, 占据的交叉轴空间叫<code>cross size</code>。</p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>一共有6 个属性是可以设置在容器上。</p><ol><li><strong>flex-direction</strong></li><li><strong>flex-wrap</strong></li><li><strong>flex-flow</strong></li><li><strong>justify-content</strong></li><li><strong>align-items</strong></li><li><strong>align-content</strong></li></ol><h3 id="flex-direction-属性"><a href="#flex-direction-属性" class="headerlink" title="flex-direction 属性"></a>flex-direction 属性</h3><p>flex-direction 决定主轴的方向（项目的排列方向）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">flex-direction: row | row-reverse | column | column-reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex-direction的4个值的含义：</p><ol><li><p>row：默认值，主轴为水平方向，起点在左端。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row; // 默认值，主轴为水平方向，起点在左端 </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/direction1.jpg" class=""><p>完整 <a href="https://jsbin.com/cuvokizabu/1/edit?html,css,output">Demo</a></p></li><li><p>row-reverse：主轴是水平方向，起点在右端</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row-reverse; // 主轴是水平方向，起点在右端</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/direction2.jpg" class=""><p>完整 <a href="https://jsbin.com/rihinemulu/edit?html,css,output">Demo</a></p></li><li><p>column：主轴为垂直方向， 起点在上沿</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column; // 主轴为垂直方向， 起点在上沿</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/direction3.jpg" class=""><p>完整 <a href="https://jsbin.com/tasofavuro/edit?html,css,js,output">Demo</a></p></li><li><p>column-reverse：主轴是垂直方向，起点在下沿</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column-reverse; //主轴是垂直方向，起点在下沿</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/direction4.jpg" class=""><p>完整 <a href="https://jsbin.com/kerinetanu/1/edit?html,css,js,output">Demo</a></p></li></ol><h3 id="flex-wrap-属性"><a href="#flex-wrap-属性" class="headerlink" title="flex-wrap 属性"></a>flex-wrap 属性</h3><p>默认情况下，所有的项目都排列在一条线上（又称为“轴线“）. flex-wrap属性定义， 如果在一条轴线上排不下， 如何换行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">flex-wrap: nowrap | wrap | wrap-column</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex-wrap的3个值的含义：</p><ol><li><p><strong>nowrap</strong>： 默认值，不换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap: // 默认值，不换行</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/wrap1.jpg" class=""><p>完整 <a href="https://jsbin.com/wutepopode/edit?html,css,js,output">Demo</a></p></li><li><p>wrap：换行， 第一行在上方</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap; // 换行， 第一行在上方</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/wrap2.jpg" class=""><p>完整 <a href="https://jsbin.com/tuzihaqaza/1/edit?html,css,js,output">Demo</a></p></li><li><p>wrap-reverse：换行， 第一行在下方</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap-reverse; // 换行， 第一行在下方</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/wrap3.jpg" class=""><p><a href="https://jsbin.com/pugusasura/edit?html,css,output">Demo</a></p></li></ol><h3 id="flex-flow-属性"><a href="#flex-flow-属性" class="headerlink" title="flex-flow 属性"></a>flex-flow 属性</h3><p><code>flex-flow</code> 属性是<code> flex-direction</code>属性  和 <code>flex-wrap</code>属性的简写形式。默认值：<code>row nowrap</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">flex-flow: &lt;flex-direction&gt; | &lt;flex-wrap&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="justify-content-属性"><a href="#justify-content-属性" class="headerlink" title="justify-content 属性"></a>justify-content 属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">justify-content: flex-start | flex-end | center| space-between | space-around</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>justify-content属性有5个值：</p><ol><li><strong>flex start:</strong>      默认值，主轴的起点对齐</li><li><strong>flex-end：</strong> 主轴的终点对齐</li><li><strong>center：</strong>居中</li><li><strong>space-between：</strong>两端对齐，项目之间的间隔是相等的</li><li><strong>space-around：</strong> 每个项目两侧的距离相等，所以项目之间的间距与项目与边框的间距要大</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container1</span> &#123;</span><br><span class="line">  <span class="comment">/* 默认值，主轴的起点对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container2</span> &#123;</span><br><span class="line"> <span class="comment">/*  主轴的终点对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container3</span> &#123;</span><br><span class="line">  <span class="comment">/* 居中 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container4</span> &#123;</span><br><span class="line">  <span class="comment">/* 两端对齐，项目之间的间隔是相等的 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container5</span> &#123;</span><br><span class="line">  <span class="comment">/* 每个项目两侧的距离相等，所以项目之间的间距与项目与边框的间距要大 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/7.jpg" class=""><p>完整<a href="https://jsbin.com/xoqikozalu/1/edit?html,css,output">Demo</a></p><h3 id="align-items-属性"><a href="#align-items-属性" class="headerlink" title="align-items 属性"></a>align-items 属性</h3><p><code>align items</code> 属性定义项目在交叉轴的对齐方式，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">   <span class="attribute">align-items</span>: flex-start |flex-end | center | baseline| stretch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有5个值：</p><ol><li><p><strong>flex start:</strong>: 交叉轴的起点对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start; // 交叉轴的起点对齐</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/flex1.jpg" class=""><p>完整 <a href="https://jsbin.com/nihavapeve/1/edit?html,css,js,output">Demo</a></p></li><li><p><strong>flex end:</strong> 交叉轴的终对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-end; // 交叉轴的终点对齐 </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/flex2.jpg" class=""><p>完整 <a href="https://jsbin.com/nuxeqobude/1/edit?html,css,output">Demo</a></p></li><li><p><strong>center：</strong>居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center; // 居中 </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/flex3.jpg" class=""><p>完整 <a href="https://jsbin.com/sikuxofozu/edit?html,css,output">Demo</a></p></li><li><p><strong>baseline</strong>： 项目的第一行文字基线对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: baseline </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/flex4.jpg" class=""><p>完整  <a href="https://jsbin.com/xinosalodo/1/edit?html,css,output">Demo</a></p></li><li><p><strong>stretch：</strong> 默认值， 如果项目未设置高度或者设置高度为auto，将铺满整个容器的高度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: #54b4c557;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: strecth; //  默认值， 如果项目未设置高度或者设置高度为auto，将铺满整个容器的高度</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">.item1 &#123;</span><br><span class="line">  background: #f19f9e;</span><br><span class="line">  width: 30px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 50px;</span><br><span class="line">   margin: 0 20px;</span><br><span class="line">&#125;</span><br><span class="line">.item2 &#123;</span><br><span class="line">  width: 30px;</span><br><span class="line">  font-size: 50px;</span><br><span class="line">  background: #f19f9e;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 50px;</span><br><span class="line">  margin: 0 20px;</span><br><span class="line">&#125;</span><br><span class="line">.item3 &#123;</span><br><span class="line">  width: 30px;</span><br><span class="line">  background: #f19f9e;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">  margin: 0 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/flex5.jpg" class=""></li></ol><p>​       完整  <a href="https://jsbin.com/vuqetirola/1/edit?html,css">Demo</a></p><h3 id="align-content-属性"><a href="#align-content-属性" class="headerlink" title="align-content 属性"></a>align-content 属性</h3><p><code>align-content</code>属性设置了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性是不生效的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性一共有6 个属性值：</p><ol><li><strong>flex start:</strong>: 交叉轴的起点对齐</li><li><strong>flex end:</strong> 交叉轴的终对齐</li><li><strong>center：</strong>居中</li><li><strong>stretch：</strong> 默认值， 如果项目未设置高度或者设置高度为auto，将铺满整个容器的高度</li><li><strong>space-between</strong>:与交叉轴两端对齐，轴线之间的间隔平均分布</li><li><strong>space-around</strong>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li><strong>stretch：</strong>默认值，占满整个容器</li></ol><p><strong>注意：</strong> <code>align-items</code> 属性和<code>align-content</code>属性的区别：<code>align-items</code>属性是设置多根轴线和单根轴线的， <code>align-content</code>属性是设置多根轴线的。这里的多根轴线和单根轴线是指<code>flex-wrap：nowrap</code>是单根轴线，align-items 和align-content同时存在的话， align-items 生效，align-content 不生效。<code>flex-wrap：wrap| wrap-reverse</code> 且项目换行了，align-items 和align-content同时存在的话， align-items 不生效，align-content 生效。</p><p>例子如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-end; </span><br><span class="line">  <span class="attribute">align-content</span>: flex-start;</span><br><span class="line">  // <span class="attribute">align-content</span>单根轴线是不生效的，当 <span class="attribute">flex-wrap</span>: nowrap, 生效的是align-items</span><br><span class="line">  // 多轴情况下， align-items 和 align-content 同时存在， align-content会覆盖align-items </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的 <a href="https://jsbin.com/sixesiquve/1/edit?html,css,output">Demo</a></p><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><p>以下6个属性设置在项目上。</p><ol><li><p><strong><code>order</code></strong></p></li><li><p><strong><code>flex-grow</code></strong></p></li><li><p><strong><code>flex-shrink</code></strong></p></li><li><p><strong><code>flex-basis</code></strong></p></li><li><p><strong><code>flex</code></strong></p></li><li><p><strong><code>align-self</code></strong></p></li></ol><h3 id="order-属性"><a href="#order-属性" class="headerlink" title="order 属性"></a>order 属性</h3><p><code>order</code> 属性定义项目的排列顺序，数值越小，排列越靠前， 默认值为0。</p><p><strong>使用语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="comment">/* order 属性定义项目的排列顺序，数值越小，排列越靠前 */</span></span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/order.jpg" class=""><p> <a href="https://jsbin.com/sazuwamure/1/edit?html,css,output">例子完整代码</a></p><h3 id="flex-grow-属性"><a href="#flex-grow-属性" class="headerlink" title="flex-grow 属性"></a>flex-grow 属性</h3><p><code>flex-grow</code>属性定义项目的放大比列。默认为0，即 即使存在剩余空间， 也不放大。 </p><p><strong>使用语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/grow.jpg" class=""><p> <a href="https://jsbin.com/zafuhamuwo/1/edit?html,css,output">例子完整代码</a></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为4，其他项目都为1，则前者占据的剩余空间将比其他多4倍。</p><h3 id="flex-shrink-属性"><a href="#flex-shrink-属性" class="headerlink" title="flex-shrink 属性"></a>flex-shrink 属性</h3><p><code>flex-shrink</code>属性定义项目的缩小比例，默认值为1， 如果剩余空间不足，项目将缩小。</p><p><strong>使用语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123; </span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例：子</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/shrink.jpg" class=""><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。</p><p>如果所有项目的<code>flex-shrink</code>属性都为1，其他的<code>flex-shrink</code> 为10，那么后者的缩小比例是前者的10倍</p><p>如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><p> <a href="https://jsbin.com/gihubasolo/2/edit?html,css,output">例子完整代码</a></p><h3 id="flex-basis-属性"><a href="#flex-basis-属性" class="headerlink" title="flex-basis 属性"></a>flex-basis 属性</h3><p><code>flex-basis</code>属性定义在分配剩余空间之前， 项目占主轴的空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小</p><p><strong>使用语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">700px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/basis.jpg" class=""><p> <a href="https://jsbin.com/bepehogude/1/edit?html,css,output">例子完整代码</a></p><h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code> <code>flex-shrink</code> <code>flex-basis    </code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><p><strong>使用语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self-属性"><a href="#align-self-属性" class="headerlink" title="align-self 属性"></a>align-self 属性</h3><p><code>align-self</code>属性允许单个项目与其他项目不一样的对齐方式，可覆盖<code>align-items</code>，默认值为auto，表示继承父级的<code>align-items</code>。如果没有父元素，则等同于<code>stretch</code>。</p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><p><strong>使用语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子:</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#54b4c5</span>57;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f19f9e</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/03/31/Flex%E5%B8%83%E5%B1%80/self.jpg" class=""><p> <a href="https://jsbin.com/luzusoceci/edit?html,css,output">例子完整代码</a></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步一步实现Promise</title>
      <link href="/2018/03/29/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AE%9E%E7%8E%B0Promise/"/>
      <url>/2018/03/29/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AE%9E%E7%8E%B0Promise/</url>
      
        <content type="html"><![CDATA[<p>上篇文章学习了 关于 <code>Promise</code> <a href="https://shuliqi.github.io/2018/03/20/ES6%E5%AD%A6%E4%B9%A0-Promise/">ES6学习笔记-Promise</a> ； 那么这篇文章就来看看如何自己实现 一个<code>Promise </code>和它的原型方法和类方法的</p><p>本文手写<code>Promise</code>的主要分为下面这三部分：</p><ul><li>实现<code>Promise</code>大体框架</li><li>添加异步处理和多次调用<code>then</code>方法</li><li>添加<code>Promise</code>的链式调用</li><li>实现<code>Promise</code>的原型方法</li><li>实现<code>Promise</code>的类方法</li></ul><h1 id="实现大体框架"><a href="#实现大体框架" class="headerlink" title="实现大体框架"></a>实现大体框架</h1><p>我们先来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  resolve(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功：&quot;</span>, value)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败：&quot;</span>, reason)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个例子的输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">成功： <span class="number">2</span></span><br></pre></td></tr></table></figure><p>那么根据这个例子我们可以得到如下的规则：</p><ul><li><code>Promise</code> 是构造函数，<code>new</code>出来的实例有<code>then</code>方法。</li><li><code>new Promise</code>的时候短笛一个参数，这个参数是一个函数（我们一般称为执行器函数–<code>executor</code>）并且执行器会立即调用。就是上面的例子中 1 会被最先打印出来。</li><li><code>executor</code>函数有两个参数：<code>resolve </code>和 <code>reject</code>；这两个参数也是函数。</li><li><code>new Promise</code> 后的实例是具有状态，默认的状态是 <code>pending</code>。当置值器<code>resolve</code>调用后，实例的状态变为<code>fulfilled</code>。当置值器<code>reject</code>调用后，实例的状态变为<code>rejected</code>。</li><li><code>Promise</code>状态的实例一经改变，就不能再次修改。</li><li>每一个<code>Promise</code>实例都有<code>then</code>方法，<code>then</code>方法中有两个参数，这两个参数都是函数。第一个函数叫做<strong>成功回调</strong>，第二个参数叫做<strong>失败回调</strong>。当置值器<code>resolve</code>调用后，<code>then</code>中的第一个参数函数会被执行；当置值器<code>reject</code>调用后，<code>then</code>中的第二个参数函数会被执行。</li></ul><p>那我们根据这个规则来写一个大体的<code>Promise</code>:</p><h2 id="构造函数的参数（executor）会立即执行"><a href="#构造函数的参数（executor）会立即执行" class="headerlink" title="构造函数的参数（executor）会立即执行"></a>构造函数的参数（executor）会立即执行</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// executor 是会被立即执行的</span></span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new-出来的实例具有then方法"><a href="#new-出来的实例具有then方法" class="headerlink" title="new 出来的实例具有then方法"></a>new 出来的实例具有then方法</h2><p><code>then</code>方法有两个参数： 成功回调函数，失败回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then =<span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new-出来的实例的状态"><a href="#new-出来的实例的状态" class="headerlink" title="new 出来的实例的状态"></a>new 出来的实例的状态</h2><p>new 出来的实例具有默认的状态，默认状态为<code>pending</code>; 需要使用<code>resolve</code>置值器或者<code>reject</code>置值器来修改状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 实例的默认状态： pending</span></span><br><span class="line">  self.status = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    self.status = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>  <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// executor 是会被立即执行的</span></span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里为什么会把 <code>this</code> 赋值 给 <code>self </code>呢？值得思考！！</p></blockquote><p>答案：这是因为普调函数的 <code>this</code> 的指向是在调用的时候确定的，如果还不了解 <code>this</code>指向的， 可以先看看这篇文章 <a href="https://shuliqi.github.io/2018/07/02/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/">关于this的指向问题</a>。因为我们的 <code>resolve</code>和 <code>reject</code> 函数里面的<code>this</code>指向的是<code>Window</code>。 而不是我们的实例。 所以我们需要使用闭包的用法，让函数能够记住并且能够访问当前的词法作用域，即使函数不是在当前的词法作用域中执行的。即我们上线的写法，将实例<code>this</code> 赋值给<code>self</code>变量，在<code>resolve</code> 和<code>reject</code>置值器函数中使用 <code>self</code>，那么当这两个函数不在当前的词法作用域中调用的时候， 也有对当前词法作用域的使用权限。如果还对闭包不了解的可以先看这边文章 <a href="https://shuliqi.github.io/2018/10/23/JavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/">JavaScript中的闭包</a></p><h2 id="then中回调函数的触发"><a href="#then中回调函数的触发" class="headerlink" title="then中回调函数的触发"></a>then中回调函数的触发</h2><p>当置值器<code>resolve</code>调用之后，<code>then</code>中的第一个函数参数会被执行（成功回调），当置值器<code>reject</code>调用之后，<code>then</code>中的第二个函数参数会被执行（失败回调）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then =<span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当置值器resolve调用之后，then中的第一个函数参数会被执行（成功回调）；</span></span><br><span class="line">  <span class="comment">// 即当前的 promise 状态为 fulfilled</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">    onFulfilled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当置值器reject调用之后，then中的第一个函数参数会被执行（失败回调）；</span></span><br><span class="line">  <span class="comment">// 即当前的 promise 状态为 rejected</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">    onRejected()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Promise的状态一经更改就不能再次改变"><a href="#Promise的状态一经更改就不能再次改变" class="headerlink" title="Promise的状态一经更改就不能再次改变"></a>Promise的状态一经更改就不能再次改变</h2><p>Promise的状态一经更改就不能再次改变，所以只有在pending状态的时候才能修状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 置值器： 用于修改状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Promise的状态一经修改就不能再改变，所以只有在 pending 状态才能修改</span></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">    self.status = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 置值器： 用于修改状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Promise的状态一经修改就不能再改变，所以只有在 pending 状态才能修改</span></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">    self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="置值器被调用之后，-传入的值会传给then中的回调函数"><a href="#置值器被调用之后，-传入的值会传给then中的回调函数" class="headerlink" title="置值器被调用之后， 传入的值会传给then中的回调函数"></a>置值器被调用之后， 传入的值会传给then中的回调函数</h2><p>当置值器<code>resolve</code>调用后，传入的值是成功的值， 我们称为 <code>value</code>。这个值会传给<code>then</code>中的第一个参数，当置值器<code>reject</code>调用后，实例的值是失败原因，称为<code>reason</code>。这个值会传给<code>then</code> 中的第二个参数函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 实例的默认状态： pending</span></span><br><span class="line">  self.status = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Promise的状态一经修改就不能再改变，所以只有在 pending 状态才能修改</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.status = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">      <span class="comment">// Promise的值</span></span><br><span class="line">      self.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>  <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Promise的状态一经修改就不能再改变，所以只有在 pending 状态才能修改</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      <span class="comment">// Promise的值</span></span><br><span class="line">      self.value = reason</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// executor 是会被立即执行的</span></span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then =<span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当置值器resolve调用之后，then中的第一个函数参数会被执行（成功回调）；</span></span><br><span class="line">  <span class="comment">// 即当前的 promise 状态为 fulfilled</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 值会传递给成功回调</span></span><br><span class="line">    onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当置值器reject调用之后，then中的第一个函数参数会被执行（失败回调）；</span></span><br><span class="line">  <span class="comment">// 即当前的 promise 状态为 rejected</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 值会传递给失败回调</span></span><br><span class="line">    onRejected(<span class="built_in">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么到现在位置， 我们大体的结构写完了。</p><h1 id="添加异步处理和多次调用then方法"><a href="#添加异步处理和多次调用then方法" class="headerlink" title="添加异步处理和多次调用then方法"></a>添加异步处理和多次调用then方法</h1><h2 id="例子参考"><a href="#例子参考" class="headerlink" title="例子参考"></a>例子参考</h2><p>我们还是先来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功1&quot;</span>, value)</span><br><span class="line">&#125;,  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败1&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功2&quot;</span>, value)</span><br><span class="line">&#125;,  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败2&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br></pre></td></tr></table></figure><p>打印的结果为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">成功<span class="number">1</span> <span class="number">2</span></span><br><span class="line">成功<span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="例子得出的规则"><a href="#例子得出的规则" class="headerlink" title="例子得出的规则"></a>例子得出的规则</h2><p>那针对异步这种情况，我们来看上面的例子可得到解决办法：</p><ol><li><p>当创建<code>Promise</code>的时候， <code>executor</code> 执行器方法中的<code>resolve(&quot;2&quot;)</code>被<code>setTimeout</code>放到了异步队列中了</p></li><li><p>所以创建出来的实例当前的状态还是默认的状态，并没有发生改变</p></li><li><p>那么当代码执行到<code>p.then</code>的时候， 我们并不知道要去执行<code>then</code>中的第一个参数（成功回调）还是第二个参数（失败会回调）。</p></li><li><p>当不知道哪个回调函数会被执行的情况下， 就需要吧把这两个回调保存起来，等到等确定调用哪个回调的时候，再拿出来调用。</p></li><li><p>因为同一个<code> promise</code> 实例的<code>then</code>是可以多次调用的（这里不是指链式调用）。所以我们应该使用数组把成功回调和失败回调保存起来。因为<code>then</code> 是可以多次被调用的。</p></li></ol><h2 id="完善异步和多次调用"><a href="#完善异步和多次调用" class="headerlink" title="完善异步和多次调用"></a>完善异步和多次调用</h2><p>那么我们现在的<code>MyPromise</code>应该添加代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存成功回调：then方法中的第一个参数</span></span><br><span class="line">  self.onResolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存失败回调：：then方法中的第二个参数</span></span><br><span class="line">  self.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 此处省略其他逻辑代码</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then =<span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 此处省略其他逻辑代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当还不知道实例状态的情况下，把成功回调和失败回调都保存起来</span></span><br><span class="line">  <span class="comment">// 等到确定调用哪个回调之后，再拿出来调用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallbacks.push(onFulfilled);</span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的<code>MyPromise</code>把我们的成功回调或者失败回调都保存起来了。 那我们该什么时候去调用回调呢？那当然是在状态发生变化的时候去调用。实例的状态只会在 <code>resolve</code> 和 <code>reject</code>置值器函数中改变， 那么我们就可以在这时候把回调拿出来调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ... 此处省略其他逻辑代码</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 把存起来的成功回调调用</span></span><br><span class="line">      self.onResolvedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        fn(self.value);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>  <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ... 此处省略其他逻辑代码</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把保存起来的失败回调拿出来调用</span></span><br><span class="line">      self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        fn(self.value);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后附上完整代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存成功回调：then方法中的第一个参数</span></span><br><span class="line">  self.onResolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存失败回调：：then方法中的第二个参数</span></span><br><span class="line">  self.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例的默认状态： pending</span></span><br><span class="line">  self.status = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;置值&quot;</span>)</span><br><span class="line">    <span class="comment">// Promise的状态一经修改就不能再改变，所以只有在 pending 状态才能修改</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.status = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">      <span class="comment">// Promise的值</span></span><br><span class="line">      self.value = value;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把存起来的成功回调调用</span></span><br><span class="line">      self.onResolvedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        fn();</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>  <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Promise的状态一经修改就不能再改变，所以只有在 pending 状态才能修改</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      <span class="comment">// Promise的值</span></span><br><span class="line">      self.value = reason;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把保存起来的失败回调拿出来调用</span></span><br><span class="line">      self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        fn();</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// executor 是会被立即执行的</span></span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then =<span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当置值器resolve调用之后，then中的第一个函数参数会被执行（成功回调）；</span></span><br><span class="line">  <span class="comment">// 即当前的 promise 状态为 fulfilled</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 值会传递给成功回调</span></span><br><span class="line">    onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当置值器reject调用之后，then中的第一个函数参数会被执行（失败回调）；</span></span><br><span class="line">  <span class="comment">// 即当前的 promise 状态为 rejected</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 值会传递给失败回调</span></span><br><span class="line">    onRejected(<span class="built_in">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当还不知道实例状态的情况下，把成功回调和失败回调都保存起来</span></span><br><span class="line">  <span class="comment">// 等到确定调用哪个回调之后，再拿出来调用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      onFulfilled(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      onRejected(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 现在我们来测试一下；还是上面的例子，只不过构造函数是我们自己实现的<code>MyPromise</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功1&quot;</span>, value)</span><br><span class="line">&#125;,  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败1&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功2&quot;</span>, value)</span><br><span class="line">&#125;,  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败2&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">成功<span class="number">1</span> <span class="number">2</span></span><br><span class="line">成功<span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>结果跟原生的一样， 完美！！！</p><h2 id="then方法是异步执行的处理"><a href="#then方法是异步执行的处理" class="headerlink" title="then方法是异步执行的处理"></a>then方法是异步执行的处理</h2><p>我们知道 <code>then</code> 方法返回的是一个<code>Promise   </code>。 而<code>Promise   </code>是一个微任务， 微任务是在同步任务执行完之后再执行的。也就是说 <code>then</code>方法是异步执行的.</p><p>ES6的原生Promise对象已经实现了这一点，但是我们自己的代码是同步执行，我们试试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  resolve(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功1&quot;</span>, value)</span><br><span class="line">&#125;,  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败1&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功2&quot;</span>, value)</span><br><span class="line">&#125;,  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败2&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们期望的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">成功<span class="number">1</span> <span class="number">2</span></span><br><span class="line">成功<span class="number">2</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是实际的结果为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">成功<span class="number">1</span> <span class="number">2</span></span><br><span class="line">成功<span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那关于这样情况如何解决呢，我们可以使用<code>setTimeOut</code>将同步代码变成异步代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line"><span class="comment">// .. 已省略</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          fn();</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span>  <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">          fn();</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .. 已省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then =<span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 值会传递给成功回调</span></span><br><span class="line">      onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 值会传递给失败回调</span></span><br><span class="line">      onRejected(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// ... 已省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样即可， 再试试我们的例子返回的结果是我们期望的结果。</p><h1 id="支持链式调用"><a href="#支持链式调用" class="headerlink" title="支持链式调用"></a>支持链式调用</h1><h2 id="then-链的知识点"><a href="#then-链的知识点" class="headerlink" title="then 链的知识点"></a>then 链的知识点</h2><p>我们知道得到一个<code>Promise</code>对象可以有三种方式：</p><ul><li>使用<code>new Promise</code>来创建</li><li>使用<code>Promise</code>的类方法如：<code>Promise.all()</code>，<code>Promise.race()</code>，<code>Promise.allsettled()</code>，<code>Promise.any()</code>，<code>Promise.resolve()</code>，<code>Promise.reject()</code>等</li><li>使用<code>Promise</code>原型方法 Promise.prototype.xxx(): 如：promise.then()<code>，</code>promise.catch()<code>，</code>promise.fanally()；</li></ul><p>由此我们知道：</p><ol><li><p><strong>每个<code>then</code>方法返回的是一个新的<code>Promise</code>对象（第三种创建方式）</strong></p><p>为什么是一个新的<code>Promise</code>呢？因为<code>Promise</code>实例的状态一旦修改，则不能再修改，所以要返回全新的<code>Promise</code></p></li></ol><p>既然返回的是一个新的<code>Promise</code>。 那这个新的<code>Promise</code>的置值逻辑是什么样子的呢？那我们先来看<code>then</code> 链上的置值逻辑:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断上一个promise的置值状态</span></span><br><span class="line">    <span class="keyword">if</span> (isRejected(p)) &#123;</span><br><span class="line">       <span class="comment">// rejected 是有效的 ? 执行rejected函数，result为reason : result </span></span><br><span class="line">       <span class="comment">// 其中result是p代理的数据</span></span><br><span class="line">        x2 = isValidHandler(rejected) ? rejected(result) :<span class="keyword">throw</span> result;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// resolved函数是有效的 ？ 执行resolved函数 ： result;</span></span><br><span class="line">        x2 = isValidHandler(resolve) : resolved(result) : result; </span><br><span class="line">    &#125; </span><br><span class="line">    resolve(x2); <span class="comment">// promise2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此我们知道比较重要的一点：</p><ol start="2"><li><strong>如果 <code>rejected</code> 和 <code>resolve</code>是有效的。无论他们返回何值，都将作为<code>resolve</code>置值器的值直接绑定给这个新的<code>Promise</code>。如果产生了<code>reject</code>值。那么就作为<code>rejecte</code>置值器的值直接绑定给这个新的<code>Promise</code>。</strong></li></ol><p>then链中产生<code>Promise</code>值的方法有两种：</p><ul><li>通过抛出异常来是的<code>Javascript</code>引擎获得异常对象。</li><li>通过显示的调用 <code>Promise.reject()</code>。</li></ul><p>现在我们知道新的<code>Promise</code>的值是重要的一点是由成功回调或者失败回调的返回值来确定的。那成功回调或者失败回调的返回值的类型是什么？如果返回值是一个普调值，该是什么样？ 如果返回值不是一个普调值，那又该怎么样？</p><p>我们来试验一下：</p><h3 id="返回普调值"><a href="#返回普调值" class="headerlink" title="返回普调值"></a>返回普调值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功回调：&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;   <span class="comment">// 返回一个普调值</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败回调：&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p2的值：&quot;</span>, value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功回调： 1</span><br><span class="line">p2的值： 2</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功回调：&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;   <span class="comment">// 返回一个普调值</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败回调：&quot;</span>, reason);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p2的值：&quot;</span>, value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">失败回调： <span class="number">1</span></span><br><span class="line">p2的值： <span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>如果返回了一个普调值，那么这个值被<code>resove</code> 置值器直接绑定给下一个<code>Promise</code>（即 <code>p2</code>）。意思就是会调用下一个<code>then</code>的第一个参数</p></blockquote><p>这里注意：如果回调里面没有显示的返回值， 那么函数默认是会返回<code> undefined</code>。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功回调：&quot;</span>, value);</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败回调：&quot;</span>, reason);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p2的值：&quot;</span>, value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">失败回调： <span class="number">1</span></span><br><span class="line">p2的值： <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h3 id="返回非普调值—Promise"><a href="#返回非普调值—Promise" class="headerlink" title="返回非普调值—Promise"></a>返回非普调值—<code>Promise</code></h3><p>例子1:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功回调：&quot;</span>, value);</span><br><span class="line">  <span class="comment">// 返回一个 Promise, 这个promise产生 resolve 值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败回调：&quot;</span>, reason);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p2的值：&quot;</span>, value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功回调： <span class="number">1</span></span><br><span class="line">p2的值： <span class="number">2</span></span><br></pre></td></tr></table></figure><p>例子2:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功回调：&quot;</span>, value);</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败回调：&quot;</span>, reason);</span><br><span class="line">  <span class="comment">// 返回一个 Promise, 这个promise产生 reject 值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p2的值：&quot;</span>, value);</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p2的reason:&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">失败回调： <span class="number">1</span></span><br><span class="line">p2的reason: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>两个例子可得出：</p><blockquote><p> 如果回调函数返回一个<code>Promise</code>. 那么会根据这个<code>Promise</code>返回成功还是失败来决定使用<code>resolve</code>置值器还是 <code>reject </code>置值器（即调用下一个<code>Promise</code>的第一个参数还是第二个参数。如果是成功的）。</p><p><code>Promise</code>返回成功，则调用<code>resolve</code> 置值器，调用下一个<code>then </code>的第一个参数；如果返回失败，则调用 <code>reject </code>置值器，调用下一个<code>then</code>的第二个参数</p></blockquote><h3 id="非普调值—报错异常"><a href="#非普调值—报错异常" class="headerlink" title="非普调值—报错异常"></a>非普调值—报错异常</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功回调：&quot;</span>, value);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;报错了&quot;</span>)</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败回调：&quot;</span>, reason);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p2的值：&quot;</span>, value);</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;p2的reason&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功回调： <span class="number">1</span></span><br><span class="line">p2的reason <span class="built_in">Error</span>: 报错了</span><br></pre></td></tr></table></figure><p>由此可知：</p><blockquote><p>当报错异常（即上面所说的产生了 reject 值）。会采用reject 置值器，直接调用下一个<code>then</code> 的第二个参数</p></blockquote><p>以上的知识点都来自于：<a href="https://shuliqi.github.io/2020/07/15/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Promised%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/#%E5%88%9B%E5%BB%BAPromise">《JavaScript语言精髓与编程实战》读书笔记-Promised的核心机制</a></p><h2 id="完善-链式调用"><a href="#完善-链式调用" class="headerlink" title="完善 链式调用"></a>完善 链式调用</h2><p>那么基于上面的知识点我们来完善我们的<code> MyPromise</code>:</p><h3 id="then-返回的是全新的-Promise"><a href="#then-返回的是全新的-Promise" class="headerlink" title="then 返回的是全新的 Promise"></a>then 返回的是全新的 Promise</h3><p>我们可以使用 <code>MyPromise</code>的<code>executor</code>函数包裹了一下。而<code>executor</code>函数是立即执行的（在new 实例的时候就会运行）。所以加上这个包裹是不会对原有的逻辑存在影响。又实现了 只要有then方法执行就会返回<code>Promise</code>实例。并且是全新的<code>MyPromise</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then 返回的是全新的 Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line"><span class="comment">// ...  已省略相关逻辑</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// ...  已省略相关逻辑</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// ...  已省略相关逻辑</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="then-链上返回值的处理"><a href="#then-链上返回值的处理" class="headerlink" title="then 链上返回值的处理"></a>then 链上返回值的处理</h3><p>由上面的知识点我们可知上一个<code>Promise</code>的回调函数的返回值会有三种: </p><ul><li>返回普调值： 会被当前的 <code>Promise</code>的<code>resolve</code>置值器直接绑定给下一个 <code>Promise</code>。则调用下一个 <code>then </code>的第一个参数</li><li>返回<code>Promise</code>：会根据当前的<code>Promise</code>的返回值来决定来使用哪个置置器。当返回 成功值，使用<code>resolve</code>置值器，调用下一个<code>then</code>的第一个参数。返回失败值。使用<code>reject</code> 置值器；调用下一个<code>then</code> 的第二个参数。</li><li>报错异常：如果当发现异常报错了，使用<code>reject</code>置值器， 调用下一个then的第二个参数。</li></ul><h4 id="对普调值和报错异常的处理"><a href="#对普调值和报错异常的处理" class="headerlink" title="对普调值和报错异常的处理"></a>对普调值和报错异常的处理</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then =<span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then 返回的是全新的 Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当置值器resolve调用之后，then中的第一个函数参数会被执行（成功回调）；</span></span><br><span class="line">      <span class="comment">// 即当前的 promise 状态为 fulfilled</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值会被当前的 MyPromise 的 resolve 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 如果报错会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            reject (error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当置值器reject调用之后，then中的第一个函数参数会被执行（失败回调）；</span></span><br><span class="line">      <span class="comment">// 即当前的 promise 状态为 rejected</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 回调函数的返回值会被当前的 MyPromise 的 resolve 置值器绑定给下一个 MyPromise</span></span><br><span class="line">             <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.value)</span><br><span class="line">             resolve(result);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 如果报错会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当还不知道实例状态的情况下，把成功回调和失败回调都保存起来</span></span><br><span class="line">      <span class="comment">// 等到确定调用哪个回调之后，再拿出来调用</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值会被当前的 MyPromise 的 resolve 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值会被当前的 MyPromise 的 resolve 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.value);</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对返回值是Promise的处理"><a href="#对返回值是Promise的处理" class="headerlink" title="对返回值是Promise的处理"></a>对返回值是Promise的处理</h4><p>因为回调函数的返回值有可能是<code>Promise</code>。 那么针对这种情况， 我们把处理返回值单独提出来处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(result, resolve, reject);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// .. 已省略</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.value)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">             resolvePromiseResult(result, resolve, reject);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// .. 已省略</span></span><br><span class="line">          &#125;         </span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;this值：&quot;</span>, <span class="built_in">this</span>)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(result, resolve, reject);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// .. 已省略</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(result, resolve, reject);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// .. 已省略</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有一种情况，<code> Promise</code> 可能调用了自己本身， 这种是不允许的, 会导致死循环。所以我们<code>resolvePromiseResult</code>函数应该再加上一个参数，就是自身的<code>Promise</code>。这样在<code>resolvePromiseResult</code>函数中判断就好判断了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then =<span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newMyPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// ...已省略</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">          resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line">          </span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// .. 已省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...已省略</span></span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// ...已省略</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.value)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">           resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// .. 已省略</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// ...已省略</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// .. 已省略</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// .. 已省略</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newMyPromise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 下面我们就来看看 <code>resolvePromiseResult</code> 函数的处理：</p><p>如果返回的是自己的 Promise 对象的话，那么状态永远<code>pending </code>状态. 再也无法称为 <code>fulfilled </code>或者 <code>rejected</code>。程序是会死掉的， 所有首先处理它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromiseResult</span>(<span class="params">promise, backResult, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果结果返回的是自身， 那么直接调用reject 置值器处理。不然程序将会死掉</span></span><br><span class="line">  <span class="keyword">if</span> (promise === backResult) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Promise发生了循环引用&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是分各种情况判断： 如果 <code>backResult</code>是一个普调值， 那么直接调用 <code>resolve</code> 置值器置值。如果是一个 <code>Promise</code>, 对象（then 对象）那么就执行它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromiseResult</span>(<span class="params">promise, backResult, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果结果返回的是自身， 那么直接调用reject 置值器处理。不然程序将会死掉</span></span><br><span class="line">  <span class="keyword">if</span> (promise === backResult) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Promise发生了循环引用&quot;</span>))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (backResult !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> backResult === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> backResult === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// Promise 或者then 对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普调值， 直接使用 resove 置值器置值</span></span><br><span class="line">    resolve(backResult);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>backResult</code> 是一个对象 或者 函数的话，那么尝试把<code>then</code> 方法取出来，此时如果报错，那么将是使用<code>reject</code>置值器置值。    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromiseResult</span>(<span class="params">promise, backResult, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果结果返回的是自身， 那么直接调用reject 置值器处理。不然程序将会死掉</span></span><br><span class="line">  <span class="keyword">if</span> (promise === backResult) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Promise发生了循环引用&quot;</span>))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (backResult !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> backResult === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> backResult === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// Promise 或者then 对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//  取出 then 方法</span></span><br><span class="line">      <span class="keyword">const</span> then = backResult.then;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果此时报错， 将世界使用 reject 置值器置值</span></span><br><span class="line">      reject(error);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普调值， 直接使用 resove 置值器置值</span></span><br><span class="line">    resolve(backResult);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对象中有<code>then</code>，并且是函数类型， 那么就可认为是一个 <code>Promise</code>对象。之后直接调用这个 <code>then</code> 方法。成功回调的话使用<code> resolve</code> 置值器，失败回调的话使用<code> reject</code> 置值器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromiseResult</span>(<span class="params">promise, backResult, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果结果返回的是自身， 那么直接调用reject 置值器处理。不然程序将会死掉</span></span><br><span class="line">  <span class="keyword">if</span> (promise === backResult) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Promise发生了循环引用&quot;</span>))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (backResult !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> backResult === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> backResult === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// Promise 或者then 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  取出 then 方法</span></span><br><span class="line">      <span class="keyword">const</span> then = backResult.then;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 then 是一个函数，那么直接执行， </span></span><br><span class="line">        then(<span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 成功的话使用 resolve 置值器</span></span><br><span class="line">          resolve(y)</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 失败的话使用 reject 置值器</span></span><br><span class="line">          reject(error);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果此时报错， 将世界使用 reject 置值器置值</span></span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普调值， 直接使用 resove 置值器置值</span></span><br><span class="line">    resolve(backResult);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行的时候，我们需要绑定一下<code> this</code> 值。 因为内部可能用到了<code>this</code> 呀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 如果 then 是一个函数，那么直接执行 </span></span><br><span class="line">  then.call(promise, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 成功的话使用 resolve 置值器</span></span><br><span class="line">    resolve(y)</span><br><span class="line">  &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 失败的话使用 reject 置值器</span></span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在链式调用已经基本完成了，但是还有一种极端的情况。如果<code> Promise</code> 对象转为成功状态或者失败的状态的时候传入的是一个<code>Promise</code> 对象。那么此时应该继续执行 ，知道最后的 <code>Promise</code>  执行完成。那么久需要递归了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 then 是一个函数，那么直接执行 </span></span><br><span class="line">then.call(promise, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 递归调用，传入y若是Promise对象，继续循环</span></span><br><span class="line">  resolvePromiseResult(promise, y, resolve, reject)</span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 失败的话使用 reject 置值器</span></span><br><span class="line">  reject(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么现在的 链式调用就全部完成了。</p><p>最后我们贴上全部的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存成功回调：then方法中的第一个参数</span></span><br><span class="line">  self.onResolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存失败回调：：then方法中的第二个参数</span></span><br><span class="line">  self.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例的默认状态： pending</span></span><br><span class="line">  self.status = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Promise的状态一经修改就不能再改变，所以只有在 pending 状态才能修改</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.status = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">      <span class="comment">// Promise的值</span></span><br><span class="line">      self.value = value;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把存起来的成功回调调用</span></span><br><span class="line">      self.onResolvedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          fn();</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>  <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Promise的状态一经修改就不能再改变，所以只有在 pending 状态才能修改</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      <span class="comment">// Promise的值</span></span><br><span class="line">      self.value = reason;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把保存起来的失败回调拿出来调用</span></span><br><span class="line">      self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          fn();</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// executor 是会被立即执行的</span></span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromiseResult</span>(<span class="params">promise, backResult, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果结果返回的是自身， 那么直接调用reject 置值器处理。不然程序将会死掉</span></span><br><span class="line">  <span class="keyword">if</span> (promise === backResult) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Promise发生了循环引用&quot;</span>))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (backResult !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> backResult === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> backResult === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// Promise 或者then 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  取出 then 方法</span></span><br><span class="line">      <span class="keyword">const</span> then = backResult.then;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 then 是一个函数，那么直接执行 </span></span><br><span class="line">        then.call(promise, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 递归调用，传入y若是Promise对象，继续循环</span></span><br><span class="line">          resolvePromiseResult(promise, y, resolve, reject)</span><br><span class="line">        &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 失败的话使用 reject 置值器</span></span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果此时报错， 将世界使用 reject 置值器置值</span></span><br><span class="line">      reject(error);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普调值， 直接使用 resove 置值器置值</span></span><br><span class="line">    resolve(backResult);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then =<span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then 返回的是全新的 Promise</span></span><br><span class="line">  <span class="keyword">const</span> newMyPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当置值器resolve调用之后，then中的第一个函数参数会被执行（成功回调）；</span></span><br><span class="line">      <span class="comment">// 即当前的 promise 状态为 fulfilled</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line">            </span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 如果报错会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            reject (error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当置值器reject调用之后，then中的第一个函数参数会被执行（失败回调）；</span></span><br><span class="line">      <span class="comment">// 即当前的 promise 状态为 rejected</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.value)</span><br><span class="line"> </span><br><span class="line">           <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line"> </span><br><span class="line">         &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">           <span class="comment">// 如果报错会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">           reject(error)</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当还不知道实例状态的情况下，把成功回调和失败回调都保存起来</span></span><br><span class="line">      <span class="comment">// 等到确定调用哪个回调之后，再拿出来调用</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newMyPromise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试例子"><a href="#测试例子" class="headerlink" title="测试例子"></a>测试例子</h2><p>最后我们来测试一下：</p><h5 id="测试用例1"><a href="#测试用例1" class="headerlink" title="测试用例1"></a>测试用例1</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功1&quot;</span>, value)</span><br><span class="line">&#125;,  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败1&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功2&quot;</span>, value)</span><br><span class="line">&#125;,  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败2&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br></pre></td></tr></table></figure><p>实际结果与期望结果一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">成功<span class="number">1</span> <span class="number">2</span></span><br><span class="line">成功<span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>支持异步，支持多次调用<code>then</code></p><h5 id="测试用例2"><a href="#测试用例2" class="headerlink" title="测试用例2"></a>测试用例2</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  resolve(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功1&quot;</span>, value)</span><br><span class="line">&#125;,  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败1&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功2&quot;</span>, value)</span><br><span class="line">&#125;,  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败2&quot;</span>, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际结果与期望结果一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">成功<span class="number">1</span> <span class="number">2</span></span><br><span class="line">成功<span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>实现<code>then</code>方法是异步的，支持多次调用<code>then</code></p><h5 id="测试用例3"><a href="#测试用例3" class="headerlink" title="测试用例3"></a>测试用例3</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功1&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// 返回普调值</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败1&quot;</span>, reason);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功2&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;,<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;失败2&quot;</span>, reason);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>实际结果与期望结构一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">成功<span class="number">1</span> <span class="number">2</span></span><br><span class="line">成功<span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>支持链式调用</p><h1 id="Promise-的原型方法"><a href="#Promise-的原型方法" class="headerlink" title="Promise 的原型方法"></a>Promise 的原型方法</h1><p>原型除了<code> then</code> 方法之外， 当然还有 <code>catch</code>, <code>finally</code>方法。 那我们来一一实现下。</p><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>catch</code>方法是<code>then</code>方法的语法糖。 只接受rejected 状态的数据。它就相当于<code>then</code> 的第二个参数函数。 那写的时候直接调用 then 方法的第二个参数函数即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 失败</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;失败&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="keyword">catch</span>((err) =&gt; &#123;</span><br><span class="line">  console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Error: 失败</span></span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally</code>方法 也是<code>Promise</code>的一个语法糖，在当前的<code>Promise</code>执行完<code>then</code>或者执行完<code>catch</code>之后均会触发。</p><p>注意：<code>finally</code>的参数（回调函数） 是不带任何的参数的。</p><ul><li><p>考虑到当前返回的<code> resolve</code> 可能是个异步函数，所以要通过调用实例上的 <code>then</code>方法，添加 <code>callback</code> 逻辑</p></li><li><p>成功传 <code>value</code> 值， 失败传<code>error</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MyPromise.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(callback())</span><br><span class="line">    .then(<span class="function">() =&gt;</span> value)</span><br><span class="line">  &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(callback())</span><br><span class="line">   .then(<span class="function">() =&gt;</span> err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="keyword">finally</span>(() =&gt; &#123;</span><br><span class="line">  console.log(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then((value) =&gt; &#123;</span><br><span class="line">  console.log(<span class="string">&quot;value&quot;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 222</span></span><br><span class="line"><span class="comment">// value 111</span></span><br></pre></td></tr></table></figure><h1 id="Promise-的类方法"><a href="#Promise-的类方法" class="headerlink" title="Promise 的类方法"></a>Promise 的类方法</h1><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><code>Promise.all(arr)</code> 返回一个新的 <code>Promise</code>实例，参数是外面传入的多个 <code>Promise</code>的实例。对于返回新的实例的，有以下这两种情况：</p><ul><li>如果传入的所有 promise 实例的状态均变为<code>fulfilled</code>，那么返回的 promise 实例的状态就是<code>fulfilled</code>，并且其 value 是 传入的所有 promise 的 value 组成的数组。</li><li>如果有一个 promise 实例状态变为了<code>rejected</code>，那么返回的 promise 实例的状态立即变为<code>rejected</code>。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>实现思路：</p><ul><li>传入的参数不一定是数组对象，可以是”遍历器”</li><li>传入的每个实例不一定是 promise，需要用<code>Promise.resolve()</code>包装</li><li>借助”计数器”，标记是否所有的实例状态均变为<code>fulfilled</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrPromises = [...arg];</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    arrPromises.forEach(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">        p.then(<span class="function">(<span class="params">vaue</span>) =&gt;</span> &#123;</span><br><span class="line">          result.push(value);</span><br><span class="line">          num++;</span><br><span class="line">          <span class="comment">// 必须要等所有的都执行完，才能返回</span></span><br><span class="line">          <span class="keyword">if</span> (num === arrPromises.length) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>尝试resolve 所有元素。只要其任一元素resolved 或 rejected，都将以该结果作为结果promise</p><blockquote><p><code>Promise.race(iterators)</code>的传参和返回值与<code>Promise.all</code>相同。但其返回的 promise 的实例的状态和 value，完全取决于：传入的所有 promise 实例中，最先改变状态那个（不论是<code>fulfilled</code>还是<code>rejected</code>）。</p></blockquote><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><ul><li>某传入实例<code>pending -&gt; fulfilled</code>时，其 value 就是<code>Promise.race</code>返回的 promise 实例的 value</li><li>某传入实例<code>pending -&gt; rejected</code>时，其 error 就是<code>Promise.race</code>返回的 promise 实例的 error</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrPromises = <span class="built_in">Array</span>.from(arg);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">ressolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    arrPromises.forEach(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h2><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h3><p><code>Promise.any(iterators)</code>的传参和返回值与<code>Promise.all</code>相同。</p><p>如果传入的实例中，有任一实例变为<code>fulfilled</code>，那么它返回的 promise 实例状态立即变为<code>fulfilled</code>；如果所有实例均变为<code>rejected</code>，那么它返回的 promise 实例状态为<code>rejected</code>。</p><p>⚠️<code>Promise.all</code>与<code>Promise.any</code>的关系，类似于，<code>Array.prototype.every</code>和<code>Array.prototype.some</code>的关系。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现思路和<code>Promise.all</code>及其类似。不过由于对异步过程的处理逻辑不同，<strong>因此这里的计数器用来标识是否所有的实例均 rejected</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.any = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrPromises = <span class="built_in">Array</span>.from(arg);</span><br><span class="line">  <span class="keyword">let</span> rejectedNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> errResult = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    arrPromises.forEach(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        rresolve(value)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        errResult.push(err)</span><br><span class="line">        rejectedNum++;</span><br><span class="line">        <span class="keyword">if</span> (rejectedNum === arrPromises.length) &#123;</span><br><span class="line">          reject(errResult);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>作用也是将多个promise实例，包装成一个新的Promise实例.。但是只要这些参数的实例都返回结果，不管是fulfilled还是rejected,包装实例才会结束。</p><h3 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h3><p><code>Promise.allSettled(iterators)</code>的传参和返回值与<code>Promise.all</code>相同。</p><p>根据<a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a>，此返回的 promise 实例的状态只能是<code>fulfilled</code>。对于传入的所有 promise 实例，会等待每个 promise 实例结束，并且返回规定的数据格式。</p><p>如果传入 a、b 两个 promise 实例：a 变为 rejected，错误是 error1；b 变为 fulfilled，value 是 1。那么<code>Promise.allSettled</code>返回的 promise 实例的 value 就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#123; <span class="attr">status</span>: <span class="string">&quot;rejected&quot;</span>, <span class="attr">value</span>: error1 &#125;, &#123; <span class="attr">status</span>: <span class="string">&quot;fulfilled&quot;</span>, <span class="attr">value</span>: <span class="number">1</span> &#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>计数器，用于统计所有传入的 promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.allSetlled = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrPromises = <span class="built_in">Array</span>.from(arg);</span><br><span class="line">  <span class="keyword">let</span>  result = [];</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    arrPromises.forEach(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        result.push(value);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (num === arrPromises.length) &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        result.push(err);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (num === arrPromises.length) &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Promise.all、Promise.any 和 Promise.allSettled 中计数器使用对比:</p><p>这三个方法均使用了计数器来进行异步流程控制，下面表格横向对比不同方法中计数器的用途，来加强理解：</p><table><thead><tr><th>方法名</th><th>用途</th></tr></thead><tbody><tr><td><code>Promise.all</code></td><td>标记 fulfilled 的实例个数</td></tr><tr><td><code>Promise.any</code></td><td>标记 rejected 的实例个数</td></tr><tr><td><code>Promise.allSettled</code></td><td>标记所有实例（fulfilled 和 rejected）的个数</td></tr></tbody></table><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>该方法是将现有的对象转成 <code>promise</code>对象。</p><h3 id="过程-4"><a href="#过程-4" class="headerlink" title="过程"></a>过程</h3><ul><li><p>如果当前的值是一个 <code>Promise</code>对象或者是 <code>thenable</code> 那么直接返回。</p></li><li><p>反之则返回一个 使用<code> resolve</code> 置值器绑定当前值 的<code>Promise</code></p></li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是一个Promise 对象 或者是 thenable 对象。那么直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> <span class="built_in">Promise</span> || (<span class="keyword">typeof</span> arg === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="string">&#x27;then&#x27;</span> <span class="keyword">in</span> arg )) <span class="keyword">return</span> arg;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(arg);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>该方法返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><p><strong>注意：</strong><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(arg);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>最后附上完整的代码。 当然在写一写Promise的原型和类方法的时候， 可能会用用到了原生的<code>Promise</code>。当然是可以替换成我们自己的<code>MyPromise</code>的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存成功回调：then方法中的第一个参数</span></span><br><span class="line">  self.onResolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存失败回调：：then方法中的第二个参数</span></span><br><span class="line">  self.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例的默认状态： pending</span></span><br><span class="line">  self.status = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Promise的状态一经修改就不能再改变，所以只有在 pending 状态才能修改</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.status = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">      <span class="comment">// Promise的值</span></span><br><span class="line">      self.value = value;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把存起来的成功回调调用</span></span><br><span class="line">      self.onResolvedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          fn();</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 置值器： 用于修改状态</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>  <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Promise的状态一经修改就不能再改变，所以只有在 pending 状态才能修改</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      <span class="comment">// Promise的值</span></span><br><span class="line">      self.value = reason;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把保存起来的失败回调拿出来调用</span></span><br><span class="line">      self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          fn();</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// executor 是会被立即执行的</span></span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromiseResult</span>(<span class="params">promise, backResult, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果结果返回的是自身， 那么直接调用reject 置值器处理。不然程序将会死掉</span></span><br><span class="line">  <span class="keyword">if</span> (promise === backResult) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Promise发生了循环引用&quot;</span>))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (backResult !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> backResult === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> backResult === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// Promise 或者then 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  取出 then 方法</span></span><br><span class="line">      <span class="keyword">const</span> then = backResult.then;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 then 是一个函数，那么直接执行 </span></span><br><span class="line">        then.call(promise, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 递归调用，传入y若是Promise对象，继续循环</span></span><br><span class="line">          resolvePromiseResult(promise, y, resolve, reject)</span><br><span class="line">        &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 失败的话使用 reject 置值器</span></span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果此时报错， 将世界使用 reject 置值器置值</span></span><br><span class="line">      reject(error);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普调值， 直接使用 resove 置值器置值</span></span><br><span class="line">    resolve(backResult);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 出来的实例在原型上有 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then 返回的是全新的 Promise</span></span><br><span class="line">  <span class="keyword">const</span> newMyPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当置值器resolve调用之后，then中的第一个函数参数会被执行（成功回调）；</span></span><br><span class="line">      <span class="comment">// 即当前的 promise 状态为 fulfilled</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line">            </span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 如果报错会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            reject (error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当置值器reject调用之后，then中的第一个函数参数会被执行（失败回调）；</span></span><br><span class="line">      <span class="comment">// 即当前的 promise 状态为 rejected</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// then 方法是异步指执行的，使用setTimeOut 将同步代码变成异步代码。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.value)</span><br><span class="line"> </span><br><span class="line">           <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line"> </span><br><span class="line">         &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">           <span class="comment">// 如果报错会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">           reject(error)</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当还不知道实例状态的情况下，把成功回调和失败回调都保存起来</span></span><br><span class="line">      <span class="comment">// 等到确定调用哪个回调之后，再拿出来调用</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  因为 result 有可能是 promise，抽离出来处理</span></span><br><span class="line">            resolvePromiseResult(newMyPromise, result, resolve, reject);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 回调函数的返回值会被当前的 MyPromise 的 reject 置值器绑定给下一个 MyPromise</span></span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newMyPromise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(callback())</span><br><span class="line">    .then(<span class="function">() =&gt;</span> value)</span><br><span class="line">  &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(callback())</span><br><span class="line">   .then(<span class="function">() =&gt;</span> err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrPromises = <span class="built_in">Array</span>.from(arg);</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    arrPromises.forEach(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">        p.then(<span class="function">(<span class="params">vaue</span>) =&gt;</span> &#123;</span><br><span class="line">          result.push(value);</span><br><span class="line">          num++;</span><br><span class="line">          <span class="comment">// 必须要等所有的都执行完，才能返回</span></span><br><span class="line">          <span class="keyword">if</span> (num === arrPromises.length) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrPromises = <span class="built_in">Array</span>.from(arg);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">ressolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    arrPromises.forEach(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.any = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrPromises = <span class="built_in">Array</span>.from(arg);</span><br><span class="line">  <span class="keyword">let</span> rejectedNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> errResult = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    arrPromises.forEach(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        rresolve(value)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        errResult.push(err)</span><br><span class="line">        rejectedNum++;</span><br><span class="line">        <span class="keyword">if</span> (rejectedNum === arrPromises.length) &#123;</span><br><span class="line">          reject(errResult);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyPromise.allSetlled = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrPromises = <span class="built_in">Array</span>.from(arg);</span><br><span class="line">  <span class="keyword">let</span>  result = [];</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    arrPromises.forEach(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        result.push(value);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (num === arrPromises.length) &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        result.push(err);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (num === arrPromises.length) &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;then&#x27;</span> <span class="keyword">in</span> obj)</span><br><span class="line"></span><br><span class="line">MyPromise.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是一个Promise 对象 或者是 thenable 对象。那么直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> <span class="built_in">Promise</span> || (<span class="keyword">typeof</span> arg === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="string">&#x27;then&#x27;</span> <span class="keyword">in</span> arg )) <span class="keyword">return</span> arg;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(arg);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(arg);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的渲染流程</title>
      <link href="/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="导航流程"><a href="#导航流程" class="headerlink" title="导航流程"></a>导航流程</h2><p>浏览器从输入<code>URL</code>到页面展示间到底发生了什么？这整个流程涉及到<strong>网络请求</strong>和<strong>渲染流程</strong>两大块内容。我们可以先看一下总体的导航流程。</p> <span id="more"></span><h3 id="浏览器进程构建完整的URL"><a href="#浏览器进程构建完整的URL" class="headerlink" title="浏览器进程构建完整的URL"></a>浏览器进程构建完整的URL</h3><ul><li>浏览器进程会检查输入的URL，组装协议，构建完整的的URL</li><li>浏览器进程会通过进程间通信（IPC）把URL请求发送网络进程</li></ul><h3 id="网络进程发起URL请求"><a href="#网络进程发起URL请求" class="headerlink" title="网络进程发起URL请求"></a>网络进程发起URL请求</h3><ul><li>检查本地缓存是有效，如果有有效，则使用本地缓存；如果无效，则进入网络请求流程</li><li>网络请求的第一步：DNS解析，获取请求域名的IP地址</li><li>和服务器建立TCP链接，并且构建请求信息</li><li>服务器接收到请求之后，会构建响应信息</li><li>浏览器接收到响应信息后，网络请求会解析响应信息， 若状态码是301/302，则会重定向到新的地址，重新发起URL请求</li><li>浏览器根据响应的类型（ConTent-Type）进行处理</li></ul><h3 id="浏览器进程向渲染进程提交文档"><a href="#浏览器进程向渲染进程提交文档" class="headerlink" title="浏览器进程向渲染进程提交文档"></a>浏览器进程向渲染进程提交文档</h3><ul><li>浏览器接收到响应信息后， 会开始准备渲染进程， 同一个站点（同根域名，同协议）会复用同一个渲染进程</li><li>浏览器进程准备完毕后，浏览器进程会和渲染进程进行通信，传输文档</li></ul><h3 id="渲染进程开始解析页面和加载子资源，完成页面的渲染"><a href="#渲染进程开始解析页面和加载子资源，完成页面的渲染" class="headerlink" title="渲染进程开始解析页面和加载子资源，完成页面的渲染"></a>渲染进程开始解析页面和加载子资源，完成页面的渲染</h3><p>这个过程就是渲染流程，就是我们本文重点讲的</p><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>为什么要构建DOM树呢？因为浏览器无法识别HTML，所以需要HTML解析成浏览器识别的数据结构——DOM树。</p><img src="/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/1.jpg" class=""><h3 id="构建CSSOM树"><a href="#构建CSSOM树" class="headerlink" title="构建CSSOM树"></a>构建CSSOM树</h3><p>一样的，浏览器也无法识别CSS，所以浏览器会先将CSS解2.jpg析成浏览器能识别的数据结构—styleSheets</p><p>然后浏览器会将属性值转化成标准值，因为标准值才容易被渲染引擎理解和使用。</p><img src="/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/2.jpg" class=""><p>最后，计算DOM树˙中的每个节点的演示， 生成最终的CSSDOM树，这个过程涉及到CSS的继承规则和层叠规则。</p><img src="/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/3.jpg" class=""><h3 id="构建渲染树（Render-Tree），并计算布局"><a href="#构建渲染树（Render-Tree），并计算布局" class="headerlink" title="构建渲染树（Render Tree），并计算布局"></a>构建渲染树（Render Tree），并计算布局</h3><p>将DOM树和CSSDOM树结合就可以得到渲染树。</p><p>首先，浏览器会遍历所有可见的元素(像hea这类不可见的标签或者display设置为none的元素等会被排除在外)。</p><p>接着，找到节点所适配的的样式并应用， 最终生成渲染树。</p><img src="/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/4.jpg" class=""><p>即使现在有了渲染树，但是浏览器不知道每个节点的位置信息，所以浏览器会遍历渲染树，计算每个节点的位置信息，这就是计算布局。</p><h3 id="分层和绘制"><a href="#分层和绘制" class="headerlink" title="分层和绘制"></a>分层和绘制</h3><p>经过计算布局之后，并不是立马进行绘制，而是会为有3D或透视变换、z轴排序等复杂效果的节点创建图层，并生成图层树，这样做的目的是方便地实现复杂效果。浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p><p>什么情况下会创建图层呢？</p><ul><li>有层叠上下文（明确定位属性的元素， 定义透明属性的元素，使用CSS 滤镜）</li><li>需要裁剪（overflow: hidden;溢出部分被剪裁）</li></ul><p>有了图层树之后，接下来就是绘制图层了。</p><p>接着，浏览器会将图层划分为图块，这么做的目的是因为视口显示的内容有限，如果直接将整个结构进行绘制开销比较大，所以浏览器会优先将视口内的图块转为位图，这个过程叫栅格化。</p><p>最后，将位图合成，浏览器开始显示。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/5.jpg" class=""><p>如上图所示，HTML的渲染过程如下：</p><ul><li><p>将HTML解析为DOM树</p></li><li><p>将CSS解析为CSSOM树</p></li><li><p>将DOM树和CSSOM树构建成渲染树，并计算布局</p></li><li><p>进行分层和绘制</p></li></ul><h2 id="渲染进程的特点"><a href="#渲染进程的特点" class="headerlink" title="渲染进程的特点"></a>渲染进程的特点</h2><h3 id="回流和绘制"><a href="#回流和绘制" class="headerlink" title="回流和绘制"></a>回流和绘制</h3><p>回流和绘制是渲染进程比较重要的概念了，了解其中的概念并进行合理的的应用，可以提升性能。</p><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><p>当元素的几何属性(尺寸),隐藏属性等改变而触发重新布局的渲染，这个过程就是回流。回流需要更新完整的渲染流程（布局-分层-绘制-图块-栅格化-合成-显示）， 所以开销比较大,需要尽量避免.</p><h4 id="触发回流的属性"><a href="#触发回流的属性" class="headerlink" title="触发回流的属性"></a>触发回流的属性</h4><ul><li>盒子模型相关属性（width、padding、margin、display、border等）</li><li>定位属性和浮动（position、top、float等）</li><li>文字结构（text-align、font、white-space、overflow等）</li></ul><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>当元素的外观、风格等属性发生改变但不会影响布局的渲染，这个过程就是重绘。重绘省去了布局和分层阶段（绘制-图块-栅格化-合成-显示），所以性能比回流要好。回流必将引起重绘，重绘不一定会触发回流。</p><h4 id="触发重绘的属性"><a href="#触发重绘的属性" class="headerlink" title="触发重绘的属性"></a>触发重绘的属性</h4><p>color，border-style, background，outlinee，box-shadow，visibility， text-decoration</p><h3 id="避免回流和重绘"><a href="#避免回流和重绘" class="headerlink" title="避免回流和重绘"></a>避免回流和重绘</h3><p>频繁触发重绘和回流，会导致UI频繁渲染，最终导致性能变差。所以要尽量避免重绘和回流：</p><ul><li>避免使用触发重绘和回流的CSS属性</li><li>将频繁重绘回流的元素创建为一个独立图层</li></ul><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><ul><li>使用transform实现效果：可以避开回流和重绘，直接进入合成阶段（图块-栅格化-合成-显示）</li><li>用opacity替代visibility：visibility会触发重绘</li><li>使用class替代DOM频繁操作样式</li><li>DOM离线后修改，如果有频繁修改，可以先把DOM隐藏，修改完成后再显示</li><li>不要在循环中读取DOM的属性值：offsetHeight会使回流缓冲失效</li><li>尽量不要使用table布局，小改动会造成整个table重新布局</li><li>动画的速度：200~500ms最佳</li><li>对动画新建图层</li><li>启用GPU硬件加速：启用translate3D</li></ul><h3 id="HTML解析的特点"><a href="#HTML解析的特点" class="headerlink" title="HTML解析的特点"></a>HTML解析的特点</h3><h4 id="顺序执行，并发加载"><a href="#顺序执行，并发加载" class="headerlink" title="顺序执行，并发加载"></a>顺序执行，并发加载</h4><ul><li>顺序执行：HTML的词法分析事从上到下， 顺序执行</li><li>并发加载：当HTML解析被脚本阻碍时，解析器虽然会停止构建DOM，但仍会识别脚本后面的内容，并进行加载</li><li>并发上限：浏览器对同域名的并发数是有限制的</li></ul><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><h5 id="css阻塞"><a href="#css阻塞" class="headerlink" title="css阻塞"></a>css阻塞</h5><ul><li>css 在head中阻塞页面的渲染：避免页面闪动</li><li>css会阻塞jsd的执行：CSSOM构建的时候，Javascript执行将被暂停，知道CSSDOM构建完成</li><li>css不会阻塞外部脚本的加载</li></ul><h5 id="js阻塞"><a href="#js阻塞" class="headerlink" title="js阻塞"></a>js阻塞</h5><ul><li>直接引入的js会阻塞页面的渲染：当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行</li><li>js不阻塞资源的加载</li><li>js顺序执行，会阻塞后续js的执行</li><li>js可以查询和修改 DOM 与 CSS</li></ul><h5 id="改变js的阻塞"><a href="#改变js的阻塞" class="headerlink" title="改变js的阻塞"></a>改变js的阻塞</h5><p><code>defer</code>和<code>async</code>属性可以改变js的阻塞情形，不过这两个只对src方式引入的script有效，对于inline-script无效。</p><p><code>defer</code>表示延迟执行，浏览器会异步地加载该脚本并且不会影响到后续DOM的渲染，该脚本将在文档完成解析后，<code>DOMContentLoaded</code>事件触发前执行。对动态嵌入的脚本使用 <code>async=false</code> 来达到类似的效果。</p><p><code>async</code>表示异步执行，浏览器会异步地加载脚本并在允许的情况下执行。与 defer 的区别在于，无论是 HTML 解析阶段还是<code>DOMContentLoaded</code>触发之后，如果脚本加载完成，就会开始执行。需要注意的是，这种方式加载的 JavaScript 依然会阻塞<code>load</code>事件。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记-Promise</title>
      <link href="/2018/03/20/ES6%E5%AD%A6%E4%B9%A0-Promise/"/>
      <url>/2018/03/20/ES6%E5%AD%A6%E4%B9%A0-Promise/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>我们知道在Javascript中，所有的代码都是单线程的。也就是说是同步执行的。而Promise就为异步编程提供了一种解决方案</strong></p></blockquote><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>Promise</code> 是一个对象，从它那里可以取得异步操作的消息。Promise 提供统一的API，各种异步操作都可以用同样的方法进行处理。</p><ul><li><p>状态：</p><p>一共有三种状态：<strong>pending（进行中</strong>)， **fulfilled（已成功)**， <strong>rejected（已失败)</strong></p></li><li><p>特点：</p><ol><li><p><strong>对象的状态不受外界的影响。</strong></p><p>只有异步的结果可以决定当前是哪一种状态（pending， fulfilled, rejected）。 其他的手段都是无法改变的。</p></li><li><p><strong>一旦状态改变，就不会再变，任何时候都可以拿到这个状态。</strong></p><p>Promise的状态只有两种可能：从pending 到 fulfilled， 从peding 到rejected。只要这两种涨停发生了，状态也就凝固了，不会再变了。</p><p>如果在对Promise对象添加回调函数，也会立刻拿到这个结果。</p></li></ol></li><li><p>缺点：</p><ol><li><strong>无法取消Promise,一旦新建就会立即执行，中途无法取消</strong></li><li><strong>如果没有设置回掉函数，Promise内部抛出错误，不会反应到外部</strong></li><li><strong>当处于pending状态的时候，无法知道目前进展到哪一个阶段（刚刚开始还是即将完成）</strong></li></ol></li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><strong>Promise 对象是有关键字new 和Promise 构造函数创建的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="comment">/** 异步操作成功 */</span> ) &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise构造函数的参数是一个函数， 这个函数有两个参数<code>resolve</code>, <code>reject</code>，这两个参数也是函数，由Javacript引擎提供， 不用自己部署。</p><p><strong>resolve函数：</strong>将Promise对象的状态“未完成” 变成”完成“ （pending —-&gt; fulfilled）. 在异步操作成功的时候调用， 并且会异步操作的结果作参数传递出去；</p><p>**reject函数: **将Promise对象的状态“未完成” 变成”失败“ （pending —-&gt; rejected）. 在异步操作失败的时候调用， 并且会异步操作的结果作参数传递出去；</p><p><strong>Promise实例生成之后， 可以使用then方法分别指定 resolve 和 rejected 状态的回调。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 异步操作成功的回调</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步操作失败的回调</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>then方法可以有两个回调函数作为参数，。 第一个回调函数是Promise对象变为resolve时调用， 第二个回调函数是Promise对象状态变为rejected时调用。其中第二个参数是可选的，不一定要提供。这两个函数都接受promise对象传出的值作为参数。</p><p>再看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">timeout(<span class="number">1000</span>).then(</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;异步操作成功&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;异步操作失败了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>Promise 新建之后就会立即执行。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;11111&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;2222&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;33333&quot;</span>);</span><br><span class="line"><span class="comment">// 11111</span></span><br><span class="line"><span class="comment">// 33333</span></span><br><span class="line"><span class="comment">// 2222</span></span><br></pre></td></tr></table></figure><p>Promise执行之后是立即执行的， 先输出了 <code>11111</code> 然后then方法指定回调函数，将当前的同步操作的任务执行完毕之后(输出 <code>33333</code>)。 最后才输出 <code>222</code></p><p>一个Promise封装的ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax = <span class="function">(<span class="params">method, url, <span class="keyword">async</span>, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.onreadychange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.resayState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">          resolve(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.status));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(method, url, <span class="keyword">async</span>);</span><br><span class="line">    xhr.send(data || <span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;api/get/shu&quot;</span>, <span class="literal">true</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;sgykiuqu&quot;</span> &#125;).then(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求成功&quot;</span>, data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求抛出错误：&quot;</span> + error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果调用resolve函数和rejecte函数时都带有参数，那么它们的参数就会被传递给回调函数。reject函数的参数通常是Error实例， 表示抛出错误，。 resolve函数的参数除了正常的值以外，还可能是另外一个Promise实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, rejecte) =&gt; &#123;&#125;);</span><br><span class="line">const p2 = new Promise((resolve, rejecte) =&gt; &#123;</span><br><span class="line">resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个例子， p1和p2都是Pro mi se实例， 但是p2的resolve方法将p1作为参数，也就是说以后个异步操作返回了另外一个异步操作。</p><p><strong>注意：</strong>这里的p1的状态会传递给p2，也就是说， p1 的状态决定了p2 的状态。如果p1的状态是pendin·g，那么p2的回调函数就会等待p1状态的改变；如果p1的状态是fulfilled 或者 rejected， 那么回调函数就会立即执行；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个例子p2就会等p1 的状态改变回调函数才会调用（等了1 秒才调用）</p><p><strong>调用resolve或者rejecte并不会终止Promise的执行</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;22222&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 22222</span></span><br><span class="line"><span class="comment">// 111111</span></span><br></pre></td></tr></table></figure><p>这个例子： 调用了 resolve(“111111”); 之后， 后面的 console.log(“22222”); 还是会执行， 并且首先打印出来。这是因为resolve 是在本轮时间循环的末尾执行， 总是晚于本轮的同步任务。</p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="string">&quot;111111&quot;</span>);  <span class="comment">//加上return </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;22222&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 111111</span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p><strong>作用：</strong>Promise 状态改变时的回调函数。</p><p>有两个函数参数：第一个是fulfilled状态的回调函数，一个是rejected状态的回调函数。 的哥参数是可选的。</p><p>then方法返回的是一个新的Pro mi se实例（不是原来的Promise实例）。 因此可以采用链式写法：then方法后面再调用另一个then方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function">() =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;22222&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> timeout(<span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;44444&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子可以看出，前一个回调函数，有可能返回一个promise对象(也就是有异步操作)， 这时后一个回调函数，就会等待该Promise对象状态发生改变(等待timeout)才会被调用。</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><strong>作用：</strong>用于指定发生错误的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax = <span class="function">(<span class="params">method, url, <span class="keyword">async</span>, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.onreadychange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.resayState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">          resolve(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.status));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(method, url, <span class="keyword">async</span>);</span><br><span class="line">    xhr.send(data || <span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;/api/getname&quot;</span>, <span class="literal">true</span>).then(() -&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发生错误&quot;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发生错误 ReferenceError: XMLHttpRequest is not defined</span></span><br></pre></td></tr></table></figure><p>这个例子： 如果对象的promise异步操作成功就会调用t hen方法， 如果一步操作抛出错误，状态变味rejected,就会调用catch()方法指定的回调函数处理这个错误，另外，then()方法指定的回调函数运行中抛出错误，也会被catch()方法捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(shu);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;发生错误&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 发生错误 ReferenceError: shu is not defined</span></span><br></pre></td></tr></table></figure><p>在then方法中没有 shu 这个变量， catch捕获到了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以发现<code>reject()</code>方法的作用，等同于抛出错误;</p><p>再看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(shu);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;发生错误&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果Promise的状态已经变成fulfilled。 再抛出错误是没用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;发生错误&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 成功</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p><p>一般来说， 不要再then方法里面定义rejecte状态的回调函数（即then的第二个参数）。总是使用catch方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><strong>作用：</strong>不管promise的最后状态如何，都会执行的操作。</p><p>该方法不接受任何参数，意思就是Promise状态到底是什么，是没有办法知道的。这表明finally方法里面的操作时跟状态无关的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;发生错误&quot;</span>, error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;不管promise状态怎么样， 我都会执行&quot;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><strong>作用:</strong> 将多个Promise实例， 包装成一个新的Promise实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1,p2,p3])</span><br></pre></td></tr></table></figure><p>Promise.all()方法接受一个数组作为参数， 也可以不是数组， 但是必须是具有iterator 接口， 且返回的每个成员都是pro mise对象。</p><p>如果传入的参数不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>p的状态是有p1,p2,p3决定，分成两种情况。</p><ol><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>状态都变成<code>fulfilled</code>，p的状态才会变成<code>fulfilled</code>。此p1,p2,p3的返回值组成一个数组，传递给p的回调函数。</li><li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.all([timeout1, timeout2])</span><br><span class="line">    .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;都执行完成了&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;没有catch&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 都执行完成了</span></span><br></pre></td></tr></table></figure><p>所有的Promise实例的状态都是fulfilled。 所有会调成功的回调， 打印：”都执行完成了”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(reject, <span class="number">2000</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.all([timeout1, timeout2])</span><br><span class="line">    .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;都执行完成了&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;至少有一个状态是rejected&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 至少有一个状态是rejected</span></span><br></pre></td></tr></table></figure><p>timeout2d的状态是rejected， 所以all的最终状态是rejected。</p><p>如果作为参数的promise实例， 自己定义了catch方法， 那么它一旦rejected。并且不会触发Pro mi se.all()的catch方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(reject, <span class="number">2000</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">  &#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timeou2 的catch&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.all([timeout1, timeout2])</span><br><span class="line">    .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;都执行完成了&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;不会到打这个catch了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  timeou2 的catch</span></span><br><span class="line"><span class="comment">//  都执行完成了</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这个例子的timeout1会resolve, timeout2首先会rejected, 但是timeout2由自己的catch方法，该方法会返回一个Promise实例。timeout2指向这个实例，该实例执行catch后，也会变成resolved。 导致两个实例都resolved.因此会调用then方法。而不会调用catch方法</p><p>如果timeout2没有自己的catch方法， 就会调用Promise.all()的catch方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(reject, <span class="number">2000</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.all([timeout1, timeout2])</span><br><span class="line">    .then(<span class="function">(<span class="params">[data1, data2]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;都执行完成了&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;参数实例没有自己的catch,所以有错误都会到这里&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 参数实例没有自己的catch,所以有错误都会到这里</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><strong>作用：</strong>作用也是将多个promise实例，包装成一个新的Promise实例。但是只要其中的一个实例状态发生改变，就会触发回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="built_in">Promise</span>.race([timeout1, timeout2])</span><br></pre></td></tr></table></figure><p>只要timeout1, timeout2其中有一个实例状态发生改变。time的状态就会发生改变。那个先改变的实例的返回值，就传递给time的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;timeout 1&quot;</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;timeout2&quot;</span>);</span><br><span class="line">      reject();</span><br><span class="line">    &#125;, <span class="number">500</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.race([timeout1, timeout2])</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;第一个time状态发生改变了&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timeout2</span></span><br><span class="line"><span class="comment">//  catch</span></span><br><span class="line"><span class="comment">//  timeout 1</span></span><br></pre></td></tr></table></figure><p>这个例子中，timeout2 在500ms 之后状态变成rejected了。比timeout1块， 所有就会立即调用time的then方法。然后timeout1 才会调用。</p><h3 id="Promise-allsettled"><a href="#Promise-allsettled" class="headerlink" title="Promise.allsettled()"></a>Promise.allsettled()</h3><p><strong>作用：</strong>作用也是将多个promise实例，包装成一个新的Promise实例.。但是只要这些参数的实例都返回结果，不管是fulfilled还是rejected,包装实例才会结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;timeout 1&quot;</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;timeout2&quot;</span>);</span><br><span class="line">      reject();</span><br><span class="line">    &#125;, <span class="number">500</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.allSettled([timeout1, timeout2]).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timeout1 和 timeou2 都结束了&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// timeout2</span></span><br><span class="line"><span class="comment">// timeout 1</span></span><br><span class="line"><span class="comment">// timeout1 和 timeou2 都结束了</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//     &#123;status: &quot;fulfilled&quot;, value: undefined&#125;</span></span><br><span class="line"><span class="comment">//     &#123;status: &quot;rejected&quot;, reason: undefined&#125;</span></span><br><span class="line"><span class="comment">//  ]</span></span><br></pre></td></tr></table></figure><p>Timeout1 和timeout2 都返回了结果， 才会调用then方法.then方法接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的两个 Promise 实例。每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。<code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</p><p>这个点方法的好处在哪里呢？ 好处就在有时候我们不关系一步操作的结果，只关心异步操作有没有结束。这个方法就很有用。</p><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h3><p><strong>作用：</strong>作用也是将多个promise实例，包装成一个新的Promise实例。 但是是是要参数实例有任何一个状态变成fulfilled。 包装实例对象就会变成fulfilled状态。如果所有的Promise状态都变成rejected, 包装实例对象才会变成rejecte的状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timeout 1&quot;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timeout2&quot;</span>);</span><br><span class="line">    reject();</span><br><span class="line">  &#125;, <span class="number">500</span>); <span class="comment">// 异步操作设置rejecte， 失败</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.any([timeout1, timeout2]).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timeout1 状态变成了 fulfilled&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>Promise.any()目前还在草案阶段。</p><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p><strong>作用</strong>: 将现有的对象转成Promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(name))</span><br></pre></td></tr></table></figure><p>Promise.resolve()方法的参数有四种情况：</p><ol><li><p>参数是一个promise实例， 那么promise.resolve将不做任何的修改， 直接原封不动的返回这个实例</p></li><li><p>参数是一个thenable对象。Promise.resolve()会将这个对象转成Promise对象， 然后立即执行thenable对象的then方法。</p><p>thenable对象就是指具有then方法的对象。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">(<span class="params">resolve, rejecte</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;ashds&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    <span class="attr">then</span>: <span class="function">(<span class="params">resolve, rejecte</span>) =&gt;</span> &#123;</span><br><span class="line">      rejecte(<span class="string">&quot;ashds&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(thenable)</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;thenable 的then方法返回的状态是fulfilled&quot;</span>, data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;thenable的then方法返回的状态是rejected&quot;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// thenable的then方法返回的状态是rejected ashds</span></span><br></pre></td></tr></table></figure><p>这个例子 Promise.resolve将thenable转成Promise对象之后，立即调用thenble对象的then方法。thenable对象的then方法返回的状态是 rejected; 所以执行到catch里面</p></li><li><p>参数不是thenable对象， 或者根本不是对象。Promise.resolve()会返回一个新的Promise实例，状态直接为resolved。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&quot;shuliqi&quot;</span>).then(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="built_in">console</span>.log(name));</span><br><span class="line"><span class="comment">// shuliqi</span></span><br></pre></td></tr></table></figure><p>这个例子的shuliqi不属于异步操作(字符串对象没有then方法)。返回的Promise从一开始就是resolved/所以会调函数就会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p></li><li><p>不带任何参数。直接返回一个<code>resolved</code>状态的 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;hahahah&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// hahahah</span></span><br></pre></td></tr></table></figure><p>Promise.resolved是没有参数的， 直接返回一个状态为resolved的Promise对象。 所以会调函数立即就调用了。</p></li></ol><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>**作用:**返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">&quot;shuliqi&quot;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejecte</span>) =&gt;</span> reject(<span class="string">&quot;shuliqi&quot;</span>))</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">   <span class="attr">then</span>: <span class="function">(<span class="params">resolve, rejecte</span>) =&gt;</span> &#123;</span><br><span class="line">     rejecte(<span class="string">&quot;ashds&quot;</span>);</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="built_in">Promise</span>.reject(thenable).catch(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data === thenable);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Promise.reject</code>方法的参数是一个<code>thenable</code>对象，执行以后，后面<code>catch</code>方法的参数不是<code>reject</code>抛出的“出错了”这个字符串，而是<code>thenable</code>对象。</p><p><a href="https://es6.ruanyifeng.com/#docs/promise">学习的链接</a></p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记- Proxy</title>
      <link href="/2018/03/05/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Proxy/"/>
      <url>/2018/03/05/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Proxy/</url>
      
        <content type="html"><![CDATA[<p>之前深入了解了**<a href="http://localhost:4000/2018/02/19/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Object-defineProperty/">Object.defineProperty</a>**。 发现ES6有一个新的对象（Proxy）也能实现属性拦截器的作用，但是功能更加强大。所以这里也学习学习，总结总结。</p><p>学习都是来自<a href="http://www.ruanyifeng.com/">阮一峰老师</a>。</p><span id="more"></span><h3 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h3><p><strong>Proxy</strong>对象在目标对象的外层设置一层拦截器，外界对目标的某些操作，必须通过这层拦截</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p><strong>new proxy</strong>表示生成一个proxy实例；</p><p><strong>target：</strong>表示拦截的目标对象；<br><strong>handler：</strong> 表示拦截的行为， 也是一个对象；</p><p><strong>注意：</strong>要使得<strong>Proxy <strong>起作用， 就必须针对</strong>Proxy <strong>实例（上面的例子就是</strong>proxyObj</strong>对象）进行操作，而不是针对目标对象（上面的例子就是(<strong>obj对象</strong>)进行操作。</p><h3 id="proxy拦截操作–handler"><a href="#proxy拦截操作–handler" class="headerlink" title="proxy拦截操作–handler"></a>proxy拦截操作–handler</h3><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h5><p>拦截对象属性的读取。 比如 <strong>proxyObj.name</strong> 和 <strong>proxyObj[name]</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">get</span>(<span class="params">target, propKey, recevier</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>get()方法接受三个参数</p><ol><li><strong>target:</strong> 目标对象</li><li><strong>propKey:</strong> 读取的属性名</li><li><strong>recevier：</strong>Proxy实例本身</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, propKey, recevier</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target[propKey]) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;找不到该属性的值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxyObj.name); <span class="comment">// shuliqi</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyObj.age);  <span class="comment">// 找不到该属性的值</span></span><br></pre></td></tr></table></figure><p>这个例子代码表示， 如果访对象不存在的属性， 会打印“找不到该属性的值”。 如过没有这个拦截， 访问不存在的属性，， 只会返回undefined。</p><h5 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h5><p>拦截某个属性的赋值操作。比如： 比如 <strong>proxyObj.name = “shuliqi”</strong> 和 <strong>proxyObj[name] =. “shuliqi”</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target, propKey，value, recevier</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> set()方法有三个参数：</p><ol><li><strong>target:</strong> 目标对象</li><li><strong>propKey:</strong> 读取的属性名</li><li><strong>value：</strong> 属性值</li><li><strong>recevier：</strong>Proxy实例本身</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, propKey, value, recevier</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey === <span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">        <span class="comment">// 如果不是整数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;age需要是一个整数&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;符合赋值&quot;</span>);</span><br><span class="line">        target[propKey] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyObj.age = <span class="number">12.1</span>; <span class="comment">// age需要是一个整数</span></span><br><span class="line">proxyObj.age = <span class="number">25</span>; <span class="comment">// 符合赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>这个例子如果age赋值的不是整数，会拦截到并且log“age需要是一个整数”。如果符合的话log“符合赋值” . 并且成功赋值。</p><h5 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply()方法"></a>apply()方法</h5><p>拦截函数的调用，<strong>call</strong> 和 <strong>apply</strong>的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">apply</span>(<span class="params">target, context, args</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>apply()方法有三个参数：</p><ol><li><strong>target：</strong> 目标函数对象</li><li><strong>context:</strong> 目标函数对象的上下文对象(this)</li><li><strong>args：</strong>目标函数对象的参数数组</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetFn = <span class="function">() =&gt;</span> <span class="string">&quot;我是目标函数对象&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> proxyFn = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetFn, &#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">_proxyFntarghet, context, args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我目标函数代理对象&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyFn.call(); <span class="comment">// 我目标函数代理对象</span></span><br><span class="line">proxyFn.apply();<span class="comment">// 我目标函数代理对象</span></span><br><span class="line">proxyFn(); <span class="comment">// 我目标函数代理对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子里面proxyFn 是 targetFn的实例，当被调用的时候，就会被apply方法拦截到。返回“我目标函数代理对象”</p><h5 id="has-方法"><a href="#has-方法" class="headerlink" title="has() 方法"></a>has() 方法</h5><p>拦截判断某个对象是否具有某个属性时(hasProperty)， 这个方法会生效。 典型的操作比如 in 操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">has</span>(<span class="params">targe, propKey</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>has() 方法 有两个参数：</p><ol><li><strong>target：</strong> 目标对象‘</li><li><strong>propKey:</strong> 需要查询的属性名；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 拦截的时候， 我们都给判断未false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">&quot;name&quot;</span> <span class="keyword">in</span> target; <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;name&quot;</span> <span class="keyword">in</span> proxyObj; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>例子里面， 我们代理对象用has()方法拦截判断对象是否具有某个属性时， 拦我们拦截到的时候都个片段未false， 所以使用代理对象判断时返回的都是false( “name” in target)。如果我们没有使用代理对象的话，那么是对象target 是具有name属性的。</p><p><strong>注意：</strong>has()方法只能拦截hasProperty， 而不是hasOwnProperty. 所以是不能判断一个属性是否是一个对象的自身属性。</p><p> 还有注意的就是：has 对 for…in… 是不管用的的</p><p>未完， 待学习….</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Object.defineProperty</title>
      <link href="/2018/02/19/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Object-defineProperty/"/>
      <url>/2018/02/19/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Object-defineProperty/</url>
      
        <content type="html"><![CDATA[<p>了解到vue的实现原理是使用了Object.defineProperty()方法。 之前对这个方法没深入了解。知道的就只有这个方法可以设置对象的的属性。现在了解了之后，感觉还是有很多点很值得记录一下。</p> <span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>Object。defineProperty()</code> 方法会直接在一个对象上添加新的属性， 或者修改一个对象的现有属性。然后返回这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, pro, descripor)</span><br></pre></td></tr></table></figure><p><strong>obj：</strong> 要定义属性的对象</p><p><strong>prop:</strong> 要定义的属性名或者是要修改的属性的名字</p><p>**descriptor:**要 定义的属性或者是要修改的属性的描述</p><p><strong>返回值</strong>：返回此对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;asjdha&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writeable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>其中<strong>obj</strong> 和 <strong>prop</strong> 参数没什么好说。 主要是这个descriptor(描述符)参数有比较深究的东西</p><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>javacript 有三种类型的属性</p><ol><li>命名数据属性：拥有一个确定的值的属性。这也是最常见的属性</li><li>命名访问器属性：通过<code>getter</code>和<code>setter</code>进行读取和赋值的属性</li><li>内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性<code>[[Prototype]]</code>，你不能直接访问这个属性，但可以通过<code>Object.getPrototypeOf()</code>方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性</li></ol><p>在js中可以访问到的对象中有两种属性： <strong>数据属性</strong> 和 <strong>访问器属性</strong>； 所以描述符也分为<strong>数据描述</strong> 和<strong>访问器描述</strong></p><p><strong>注意：</strong> 在使用描述符时， 必须是两种描述符之一，且两者是不能并存的。</p><h2 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h2><p>数据描述符是一个具有值的属性，该值可写可不写</p><p>具有以下的键值：</p><ol><li><strong>configurable：</strong> 该属性表示是否可以通过delete删除，是否能够修改属性的特征或者访问器属性。默认值是false；</li><li><strong>enumerable:</strong> 属性述否可枚举。 即 可否通过for..in 访问属性；默认值为 false</li><li><strong>value:</strong> 属性的值； 默认为undefined；</li><li><strong>writable：</strong> 该属性的值是否可写。 默认值为false。</li></ol><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;asjdha&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 不可写</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>, <span class="comment">// 不可删除，不可修改属性的特性和防访问器属性</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">// 不可枚举</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.age = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.age;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);   <span class="comment">// name, 没有把age 枚举出来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 12，  值没有被删除</span></span><br></pre></td></tr></table></figure><p>由例子可以知道：当我们设置不可写， 不可删除，不可枚举的时候， 我们是分别改变不了它们的值，删除不了， 枚举不了的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;asjdha&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">   <span class="attr">value</span>: <span class="number">12</span>,</span><br><span class="line">   <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">// 可写</span></span><br><span class="line">   <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可删除，可修改属性的特性和防访问器属性</span></span><br><span class="line">   <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line"> &#125;)</span><br><span class="line"> obj.age = <span class="number">15</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(key);   <span class="comment">// name, age   把age 枚举出来</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(obj.age); <span class="comment">// 15， 值被改变了</span></span><br><span class="line"> <span class="keyword">delete</span> obj.age;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(obj.age); <span class="comment">// undefined  值已经被删除了</span></span><br></pre></td></tr></table></figure><p>由例子可以知道：当我们设置可写， 可删除，可枚举的时候， 我们是分别可改变它们的值，可删除， 可枚举不的。</p><h2 id="访问器描述符"><a href="#访问器描述符" class="headerlink" title="访问器描述符"></a>访问器描述符</h2><ol><li><strong>configurable：</strong> 该属性表示是否可以通过delete删除，是否能够修改属性的特征或者访问器属性。默认值是false；</li><li><strong>enumerable:</strong> 属性述否可枚举。 即 可否通过for..in 访问属性；默认值为 false</li><li><strong>get：</strong>在读取属性的时候调用的函数， 默认值为undefned</li><li><strong>set：</strong>在写入属性时调用的函数， 默认值是undefined</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;asjdha&quot;</span>,</span><br><span class="line">    <span class="attr">_age</span>: <span class="literal">null</span>, <span class="comment">// 私有变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span>, value);</span><br><span class="line">      <span class="built_in">this</span>._age = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  obj.age = <span class="number">12</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h2><p> 数据描述符 和访问器描述符是不能同时是使用的</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;asjdha&quot;</span>,</span><br><span class="line">    <span class="attr">_age</span>: <span class="literal">null</span>, <span class="comment">// 私有变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">//  数据描述符 和 访问描述符 共同有的</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 数据描述符 和 访问描述符 共同有的</span></span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>, <span class="comment">// 数据描述符单有的</span></span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;shuliqi&quot;</span>, <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;    <span class="comment">// 访问器描述符</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span>, value);</span><br><span class="line">      <span class="built_in">this</span>._age = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 访问器描述符</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  obj.age = <span class="number">12</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是页面报错了</p><img src="/2018/02/19/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Object-defineProperty/1.jpg" class="">]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的数据结构之链表</title>
      <link href="/2018/02/16/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/02/16/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>在<code>JavaScript</code>中， 我们最常用的是数据结构应该是数组。但是对其他很多的编程语言来说，数组不是最佳的数据结构， 因为在其他的很多编程语言中，数组的长度是固定，如果数组的数据已经填满，再要加入新的数据就很困难。对于数组的删除和添加操作，通常需要将数组中的其他元素向后移或者向前移动，这些操作就很繁琐。</p><p>在<code>JavaScript</code>中，数组是不存在上述的问题的，是因为在<code>JavaScript</code>实现的时候被实现成了对象，但是这样设计之后<code>JavaScript</code>中的数组就会比其他语言的效率低很多。</p><p>这时，就可以使用链表来代替它，它对数据是可以随机访问，并且链表可以在任何可以使用一维数组的情况中。</p><p>链表分成了很多种类：单向链表，双向链表，单向循环链表，双向循环链表。下面我们来实现一个单向链表，因为单向链表的使用最为广泛。</p><span id="more"></span><h1 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h1><p>链表是一组节点组成的集合，每个节点有一个对象的引用来指向的它的后一个节点，指向另外一个节点的引用，我们叫做链。我们看下面的;链表结构图：</p><img src="/2018/02/16/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/1.png" class=""><p><code>data</code>中存的数据，<code>next</code>保存着下一个链表的引用。在上面的图中，我们只能说<code>data2</code>跟在<code>data1</code> 后面，而不能说<code>data2</code>是链表的第二个元素。<code>data3</code>的<code>next</code>指向了<code>null</code>，表示链表的结束的位置。</p><p>因为链表的起点的确定比较麻烦，所有很多链表的是实现都会在链表的最前面添加一个特殊的节点，我们成为<strong>头节点</strong>， 表示链表的头部。如下图是表示有头节点的链表：</p><img src="/2018/02/16/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/2.png" class=""><p>向链表插入一个节点的效率是很高的，只需要修改它前面的节点，使指向新加入的的节点，而新加入的节点指向原来节点指向的节点即可。如下图：</p><img src="/2018/02/16/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/3.png" class=""><p>在链表中删除一个节点也很简单，只需要将待删除节点的前节点的指向待删除节点指向的节点即可。 如下图：</p><img src="/2018/02/16/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/4.png" class=""><h1 id="实现单向链表"><a href="#实现单向链表" class="headerlink" title="实现单向链表"></a>实现单向链表</h1><p>实现链表要设计两个类，一个 <code>Node</code>类来表示节点，另外一个是<code>LinkedList</code>类来生成链表及其操作链表的方法。</p><h2 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h2><p> <code>Node</code>类包含两个属性， <code>data</code>表示当前节点的数据，<code>next</code>用来保存下一个节点的链接。我们来具体实现以下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  表示节点的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data; <span class="comment">// 节点的数据</span></span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>; <span class="comment">// 指向下一个点的链接</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h2><p><code>LinkedList</code>类只有一个属性，就是使用一个<code>Node</code>对象来表示链表的头节点。<code>LinkedList</code>类的构造函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 生成头节点</span></span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> Node(<span class="string">&quot;head&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头节点<code>head</code>初始化的<code>next</code>指<code>向null</code>，当有新的元素插入的时候， 会指向新的元素节点。</p><p><code>LinkedList</code>类除了有一个头节点的属性之外，还提供对链表进行操作的方法如：查找给定节点，删除指定节点，插入节点等操作，下面我们一一来实现</p><h2 id="查找给定的节点"><a href="#查找给定的节点" class="headerlink" title="查找给定的节点"></a>查找给定的节点</h2><p>查找一个指定的节点，我们需要循环连链表，所有刚开始我们创建一个新节点， 将链表的头节点赋值给新节点，然后循环链表，如果当前节点的data属性跟我们要查找的信息不符合，则将当前节点的移动到下一个节点。如果查找成功， 则返回包含这个数据的这个节点。否则返回<code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 查找指定的节点</span></span><br><span class="line"><span class="function"><span class="title">find</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个新节点，将链表的头节点赋给这个新创建的节点</span></span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span> (currentNode &amp;&amp; currentNode.data != data) &#123;</span><br><span class="line">    <span class="comment">// 然后在链表上循环，如果当前节点的 element 属性和我们要找的信息不符，就将当前节点移动到下一个节点</span></span><br><span class="line">    currentNode =  currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果查找成功，该方法返回包含该数据的节点；否则，就会返回null。</span></span><br><span class="line">  <span class="keyword">return</span> currentNode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="插入新的节点"><a href="#插入新的节点" class="headerlink" title="插入新的节点"></a>插入新的节点</h2><p>想要插入新的节点， 我们就需要要在哪个节点（节点前面或者节点后面）插入，我们这里的示例是在节点的后面插入一个新的节点。在一个已知节点的后面插入节点， 首先我们先找到该节点。一旦找到了节点，我们就可以将新节点插入到链表中，我们将新节点的<code>next</code>属性指向查找到节点的<code>next</code>指向的节点。然后将查找的节点的<code>next</code>指向新节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 插入节点， 在节点后面插入一个新节点：newData</span></span><br><span class="line"><span class="function"><span class="title">insert</span>(<span class="params">newData, data</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 查找要在这个节点后面插入新节点的节点</span></span><br><span class="line">  <span class="keyword">const</span> currentNode = <span class="built_in">this</span>.find(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新的节点</span></span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(newData); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新节点的next指向 在该节点后面插入新节点的节点的next</span></span><br><span class="line">  newNode.next = currentNode.next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  在该节点后面插入新节点的节点的next指向这个新节点</span></span><br><span class="line">  currentNode.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找一个节点的的前节点"><a href="#查找一个节点的的前节点" class="headerlink" title="查找一个节点的的前节点"></a>查找一个节点的的前节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找一个节点的前一个节点</span></span><br><span class="line"><span class="function"><span class="title">findPrev</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span>( currentNode.next &amp;&amp; currentNode.next.data !== data) &#123;</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currentNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>从链表中删除一个节点，需要找到待删除节点的前一个节点，找到后将它的<code>next</code>属性不在指向待删除的节点，而是指向待删除节点的下一个节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 删除一个节点</span></span><br><span class="line"><span class="function"><span class="title">remove</span>(<span class="params">removeData</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 找到带删除节点的前一个节点</span></span><br><span class="line">  <span class="keyword">const</span> preNode = <span class="built_in">this</span>.findPrev(removeData);</span><br><span class="line">  <span class="comment">// 如果前一个点为null，则直接退出</span></span><br><span class="line">  <span class="keyword">if</span> (preNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 待删除的节点</span></span><br><span class="line">    <span class="keyword">const</span> removeNode = <span class="built_in">this</span>.find(removeData);</span><br><span class="line">    <span class="comment">// 待删除节点的 next 属性指向 待删除节点的 next</span></span><br><span class="line">    preNode.next = removeNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印节点的数据"><a href="#打印节点的数据" class="headerlink" title="打印节点的数据"></a>打印节点的数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印节点的数据</span></span><br><span class="line"><span class="function"><span class="title">display</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span>( currentNode &amp;&amp; currentNode.next ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(currentNode.next.data);</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最后放上我们整体的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  表示节点的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data; <span class="comment">// 节点的数据</span></span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>; <span class="comment">// 指向下一个点的链接</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成链表及其操作链表的方法 --&gt; 链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 生成头节点</span></span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> Node(<span class="string">&quot;head&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找指定的节点</span></span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新节点，将链表的头节点赋给这个新创建的节点</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (currentNode &amp;&amp; currentNode.data != data) &#123;</span><br><span class="line">      <span class="comment">// 然后在链表上循环，如果当前节点的 element 属性和我们要找的信息不符，就将当前节点移动到下一个节点</span></span><br><span class="line">      currentNode =  currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果查找成功，该方法返回包含该数据的节点；否则，就会返回null。</span></span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 插入节点， 在节点后面插入一个新节点：newData</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">newData, data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找要在这个节点后面插入新节点的节点</span></span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="built_in">this</span>.find(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(newData); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新节点的next指向 在该节点后面插入新节点的节点的next</span></span><br><span class="line">    newNode.next = currentNode.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  在该节点后面插入新节点的节点的next指向这个新节点</span></span><br><span class="line">    currentNode.next = newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找一个节点的前一个节点</span></span><br><span class="line">  <span class="function"><span class="title">findPrev</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span>( currentNode.next &amp;&amp; currentNode.next.data !== data) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除一个节点</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">removeData</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到带删除节点的前一个节点</span></span><br><span class="line">    <span class="keyword">const</span> preNode = <span class="built_in">this</span>.findPrev(removeData);</span><br><span class="line">    <span class="comment">// 如果前一个点为null，则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (preNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 待删除的节点</span></span><br><span class="line">      <span class="keyword">const</span> removeNode = <span class="built_in">this</span>.find(removeData);</span><br><span class="line">      <span class="comment">// 待删除节点的 next 属性指向 待删除节点的 next</span></span><br><span class="line">      preNode.next = removeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印节点的数据</span></span><br><span class="line">  <span class="function"><span class="title">display</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span>( currentNode &amp;&amp; currentNode.next ) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(currentNode.next.data);</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 我们来检测一下是否正确：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> linked = <span class="keyword">new</span> LinkedList();</span><br><span class="line">linked.insert(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;head&#x27;</span>);</span><br><span class="line">linked.insert(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">linked.insert(<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">linked.insert(<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">linked.display();</span><br><span class="line">linked.remove(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">linked.display();</span><br></pre></td></tr></table></figure><p>打印的结果如下：</p><img src="/2018/02/16/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/5.png" class=""><p>可见，成功实现了一个单向链表</p><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>单向链表从头节点来时遍历链表很简单，但是反过来，从后往前遍历却是不容易的。但是我们给<code>Node</code>类添加一个<code>pre</code>属性，让它指向前驱节点的链接。这从后往前遍历不就简单了吗？是的，是变得简单了。这种就形成了双向链表，如图：</p><img src="/2018/02/16/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/6.png" class=""><p>双向链表插入一个节点的话就需要更新<code>next</code>和 <code>pre </code>属性了。会显得麻烦点， 但是删除节点的效率更高了。不需要查找待删除节点的前一个前节点了。</p><h1 id="实现双向链表"><a href="#实现双向链表" class="headerlink" title="实现双向链表"></a>实现双向链表</h1><p>要实现双向链表，首先先给<code>Node</code>节点添加一个<code>pre</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  表示节点的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data; <span class="comment">// 节点的数据</span></span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>; <span class="comment">// 下一个点的链接</span></span><br><span class="line">    <span class="built_in">this</span>.pre = <span class="literal">null</span> <span class="comment">// 上一节点的链接</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向链表的够构造函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LlinkedList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> Node(<span class="string">&quot;head&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找一个节点"><a href="#查找一个节点" class="headerlink" title="查找一个节点"></a>查找一个节点</h2><p>双向链表查找一个节点的方式和单向链表的方式是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到含有该数据的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>data </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">find</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 创建一个新节点，将链表的头节点赋给这个新创建的节点</span></span><br><span class="line">   <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">   <span class="keyword">while</span> (currentNode &amp;&amp; currentNode.data != data) &#123;</span><br><span class="line">     <span class="comment">// 然后在链表上循环，如果当前节点的 element 属性和我们要找的信息不符，就将当前节点移动到下一个节点</span></span><br><span class="line">     currentNode =  currentNode.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果查找成功，该方法返回包含该数据的节点；否则，就会返回null。</span></span><br><span class="line">   <span class="keyword">return</span> currentNode;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="插入一个节点"><a href="#插入一个节点" class="headerlink" title="插入一个节点"></a>插入一个节点</h2><p>双向链表的插入一个节点的时候还需要设置新节点的<code>pre</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  插入一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>newData 插入的新数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>currentData 要插入到有该数据的节点之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">insert</span>(<span class="params">newData, currentData</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 新节点</span></span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(newData);</span><br><span class="line">  <span class="comment">// 当前节点：在该节点之后插入新的节点</span></span><br><span class="line">  <span class="keyword">const</span> currentNode = <span class="built_in">this</span>.find(currentData);</span><br><span class="line">  newNode.next = currentNode.next;</span><br><span class="line">  newNode.pre = currentNode;</span><br><span class="line">  currentNode.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除一个节点"><a href="#删除一个节点" class="headerlink" title="删除一个节点"></a>删除一个节点</h2><p>双向链表的删除节点比单向链表的效率要高， 只要找出待删除的节点就可以了。然后将该节点的前驱 <code>next </code>属性指向待删除节点的后继，设置该节点后继 <code>pre</code> 属性，指向待删除节点的前驱即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>removeData 删除含有该节点的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">remove</span>(<span class="params">removeData</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> removeNode = <span class="built_in">this</span>.find(removeData);</span><br><span class="line">  <span class="keyword">if</span> (removeNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    removeNode.pre.next = removeNode.next;</span><br><span class="line">    removeNode.next.pre = removeNode.pre;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找链表中的最后一个元素"><a href="#查找链表中的最后一个元素" class="headerlink" title="查找链表中的最后一个元素"></a>查找链表中的最后一个元素</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找链表的最后有一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">findLast</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span>(currentNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currentNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向打印链表的数据"><a href="#反向打印链表的数据" class="headerlink" title="反向打印链表的数据"></a>反向打印链表的数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向打印链表的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">displayReverse</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.findLast();</span><br><span class="line">  <span class="keyword">while</span>(currentNode.pre !== <span class="literal">null</span> ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(currentNode.data);</span><br><span class="line">    currentNode = currentNode.pre;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外的<code>display</code> 和单向链表的方式一样。</p><p>最后贴上最终的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  表示节点的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data; <span class="comment">// 节点的数据</span></span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>; <span class="comment">// 下一个点的链接</span></span><br><span class="line">    <span class="built_in">this</span>.pre = <span class="literal">null</span> <span class="comment">// 上一节点的链接</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> Node(<span class="string">&quot;head&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 找到含有该数据的节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>data </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">     <span class="comment">// 创建一个新节点，将链表的头节点赋给这个新创建的节点</span></span><br><span class="line">     <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">     <span class="keyword">while</span> (currentNode &amp;&amp; currentNode.data != data) &#123;</span><br><span class="line">       <span class="comment">// 然后在链表上循环，如果当前节点的 element 属性和我们要找的信息不符，就将当前节点移动到下一个节点</span></span><br><span class="line">       currentNode =  currentNode.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果查找成功，该方法返回包含该数据的节点；否则，就会返回null。</span></span><br><span class="line">     <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  插入一个节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>newData 插入的新数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>currentData 要插入到有该数据的节点之后</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">newData, currentData</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(newData);</span><br><span class="line">    <span class="comment">// 当前节点：在该节点之后插入新的节点</span></span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="built_in">this</span>.find(currentData);</span><br><span class="line">    newNode.next = currentNode.next;</span><br><span class="line">    newNode.pre = currentNode;</span><br><span class="line">    currentNode.next = newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除一个节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>removeData 删除含有该节点的节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">removeData</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> removeNode = <span class="built_in">this</span>.find(removeData);</span><br><span class="line">    <span class="keyword">if</span> (removeNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      removeNode.pre.next = removeNode.next;</span><br><span class="line">      removeNode.next.pre = removeNode.pre;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查找链表的最后有一个元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">findLast</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span>(currentNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印节点的数据</span></span><br><span class="line">  <span class="function"><span class="title">display</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span>( currentNode &amp;&amp; currentNode.next ) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(currentNode.next.data);</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 反向打印链表的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">displayReverse</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.findLast();</span><br><span class="line">    <span class="keyword">while</span>(currentNode.pre !== <span class="literal">null</span> ) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(currentNode.data);</span><br><span class="line">      currentNode = currentNode.pre;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 最后我们检测一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> linked = <span class="keyword">new</span> LLinkedList();</span><br><span class="line">linked.insert(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;head&#x27;</span>);</span><br><span class="line">linked.insert(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">linked.insert(<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">linked.insert(<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">linked.display();</span><br><span class="line">linked.remove(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;--删除了数据为2的节点----&quot;</span>);</span><br><span class="line">linked.display();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;----findLast---&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(linked.findLast().data);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;----反向打印---&quot;</span>);</span><br><span class="line">linked.displayReverse();</span><br></pre></td></tr></table></figure><p>打印的结果为：</p><img src="/2018/02/16/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/7.png" class="">]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 组件 data 为什么必须是函数</title>
      <link href="/2018/02/14/Vue-%E7%BB%84%E4%BB%B6-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0/"/>
      <url>/2018/02/14/Vue-%E7%BB%84%E4%BB%B6-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在使用<code>vue</code>开发的时候，有一点觉得非常奇怪；使用<code>new Vue()</code>的时候，<code>data</code>是可以传入一个对象的；但是在组件中<code>data</code>就必须为一个函数；<code>vue</code>的官方文档是这么写的：</p><blockquote><p>通过<code>Vue</code>构造器传入的各种选项大多数是可以在组件里使用。<code>data</code>是一个例外，它必须是一个函数。如果定义成了一个对象，那么<code>Vue</code>就会停止。并且会在控制台发出警告，告诉你在组件中<code>data</code>必须是一个函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new Vue() ---- 实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">name</span>: shuliqi,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件</span></span><br><span class="line">Vue.compoment(<span class="string">&quot;people&quot;</span>, &#123;</span><br><span class="line"><span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: shuliqi,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是为什么？为什么在组件中<code>data</code>就必须为一个函数。而<code>new Vue()</code>的<code>data</code>可为函数，可为对象</p> <span id="more"></span><h2 id="vue-组件的data-必须为函数的原因"><a href="#vue-组件的data-必须为函数的原因" class="headerlink" title="vue 组件的data 必须为函数的原因"></a>vue 组件的data 必须为函数的原因</h2><p>最根本的原因是是我们<strong>js对于对象是传引用地址的</strong>。 如果我们传了一个对象进去。那么依此配置初始化多个实例之后，这个对象是这些多个实例共享的。</p><p>例子1：如果 <code>data</code> 是一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ppeople</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Ppeople.prototype.data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Ppeople();</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Ppeople();</span><br><span class="line"><span class="built_in">console</span>.log(p1.data === p2.data, p1.data.name, p2.data.name); </span><br><span class="line"><span class="comment">// true shuliqi shuliqi</span></span><br><span class="line"></span><br><span class="line">p2.data.name = <span class="string">&quot;舒丽琦&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p1.data.name, p2.data.name); <span class="comment">// 舒丽琦 舒丽琦</span></span><br></pre></td></tr></table></figure><p>我们可以看出来：<code>p1</code> 和 <code>p2</code> 的原型都是<code> People</code>。也就是会继承原型的属性；<strong>因为 原型上的<code>data</code>是普通对象，属于引用类型</strong>。所以<code>P1</code> 和<code>p2</code>的<code>data</code>其实都是指向同一块内存地址。严格运算符判断都是相等的，说明他们的值相等，内存地址也相同，所以修改其中一个也会影响另外一个。</p><p>例子2：如果<code>data</code>是一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ppeople</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.data = <span class="built_in">this</span>.data();</span><br><span class="line">&#125;;</span><br><span class="line">Ppeople.prototype.data = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;shuliqi&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Ppeople();</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Ppeople();</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2, p1.data.name, p2.data.name ); </span><br><span class="line"><span class="comment">// false shuliqi shuliqi</span></span><br><span class="line">p2.data.name = <span class="string">&quot;舒丽琦&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p1.data.name, p2.data.name); <span class="comment">// shuliqi 舒丽琦</span></span><br></pre></td></tr></table></figure><p>我们在执行 <code>new</code>的时候，<code>Ppeople</code>其实充当了<code>constructor</code>。这时候的<code>this.data</code>还是一个函数，还没执行的函数。所以调用一下<code>this.data()</code>让函数返回一个值然后重新赋值给<code>this.data</code>。</p><p><code>Ppeople</code>原型的<code>data</code>使用了<code>function</code>。使用了<code>function</code>后，<code>data</code>都被锁定在当前的<code>function</code>作用域中，然后被<code>return</code>出去。 <strong>相当于创建了另外一个对象，所以多个实例之间互相不影响</strong></p><h2 id="new-Vue-的data为对象为函数都可行的原因"><a href="#new-Vue-的data为对象为函数都可行的原因" class="headerlink" title="new Vue()的data为对象为函数都可行的原因"></a>new Vue()的data为对象为函数都可行的原因</h2><p>我们看如下的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ppeople</span> (<span class="params">&#123; data &#125;</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.data = data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Ppeople(&#123; <span class="attr">data</span>:&#123; <span class="attr">name</span>:<span class="string">&quot;shuliqi&quot;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125; &#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Ppeople(&#123; <span class="attr">data</span>:&#123; <span class="attr">name</span>:<span class="string">&quot;shuliqi&quot;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125; &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2, p1.data.name, p2.data.name ); <span class="comment">// shuliqi shuliqi</span></span><br><span class="line">p2.data.name = <span class="string">&quot;舒丽琦&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p1.data.name, p2.data.name); <span class="comment">// shuliqi 舒丽琦</span></span><br></pre></td></tr></table></figure><p>这里的变量声明方式是直接放在了构造函数中，并不是通过原型链来查找的，这也就是为什么<code>new Vue</code>的时候 <code>data</code>说是可以直接为非函数。在构造函数执行的时候，<code>data</code>就已经相互隔离。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
